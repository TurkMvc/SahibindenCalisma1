/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 243);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/renderer.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(103);
module.exports = $;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/extend.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var isPlainObject = __webpack_require__(9).isPlainObject;
var extendFromObject = function(target, source, overrideExistingValues) {
    target = target || {};
    for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
            var value = source[prop];
            if (!(prop in target) || overrideExistingValues) {
                target[prop] = value
            }
        }
    }
    return target
};
var extend = function(target) {
    target = target || {};
    var i = 1,
        deep = false;
    if ("boolean" === typeof target) {
        deep = target;
        target = arguments[1] || {};
        i++
    }
    for (; i < arguments.length; i++) {
        var source = arguments[i];
        if (null == source) {
            continue
        }
        for (var key in source) {
            var clone, targetValue = target[key],
                sourceValue = source[key],
                sourceValueIsArray = false;
            if (target === sourceValue) {
                continue
            }
            if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
                if (sourceValueIsArray) {
                    clone = targetValue && Array.isArray(targetValue) ? targetValue : []
                } else {
                    clone = targetValue && isPlainObject(targetValue) ? targetValue : {}
                }
                target[key] = extend(deep, clone, sourceValue)
            } else {
                if (void 0 !== sourceValue) {
                    target[key] = sourceValue
                }
            }
        }
    }
    return target
};
exports.extend = extend;
exports.extendFromObject = extendFromObject;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/common.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    config = __webpack_require__(31),
    deferredUtils = __webpack_require__(10);
var type = function(object) {
    var types = {
            "[object Array]": "array",
            "[object Date]": "date",
            "[object Object]": "object",
            "[object Null]": "null"
        },
        typeOfObject = Object.prototype.toString.call(object);
    return "object" === typeof object ? types[typeOfObject] || "object" : typeof object
};
var isDefined = function(object) {
    return null !== object && void 0 !== object
};
var isString = function(object) {
    return "string" === typeof object
};
var isNumeric = function(object) {
    return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object))
};
var isObject = function(object) {
    return "object" === type(object)
};
var isDate = function(object) {
    return "date" === type(object)
};
var isBoolean = function(object) {
    return "boolean" === typeof object
};
var isFunction = function(object) {
    return "function" === typeof object
};
var isPrimitive = function(value) {
    return ["object", "array", "function"].indexOf(type(value)) === -1
};
var isExponential = function(value) {
    return isNumeric(value) && value.toString().indexOf("e") !== -1
};
var isWindow = function(object) {
    return null != object && object === object.window
};
var isDomNode = function(node) {
    return node instanceof Element
};
var ensureDefined = function(value, defaultValue) {
    return isDefined(value) ? value : defaultValue
};
var executeAsync = function(action, context) {
    var timerId, deferred = $.Deferred(),
        normalizedContext = context || this,
        task = {
            promise: deferred.promise(),
            abort: function() {
                clearTimeout(timerId);
                deferred.rejectWith(normalizedContext)
            }
        },
        callback = function() {
            var result = action.call(normalizedContext);
            if (result && result.done && isFunction(result.done)) {
                result.done(function() {
                    deferred.resolveWith(normalizedContext)
                })
            } else {
                deferred.resolveWith(normalizedContext)
            }
        };
    timerId = (arguments[2] || setTimeout)(callback, "number" === typeof context ? context : 0);
    return task
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name, func, deferred) {
    if (executingName && executingName !== name) {
        delayedFuncs.push(func);
        delayedNames.push(name);
        deferred = deferred || $.Deferred();
        delayedDeferreds.push(deferred);
        return deferred
    } else {
        var oldExecutingName = executingName,
            currentDelayedCount = delayedDeferreds.length;
        executingName = name;
        var result = func();
        if (!result) {
            if (delayedDeferreds.length > currentDelayedCount) {
                result = deferredUtils.when.apply($, delayedDeferreds.slice(currentDelayedCount))
            } else {
                if (deferred) {
                    deferred.resolve()
                }
            }
        }
        executingName = oldExecutingName;
        if (deferred && result && result.done) {
            result.done(deferred.resolve).fail(deferred.reject)
        }
        if (!executingName && delayedFuncs.length) {
            ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift())
        }
        return result
    }
};
var deferRender = function(func, deferred) {
    return deferExecute("render", func, deferred)
};
var deferUpdate = function(func, deferred) {
    return deferExecute("update", func, deferred)
};
var deferRenderer = function(func) {
    return function() {
        var that = this;
        return deferExecute("render", function() {
            return func.call(that)
        })
    }
};
var deferUpdater = function(func) {
    return function() {
        var that = this;
        return deferExecute("update", function() {
            return func.call(that)
        })
    }
};
var findBestMatches = function(targetFilter, items, mapFn) {
    var bestMatches = [],
        maxMatchCount = 0;
    $.each(items, function(index, itemSrc) {
        var matchCount = 0,
            item = mapFn ? mapFn(itemSrc) : itemSrc;
        $.each(targetFilter, function(paramName, targetValue) {
            var value = item[paramName];
            if (void 0 === value) {
                return
            }
            if (match(value, targetValue)) {
                matchCount++;
                return
            }
            matchCount = -1;
            return false
        });
        if (matchCount < maxMatchCount) {
            return
        }
        if (matchCount > maxMatchCount) {
            bestMatches.length = 0;
            maxMatchCount = matchCount
        }
        bestMatches.push(itemSrc)
    });
    return bestMatches
};
var match = function(value, targetValue) {
    if (Array.isArray(value) && Array.isArray(targetValue)) {
        var mismatch = false;
        $.each(value, function(index, valueItem) {
            if (valueItem !== targetValue[index]) {
                mismatch = true;
                return false
            }
        });
        if (mismatch) {
            return false
        }
        return true
    }
    if (value === targetValue) {
        return true
    }
    return false
};
var splitPair = function(raw) {
    switch (typeof raw) {
        case "string":
            return raw.split(/\s+/, 2);
        case "object":
            return [raw.x || raw.h, raw.y || raw.v];
        case "number":
            return [raw];
        default:
            return raw
    }
};
var splitQuad = function(raw) {
    switch (typeof raw) {
        case "string":
            return raw.split(/\s+/, 4);
        case "object":
            return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
        case "number":
            return [raw];
        default:
            return raw
    }
};
var normalizeKey = function(id) {
    var key = isString(id) ? id : id.toString(),
        arr = key.match(/[^a-zA-Z0-9_]/g);
    arr && $.each(arr, function(_, sign) {
        key = key.replace(sign, "__" + sign.charCodeAt() + "__")
    });
    return key
};
var denormalizeKey = function(key) {
    var arr = key.match(/__\d+__/g);
    arr && arr.forEach(function(char) {
        var charCode = parseInt(char.replace("__", ""));
        key = key.replace(char, String.fromCharCode(charCode))
    });
    return key
};
var isArraysEqualByValue = function(array1, array2, deep) {
    if (array1.length !== array2.length) {
        return false
    }
    for (var i = 0; i < array1.length; i++) {
        if (!equalByValue(array1[i], array2[i], deep + 1)) {
            return false
        }
    }
    return true
};
var isObjectsEqualByValue = function(object1, object2, deep) {
    for (var propertyName in object1) {
        if (object1.hasOwnProperty(propertyName) && !equalByValue(object1[propertyName], object2[propertyName], deep + 1)) {
            return false
        }
    }
    for (propertyName in object2) {
        if (!(propertyName in object1)) {
            return false
        }
    }
    return true
};
var equalByValue = function(object1, object2, deep) {
    if (object1 === object2) {
        return true
    }
    var maxDeep = 3;
    deep = deep || 0;
    if (deep >= maxDeep) {
        return true
    }
    if (isObject(object1) && isObject(object2)) {
        return isObjectsEqualByValue(object1, object2, deep)
    } else {
        if (Array.isArray(object1) && Array.isArray(object2)) {
            return isArraysEqualByValue(object1, object2, deep)
        } else {
            if (isDate(object1) && isDate(object2)) {
                return object1.getTime() === object2.getTime()
            }
        }
    }
    return false
};
var getKeyHash = function(key) {
    if (isObject(key) || Array.isArray(key)) {
        try {
            var keyHash = JSON.stringify(key);
            return "{}" === keyHash ? key : keyHash
        } catch (e) {
            return key
        }
    }
    return key
};
var escapeRegExp = function(string) {
    return string.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
};
var applyServerDecimalSeparator = function(value) {
    var separator = config().serverDecimalSeparator;
    if (isDefined(value)) {
        value = value.toString().replace(".", separator)
    }
    return value
};
var noop = function() {};
var grep = function(elements, checkFunction, invert) {
    var check, result = [],
        expectedCheck = !invert;
    for (var i = 0; i < elements.length; i++) {
        check = !!checkFunction(elements[i], i);
        if (check === expectedCheck) {
            result.push(elements[i])
        }
    }
    return result
};
exports.type = type;
exports.isDefined = isDefined;
exports.isString = isString;
exports.isNumeric = isNumeric;
exports.isObject = isObject;
exports.isDate = isDate;
exports.isBoolean = isBoolean;
exports.isFunction = isFunction;
exports.isPrimitive = isPrimitive;
exports.isExponential = isExponential;
exports.isWindow = isWindow;
exports.isDomNode = isDomNode;
exports.ensureDefined = ensureDefined;
exports.executeAsync = executeAsync;
exports.deferRender = deferRender;
exports.deferRenderer = deferRenderer;
exports.deferUpdate = deferUpdate;
exports.deferUpdater = deferUpdater;
exports.splitPair = splitPair;
exports.splitQuad = splitQuad;
exports.findBestMatches = findBestMatches;
exports.normalizeKey = normalizeKey;
exports.denormalizeKey = denormalizeKey;
exports.equalByValue = equalByValue;
exports.getKeyHash = getKeyHash;
exports.escapeRegExp = escapeRegExp;
exports.applyServerDecimalSeparator = applyServerDecimalSeparator;
exports.noop = noop;
exports.grep = grep;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(13),
    extend = __webpack_require__(1).extend,
    copyEvent = __webpack_require__(250).copy;
var eventSource = function() {
    var EVENT_SOURCES_REGEX = {
        dx: /^dx/i,
        mouse: /(mouse|wheel)/i,
        touch: /^touch/i,
        keyboard: /^key/i,
        pointer: /^(ms)?pointer/i
    };
    return function(e) {
        var result = "other";
        $.each(EVENT_SOURCES_REGEX, function(key) {
            if (this.test(e.type)) {
                result = key;
                return false
            }
        });
        return result
    }
}();
var isDxEvent = function(e) {
    return "dx" === eventSource(e)
};
var isNativeMouseEvent = function(e) {
    return "mouse" === eventSource(e)
};
var isNativeTouchEvent = function(e) {
    return "touch" === eventSource(e)
};
var isPointerEvent = function(e) {
    return "pointer" === eventSource(e)
};
var isMouseEvent = function(e) {
    return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType
};
var isTouchEvent = function(e) {
    return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType
};
var isKeyboardEvent = function(e) {
    return "keyboard" === eventSource(e)
};
var isFakeClickEvent = function(e) {
    return 0 === e.screenX && !e.offsetX && 0 === e.pageX
};
var eventData = function(e) {
    return {
        x: e.pageX,
        y: e.pageY,
        time: e.timeStamp
    }
};
var eventDelta = function(from, to) {
    return {
        x: to.x - from.x,
        y: to.y - from.y,
        time: to.time - from.time || 1
    }
};
var hasTouches = function(e) {
    if (isNativeTouchEvent(e)) {
        return (e.originalEvent.touches || []).length
    }
    if (isDxEvent(e)) {
        return (e.pointers || []).length
    }
    return 0
};
var needSkipEvent = function(e) {
    var $target = $(e.target),
        touchInInput = $target.is("input, textarea, select");
    if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event")) {
        return true
    }
    if ("dxmousewheel" === e.type) {
        return $target.is("input[type='number'], textarea, select") && $target.is(":focus")
    }
    if (isMouseEvent(e)) {
        return touchInInput || e.which > 1
    }
    if (isTouchEvent(e)) {
        return touchInInput && $target.is(":focus")
    }
};
var createEvent = function(originalEvent, args) {
    var event = copyEvent(originalEvent);
    if (args) {
        extend(event, args)
    }
    return event
};
var fireEvent = function(props) {
    var event = createEvent(props.originalEvent, props);
    $.event.trigger(event, null, props.delegateTarget || event.target);
    return event
};
var addNamespace = function(eventNames, namespace) {
    if (!namespace) {
        throw errors.Error("E0017")
    }
    if ("string" === typeof eventNames) {
        if (eventNames.indexOf(" ") === -1) {
            return eventNames + "." + namespace
        }
        return addNamespace(eventNames.split(/\s+/g), namespace)
    }
    $.each(eventNames, function(index, eventName) {
        eventNames[index] = eventName + "." + namespace
    });
    return eventNames.join(" ")
};
module.exports = {
    eventSource: eventSource,
    isPointerEvent: isPointerEvent,
    isMouseEvent: isMouseEvent,
    isTouchEvent: isTouchEvent,
    isKeyboardEvent: isKeyboardEvent,
    isFakeClickEvent: isFakeClickEvent,
    hasTouches: hasTouches,
    eventData: eventData,
    eventDelta: eventDelta,
    needSkipEvent: needSkipEvent,
    createEvent: createEvent,
    fireEvent: fireEvent,
    addNamespace: addNamespace
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/component_registrator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    jQuery = __webpack_require__(103),
    errors = __webpack_require__(13),
    MemorizedCallbacks = __webpack_require__(165),
    publicComponentUtils = __webpack_require__(73);
var callbacks = new MemorizedCallbacks;
var registerComponent = function(name, namespace, componentClass) {
    if (!componentClass) {
        componentClass = namespace
    } else {
        namespace[name] = componentClass
    }
    publicComponentUtils.name(componentClass, name);
    callbacks.fire(name, componentClass)
};
registerComponent.callbacks = callbacks;
var registerJQueryComponent = function(name, componentClass) {
    $.fn[name] = jQuery.fn[name] = function(options) {
        var result, isMemberInvoke = "string" === typeof options;
        if (isMemberInvoke) {
            var memberName = options,
                memberArgs = $.makeArray(arguments).slice(1);
            this.each(function() {
                var instance = componentClass.getInstance(this);
                if (!instance) {
                    throw errors.Error("E0009", name)
                }
                var member = instance[memberName],
                    memberValue = member.apply(instance, memberArgs);
                if (void 0 === result) {
                    result = memberValue
                }
            })
        } else {
            this.each(function() {
                var instance = componentClass.getInstance(this);
                if (instance) {
                    instance.option(options)
                } else {
                    new componentClass(this, options)
                }
            });
            result = this
        }
        return result
    }
};
callbacks.add(registerJQueryComponent);
module.exports = registerComponent;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/class.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errors = __webpack_require__(13);
var wrapOverridden = function(baseProto, methodName, method) {
    return function() {
        var prevCallBase = this.callBase;
        this.callBase = baseProto[methodName];
        try {
            return method.apply(this, arguments)
        } finally {
            this.callBase = prevCallBase
        }
    }
};
var clonePrototype = function(obj) {
    var func = function() {};
    func.prototype = obj.prototype;
    return new func
};
var redefine = function(members) {
    var overridden, memberName, member, that = this;
    if (!members) {
        return that
    }
    for (memberName in members) {
        member = members[memberName];
        overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
        that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member
    }
    return that
};
var include = function() {
    var argument, name, i, classObj = this;
    for (i = 0; i < arguments.length; i++) {
        argument = arguments[i];
        if (argument.ctor) {
            classObj._includedCtors.push(argument.ctor)
        }
        if (argument.postCtor) {
            classObj._includedPostCtors.push(argument.postCtor)
        }
        for (name in argument) {
            if ("ctor" === name || "postCtor" === name) {
                continue
            }
            classObj.prototype[name] = argument[name]
        }
    }
    return classObj
};
var subclassOf = function(parentClass) {
    if (this.parent === parentClass) {
        return true
    }
    if (!this.parent || !this.parent.subclassOf) {
        return false
    }
    return this.parent.subclassOf(parentClass)
};
var abstract = function() {
    throw errors.Error("E0001")
};
var copyStatic = function() {
    var hasOwn = Object.prototype.hasOwnProperty;
    return function(source, destination) {
        for (var key in source) {
            if (!hasOwn.call(source, key)) {
                return
            }
            destination[key] = source[key]
        }
    }
}();
var classImpl = function() {};
classImpl.inherit = function(members) {
    var inheritor = function() {
        if (!this || this === window || "function" !== typeof this.constructor) {
            throw errors.Error("E0003")
        }
        var i, instance = this,
            ctor = instance.ctor,
            includedCtors = instance.constructor._includedCtors,
            includedPostCtors = instance.constructor._includedPostCtors;
        for (i = 0; i < includedCtors.length; i++) {
            includedCtors[i].call(instance)
        }
        if (ctor) {
            ctor.apply(instance, arguments)
        }
        for (i = 0; i < includedPostCtors.length; i++) {
            includedPostCtors[i].call(instance)
        }
    };
    inheritor.prototype = clonePrototype(this);
    copyStatic(this, inheritor);
    inheritor.inherit = this.inherit;
    inheritor.abstract = abstract;
    inheritor.redefine = redefine;
    inheritor.include = include;
    inheritor.subclassOf = subclassOf;
    inheritor.parent = this;
    inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
    inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
    inheritor.prototype.constructor = inheritor;
    inheritor.redefine(members);
    return inheritor
};
classImpl.abstract = abstract;
module.exports = classImpl;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/devices.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    Class = __webpack_require__(5),
    errors = __webpack_require__(13),
    resizeCallbacks = __webpack_require__(61).resizeCallbacks,
    EventsMixin = __webpack_require__(38),
    SessionStorage = __webpack_require__(107).sessionStorage,
    viewPort = __webpack_require__(54),
    Config = __webpack_require__(31);
var KNOWN_UA_TABLE = {
    iPhone: "iPhone",
    iPhone5: "iPhone",
    iPhone6: "iPhone",
    iPhone6plus: "iPhone",
    iPad: "iPad",
    iPadMini: "iPad Mini",
    androidPhone: "Android Mobile",
    androidTablet: "Android",
    win8: "MSAppHost",
    win8Phone: "Windows Phone 8.0",
    msSurface: "Windows ARM Tablet PC",
    desktop: "desktop",
    win10Phone: "Windows Phone 10.0",
    win10: "MSAppHost/3.0"
};
var DEFAULT_DEVICE = {
    deviceType: "desktop",
    platform: "generic",
    version: [],
    phone: false,
    tablet: false,
    android: false,
    ios: false,
    win: false,
    generic: true,
    grade: "A",
    mac: false
};
var uaParsers = {
    win: function(userAgent) {
        var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/),
            isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent),
            isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
        if (!(isPhone || isTablet || isDesktop)) {
            return
        }
        var matches = userAgent.match(/windows phone (\d+).(\d+)/i) || userAgent.match(/windows nt (\d+).(\d+)/i),
            version = [];
        if (matches) {
            version.push(parseInt(matches[1], 10), parseInt(matches[2], 10))
        } else {
            matches = userAgent.match(/msapphost(\/(\d+).(\d+))?/i);
            matches && version.push(3 === parseInt(matches[2], 10) ? 10 : 8)
        }
        return {
            deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
            platform: "win",
            version: version,
            grade: "A"
        }
    },
    ios: function(userAgent) {
        if (!/ip(hone|od|ad)/i.test(userAgent)) {
            return
        }
        var isPhone = /ip(hone|od)/i.test(userAgent),
            matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i),
            version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
            isIPhone4 = 480 === window.screen.height,
            grade = isIPhone4 ? "B" : "A";
        return {
            deviceType: isPhone ? "phone" : "tablet",
            platform: "ios",
            version: version,
            grade: grade
        }
    },
    android: function(userAgent) {
        if (!/android|htc_|silk/i.test(userAgent)) {
            return
        }
        var isPhone = /mobile/i.test(userAgent),
            matches = userAgent.match(/android (\d+)\.(\d+)\.?(\d+)?/i),
            version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
            worseThan4_4 = version.length > 1 && (version[0] < 4 || 4 === version[0] && version[1] < 4),
            grade = worseThan4_4 ? "B" : "A";
        return {
            deviceType: isPhone ? "phone" : "tablet",
            platform: "android",
            version: version,
            grade: grade
        }
    }
};
var Devices = Class.inherit({
    ctor: function(options) {
        this._window = options && options.window || window;
        this._realDevice = this._getDevice();
        this._currentDevice = void 0;
        this._currentOrientation = void 0;
        this.changed = $.Callbacks();
        this._recalculateOrientation();
        resizeCallbacks.add(this._recalculateOrientation.bind(this))
    },
    current: function(deviceOrName) {
        if (deviceOrName) {
            this._currentDevice = this._getDevice(deviceOrName);
            this._forced = true;
            this.changed.fire();
            if ("win" === this._currentDevice.platform && 8 === this._currentDevice.version[0]) {
                errors.log("W0010", "the 'win8' theme", "16.1", "Use the 'win10' theme instead.")
            }
            return
        }
        if (!this._currentDevice) {
            deviceOrName = void 0;
            try {
                deviceOrName = this._getDeviceOrNameFromWindowScope()
            } catch (e) {
                deviceOrName = this._getDeviceNameFromSessionStorage()
            } finally {
                if (!deviceOrName) {
                    deviceOrName = this._getDeviceNameFromSessionStorage()
                }
                if (deviceOrName) {
                    this._forced = true
                }
            }
            this._currentDevice = this._getDevice(deviceOrName)
        }
        return this._currentDevice
    },
    real: function() {
        return extend({}, this._realDevice)
    },
    orientation: function() {
        return this._currentOrientation
    },
    isForced: function() {
        return this._forced
    },
    isRippleEmulator: function() {
        return !!this._window.tinyHippos
    },
    _getCssClasses: function(device) {
        var result = [];
        var realDevice = this._realDevice;
        device = device || this.current();
        if (device.deviceType) {
            result.push("dx-device-" + device.deviceType);
            if ("desktop" !== device.deviceType) {
                result.push("dx-device-mobile")
            }
        }
        result.push("dx-device-" + realDevice.platform);
        if (realDevice.version && realDevice.version.length) {
            result.push("dx-device-" + realDevice.platform + "-" + realDevice.version[0])
        }
        if (devices.isSimulator()) {
            result.push("dx-simulator")
        }
        if (Config().rtlEnabled) {
            result.push("dx-rtl")
        }
        return result
    },
    attachCssClasses: function(element, device) {
        this._deviceClasses = this._getCssClasses(device).join(" ");
        $(element).addClass(this._deviceClasses)
    },
    detachCssClasses: function(element) {
        $(element).removeClass(this._deviceClasses)
    },
    isSimulator: function() {
        try {
            return this._isSimulator || this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
        } catch (e) {
            return false
        }
    },
    forceSimulator: function() {
        this._isSimulator = true
    },
    _getDevice: function(deviceName) {
        if ("genericPhone" === deviceName) {
            deviceName = {
                deviceType: "phone",
                platform: "generic",
                generic: true
            }
        }
        if (isPlainObject(deviceName)) {
            return this._fromConfig(deviceName)
        } else {
            var ua;
            if (deviceName) {
                ua = KNOWN_UA_TABLE[deviceName];
                if (!ua) {
                    throw errors.Error("E0005")
                }
            } else {
                ua = navigator.userAgent
            }
            return this._fromUA(ua)
        }
    },
    _getDeviceOrNameFromWindowScope: function() {
        var result;
        if (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]) {
            result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"]
        }
        return result
    },
    _getDeviceNameFromSessionStorage: function() {
        var sessionStorage = SessionStorage();
        if (!sessionStorage) {
            return
        }
        var deviceOrName = sessionStorage.getItem("dx-force-device");
        try {
            return JSON.parse(deviceOrName)
        } catch (ex) {
            return deviceOrName
        }
    },
    _fromConfig: function(config) {
        var result = extend({}, DEFAULT_DEVICE, this._currentDevice, config),
            shortcuts = {
                phone: "phone" === result.deviceType,
                tablet: "tablet" === result.deviceType,
                android: "android" === result.platform,
                ios: "ios" === result.platform,
                win: "win" === result.platform,
                generic: "generic" === result.platform
            };
        return extend(result, shortcuts)
    },
    _fromUA: function(ua) {
        var config;
        $.each(uaParsers, function(platform, parser) {
            config = parser(ua);
            return !config
        });
        if (config) {
            return this._fromConfig(config)
        }
        var isMac = /(mac os)/.test(ua.toLowerCase()),
            deviceWithOS = DEFAULT_DEVICE;
        deviceWithOS.mac = isMac;
        return deviceWithOS
    },
    _changeOrientation: function() {
        var $window = $(this._window),
            orientation = $window.height() > $window.width() ? "portrait" : "landscape";
        if (this._currentOrientation === orientation) {
            return
        }
        this._currentOrientation = orientation;
        this.fireEvent("orientationChanged", [{
            orientation: orientation
        }])
    },
    _recalculateOrientation: function() {
        var windowWidth = $(this._window).width();
        if (this._currentWidth === windowWidth) {
            return
        }
        this._currentWidth = windowWidth;
        this._changeOrientation()
    }
}).include(EventsMixin);
var devices = new Devices;
viewPort.changeCallback.add(function(viewPort, prevViewport) {
    devices.detachCssClasses(prevViewport);
    devices.attachCssClasses(viewPort)
});
if (!devices.isForced() && "win" === devices.current().platform) {
    devices.current({
        version: [10]
    })
}
module.exports = devices;
module.exports.default = module.exports;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/array.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    objectUtils = __webpack_require__(84);
var isEmpty = function(entity) {
    return Array.isArray(entity) && !entity.length
};
var wrapToArray = function(entity) {
    return Array.isArray(entity) ? entity : [entity]
};
var intersection = function(a, b) {
    if (!Array.isArray(a) || 0 === a.length || !Array.isArray(b) || 0 === b.length) {
        return []
    }
    var result = [];
    $.each(a, function(_, value) {
        var index = inArray(value, b);
        if (index !== -1) {
            result.push(value)
        }
    });
    return result
};
var removeDuplicates = function(from, what) {
    if (!Array.isArray(from) || 0 === from.length) {
        return []
    }
    if (!Array.isArray(what) || 0 === what.length) {
        return from.slice()
    }
    var result = [];
    $.each(from, function(_, value) {
        var index = inArray(value, what);
        if (index === -1) {
            result.push(value)
        }
    });
    return result
};
var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
    var indexedItems = {},
        parameterIndex = 0;
    $.each(items, function(index, item) {
        index = item[indexParameterName];
        if (commonUtils.isDefined(index)) {
            indexedItems[index] = indexedItems[index] || [];
            if (item === currentItem) {
                indexedItems[index].unshift(item)
            } else {
                indexedItems[index].push(item)
            }
            delete item[indexParameterName]
        }
    });
    objectUtils.orderEach(indexedItems, function(index, items) {
        $.each(items, function() {
            if (index >= 0) {
                this[indexParameterName] = parameterIndex++
            }
        })
    });
    $.each(items, function() {
        if (!commonUtils.isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
            this[indexParameterName] = parameterIndex++
        }
    });
    return parameterIndex
};
var inArray = function(value, object) {
    if (!object) {
        return -1
    }
    var array = Array.isArray(object) ? object : object.toArray();
    return array.indexOf(value)
};
exports.isEmpty = isEmpty;
exports.wrapToArray = wrapToArray;
exports.intersection = intersection;
exports.removeDuplicates = removeDuplicates;
exports.normalizeIndexes = normalizeIndexes;
exports.inArray = inArray;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/message.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    dependencyInjector = __webpack_require__(72),
    extend = __webpack_require__(1).extend,
    stringFormat = __webpack_require__(30).format,
    humanize = __webpack_require__(36).humanize,
    coreLocalization = __webpack_require__(60);
__webpack_require__(60);
var baseDictionary = extend(true, {}, __webpack_require__(254));
var newMessages = {};
var messageLocalization = dependencyInjector({
    _dictionary: baseDictionary,
    load: function(messages) {
        extend(true, this._dictionary, messages)
    },
    _localizablePrefix: "@",
    setup: function(localizablePrefix) {
        this._localizablePrefix = localizablePrefix
    },
    localizeString: function(text) {
        var that = this,
            regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"),
            escapeString = that._localizablePrefix + that._localizablePrefix;
        return text.replace(regex, function(str, prefix, escape, localizationKey) {
            var result, defaultResult = that._localizablePrefix + localizationKey;
            if (escape !== escapeString) {
                result = that.format(localizationKey)
            }
            if (!result) {
                newMessages[localizationKey] = humanize(localizationKey)
            }
            return prefix + (result || defaultResult)
        })
    },
    _messageLoaded: function(key, locale) {
        return void 0 !== this._dictionary[locale || coreLocalization.locale()][key]
    },
    localizeNode: function(node) {
        var that = this;
        $(node).each(function(index, nodeItem) {
            if (!nodeItem.nodeType) {
                return
            }
            if (3 === nodeItem.nodeType) {
                nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue)
            } else {
                if (!$(nodeItem).is("iframe")) {
                    $.each(nodeItem.attributes || [], function(index, attr) {
                        if ("string" === typeof attr.value) {
                            var localizedValue = that.localizeString(attr.value);
                            if (attr.value !== localizedValue) {
                                attr.value = localizedValue
                            }
                        }
                    });
                    $(nodeItem).contents().each(function(index, node) {
                        that.localizeNode(node)
                    })
                }
            }
        })
    },
    getMessagesByLocales: function() {
        return this._dictionary
    },
    getDictionary: function(onlyNew) {
        if (onlyNew) {
            return newMessages
        }
        return extend({}, newMessages, this.getMessagesByLocales()[coreLocalization.locale()])
    },
    getFormatter: function(key) {
        return this._getFormatterBase(key) || this._getFormatterBase(key, "en")
    },
    _getFormatterBase: function(key, locale) {
        var localeMessages = this._dictionary[locale || coreLocalization.locale()],
            message = localeMessages && localeMessages[key];
        if (message) {
            return function() {
                var args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
                args.unshift(message);
                return stringFormat.apply(this, args)
            }
        }
    },
    format: function(key) {
        var formatter = this.getFormatter(key);
        return formatter && formatter() || ""
    }
});
module.exports = messageLocalization;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/type.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var isEmptyObject = function(object) {
    var property;
    for (property in object) {
        return false
    }
    return true
};
var isPlainObject = function(object) {
    if (!object || "[object Object]" !== Object.prototype.toString.call(object)) {
        return false
    }
    var proto = Object.getPrototypeOf(object),
        ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object)
};
exports.isEmptyObject = isEmptyObject;
exports.isPlainObject = isPlainObject;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/jquery/deferred.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    compareVersion = __webpack_require__(37).compare;
exports.fromPromise = function(promise, context) {
    var isDeferred = promise && commonUtils.isFunction(promise.done) && commonUtils.isFunction(promise.fail);
    if (isDeferred) {
        return promise
    }
    var d = $.Deferred();
    promise.then(function() {
        d.resolveWith.apply(d, [context].concat([$.makeArray(arguments)]))
    }, function() {
        d.rejectWith.apply(d, [context].concat([$.makeArray(arguments)]))
    });
    return d
};
exports.when = compareVersion($.fn.jquery, [3]) < 0 ? $.when : function(singleArg) {
    if (0 === arguments.length) {
        return $.Deferred().resolve()
    } else {
        if (1 === arguments.length) {
            return singleArg && singleArg.then ? singleArg : $.Deferred().resolve(singleArg)
        } else {
            return $.when.apply($, arguments)
        }
    }
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/click.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    domUtils = __webpack_require__(15),
    animationFrame = __webpack_require__(87),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    Emitter = __webpack_require__(89),
    registerEmitter = __webpack_require__(63),
    compareVersions = __webpack_require__(37).compare;
var CLICK_EVENT_NAME = "dxclick",
    TOUCH_BOUNDARY = 10,
    abs = Math.abs;
var isInput = function(element) {
    return $(element).is("input, textarea, select, button ,:focus, :focus *")
};
var misc = {
    requestAnimationFrame: animationFrame.requestAnimationFrame,
    cancelAnimationFrame: animationFrame.cancelAnimationFrame
};
var ClickEmitter = Emitter.inherit({
    ctor: function(element) {
        this.callBase(element);
        this._makeElementClickable($(element))
    },
    _makeElementClickable: function($element) {
        if (!$element.attr("onclick")) {
            $element.attr("onclick", "void(0)")
        }
    },
    start: function(e) {
        this._blurPrevented = e.isDefaultPrevented();
        this._startTarget = e.target;
        this._startEventData = eventUtils.eventData(e)
    },
    end: function(e) {
        if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointerEvents.cancel) {
            this._cancel(e);
            return
        }
        if (!isInput(e.target) && !this._blurPrevented) {
            domUtils.resetActiveElement()
        }
        this._accept(e);
        this._clickAnimationFrame = misc.requestAnimationFrame(function() {
            this._fireClickEvent(e)
        }.bind(this))
    },
    _eventOutOfElement: function(e, element) {
        var target = e.target,
            targetChanged = !$.contains(element, target) && element !== target,
            gestureDelta = eventUtils.eventDelta(eventUtils.eventData(e), this._startEventData),
            boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
        return targetChanged || boundsExceeded
    },
    _fireClickEvent: function(e) {
        this._fireEvent(CLICK_EVENT_NAME, e, {
            target: domUtils.closestCommonParent(this._startTarget, e.target)
        })
    },
    dispose: function() {
        misc.cancelAnimationFrame(this._clickAnimationFrame)
    }
});
! function() {
    var NATIVE_CLICK_CLASS = "dx-native-click";
    var realDevice = devices.real(),
        useNativeClick = realDevice.generic || realDevice.ios && compareVersions(realDevice.version, [9, 3]) >= 0 || realDevice.android && compareVersions(realDevice.version, [5]) >= 0;
    var isNativeClickEvent = function(target) {
        return useNativeClick || $(target).closest("." + NATIVE_CLICK_CLASS).length
    };
    var prevented = null,
        lastFiredEvent = null;
    var clickHandler = function(e) {
        var originalEvent = e.originalEvent,
            eventAlreadyFired = lastFiredEvent !== originalEvent,
            leftButton = !e.which || 1 === e.which;
        if (leftButton && !prevented && isNativeClickEvent(e.target) && eventAlreadyFired) {
            lastFiredEvent = originalEvent;
            eventUtils.fireEvent({
                type: CLICK_EVENT_NAME,
                originalEvent: e
            })
        }
    };
    ClickEmitter = ClickEmitter.inherit({
        _makeElementClickable: function($element) {
            if (!isNativeClickEvent($element)) {
                this.callBase($element)
            }
            $element.on("click", clickHandler)
        },
        configure: function(data) {
            this.callBase(data);
            if (data.useNative) {
                this.getElement().addClass(NATIVE_CLICK_CLASS)
            }
        },
        start: function(e) {
            prevented = null;
            if (!isNativeClickEvent(e.target)) {
                this.callBase(e)
            }
        },
        end: function(e) {
            if (!isNativeClickEvent(e.target)) {
                this.callBase(e)
            }
        },
        cancel: function() {
            prevented = true
        },
        dispose: function() {
            this.callBase();
            this.getElement().off("click", clickHandler)
        }
    })
}();
! function() {
    var desktopDevice = devices.real().generic;
    if (!desktopDevice) {
        var startTarget = null,
            blurPrevented = false;
        var pointerDownHandler = function(e) {
            startTarget = e.target;
            blurPrevented = e.isDefaultPrevented()
        };
        var clickHandler = function(e) {
            var $target = $(e.target);
            if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target)) {
                domUtils.resetActiveElement()
            }
            startTarget = null;
            blurPrevented = false
        };
        var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
        $(document).on(eventUtils.addNamespace(pointerEvents.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler).on(eventUtils.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
    }
}();
registerEmitter({
    emitter: ClickEmitter,
    bubble: true,
    events: [CLICK_EVENT_NAME]
});
exports.name = CLICK_EVENT_NAME;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    gridCoreUtils = __webpack_require__(26),
    modules = __webpack_require__(23);
extend(exports, modules, gridCoreUtils, {
    modules: []
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/errors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errorUtils = __webpack_require__(102);
module.exports = errorUtils({
    E0001: "Method is not implemented",
    E0002: "Member name collision: {0}",
    E0003: "A class must be instantiated using the 'new' keyword",
    E0004: "The NAME property of the component is not specified",
    E0005: "Unknown device",
    E0006: "Unknown endpoint key is requested",
    E0007: "'Invalidate' method is called outside the update transaction",
    E0008: "Type of the option name is not appropriate to create an action",
    E0009: "Component '{0}' has not been initialized for an element",
    E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
    E0011: "Unknown animation type '{0}'",
    E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
    E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
    E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
    E0015: "Queued task returned an unexpected result",
    E0017: "Event namespace is not defined",
    E0018: "DevExpress.ui.DevExpressPopup widget is required",
    E0020: "Template engine '{0}' is not supported",
    E0021: "Unknown theme is set: {0}",
    E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
    E0023: "Template name is not specified",
    E0024: "DevExtreme bundle already included",
    E0100: "Unknown validation type is detected",
    E0101: "Misconfigured range validation rule is detected",
    E0102: "Misconfigured comparison validation rule is detected",
    E0110: "Unknown validation group is detected",
    E0120: "Adapter for a DevExpressValidator component cannot be configured",
    E0121: "The onCustomItemCreating action should return an item or Promise of jQuery Deferred object resolved when an item is created",
    E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
    W0000: "'{0}' is deprecated in {1}. {2}",
    W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
    W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
    W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
    W0004: "Timeout for theme loading is over: {0}",
    W0005: "'{0}' event is deprecated in {1}. {2}",
    W0006: "Invalid recurrence rule: '{0}'",
    W0007: "'{0}' Globalize culture is not defined",
    W0008: "Invalid view name: '{0}'",
    W0009: "Invalid time zone name: '{0}'",
    W0010: "{0} is deprecated in {1}. {2}",
    W0011: "Number parsing is invoked while the parser is not defined",
    W0012: "Date parsing is invoked while the parser is not defined",
    W0013: "'{0}' file is deprecated in {1}. {2}"
});


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/data.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(13),
    Class = __webpack_require__(5),
    objectUtils = __webpack_require__(84),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    variableWrapper = __webpack_require__(41),
    unwrapVariable = variableWrapper.unwrap,
    isWrapped = variableWrapper.isWrapped,
    assign = variableWrapper.assign;
var bracketsToDots = function(expr) {
    return expr.replace(/\[/g, ".").replace(/\]/g, "")
};
var readPropValue = function(obj, propName) {
    if ("this" === propName) {
        return obj
    }
    return obj[propName]
};
var assignPropValue = function(obj, propName, value, options) {
    if ("this" === propName) {
        throw new errors.Error("E4016")
    }
    var propValue = obj[propName];
    if (options.unwrapObservables && isWrapped(propValue)) {
        assign(propValue, value)
    } else {
        obj[propName] = value
    }
};
var prepareOptions = function(options) {
    options = options || {};
    options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;
    return options
};
var unwrap = function(value, options) {
    return options.unwrapObservables ? unwrapVariable(value) : value
};
var compileGetter = function(expr) {
    if (arguments.length > 1) {
        expr = $.makeArray(arguments)
    }
    if (!expr || "this" === expr) {
        return function(obj) {
            return obj
        }
    }
    if ("string" === typeof expr) {
        expr = bracketsToDots(expr);
        var path = expr.split(".");
        return function(obj, options) {
            options = prepareOptions(options);
            var functionAsIs = options.functionsAsIs,
                current = unwrap(obj, options);
            for (var i = 0; i < path.length; i++) {
                if (!current) {
                    break
                }
                var next = unwrap(current[path[i]], options);
                if (!functionAsIs && commonUtils.isFunction(next)) {
                    next = next.call(current)
                }
                current = next
            }
            return current
        }
    }
    if (Array.isArray(expr)) {
        return combineGetters(expr)
    }
    if (commonUtils.isFunction(expr)) {
        return expr
    }
};
var combineGetters = function(getters) {
    var compiledGetters = {};
    for (var i = 0, l = getters.length; i < l; i++) {
        var getter = getters[i];
        compiledGetters[getter] = compileGetter(getter)
    }
    return function(obj, options) {
        var result;
        $.each(compiledGetters, function(name) {
            var current, path, last, i, value = this(obj, options);
            if (void 0 === value) {
                return
            }
            current = result || (result = {});
            path = name.split(".");
            last = path.length - 1;
            for (i = 0; i < last; i++) {
                current = current[path[i]] = {}
            }
            current[path[i]] = value
        });
        return result
    }
};
var compileSetter = function(expr) {
    expr = expr || "this";
    expr = bracketsToDots(expr);
    var pos = expr.lastIndexOf("."),
        targetGetter = compileGetter(expr.substr(0, pos)),
        targetPropName = expr.substr(1 + pos);
    return function(obj, value, options) {
        options = prepareOptions(options);
        var target = targetGetter(obj, {
                functionsAsIs: options.functionsAsIs,
                unwrapObservables: options.unwrapObservables
            }),
            prevTargetValue = readPropValue(target, targetPropName);
        if (!options.functionsAsIs && commonUtils.isFunction(prevTargetValue) && !isWrapped(prevTargetValue)) {
            target[targetPropName](value)
        } else {
            prevTargetValue = unwrap(prevTargetValue, options);
            if (options.merge && typeUtils.isPlainObject(value) && (void 0 === prevTargetValue || typeUtils.isPlainObject(prevTargetValue)) && !(value instanceof $.Event)) {
                if (!prevTargetValue) {
                    assignPropValue(target, targetPropName, {}, options)
                }
                target = unwrap(readPropValue(target, targetPropName), options);
                objectUtils.deepExtendArraySafe(target, value, false, true)
            } else {
                assignPropValue(target, targetPropName, value, options)
            }
        }
    }
};
var toComparable = function(value, caseSensitive) {
    if (value instanceof Date) {
        return value.getTime()
    }
    if (value && value instanceof Class && value.valueOf) {
        return value.valueOf()
    }
    if (!caseSensitive && "string" === typeof value) {
        return value.toLowerCase()
    }
    return value
};
exports.compileGetter = compileGetter;
exports.compileSetter = compileSetter;
exports.toComparable = toComparable;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/dom.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(13),
    inArray = __webpack_require__(7).inArray,
    commonUtils = __webpack_require__(2);
var resetActiveElement = function() {
    var activeElement = document.activeElement;
    if (activeElement && activeElement !== document.body && activeElement.blur) {
        activeElement.blur()
    }
};
var clearSelection = function() {
    var selection = window.getSelection();
    if (!selection) {
        return
    }
    if ("Caret" === selection.type) {
        return
    }
    if (selection.empty) {
        selection.empty()
    } else {
        if (selection.removeAllRanges) {
            try {
                selection.removeAllRanges()
            } catch (e) {}
        }
    }
};
var closestCommonParent = function(startTarget, endTarget) {
    var $startTarget = $(startTarget),
        $endTarget = $(endTarget);
    if ($startTarget[0] === $endTarget[0]) {
        return $startTarget[0]
    }
    var $startParents = $startTarget.parents(),
        $endParents = $endTarget.parents(),
        startingParent = Math.min($startParents.length, $endParents.length);
    for (var i = -startingParent; i < 0; i++) {
        if ($startParents.get(i) === $endParents.get(i)) {
            return $startParents.get(i)
        }
    }
};
var triggerVisibilityChangeEvent = function(eventName) {
    var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
    return function(element) {
        var $element = $(element || "body");
        var changeHandlers = $element.filter(VISIBILITY_CHANGE_SELECTOR).add($element.find(VISIBILITY_CHANGE_SELECTOR));
        for (var i = 0; i < changeHandlers.length; i++) {
            $(changeHandlers[i]).triggerHandler(eventName)
        }
    }
};
var uniqueId = function() {
    var counter = 0;
    return function(prefix) {
        return (prefix || "") + counter++
    }
}();
var dataOptionsAttributeName = "data-options";
var getElementOptions = function(element) {
    var result, optionsString = $(element).attr(dataOptionsAttributeName);
    if ("{" !== $.trim(optionsString).charAt(0)) {
        optionsString = "{" + optionsString + "}"
    }
    try {
        result = new Function("return " + optionsString)()
    } catch (ex) {
        throw errors.Error("E3018", ex, optionsString)
    }
    return result
};
var createComponents = function(elements, componentTypes) {
    var result = [],
        selector = "[" + dataOptionsAttributeName + "]";
    var $items = elements.find(selector).add(elements.filter(selector));
    $items.each(function(index, element) {
        var $element = $(element),
            options = getElementOptions(element);
        for (var componentName in options) {
            if (!componentTypes || inArray(componentName, componentTypes) > -1) {
                if ($element[componentName]) {
                    $element[componentName](options[componentName]);
                    result.push($element[componentName]("instance"))
                }
            }
        }
    });
    return result
};
var createMarkupFromString = function(str) {
    if (!window.WinJS) {
        return $(str)
    }
    var tempElement = $("<div />");
    window.WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
    return tempElement.contents()
};
var normalizeTemplateElement = function(element) {
    var $element = commonUtils.isDefined(element) && (element.nodeType || element.jquery) ? $(element) : $("<div>").html(element).contents();
    if (1 === $element.length) {
        if ($element.is("script")) {
            $element = normalizeTemplateElement($element.html())
        } else {
            if ($element.is("table")) {
                $element = $element.children("tbody").contents()
            }
        }
    }
    return $element
};
var toggleAttr = function($target, attr, value) {
    value ? $target.attr(attr, value) : $target.removeAttr(attr)
};
var clipboardText = function(event, text) {
    var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
    if (1 === arguments.length) {
        return clipboard && clipboard.getData("Text")
    }
    clipboard && clipboard.setData("Text", text)
};
exports.resetActiveElement = resetActiveElement;
exports.createMarkupFromString = createMarkupFromString;
exports.triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
exports.triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
exports.triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
exports.getElementOptions = getElementOptions;
exports.createComponents = createComponents;
exports.normalizeTemplateElement = normalizeTemplateElement;
exports.clearSelection = clearSelection;
exports.uniqueId = uniqueId;
exports.closestCommonParent = closestCommonParent;
exports.clipboardText = clipboardText;
exports.toggleAttr = toggleAttr;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/ui.errors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errorUtils = __webpack_require__(102),
    errors = __webpack_require__(13);
module.exports = errorUtils(errors.ERROR_MESSAGES, {
    E1001: "Module '{0}'. Controller '{1}' is already registered",
    E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
    E1003: "Module '{0}'. View '{1}' is already registered",
    E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
    E1005: "Public method '{0}' is already registered",
    E1006: "Public method '{0}.{1}' does not exist",
    E1007: "State storing cannot be provided due to the restrictions of the browser",
    E1010: "The template does not contain the TextBox widget",
    E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
    E1012: "Editing type '{0}' with the name '{1}' is unsupported",
    E1016: "Unexpected type of data source is provided for a lookup column",
    E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
    E1019: "Search mode '{0}' is unavailable",
    E1020: "The type cannot be changed after initialization",
    E1021: "{0} '{1}' you are trying to remove does not exist",
    E1022: 'The "markers" option is given an invalid value. Assign an array instead',
    E1023: 'The "routes" option is given an invalid value. Assign an array instead',
    E1025: "This layout is too complex to render",
    E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
    E1030: "Unknown ScrollView refresh strategy: '{0}'",
    E1031: "Unknown subscription in the Scheduler widget: '{0}'",
    E1032: "Unknown start date in an appointment: '{0}'",
    E1033: "Unknown step in the date navigator: '{0}'",
    E1034: "The browser does not implement an API for saving files",
    E1035: "The editor cannot be created because of an internal error: {0}",
    E1036: "Validation rules are not defined for any form item",
    E1037: "Invalid structure of grouped data",
    E1038: "The browser does not support local storages for local web pages",
    E1039: "A cell's position cannot be calculated",
    E1040: "The '{0}' key value is not unique within the data array",
    E1041: "The JSZip script is referenced after DevExtreme scripts",
    E1042: 'Deferred selection cannot be performed. Set the "key" field for the data store',
    E1043: "Changes cannot be processed due to the incorrectly set key",
    E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
    E1045: "Editing requires the key field to be specified in the data store",
    E1046: "The '{0}' key field is not found in data objects",
    W1001: 'The "key" option cannot be modified after initialization',
    W1002: "An item with the key '{0}' does not exist",
    W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
    W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
    W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
    W1006: "The map service returned the '{0}' error",
    W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
    W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view"
});


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    devices = __webpack_require__(6),
    registerEvent = __webpack_require__(47),
    TouchStrategy = __webpack_require__(169),
    MsPointerStrategy = __webpack_require__(251),
    MouseStrategy = __webpack_require__(171),
    MouseAndTouchStrategy = __webpack_require__(252);
var EventStrategy = function() {
    if (support.pointerEvents) {
        return MsPointerStrategy
    }
    var device = devices.real();
    if (support.touch && !(device.tablet || device.phone)) {
        return MouseAndTouchStrategy
    }
    if (support.touch) {
        return TouchStrategy
    }
    return MouseStrategy
}();
$.each(EventStrategy.map, function(pointerEvent, originalEvents) {
    registerEvent(pointerEvent, new EventStrategy(pointerEvent, originalEvents))
});
module.exports = {
    down: "dxpointerdown",
    up: "dxpointerup",
    move: "dxpointermove",
    cancel: "dxpointercancel",
    enter: "dxpointerenter",
    leave: "dxpointerleave",
    over: "dxpointerover",
    out: "dxpointerout"
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    modules = __webpack_require__(23);
extend(exports, modules, {
    modules: []
});


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/translator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    type = __webpack_require__(2).type;
var TRANSLATOR_DATA_KEY = "dxTranslator",
    TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
    TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
    var translate = getTranslate($element);
    return {
        left: translate.x,
        top: translate.y
    }
};
var move = function($element, position) {
    var translate, left = position.left,
        top = position.top;
    if (void 0 === left) {
        translate = getTranslate($element);
        translate.y = top || 0
    } else {
        if (void 0 === top) {
            translate = getTranslate($element);
            translate.x = left || 0
        } else {
            translate = {
                x: left || 0,
                y: top || 0,
                z: 0
            };
            cacheTranslate($element, translate)
        }
    }
    $element.css({
        transform: getTranslateCss(translate)
    });
    if (isPercentValue(left) || isPercentValue(top)) {
        clearCache($element)
    }
};
var isPercentValue = function(value) {
    return "string" === type(value) && "%" === value[value.length - 1]
};
var getTranslate = function($element) {
    var result = $element.length ? $.data($element.get(0), TRANSLATOR_DATA_KEY) : null;
    if (!result) {
        var transformValue = $element.css("transform") || getTranslateCss({
                x: 0,
                y: 0
            }),
            matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
            is3D = matrix && matrix[1];
        if (matrix) {
            matrix = matrix[2].split(",");
            if ("3d" === is3D) {
                matrix = matrix.slice(12, 15)
            } else {
                matrix.push(0);
                matrix = matrix.slice(4, 7)
            }
        } else {
            matrix = [0, 0, 0]
        }
        result = {
            x: parseFloat(matrix[0]),
            y: parseFloat(matrix[1]),
            z: parseFloat(matrix[2])
        };
        cacheTranslate($element, result)
    }
    return result
};
var cacheTranslate = function($element, translate) {
    if ($element.length) {
        $.data($element.get(0), TRANSLATOR_DATA_KEY, translate)
    }
};
var clearCache = function($element) {
    if ($element.length) {
        $.removeData($element.get(0), TRANSLATOR_DATA_KEY)
    }
};
var resetPosition = function($element) {
    $element.css({
        left: 0,
        top: 0,
        transform: "none"
    });
    clearCache($element)
};
var parseTranslate = function(translateString) {
    var result = translateString.match(TRANSLATE_REGEX);
    if (!result || !result[1]) {
        return
    }
    result = result[1].split(",");
    result = {
        x: parseFloat(result[0]),
        y: parseFloat(result[1]),
        z: parseFloat(result[2])
    };
    return result
};
var getTranslateCss = function(translate) {
    translate.x = translate.x || 0;
    translate.y = translate.y || 0;
    var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
    var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
    return "translate(" + xValueString + ", " + yValueString + ")"
};
exports.move = move;
exports.locate = locate;
exports.clearCache = clearCache;
exports.parseTranslate = parseTranslate;
exports.getTranslate = getTranslate;
exports.getTranslateCss = getTranslateCss;
exports.resetPosition = resetPosition;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/themes.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    domUtils = __webpack_require__(15),
    ready = __webpack_require__(135),
    devices = __webpack_require__(6),
    viewPortUtils = __webpack_require__(54),
    viewPort = viewPortUtils.value,
    viewPortChanged = viewPortUtils.changeCallback,
    holdReady = $.holdReady || $.fn.holdReady;
var DX_LINK_SELECTOR = "link[rel=dx-theme]",
    THEME_ATTR = "data-theme",
    ACTIVE_ATTR = "data-active",
    DX_HAIRLINES_CLASS = "dx-hairlines";
var context, $activeThemeLink, knownThemes, currentThemeName, pendingThemeName;
var THEME_MARKER_PREFIX = "dx.";

function readThemeMarker() {
    var result, element = $("<div></div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
    try {
        result = element.css("font-family");
        if (!result) {
            return null
        }
        result = result.replace(/["']/g, "");
        if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
            return null
        }
        return result.substr(THEME_MARKER_PREFIX.length)
    } finally {
        element.remove()
    }
}

function waitForThemeLoad(themeName, callback) {
    var timerId, waitStartTime;
    pendingThemeName = themeName;

    function handleLoaded() {
        pendingThemeName = null;
        callback()
    }
    if (isPendingThemeLoaded()) {
        handleLoaded()
    } else {
        waitStartTime = $.now();
        timerId = setInterval(function() {
            var isLoaded = isPendingThemeLoaded(),
                isTimeout = !isLoaded && $.now() - waitStartTime > 15e3;
            if (isTimeout) {
                errors.log("W0004", pendingThemeName)
            }
            if (isLoaded || isTimeout) {
                clearInterval(timerId);
                handleLoaded()
            }
        }, 10)
    }
}

function isPendingThemeLoaded() {
    return !pendingThemeName || readThemeMarker() === pendingThemeName
}

function processMarkup() {
    var $allThemeLinks = $(DX_LINK_SELECTOR, context);
    if (!$allThemeLinks.length) {
        return
    }
    knownThemes = {};
    $activeThemeLink = $(domUtils.createMarkupFromString("<link rel=stylesheet>"), context);
    $allThemeLinks.each(function() {
        var link = $(this, context),
            fullThemeName = link.attr(THEME_ATTR),
            url = link.attr("href"),
            isActive = "true" === link.attr(ACTIVE_ATTR);
        knownThemes[fullThemeName] = {
            url: url,
            isActive: isActive
        }
    });
    $allThemeLinks.last().after($activeThemeLink);
    $allThemeLinks.remove()
}

function resolveFullThemeName(desiredThemeName) {
    var desiredThemeParts = desiredThemeName.split("."),
        result = null;
    if (knownThemes) {
        if (desiredThemeName in knownThemes) {
            return desiredThemeName
        }
        $.each(knownThemes, function(knownThemeName, themeData) {
            var knownThemeParts = knownThemeName.split(".");
            if (knownThemeParts[0] !== desiredThemeParts[0]) {
                return
            }
            if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
                return
            }
            if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
                return
            }
            if (!result || themeData.isActive) {
                result = knownThemeName
            }
            if (themeData.isActive) {
                return false
            }
        })
    }
    return result
}

function initContext(newContext) {
    try {
        if (newContext !== context) {
            knownThemes = null
        }
    } catch (x) {
        knownThemes = null
    }
    context = newContext
}

function init(options) {
    options = options || {};
    initContext(options.context || document);
    processMarkup();
    currentThemeName = void 0;
    current(options)
}

function current(options) {
    if (!arguments.length) {
        currentThemeName = currentThemeName || readThemeMarker();
        return currentThemeName
    }
    detachCssClasses(viewPort());
    options = options || {};
    if ("string" === typeof options) {
        options = {
            theme: options
        }
    }
    var currentThemeData, isAutoInit = options._autoInit,
        loadCallback = options.loadCallback;
    currentThemeName = options.theme || currentThemeName;
    if (isAutoInit && !currentThemeName) {
        currentThemeName = themeNameFromDevice(devices.current())
    }
    currentThemeName = resolveFullThemeName(currentThemeName);
    if (currentThemeName) {
        currentThemeData = knownThemes[currentThemeName]
    }
    if (currentThemeData) {
        $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
        if (loadCallback) {
            waitForThemeLoad(currentThemeName, loadCallback)
        } else {
            if (pendingThemeName) {
                pendingThemeName = currentThemeName
            }
        }
    } else {
        if (isAutoInit) {
            if (loadCallback) {
                loadCallback()
            }
        } else {
            throw errors.Error("E0021", currentThemeName)
        }
    }
    attachCssClasses(viewPortUtils.originalViewPort(), currentThemeName)
}

function themeNameFromDevice(device) {
    var themeName = device.platform;
    var majorVersion = device.version && device.version[0];
    switch (themeName) {
        case "ios":
            themeName += "7";
            break;
        case "android":
            themeName += "5";
            break;
        case "win":
            themeName += majorVersion && 8 === majorVersion ? "8" : "10"
    }
    return themeName
}

function getCssClasses(themeName) {
    themeName = themeName || current();
    var result = [],
        themeNameParts = themeName && themeName.split(".");
    if (themeNameParts) {
        result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
        if (themeNameParts.length > 1) {
            result.push("dx-color-scheme-" + themeNameParts[1])
        }
    }
    return result
}
var themeClasses;

function attachCssClasses(element, themeName) {
    themeClasses = getCssClasses(themeName).join(" ");
    $(element).addClass(themeClasses);
    var activateHairlines = function() {
        var pixelRatio = window.devicePixelRatio;
        if (!pixelRatio || pixelRatio < 2) {
            return
        }
        var $tester = $("<div>");
        $tester.css("border", ".5px solid transparent");
        $("body").append($tester);
        if (1 === $tester.outerHeight()) {
            $(element).addClass(DX_HAIRLINES_CLASS);
            themeClasses += " " + DX_HAIRLINES_CLASS
        }
        $tester.remove()
    };
    activateHairlines()
}

function detachCssClasses(element) {
    $(element).removeClass(themeClasses)
}
holdReady(true);
init({
    _autoInit: true,
    loadCallback: function() {
        holdReady(false)
    }
});
ready(function() {
    if ($(DX_LINK_SELECTOR, context).length) {
        throw errors.Error("E0022")
    }
});
viewPortChanged.add(function(viewPort, prevViewPort) {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort)
});
devices.changed.add(function() {
    init({
        _autoInit: true
    })
});
exports.current = current;
exports.init = init;
exports.attachCssClasses = attachCssClasses;
exports.detachCssClasses = detachCssClasses;
exports.themeNameFromDevice = themeNameFromDevice;
exports.waitForThemeLoad = waitForThemeLoad;
exports.resetTheme = function() {
    $activeThemeLink && $activeThemeLink.attr("href", "about:blank");
    currentThemeName = null;
    pendingThemeName = null
};
module.exports.default = module.exports;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/browser.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend;
var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
    ieRegExp = /(msie) (\d{1,2}\.\d)/,
    ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/,
    msEdge = /(edge)\/((\d+)?[\w\.]+)/,
    safari = /(safari)/i,
    mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = function(ua) {
    ua = ua.toLowerCase();
    var result = {},
        matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [],
        browserName = matches[1],
        browserVersion = matches[2];
    if ("webkit" === browserName && ua.indexOf("chrome") < 0 && safari.exec(ua)) {
        browserName = "safari";
        result.webkit = true;
        browserVersion = /Version\/([0-9.]+)/i.exec(ua);
        browserVersion = browserVersion && browserVersion[1]
    }
    if ("trident" === browserName || "edge" === browserName) {
        browserName = "msie"
    }
    if (browserName) {
        result[browserName] = true;
        result.version = browserVersion
    }
    return result
};
module.exports = extend({
    _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/fx.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(13),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    translator = __webpack_require__(19),
    animationFrame = __webpack_require__(87),
    support = __webpack_require__(24),
    positionUtils = __webpack_require__(46),
    removeEvent = __webpack_require__(86),
    eventUtils = __webpack_require__(3),
    when = __webpack_require__(10).when,
    transitionEndEventName = support.transitionEndEventName + ".dxFX",
    removeEventName = eventUtils.addNamespace(removeEvent, "dxFX"),
    isFunction = commonUtils.isFunction,
    isPlainObject = typeUtils.isPlainObject,
    noop = commonUtils.noop;
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
    RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i,
    ANIM_DATA_KEY = "dxAnimData",
    ANIM_QUEUE_KEY = "dxAnimQueue",
    TRANSFORM_PROP = "transform";
var TransitionAnimationStrategy = {
    initAnimation: function($element, config) {
        $element.css({
            transitionProperty: "none"
        });
        if ("string" === typeof config.from) {
            $element.addClass(config.from)
        } else {
            setProps($element, config.from)
        }
        var that = this,
            deferred = $.Deferred(),
            cleanupWhen = config.cleanupWhen;
        config.transitionAnimation = {
            deferred: deferred,
            finish: function() {
                that._finishTransition($element);
                if (cleanupWhen) {
                    when(deferred, cleanupWhen).always(function() {
                        that._cleanup($element, config)
                    })
                } else {
                    that._cleanup($element, config)
                }
                deferred.resolveWith($element, [config, $element])
            }
        };
        this._completeAnimationCallback($element, config).done(function() {
            config.transitionAnimation.finish()
        }).fail(function() {
            deferred.rejectWith($element, [config, $element])
        });
        if (!config.duration) {
            config.transitionAnimation.finish()
        }
        $element.css("transform")
    },
    animate: function($element, config) {
        this._startAnimation($element, config);
        return config.transitionAnimation.deferred.promise()
    },
    _completeAnimationCallback: function($element, config) {
        var simulatedEndEventTimer, waitForJSCompleteTimer, that = this,
            startTime = $.now() + config.delay,
            deferred = $.Deferred(),
            transitionEndFired = $.Deferred(),
            simulatedTransitionEndFired = $.Deferred();
        config.transitionAnimation.cleanup = function() {
            clearTimeout(simulatedEndEventTimer);
            clearTimeout(waitForJSCompleteTimer);
            $element.off(transitionEndEventName);
            $element.off(removeEventName)
        };
        $element.one(transitionEndEventName, function() {
            if ($.now() - startTime >= config.duration) {
                transitionEndFired.reject()
            }
        }).off(removeEventName).on(removeEventName, function() {
            that.stop($element, config);
            deferred.reject()
        });
        waitForJSCompleteTimer = setTimeout(function() {
            simulatedEndEventTimer = setTimeout(function() {
                simulatedTransitionEndFired.reject()
            }, config.duration + config.delay + fx._simulatedTransitionEndDelay);
            when(transitionEndFired, simulatedTransitionEndFired).fail(function() {
                deferred.resolve()
            }.bind(this))
        });
        return deferred.promise()
    },
    _startAnimation: function($element, config) {
        $element.css({
            transitionProperty: "all",
            transitionDelay: config.delay + "ms",
            transitionDuration: config.duration + "ms",
            transitionTimingFunction: config.easing
        });
        if ("string" === typeof config.to) {
            $element[0].className += " " + config.to
        } else {
            if (config.to) {
                setProps($element, config.to)
            }
        }
    },
    _finishTransition: function($element) {
        $element.css("transition", "none")
    },
    _cleanup: function($element, config) {
        config.transitionAnimation.cleanup();
        if ("string" === typeof config.from) {
            $element.removeClass(config.from);
            $element.removeClass(config.to)
        }
    },
    stop: function($element, config, jumpToEnd) {
        if (!config) {
            return
        }
        if (jumpToEnd) {
            config.transitionAnimation.finish()
        } else {
            if (isPlainObject(config.to)) {
                $.each(config.to, function(key) {
                    $element.css(key, $element.css(key))
                })
            }
            this._finishTransition($element);
            this._cleanup($element, config)
        }
    }
};
var FrameAnimationStrategy = {
    initAnimation: function($element, config) {
        setProps($element, config.from)
    },
    animate: function($element, config) {
        var deferred = $.Deferred(),
            that = this;
        if (!config) {
            return deferred.reject().promise()
        }
        $.each(config.to, function(prop) {
            if (void 0 === config.from[prop]) {
                config.from[prop] = that._normalizeValue($element.css(prop))
            }
        });
        if (config.to[TRANSFORM_PROP]) {
            config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
            config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
        }
        config.frameAnimation = {
            to: config.to,
            from: config.from,
            currentValue: config.from,
            easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
            duration: config.duration,
            startTime: (new Date).valueOf(),
            finish: function() {
                this.currentValue = this.to;
                this.draw();
                animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId);
                deferred.resolve()
            },
            draw: function() {
                if (config.draw) {
                    config.draw(this.currentValue);
                    return
                }
                var currentValue = extend({}, this.currentValue);
                if (currentValue[TRANSFORM_PROP]) {
                    currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                        if ("translate" === prop) {
                            return translator.getTranslateCss(value)
                        } else {
                            if ("scale" === prop) {
                                return "scale(" + value + ")"
                            } else {
                                if ("rotate" === prop.substr(0, prop.length - 1)) {
                                    return prop + "(" + value + "deg)"
                                }
                            }
                        }
                    }).join(" ")
                }
                $element.css(currentValue)
            }
        };
        if (config.delay) {
            config.frameAnimation.startTime += config.delay;
            config.frameAnimation.delayTimeout = setTimeout(function() {
                that._startAnimation($element, config)
            }, config.delay)
        } else {
            that._startAnimation($element, config)
        }
        return deferred.promise()
    },
    _startAnimation: function($element, config) {
        $element.off(removeEventName).on(removeEventName, function() {
            if (config.frameAnimation) {
                animationFrame.cancelAnimationFrame(config.frameAnimation.animationFrameId)
            }
        });
        this._animationStep($element, config)
    },
    _parseTransform: function(transformString) {
        var result = {};
        $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
            var translateData = translator.parseTranslate(part),
                scaleData = part.match(/scale\((.+?)\)/),
                rotateData = part.match(/(rotate.)\((.+)deg\)/);
            if (translateData) {
                result.translate = translateData
            }
            if (scaleData && scaleData[1]) {
                result.scale = parseFloat(scaleData[1])
            }
            if (rotateData && rotateData[1]) {
                result[rotateData[1]] = parseFloat(rotateData[2])
            }
        });
        return result
    },
    stop: function($element, config, jumpToEnd) {
        var frameAnimation = config && config.frameAnimation;
        if (!frameAnimation) {
            return
        }
        animationFrame.cancelAnimationFrame(frameAnimation.animationFrameId);
        clearTimeout(frameAnimation.delayTimeout);
        if (jumpToEnd) {
            frameAnimation.finish()
        }
        delete config.frameAnimation
    },
    _animationStep: function($element, config) {
        var frameAnimation = config && config.frameAnimation;
        if (!frameAnimation) {
            return
        }
        var now = (new Date).valueOf();
        if (now >= frameAnimation.startTime + frameAnimation.duration) {
            frameAnimation.finish();
            return
        }
        frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
        frameAnimation.draw();
        var that = this;
        frameAnimation.animationFrameId = animationFrame.requestAnimationFrame(function() {
            that._animationStep($element, config)
        })
    },
    _calcStepValue: function(frameAnimation, currentDuration) {
        var calcValueRecursively = function(from, to) {
            var result = Array.isArray(to) ? [] : {};
            var calcEasedValue = function(propName) {
                var x = currentDuration / frameAnimation.duration,
                    t = currentDuration,
                    b = 1 * from[propName],
                    c = to[propName] - from[propName],
                    d = frameAnimation.duration;
                return $.easing[frameAnimation.easing](x, t, b, c, d)
            };
            $.each(to, function(propName, endPropValue) {
                if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
                    return true
                }
                result[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
            });
            return result
        };
        return calcValueRecursively(frameAnimation.from, frameAnimation.to)
    },
    _normalizeValue: function(value) {
        var numericValue = parseFloat(value, 10);
        if (false === numericValue) {
            return value
        }
        return numericValue
    }
};
var FallbackToNoAnimationStrategy = {
    initAnimation: function() {},
    animate: function() {
        return $.Deferred().resolve().promise()
    },
    stop: noop,
    isSynchronous: true
};
var animationStrategies = {
    transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
};
var getAnimationStrategy = function(config) {
    config = config || {};
    var strategy = config.strategy || "transition";
    if ("css" === config.type && !support.transition) {
        strategy = "noAnimation"
    }
    return animationStrategies[strategy]
};
var TransitionTimingFuncMap = {
    linear: "cubic-bezier(0, 0, 1, 1)",
    ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
    cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
    var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
    if (!coeffs) {
        return "linear"
    }
    coeffs = coeffs.slice(1, 5);
    $.each(coeffs, function(index, value) {
        coeffs[index] = parseFloat(value)
    });
    var easingName = "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
    if (!isFunction($.easing[easingName])) {
        var polynomBezier = function(x1, y1, x2, y2) {
            var Cx = 3 * x1,
                Bx = 3 * (x2 - x1) - Cx,
                Ax = 1 - Cx - Bx,
                Cy = 3 * y1,
                By = 3 * (y2 - y1) - Cy,
                Ay = 1 - Cy - By;
            var bezierX = function(t) {
                return t * (Cx + t * (Bx + t * Ax))
            };
            var bezierY = function(t) {
                return t * (Cy + t * (By + t * Ay))
            };
            var findXFor = function(t) {
                var z, x = t,
                    i = 0;
                while (i < 14) {
                    z = bezierX(x) - t;
                    if (Math.abs(z) < .001) {
                        break
                    }
                    x -= z / derivativeX(x);
                    i++
                }
                return x
            };
            var derivativeX = function(t) {
                return Cx + t * (2 * Bx + 3 * t * Ax)
            };
            return function(t) {
                return bezierY(findXFor(t))
            }
        };
        $.easing[easingName] = function(x, t, b, c, d) {
            return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b
        }
    }
    return easingName
};
var baseConfigValidator = function(config, animationType, validate, typeMessage) {
    $.each(["from", "to"], function() {
        if (!validate(config[this])) {
            throw errors.Error("E0010", animationType, this, typeMessage)
        }
    })
};
var isObjectConfigValidator = function(config, animationType) {
    return baseConfigValidator(config, animationType, function(target) {
        return isPlainObject(target)
    }, "a plain object")
};
var isStringConfigValidator = function(config, animationType) {
    return baseConfigValidator(config, animationType, function(target) {
        return "string" === typeof target
    }, "a string")
};
var CustomAnimationConfigurator = {
    setup: function() {}
};
var CssAnimationConfigurator = {
    validateConfig: function(config) {
        isStringConfigValidator(config, "css")
    },
    setup: function() {}
};
var positionAliases = {
    top: {
        my: "bottom center",
        at: "top center"
    },
    bottom: {
        my: "top center",
        at: "bottom center"
    },
    right: {
        my: "left center",
        at: "right center"
    },
    left: {
        my: "right center",
        at: "left center"
    }
};
var SlideAnimationConfigurator = {
    validateConfig: function(config) {
        isObjectConfigValidator(config, "slide")
    },
    setup: function($element, config) {
        var location = translator.locate($element);
        if ("slide" !== config.type) {
            var positioningConfig = "slideIn" === config.type ? config.from : config.to;
            positioningConfig.position = extend({ of: window
            }, positionAliases[config.direction]);
            setupPosition($element, positioningConfig)
        }
        this._setUpConfig(location, config.from);
        this._setUpConfig(location, config.to);
        translator.clearCache($element)
    },
    _setUpConfig: function(location, config) {
        config.left = "left" in config ? config.left : "+=0";
        config.top = "top" in config ? config.top : "+=0";
        this._initNewPosition(location, config)
    },
    _initNewPosition: function(location, config) {
        var position = {
            left: config.left,
            top: config.top
        };
        delete config.left;
        delete config.top;
        var relativeValue = this._getRelativeValue(position.left);
        if (void 0 !== relativeValue) {
            position.left = relativeValue + location.left
        } else {
            config.left = 0
        }
        relativeValue = this._getRelativeValue(position.top);
        if (void 0 !== relativeValue) {
            position.top = relativeValue + location.top
        } else {
            config.top = 0
        }
        config[TRANSFORM_PROP] = translator.getTranslateCss({
            x: position.left,
            y: position.top
        })
    },
    _getRelativeValue: function(value) {
        var relativeValue;
        if ("string" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
            return parseInt(relativeValue[1] + "1") * relativeValue[2]
        }
    }
};
var FadeAnimationConfigurator = {
    setup: function($element, config) {
        var toOpacity, from = config.from,
            fromOpacity = isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from);
        switch (config.type) {
            case "fadeIn":
                toOpacity = 1;
                break;
            case "fadeOut":
                toOpacity = 0;
                break;
            default:
                toOpacity = String(config.to)
        }
        config.from = {
            visibility: "visible",
            opacity: fromOpacity
        };
        config.to = {
            opacity: toOpacity
        }
    }
};
var PopAnimationConfigurator = {
    validateConfig: function(config) {
        isObjectConfigValidator(config, "pop")
    },
    setup: function($element, config) {
        var from = config.from,
            to = config.to,
            fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
            toOpacity = "opacity" in to ? to.opacity : 1,
            fromScale = "scale" in from ? from.scale : 0,
            toScale = "scale" in to ? to.scale : 1;
        config.from = {
            opacity: fromOpacity
        };
        var translate = translator.getTranslate($element);
        config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
        config.to = {
            opacity: toOpacity
        };
        config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
    },
    _getCssTransform: function(translate, scale) {
        return translator.getTranslateCss(translate) + "scale(" + scale + ")"
    }
};
var animationConfigurators = {
    custom: CustomAnimationConfigurator,
    slide: SlideAnimationConfigurator,
    slideIn: SlideAnimationConfigurator,
    slideOut: SlideAnimationConfigurator,
    fade: FadeAnimationConfigurator,
    fadeIn: FadeAnimationConfigurator,
    fadeOut: FadeAnimationConfigurator,
    pop: PopAnimationConfigurator,
    css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config) {
    var result = animationConfigurators[config.type];
    if (!result) {
        throw errors.Error("E0011", config.type)
    }
    return result
};
var defaultJSConfig = {
        type: "custom",
        from: {},
        to: {},
        duration: 400,
        start: noop,
        complete: noop,
        easing: "ease",
        delay: 0
    },
    defaultCssConfig = {
        duration: 400,
        easing: "ease",
        delay: 0
    };
var setupAnimationOnElement = function() {
    var animation = this,
        $element = animation.element,
        config = animation.config;
    setupPosition($element, config.from);
    setupPosition($element, config.to);
    animation.configurator.setup($element, config);
    $element.data(ANIM_DATA_KEY, animation);
    if (fx.off) {
        config.duration = 0;
        config.delay = 0
    }
    animation.strategy.initAnimation($element, config);
    if (config.start) {
        config.start.apply(this, [$element, config])
    }
};
var onElementAnimationComplete = function(animation) {
    var $element = animation.element,
        config = animation.config;
    $element.removeData(ANIM_DATA_KEY);
    if (config.complete) {
        config.complete.apply(this, [$element, config])
    }
    animation.deferred.resolveWith(this, [$element, config])
};
var startAnimationOnElement = function() {
    var animation = this,
        $element = animation.element,
        config = animation.config;
    animation.isStarted = true;
    return animation.strategy.animate($element, config).done(function() {
        onElementAnimationComplete(animation)
    }).fail(function() {
        animation.deferred.rejectWith(this, [$element, config])
    })
};
var stopAnimationOnElement = function(jumpToEnd) {
    var animation = this,
        $element = animation.element,
        config = animation.config;
    clearTimeout(animation.startTimeout);
    if (!animation.isStarted) {
        animation.start()
    }
    animation.strategy.stop($element, config, jumpToEnd)
};
var scopedRemoveEvent = eventUtils.addNamespace(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation) {
    animation.element.off(scopedRemoveEvent).on(scopedRemoveEvent, function() {
        fx.stop(animation.element)
    });
    animation.deferred.always(function() {
        animation.element.off(scopedRemoveEvent)
    })
};
var createAnimation = function(element, initialConfig) {
    var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig,
        config = extend(true, {}, defaultConfig, initialConfig),
        configurator = getAnimationConfigurator(config),
        strategy = getAnimationStrategy(config),
        animation = {
            element: $(element),
            config: config,
            configurator: configurator,
            strategy: strategy,
            isSynchronous: strategy.isSynchronous,
            setup: setupAnimationOnElement,
            start: startAnimationOnElement,
            stop: stopAnimationOnElement,
            deferred: $.Deferred()
        };
    if (isFunction(configurator.validateConfig)) {
        configurator.validateConfig(config)
    }
    subscribeToRemoveEvent(animation);
    return animation
};
var animate = function(element, config) {
    var $element = $(element);
    if (!$element.length) {
        return $.Deferred().resolve().promise()
    }
    var animation = createAnimation($element, config);
    pushInAnimationQueue($element, animation);
    return animation.deferred.promise()
};
var pushInAnimationQueue = function($element, animation) {
    var queueData = getAnimQueueData($element);
    writeAnimQueueData($element, queueData);
    queueData.push(animation);
    if (!isAnimating($element)) {
        shiftFromAnimationQueue($element, queueData)
    }
};
var getAnimQueueData = function($element) {
    return $element.data(ANIM_QUEUE_KEY) || []
};
var writeAnimQueueData = function($element, queueData) {
    $element.data(ANIM_QUEUE_KEY, queueData)
};
var destroyAnimQueueData = function($element) {
    $element.removeData(ANIM_QUEUE_KEY)
};
var isAnimating = function($element) {
    return !!$element.data(ANIM_DATA_KEY)
};
var shiftFromAnimationQueue = function($element, queueData) {
    queueData = getAnimQueueData($element);
    if (!queueData.length) {
        return
    }
    var animation = queueData.shift();
    if (0 === queueData.length) {
        destroyAnimQueueData($element)
    }
    executeAnimation(animation).done(function() {
        if (!isAnimating($element)) {
            shiftFromAnimationQueue($element)
        }
    })
};
var executeAnimation = function(animation) {
    animation.setup();
    if (fx.off || animation.isSynchronous) {
        animation.start()
    } else {
        animation.startTimeout = setTimeout(function() {
            animation.start()
        })
    }
    return animation.deferred.promise()
};
var setupPosition = function($element, config) {
    if (!config || !config.position) {
        return
    }
    var position = positionUtils.calculate($element, config.position),
        offset = $element.offset(),
        currentPosition = $element.position();
    extend(config, {
        left: position.h.location - offset.left + currentPosition.left,
        top: position.v.location - offset.top + currentPosition.top
    });
    delete config.position
};
var setProps = function($element, props) {
    $.each(props, function(key, value) {
        try {
            $element.css(key, value)
        } catch (e) {}
    })
};
var stop = function(element, jumpToEnd) {
    var $element = $(element),
        queueData = getAnimQueueData($element);
    $.each(queueData, function(_, animation) {
        animation.config.delay = 0;
        animation.config.duration = 0;
        animation.isSynchronous = true
    });
    if (!isAnimating($element)) {
        shiftFromAnimationQueue($element, queueData)
    }
    var animation = $element.data(ANIM_DATA_KEY);
    if (animation) {
        animation.stop(jumpToEnd)
    }
    $element.removeData(ANIM_DATA_KEY);
    destroyAnimQueueData($element)
};
var fx = {
    off: false,
    animationTypes: animationConfigurators,
    animate: animate,
    createAnimation: createAnimation,
    isAnimating: isAnimating,
    stop: stop,
    _simulatedTransitionEndDelay: 100
};
module.exports = fx;
module.exports.default = module.exports;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.modules.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(16),
    messageLocalization = __webpack_require__(8),
    WIDGET_WITH_LEGACY_CONTAINER_NAME = "dxDataGrid";
var CallBacks = function(options) {
    options = options || {};
    var firing, firingIndex, list = [],
        fireCore = function(context, args) {
            firing = true;
            var oldFiringIndex = firingIndex;
            for (firingIndex = 0; firingIndex < list.length; firingIndex++) {
                if (list[firingIndex] && false === list[firingIndex].apply(context, args) && options.stopOnFalse) {
                    break
                }
            }
            firingIndex = oldFiringIndex;
            firing = false
        },
        that = {
            add: function(fn) {
                if ("function" === typeof fn && !that.has(fn)) {
                    list.push(fn)
                }
                return this
            },
            has: function(fn) {
                return fn ? inArray(fn, list) > -1 : !!list.length
            },
            remove: function(fn) {
                var index = inArray(fn, list);
                if (index > -1) {
                    list.splice(index, 1);
                    if (firing && index <= firingIndex) {
                        firingIndex--
                    }
                }
                return this
            },
            fireWith: function(context, args) {
                args = args || [];
                fireCore(context, args.slice ? args.slice() : args)
            },
            fire: function() {
                that.fireWith(this, arguments);
                return this
            },
            empty: function() {
                list = [];
                return this
            }
        };
    return that
};
var ModuleItem = Class.inherit({
    _endUpdateCore: function() {},
    ctor: function(component) {
        var that = this;
        that._updateLockCount = 0;
        that.component = component;
        that._actions = {};
        that._actionConfigs = {};
        $.each(this.callbackNames() || [], function(index, name) {
            var flags = that.callbackFlags(name);
            that[this] = CallBacks(flags)
        })
    },
    init: function() {},
    callbackNames: function() {},
    callbackFlags: function() {},
    publicMethods: function() {},
    beginUpdate: function() {
        this._updateLockCount++
    },
    endUpdate: function() {
        if (this._updateLockCount > 0) {
            this._updateLockCount--;
            if (!this._updateLockCount) {
                this._endUpdateCore()
            }
        }
    },
    option: function(name) {
        var component = this.component,
            optionCache = component._optionCache;
        if (1 === arguments.length && optionCache) {
            if (!(name in optionCache)) {
                optionCache[name] = component.option(name)
            }
            return optionCache[name]
        }
        return component.option.apply(component, arguments)
    },
    localize: function(name) {
        var optionCache = this.component._optionCache;
        if (optionCache) {
            if (!(name in optionCache)) {
                optionCache[name] = messageLocalization.format(name)
            }
            return optionCache[name]
        }
        return messageLocalization.format(name)
    },
    on: function() {
        return this.component.on.apply(this.component, arguments)
    },
    off: function() {
        return this.component.off.apply(this.component, arguments)
    },
    optionChanged: function(args) {
        if (args.name in this._actions) {
            this.createAction(args.name, this._actionConfigs[args.name]);
            args.handled = true
        }
    },
    getAction: function(actionName) {
        return this._actions[actionName]
    },
    setAria: function(name, value, $target) {
        var target = $target.get(0),
            prefix = "role" !== name && "id" !== name ? "aria-" : "";
        if (target.setAttribute) {
            target.setAttribute(prefix + name, value)
        } else {
            $target.attr(prefix + name, value)
        }
    },
    _createComponent: function() {
        return this.component._createComponent.apply(this.component, arguments)
    },
    getController: function(name) {
        return this.component._controllers[name]
    },
    createAction: function(actionName, config) {
        var action;
        if (commonUtils.isFunction(actionName)) {
            action = this.component._createAction(actionName.bind(this), config);
            return function(e) {
                action({
                    jQueryEvent: e
                })
            }
        } else {
            this._actions[actionName] = this.component._createActionByOption(actionName, config);
            this._actionConfigs[actionName] = config
        }
    },
    executeAction: function(actionName, options) {
        var action = this._actions[actionName];
        return action && action(options)
    },
    dispose: function() {
        var that = this;
        $.each(that.callbackNames() || [], function() {
            that[this].empty()
        })
    },
    addWidgetPrefix: function(className) {
        var componentName = this.component.NAME;
        return "dx-" + componentName.slice(2).toLowerCase() + (className ? "-" + className : "")
    },
    getWidgetContainerClass: function() {
        var containerName = this.component.NAME === WIDGET_WITH_LEGACY_CONTAINER_NAME ? null : "container";
        return this.addWidgetPrefix(containerName)
    }
});
var Controller = ModuleItem;
var ViewController = Controller.inherit({
    getView: function(name) {
        return this.component._views[name]
    },
    getViews: function() {
        return this.component._views
    }
});
var View = ModuleItem.inherit({
    _isReady: function() {
        return this.component.isReady()
    },
    _endUpdateCore: function() {
        this.callBase();
        if (!this._isReady() && this._requireReady) {
            this._requireRender = false;
            this.component._requireResize = false
        }
        if (this._requireRender) {
            this._requireRender = false;
            this.render(this._$parent)
        }
    },
    _invalidate: function(requireResize, requireReady) {
        this._requireRender = true;
        this.component._requireResize = this.component._requireResize || requireResize;
        this._requireReady = this._requireReady || requireReady
    },
    _renderCore: function() {},
    _resizeCore: function() {},
    _afterRender: function() {},
    _parentElement: function() {
        return this._$parent
    },
    ctor: function(component) {
        this.callBase(component);
        this.renderCompleted = $.Callbacks();
        this.resizeCompleted = $.Callbacks()
    },
    element: function() {
        return this._$element
    },
    getElementHeight: function() {
        var $element = this.element();
        if (!$element) {
            return 0
        }
        var marginTop = parseFloat($element.css("marginTop")) || 0,
            marginBottom = parseFloat($element.css("marginBottom")) || 0,
            offsetHeight = $element.get(0).offsetHeight;
        return offsetHeight + marginTop + marginBottom
    },
    isVisible: function() {
        return true
    },
    getTemplate: function(name) {
        return this.component._getTemplate(name)
    },
    render: function($parent, options) {
        var $element = this._$element,
            isVisible = this.isVisible();
        if (!$element && !$parent) {
            return
        }
        this._requireReady = false;
        if (!$element) {
            $element = this._$element = $("<div />").appendTo($parent);
            this._$parent = $parent
        }
        $element.toggleClass("dx-hidden", !isVisible);
        if (isVisible) {
            this.component._optionCache = {};
            this._renderCore(options);
            this.component._optionCache = void 0;
            this._afterRender($parent);
            this.renderCompleted.fire()
        }
    },
    resize: function() {
        this.isResizing = true;
        this._resizeCore();
        this.resizeCompleted.fire();
        this.isResizing = false
    },
    focus: function() {
        this.element().focus()
    }
});
var MODULES_ORDER_MAX_INDEX = 1e6;
var processModules = function(that, componentClass) {
    var modules = componentClass.modules,
        modulesOrder = componentClass.modulesOrder,
        controllerTypes = componentClass.controllerTypes || {},
        viewTypes = componentClass.viewTypes || {};
    if (!componentClass.controllerTypes) {
        if (modulesOrder) {
            modules.sort(function(module1, module2) {
                var orderIndex1 = inArray(module1.name, modulesOrder);
                var orderIndex2 = inArray(module2.name, modulesOrder);
                if (orderIndex1 < 0) {
                    orderIndex1 = MODULES_ORDER_MAX_INDEX
                }
                if (orderIndex2 < 0) {
                    orderIndex2 = MODULES_ORDER_MAX_INDEX
                }
                return orderIndex1 - orderIndex2
            })
        }
        $.each(modules, function() {
            var controllers = this.controllers,
                moduleName = this.name,
                views = this.views;
            controllers && $.each(controllers, function(name, type) {
                if (controllerTypes[name]) {
                    throw errors.Error("E1001", moduleName, name)
                } else {
                    if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                        type.subclassOf(Controller);
                        throw errors.Error("E1002", moduleName, name)
                    }
                }
                controllerTypes[name] = type
            });
            views && $.each(views, function(name, type) {
                if (viewTypes[name]) {
                    throw errors.Error("E1003", moduleName, name)
                } else {
                    if (!(type && type.subclassOf && type.subclassOf(View))) {
                        throw errors.Error("E1004", moduleName, name)
                    }
                }
                viewTypes[name] = type
            })
        });
        $.each(modules, function() {
            var extenders = this.extenders;
            if (extenders) {
                extenders.controllers && $.each(extenders.controllers, function(name, extender) {
                    if (controllerTypes[name]) {
                        controllerTypes[name] = controllerTypes[name].inherit(extender)
                    }
                });
                extenders.views && $.each(extenders.views, function(name, extender) {
                    if (viewTypes[name]) {
                        viewTypes[name] = viewTypes[name].inherit(extender)
                    }
                })
            }
        });
        componentClass.controllerTypes = controllerTypes;
        componentClass.viewTypes = viewTypes
    }
    var registerPublicMethods = function(that, name, moduleItem) {
        var publicMethods = moduleItem.publicMethods();
        if (publicMethods) {
            $.each(publicMethods, function(index, methodName) {
                if (moduleItem[methodName]) {
                    if (!that[methodName]) {
                        that[methodName] = function() {
                            return moduleItem[methodName].apply(moduleItem, arguments)
                        }
                    } else {
                        throw errors.Error("E1005", methodName)
                    }
                } else {
                    throw errors.Error("E1006", name, methodName)
                }
            })
        }
    };
    var createModuleItems = function(moduleTypes) {
        var moduleItems = {};
        $.each(moduleTypes, function(name, moduleType) {
            var moduleItem = new moduleType(that);
            moduleItem.name = name;
            registerPublicMethods(that, name, moduleItem);
            moduleItems[name] = moduleItem
        });
        return moduleItems
    };
    that._controllers = createModuleItems(controllerTypes);
    that._views = createModuleItems(viewTypes)
};
var callModuleItemsMethod = function(that, methodName, args) {
    args = args || [];
    if (that._controllers) {
        $.each(that._controllers, function() {
            this[methodName] && this[methodName].apply(this, args)
        })
    }
    if (that._views) {
        $.each(that._views, function() {
            this[methodName] && this[methodName].apply(this, args)
        })
    }
};
module.exports = {
    modules: [],
    View: View,
    ViewController: ViewController,
    Controller: Controller,
    registerModule: function(name, module) {
        var i, modules = this.modules;
        for (i = 0; i < modules.length; i++) {
            if (modules[i].name === name) {
                return
            }
        }
        module.name = name;
        modules.push(module);
        delete this.controllerTypes;
        delete this.viewTypes
    },
    registerModulesOrder: function(moduleNames) {
        this.modulesOrder = moduleNames
    },
    unregisterModule: function(name) {
        this.modules = commonUtils.grep(this.modules, function(module) {
            return module.name !== name
        });
        delete this.controllerTypes;
        delete this.viewTypes
    },
    processModules: processModules,
    callModuleItemsMethod: callModuleItemsMethod
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/support.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var inflector = __webpack_require__(36),
    inArray = __webpack_require__(7).inArray,
    devices = __webpack_require__(6);
var camelize = inflector.camelize;
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"],
    cssPrefixes = {
        "": "",
        Webkit: "-webkit-",
        Moz: "-moz-",
        O: "-o-",
        ms: "-ms-"
    },
    styles = document.createElement("dx").style;
var transitionEndEventNames = {
    webkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "oTransitionEnd",
    msTransition: "MsTransitionEnd",
    transition: "transitionend"
};
var forEachPrefixes = function(prop, callBack) {
    prop = camelize(prop, true);
    var result;
    for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
        var jsPrefix = jsPrefixes[i];
        var prefixedProp = jsPrefix + prop;
        var lowerPrefixedProp = camelize(prefixedProp);
        result = callBack(lowerPrefixedProp, jsPrefix);
        if (void 0 === result) {
            result = callBack(prefixedProp, jsPrefix)
        }
        if (void 0 !== result) {
            break
        }
    }
    return result
};
var styleProp = function(prop) {
    return forEachPrefixes(prop, function(specific) {
        if (specific in styles) {
            return specific
        }
    })
};
var stylePropPrefix = function(prop) {
    return forEachPrefixes(prop, function(specific, jsPrefix) {
        if (specific in styles) {
            return cssPrefixes[jsPrefix]
        }
    })
};
var supportProp = function(prop) {
    return !!styleProp(prop)
};
var isNativeScrollingSupported = function() {
    var realDevice = devices.real(),
        realPlatform = realDevice.platform,
        realVersion = realDevice.version,
        isObsoleteAndroid = realVersion && realVersion[0] < 4 && "android" === realPlatform,
        isNativeScrollDevice = !isObsoleteAndroid && inArray(realPlatform, ["ios", "android", "win"]) > -1 || realDevice.mac;
    return isNativeScrollDevice
};
var inputType = function(type) {
    if ("text" === type) {
        return true
    }
    var input = document.createElement("input");
    try {
        input.setAttribute("type", type);
        input.value = "wrongValue";
        return !input.value
    } catch (e) {
        return false
    }
};
var touchEvents = "ontouchstart" in window && !("callPhantom" in window),
    pointerEvents = !!window.navigator.pointerEnabled || !!window.navigator.msPointerEnabled,
    touchPointersPresent = !!window.navigator.maxTouchPoints || !!window.navigator.msMaxTouchPoints;
exports.touchEvents = touchEvents;
exports.pointerEvents = pointerEvents;
exports.touch = touchEvents || pointerEvents && touchPointersPresent;
exports.transition = supportProp("transition");
exports.transitionEndEventName = transitionEndEventNames[styleProp("transition")];
exports.animation = supportProp("animation");
exports.nativeScrolling = isNativeScrollingSupported();
exports.styleProp = styleProp;
exports.stylePropPrefix = stylePropPrefix;
exports.supportProp = supportProp;
exports.hasKo = !!window.ko;
exports.inputType = inputType;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/button.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    iconUtils = __webpack_require__(77),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    ValidationMixin = __webpack_require__(114),
    ValidationEngine = __webpack_require__(58),
    Widget = __webpack_require__(27),
    inkRipple = __webpack_require__(43),
    eventUtils = __webpack_require__(3),
    themes = __webpack_require__(20),
    clickEvent = __webpack_require__(11),
    FunctionTemplate = __webpack_require__(91);
var BUTTON_CLASS = "dx-button",
    BUTTON_CONTENT_CLASS = "dx-button-content",
    BUTTON_HAS_TEXT_CLASS = "dx-button-has-text",
    BUTTON_HAS_ICON_CLASS = "dx-button-has-icon",
    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
    BUTTON_TEXT_CLASS = "dx-button-text",
    ANONYMOUS_TEMPLATE_NAME = "content",
    BUTTON_FEEDBACK_HIDE_TIMEOUT = 100;
var Button = Widget.inherit({
    _supportedKeys: function() {
        var that = this,
            click = function(e) {
                e.preventDefault();
                that._executeClickAction(e)
            };
        return extend(this.callBase(), {
            space: click,
            enter: click
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            iconSrc: {
                since: "15.1",
                alias: "icon"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            onClick: null,
            type: "normal",
            text: "",
            icon: "",
            validationGroup: void 0,
            activeStateEnabled: true,
            template: "content",
            useSubmitBehavior: false,
            useInkRipple: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _feedbackHideTimeout: BUTTON_FEEDBACK_HIDE_TIMEOUT,
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.content = new FunctionTemplate(function(options) {
            var data = options.model,
                $iconElement = iconUtils.getImageContainer(data && data.icon),
                $textContainer = data && data.text ? $("<span>").text(data.text).addClass(BUTTON_TEXT_CLASS) : void 0;
            options.container.append($iconElement).append($textContainer)
        }, this)
    },
    _render: function() {
        this.element().addClass(BUTTON_CLASS);
        this._renderType();
        this.option("useInkRipple") && this._renderInkRipple();
        this._renderClick();
        this.setAria("role", "button");
        this._updateAriaLabel();
        this.callBase()
    },
    _renderInkRipple: function() {
        var isOnlyIconButton = !this.option("text") && this.option("icon") || "back" === this.option("type"),
            config = {};
        if (isOnlyIconButton) {
            extend(config, {
                waveSizeCoefficient: 1,
                useHoldAnimation: false,
                isCentered: true
            })
        }
        this._inkRipple = inkRipple.render(config)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: this._$content,
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _renderContentImpl: function() {
        var $element = this.element(),
            data = this._getContentData();
        if (this._$content) {
            this._$content.empty()
        } else {
            this._$content = $("<div>").addClass(BUTTON_CONTENT_CLASS).appendTo($element)
        }
        $element.toggleClass(BUTTON_HAS_ICON_CLASS, !!data.icon).toggleClass(BUTTON_HAS_TEXT_CLASS, !!data.text);
        var template = this._getTemplateByOption("template"),
            $result = template.render({
                model: data,
                container: this._$content
            });
        if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
            this._$content.replaceWith($result);
            this._$content = $result;
            this._$content.addClass(BUTTON_CONTENT_CLASS)
        }
        if (this.option("useSubmitBehavior")) {
            this._renderSubmitInput()
        }
    },
    _renderSubmitInput: function() {
        var submitAction = this._createAction(function(args) {
            var e = args.jQueryEvent,
                validationGroup = ValidationEngine.getGroupConfig(args.component._findGroup());
            if (validationGroup && !validationGroup.validate().isValid) {
                e.preventDefault()
            }
            e.stopPropagation()
        });
        this._$submitInput = $("<input>").attr("type", "submit").addClass("dx-button-submit-input").appendTo(this._$content).on("click", function(e) {
            submitAction({
                jQueryEvent: e
            })
        })
    },
    _getContentData: function() {
        var icon = this.option("icon"),
            text = this.option("text"),
            back = "back" === this.option("type");
        if (back && !icon) {
            icon = "back"
        }
        return {
            icon: icon,
            text: text
        }
    },
    _renderClick: function() {
        var that = this,
            eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
            actionConfig = {};
        if (this.option("useSubmitBehavior")) {
            actionConfig.afterExecute = function(e) {
                setTimeout(function() {
                    e.component._$submitInput.get(0).click()
                })
            }
        }
        this._clickAction = this._createActionByOption("onClick", actionConfig);
        this.element().off(eventName).on(eventName, function(e) {
            that._executeClickAction(e)
        })
    },
    _executeClickAction: function(e) {
        this._clickAction({
            jQueryEvent: e,
            validationGroup: ValidationEngine.getGroupConfig(this._findGroup())
        })
    },
    _updateAriaLabel: function() {
        var icon = this.option("icon"),
            text = this.option("text");
        if ("image" === iconUtils.getImageSourceType(icon)) {
            if (icon.indexOf("base64") === -1) {
                icon = icon.replace(/.+\/([^\.]+)\..+$/, "$1")
            } else {
                icon = "Base64"
            }
        }
        var ariaLabel = text || icon;
        this.setAria("label", $.trim(ariaLabel))
    },
    _renderType: function() {
        var type = this.option("type");
        if (type) {
            this.element().addClass("dx-button-" + type)
        }
    },
    _refreshType: function(prevType) {
        var type = this.option("type");
        prevType && this.element().removeClass("dx-button-" + prevType).addClass("dx-button-" + type);
        if (!this.element().hasClass(BUTTON_HAS_ICON_CLASS) && "back" === type) {
            this._renderContentImpl()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onClick":
                this._renderClick();
                break;
            case "icon":
            case "text":
                this._renderContentImpl();
                this._updateAriaLabel();
                break;
            case "type":
                this._refreshType(args.previousValue);
                this._renderContentImpl();
                this._updateAriaLabel();
                break;
            case "template":
                this._renderContentImpl();
                break;
            case "useInkRipple":
                this._invalidate();
                break;
            case "useSubmitBehavior":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        this.callBase();
        delete this._$content;
        delete this._inkRipple
    }
}).include(ValidationMixin);
registerComponent("dxButton", Button);
module.exports = Button;
module.exports.default = module.exports;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    stringUtils = __webpack_require__(30),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    toComparable = __webpack_require__(14).toComparable,
    LoadPanel = __webpack_require__(151),
    dataUtils = __webpack_require__(28),
    formatHelper = __webpack_require__(168);
var NO_DATA_CLASS = "nodata",
    DATE_INTERVAL_SELECTORS = {
        year: function(value) {
            return value && value.getFullYear()
        },
        month: function(value) {
            return value && value.getMonth() + 1
        },
        day: function(value) {
            return value && value.getDate()
        },
        quarter: function(value) {
            return value && Math.floor(value.getMonth() / 3) + 1
        },
        hour: function(value) {
            return value && value.getHours()
        },
        minute: function(value) {
            return value && value.getMinutes()
        },
        second: function(value) {
            return value && value.getSeconds()
        }
    },
    DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
module.exports = function() {
    var getIntervalSelector = function() {
        var groupInterval, nameIntervalSelector, data = arguments[1],
            value = this.calculateCellValue(data);
        if (!commonUtils.isDefined(value)) {
            return null
        } else {
            if ("date" === this.dataType) {
                nameIntervalSelector = arguments[0];
                return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value)
            } else {
                if ("number" === this.dataType) {
                    groupInterval = arguments[0];
                    return Math.floor(Number(value) / groupInterval) * groupInterval
                }
            }
        }
    };
    var getDateValues = function(dateValue) {
        if (commonUtils.isDate(dateValue)) {
            return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()]
        }
        return $.map(("" + dateValue).split("/"), function(value, index) {
            return 1 === index ? Number(value) - 1 : Number(value)
        })
    };
    var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
        var dateStart, dateEnd, column = this,
            selector = getFilterSelector(column, target),
            values = getDateValues(filterValue),
            dateInterval = "headerFilter" === target && module.exports.getGroupInterval(column)[values.length - 1];
        switch (dateInterval) {
            case "year":
                dateStart = new Date(values[0], 0, 1);
                dateEnd = new Date(values[0] + 1, 0, 1);
                break;
            case "month":
                dateStart = new Date(values[0], values[1], 1);
                dateEnd = new Date(values[0], values[1] + 1, 1);
                break;
            case "quarter":
                dateStart = new Date(values[0], 3 * values[1], 1);
                dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
                break;
            case "hour":
                dateStart = new Date(values[0], values[1], values[2], values[3]);
                dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
                break;
            case "minute":
                dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
                break;
            case "second":
                dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
                break;
            default:
                dateStart = new Date(values[0], values[1], values[2]);
                dateEnd = new Date(values[0], values[1], values[2] + 1)
        }
        switch (selectedFilterOperation) {
            case "<":
                return [selector, "<", dateStart];
            case "<=":
                return [selector, "<", dateEnd];
            case ">":
                return [selector, ">=", dateEnd];
            case ">=":
                return [selector, ">=", dateStart];
            case "<>":
                return [
                    [selector, "<", dateStart], "or", [selector, ">=", dateEnd]
                ];
            default:
                return [
                    [selector, ">=", dateStart], "and", [selector, "<", dateEnd]
                ]
        }
    };
    var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
        var interval, startFilterValue, endFilterValue, column = this,
            selector = getFilterSelector(column, target),
            values = ("" + filterValue).split("/"),
            value = Number(values[values.length - 1]),
            isExclude = "exclude" === column.filterType,
            groupInterval = module.exports.getGroupInterval(column);
        if ("headerFilter" === target && groupInterval && commonUtils.isDefined(filterValue)) {
            interval = groupInterval[values.length - 1];
            startFilterValue = [selector, isExclude ? "<" : ">=", value];
            endFilterValue = [selector, isExclude ? ">=" : "<", value + interval];
            return [startFilterValue, isExclude ? "or" : "and", endFilterValue]
        }
        return [selector, selectedFilterOperation || "=", filterValue]
    };
    var getFilterSelector = function(column, target) {
        var selector = column.dataField || column.selector;
        if ("search" === target) {
            selector = column.displayField || column.calculateDisplayValue || selector
        }
        return selector
    };
    var isZeroTime = function(date) {
        return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
    };
    var getFilterExpressionByRange = function(filterValue) {
        var endFilterValue, startFilterExpression, endFilterExpression, column = this,
            dataField = column.dataField;
        if (Array.isArray(filterValue) && commonUtils.isDefined(filterValue[0]) && commonUtils.isDefined(filterValue[1])) {
            startFilterExpression = [dataField, ">=", filterValue[0]];
            endFilterExpression = [dataField, "<=", filterValue[1]];
            if ("date" === column.dataType) {
                if (isZeroTime(filterValue[1])) {
                    endFilterValue = new Date(filterValue[1].getTime());
                    endFilterValue.setDate(filterValue[1].getDate() + 1);
                    endFilterExpression = [dataField, "<", endFilterValue]
                }
            }
            return [startFilterExpression, "and", endFilterExpression]
        }
    };
    var equalSelectors = function(selector1, selector2) {
        if (commonUtils.isFunction(selector1) && commonUtils.isFunction(selector2)) {
            if (selector1.originalCallback && selector2.originalCallback) {
                return selector1.originalCallback === selector2.originalCallback
            }
        }
        return selector1 === selector2
    };
    return {
        renderNoDataText: function($element) {
            var that = this;
            $element = $element || this.element();
            if (!$element) {
                return
            }
            var noDataClass = that.addWidgetPrefix(NO_DATA_CLASS),
                noDataElement = $element.find("." + noDataClass).last(),
                isVisible = this._dataController.isEmpty(),
                isLoading = this._dataController.isLoading(),
                rtlEnabled = this.option("rtlEnabled");
            if (!noDataElement.length) {
                noDataElement = $("<span>").addClass(noDataClass).appendTo($element)
            }
            if (isVisible && !isLoading) {
                noDataElement.removeClass("dx-hidden").text(that._getNoDataText());
                commonUtils.deferUpdate(function() {
                    var noDataHeight = noDataElement.height(),
                        noDataWidth = noDataElement.width();
                    commonUtils.deferRender(function() {
                        noDataElement.css({
                            marginTop: -Math.floor(noDataHeight / 2),
                            marginRight: rtlEnabled ? -Math.floor(noDataWidth / 2) : 0,
                            marginLeft: rtlEnabled ? 0 : -Math.floor(noDataWidth / 2)
                        })
                    })
                })
            } else {
                noDataElement.addClass("dx-hidden")
            }
        },
        renderLoadPanel: function($element, $container, isLocalStore) {
            var loadPanelOptions, that = this;
            that._loadPanel && that._loadPanel.element().remove();
            loadPanelOptions = that.option("loadPanel");
            if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
                loadPanelOptions = extend({
                    shading: false,
                    message: loadPanelOptions.text,
                    position: { of: $element
                    },
                    container: $element
                }, loadPanelOptions);
                that._loadPanel = that._createComponent($("<div>").appendTo($container), LoadPanel, loadPanelOptions)
            } else {
                that._loadPanel = null
            }
        },
        getIndexByKey: function(key, items, keyName) {
            var item, index = -1;
            if (Array.isArray(items)) {
                keyName = arguments.length <= 2 ? "key" : keyName;
                for (var i = 0; i < items.length; i++) {
                    item = commonUtils.isDefined(keyName) ? items[i][keyName] : items[i];
                    if (commonUtils.equalByValue(key, item)) {
                        index = i;
                        break
                    }
                }
            }
            return index
        },
        combineFilters: function(filters, operation) {
            var i, resultFilter = [];
            operation = operation || "and";
            for (i = 0; i < filters.length; i++) {
                if (!filters[i]) {
                    continue
                }
                if (resultFilter.length) {
                    resultFilter.push(operation)
                }
                resultFilter.push(filters[i])
            }
            if (1 === resultFilter.length) {
                resultFilter = resultFilter[0]
            }
            if (resultFilter.length) {
                return resultFilter
            }
        },
        checkChanges: function(changes, changeNames) {
            var i, changesWithChangeNamesCount = 0;
            for (i = 0; i < changeNames.length; i++) {
                if (changes[changeNames[i]]) {
                    changesWithChangeNamesCount++
                }
            }
            return changes.length && changes.length === changesWithChangeNamesCount
        },
        equalFilterParameters: function(filter1, filter2) {
            var i;
            if (Array.isArray(filter1) && Array.isArray(filter2)) {
                if (filter1.length !== filter2.length) {
                    return false
                } else {
                    for (i = 0; i < filter1.length; i++) {
                        if (!module.exports.equalFilterParameters(filter1[i], filter2[i])) {
                            return false
                        }
                    }
                }
                return true
            } else {
                if (commonUtils.isFunction(filter1) && filter1.columnIndex >= 0 && commonUtils.isFunction(filter2) && filter2.columnIndex >= 0) {
                    return filter1.columnIndex === filter2.columnIndex
                } else {
                    return toComparable(filter1) == toComparable(filter2)
                }
            }
        },
        proxyMethod: function(instance, methodName, defaultResult) {
            if (!instance[methodName]) {
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
            }
        },
        formatValue: function(value, options) {
            var valueText = formatHelper.format(value, options.format, options.precision) || value && value.toString() || "",
                formatObject = {
                    value: value,
                    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
                    target: options.target || "row",
                    groupInterval: options.groupInterval
                };
            return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
        },
        getFormatOptionsByColumn: function(column, target) {
            return {
                format: column.format,
                precision: column.precision,
                getDisplayFormat: column.getDisplayFormat,
                customizeText: column.customizeText,
                target: target,
                trueText: column.trueText,
                falseText: column.falseText
            }
        },
        getDisplayValue: function(column, value, data, rowType) {
            if (column.displayValueMap && void 0 !== column.displayValueMap[value]) {
                return column.displayValueMap[value]
            } else {
                if (column.calculateDisplayValue && data && "group" !== rowType) {
                    return column.calculateDisplayValue(data)
                } else {
                    if (column.lookup && !("group" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {
                        return column.lookup.calculateCellValue(value)
                    }
                }
            }
            return value
        },
        getGroupRowSummaryText: function(summaryItems, summaryTexts) {
            var i, summaryItem, result = "(";
            for (i = 0; i < summaryItems.length; i++) {
                summaryItem = summaryItems[i];
                result += (i > 0 ? ", " : "") + module.exports.getSummaryText(summaryItem, summaryTexts)
            }
            return result += ")"
        },
        getSummaryText: function(summaryItem, summaryTexts) {
            var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
            return this.formatValue(summaryItem.value, {
                format: summaryItem.valueFormat,
                precision: summaryItem.precision,
                getDisplayFormat: function(valueText) {
                    return displayFormat ? stringUtils.format(displayFormat, valueText, summaryItem.columnCaption) : valueText
                },
                customizeText: summaryItem.customizeText
            })
        },
        normalizeSortingInfo: function(sort) {
            sort = sort || [];
            var result, i;
            result = dataUtils.normalizeSortingInfo(sort);
            for (i = 0; i < sort.length; i++) {
                if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
                    result[i].isExpanded = sort[i].isExpanded
                }
                if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
                    result[i].groupInterval = sort[i].groupInterval
                }
            }
            return result
        },
        getFormatByDataType: function(dataType) {
            switch (dataType) {
                case "date":
                    return "shortDate"
            }
        },
        defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
            var column = this,
                selector = getFilterSelector(column, target),
                isSearchByDisplayValue = column.calculateDisplayValue && "search" === target,
                dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType,
                filter = null;
            if ("headerFilter" === target && null === filterValue) {
                filter = [selector, selectedFilterOperation || "=", null];
                if ("string" === dataType) {
                    filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]]
                }
            } else {
                if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
                    filter = [selector, selectedFilterOperation || "contains", filterValue]
                } else {
                    if ("between" === selectedFilterOperation) {
                        return getFilterExpressionByRange.apply(column, arguments)
                    } else {
                        if ("date" === dataType && commonUtils.isDefined(filterValue)) {
                            return getFilterExpressionForDate.apply(column, arguments)
                        } else {
                            if ("number" === dataType) {
                                return getFilterExpressionForNumber.apply(column, arguments)
                            } else {
                                if ("object" !== dataType) {
                                    filter = [selector, selectedFilterOperation || "=", filterValue]
                                }
                            }
                        }
                    }
                }
            }
            return filter
        },
        getHeaderFilterGroupParameters: function(column, remoteGrouping) {
            var result = [],
                dataField = column.dataField || column.name,
                groupInterval = this.getGroupInterval(column);
            if (groupInterval) {
                $.each(groupInterval, function(index, interval) {
                    result.push(remoteGrouping ? {
                        selector: dataField,
                        groupInterval: interval,
                        isExpanded: index < groupInterval.length - 1
                    } : getIntervalSelector.bind(column, interval))
                });
                return result
            }
            if (remoteGrouping) {
                result = [{
                    selector: dataField,
                    isExpanded: false
                }]
            } else {
                result = function(data) {
                    var result = column.calculateCellValue(data);
                    if (void 0 === result || "" === result) {
                        result = null
                    }
                    return result
                };
                if (column.sortingMethod) {
                    result = [{
                        selector: result,
                        compare: column.sortingMethod.bind(column)
                    }]
                }
            }
            return result
        },
        getGroupInterval: function(column) {
            var index, result = [],
                dateIntervals = ["year", "month", "day", "hour", "minute", "second"],
                groupInterval = column.headerFilter && column.headerFilter.groupInterval,
                interval = "quarter" === groupInterval ? "month" : groupInterval;
            if ("date" === column.dataType) {
                result = DEFAULT_DATE_INTERVAL;
                index = inArray(interval, dateIntervals);
                if (index >= 0) {
                    result = dateIntervals.slice(0, index);
                    result.push(groupInterval);
                    return result
                }
                return result
            } else {
                if (commonUtils.isDefined(groupInterval)) {
                    return Array.isArray(groupInterval) ? groupInterval : [groupInterval]
                }
            }
        },
        equalSortParameters: function(sortParameters1, sortParameters2, ignoreIsExpanded) {
            var i;
            sortParameters1 = module.exports.normalizeSortingInfo(sortParameters1);
            sortParameters2 = module.exports.normalizeSortingInfo(sortParameters2);
            if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
                if (sortParameters1.length !== sortParameters2.length) {
                    return false
                } else {
                    for (i = 0; i < sortParameters1.length; i++) {
                        if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
                            return false
                        }
                    }
                }
                return true
            } else {
                return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
            }
        },
        getPointsByColumns: function(items, pointCreated, isVertical, startColumnIndex) {
            var point, i, item, offset, prevItemOffset, rtlEnabled, cellsLength = items.length,
                notCreatePoint = false,
                columnIndex = startColumnIndex || 0,
                result = [];
            for (i = 0; i <= cellsLength; i++) {
                if (i < cellsLength) {
                    item = items.eq(i);
                    offset = item.offset();
                    rtlEnabled = "rtl" === item.css("direction")
                }
                point = {
                    index: columnIndex,
                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
                    columnIndex: columnIndex
                };
                if (!isVertical && i > 0) {
                    prevItemOffset = items.eq(i - 1).offset();
                    if (prevItemOffset.top < point.y) {
                        point.y = prevItemOffset.top
                    }
                }
                if (pointCreated) {
                    notCreatePoint = pointCreated(point)
                }
                if (!notCreatePoint) {
                    result.push(point)
                }
                columnIndex++
            }
            return result
        }
    }
}();


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/ui.widget.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    Action = __webpack_require__(62),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    domUtils = __webpack_require__(15),
    devices = __webpack_require__(6),
    DOMComponent = __webpack_require__(45),
    Template = __webpack_require__(172),
    FunctionTemplate = __webpack_require__(91),
    EmptyTemplate = __webpack_require__(138),
    ChildDefaultTemplate = __webpack_require__(74),
    KeyboardProcessor = __webpack_require__(112),
    selectors = __webpack_require__(92),
    eventUtils = __webpack_require__(3),
    hoverEvents = __webpack_require__(113),
    feedbackEvents = __webpack_require__(75),
    clickEvent = __webpack_require__(11),
    inflector = __webpack_require__(36);
var UI_FEEDBACK = "UIFeedback",
    WIDGET_CLASS = "dx-widget",
    ACTIVE_STATE_CLASS = "dx-state-active",
    DISABLED_STATE_CLASS = "dx-state-disabled",
    INVISIBLE_STATE_CLASS = "dx-state-invisible",
    HOVER_STATE_CLASS = "dx-state-hover",
    FOCUSED_STATE_CLASS = "dx-state-focused",
    FEEDBACK_SHOW_TIMEOUT = 30,
    FEEDBACK_HIDE_TIMEOUT = 400,
    FOCUS_NAMESPACE = "Focus",
    ANONYMOUS_TEMPLATE_NAME = "template",
    TEXT_NODE = 3,
    TEMPLATE_SELECTOR = "[data-options*='dxTemplate']",
    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate(function(options) {
    var widgetName = options.model.widget;
    if (widgetName) {
        var widgetElement = $("<div>"),
            widgetOptions = options.model.options || {};
        if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
            var deprecatedName = widgetName;
            widgetName = inflector.camelize("dx-" + widgetName);
            errors.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
        }
        widgetElement[widgetName](widgetOptions);
        return widgetElement
    }
    return $()
});
var beforeActivateExists = void 0 !== document.onbeforeactivate;
var Widget = DOMComponent.inherit({
    _supportedKeys: function() {
        return {}
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            disabled: false,
            visible: true,
            hint: void 0,
            activeStateEnabled: false,
            onContentReady: null,
            hoverStateEnabled: false,
            focusStateEnabled: false,
            tabIndex: 0,
            accessKey: null,
            onFocusIn: null,
            onFocusOut: null,
            integrationOptions: {
                watchMethod: function(fn, callback, options) {
                    options = options || {};
                    if (!options.skipImmediate) {
                        callback(fn())
                    }
                    return commonUtils.noop
                },
                templates: {
                    "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
                },
                createTemplate: function(element) {
                    return new Template(element)
                }
            },
            _keyboardProcessor: void 0
        })
    },
    _feedbackShowTimeout: FEEDBACK_SHOW_TIMEOUT,
    _feedbackHideTimeout: FEEDBACK_HIDE_TIMEOUT,
    _init: function() {
        this.callBase();
        this._tempTemplates = [];
        this._defaultTemplates = {};
        this._initTemplates();
        this._initContentReadyAction()
    },
    _initTemplates: function() {
        this._extractTemplates();
        this._extractAnonymousTemplate()
    },
    _extractTemplates: function() {
        var templates = this.option("integrationOptions.templates"),
            templateElements = this.element().contents().filter(TEMPLATE_SELECTOR);
        var templatesMap = {};
        templateElements.each(function(_, template) {
            var templateOptions = domUtils.getElementOptions(template).dxTemplate;
            if (!templateOptions) {
                return
            }
            if (!templateOptions.name) {
                throw errors.Error("E0023")
            }
            $(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();
            templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
            templatesMap[templateOptions.name].push(template)
        });
        $.each(templatesMap, function(templateName, value) {
            var deviceTemplate = this._findTemplateByDevice(value);
            if (deviceTemplate) {
                templates[templateName] = this._createTemplate(deviceTemplate)
            }
        }.bind(this))
    },
    _findTemplateByDevice: function(templates) {
        var suitableTemplate = commonUtils.findBestMatches(devices.current(), templates, function(template) {
            return domUtils.getElementOptions(template).dxTemplate
        })[0];
        $.each(templates, function(index, template) {
            if (template !== suitableTemplate) {
                $(template).remove()
            }
        });
        return suitableTemplate
    },
    _extractAnonymousTemplate: function() {
        var templates = this.option("integrationOptions.templates"),
            anonymousTemplateName = this._getAnonymousTemplateName(),
            $anonymousTemplate = this.element().contents().detach();
        var $notJunkTemplateContent = $anonymousTemplate.filter(function(_, element) {
                var isTextNode = element.nodeType === TEXT_NODE,
                    isEmptyText = $.trim($(element).text()).length < 1;
                return !(isTextNode && isEmptyText)
            }),
            onlyJunkTemplateContent = $notJunkTemplateContent.length < 1;
        if (!templates[anonymousTemplateName] && !onlyJunkTemplateContent) {
            templates[anonymousTemplateName] = this._createTemplate($anonymousTemplate)
        }
    },
    _getAriaTarget: function() {
        return this._focusTarget()
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _getTemplateByOption: function(optionName) {
        return this._getTemplate(this.option(optionName))
    },
    _getTemplate: function(templateSource) {
        if (commonUtils.isFunction(templateSource)) {
            return new FunctionTemplate(function(options) {
                var templateSourceResult = templateSource.apply(this, this._getNormalizedTemplateArgs(options));
                if (!commonUtils.isDefined(templateSourceResult)) {
                    return new EmptyTemplate
                }
                var dispose = false;
                var template = this._acquireTemplate(templateSourceResult, function(templateSource) {
                    if (templateSource.nodeType || templateSource.jquery && !$(templateSource).is("script")) {
                        return new FunctionTemplate(function() {
                            return templateSource
                        })
                    }
                    dispose = true;
                    return this._createTemplate(templateSource)
                }.bind(this));
                var result = template.render(options);
                dispose && template.dispose && template.dispose();
                return result
            }.bind(this))
        }
        return this._acquireTemplate(templateSource, this._createTemplateIfNeeded.bind(this))
    },
    _acquireTemplate: function(templateSource, createTemplate) {
        if (null == templateSource) {
            return new EmptyTemplate
        }
        if (templateSource instanceof ChildDefaultTemplate) {
            return this._defaultTemplates[templateSource.name]
        }
        if (commonUtils.isFunction(templateSource.render) && !templateSource.jquery) {
            return templateSource
        }
        if (templateSource.nodeType || templateSource.jquery) {
            templateSource = $(templateSource);
            return createTemplate(templateSource)
        }
        if ("string" === typeof templateSource) {
            var userTemplate = this.option("integrationOptions.templates")[templateSource];
            if (userTemplate) {
                return userTemplate
            }
            var dynamicTemplate = this._defaultTemplates[templateSource];
            if (dynamicTemplate) {
                return dynamicTemplate
            }
            return createTemplate(templateSource)
        }
        return this._acquireTemplate(templateSource.toString(), createTemplate)
    },
    _createTemplateIfNeeded: function(templateSource) {
        var templateKey = function(templateSource) {
            return templateSource.jquery && templateSource[0] || templateSource
        };
        var cachedTemplate = this._tempTemplates.filter(function(t) {
            templateSource = templateKey(templateSource);
            return t.source === templateSource
        })[0];
        if (cachedTemplate) {
            return cachedTemplate.template
        }
        var template = this._createTemplate(templateSource);
        this._tempTemplates.push({
            template: template,
            source: templateKey(templateSource)
        });
        return template
    },
    _createTemplate: function(templateSource) {
        templateSource = "string" === typeof templateSource ? domUtils.normalizeTemplateElement(templateSource) : templateSource;
        return this.option("integrationOptions.createTemplate")(templateSource)
    },
    _getNormalizedTemplateArgs: function(options) {
        var args = [];
        if ("model" in options) {
            args.push(options.model)
        }
        if ("index" in options) {
            args.push(options.index)
        }
        args.push(options.container);
        return args
    },
    _cleanTemplates: function() {
        this._tempTemplates.forEach(function(t) {
            t.template.dispose && t.template.dispose()
        });
        this._tempTemplates = []
    },
    _initContentReadyAction: function() {
        this._contentReadyAction = this._createActionByOption("onContentReady", {
            excludeValidators: ["designMode", "disabled", "readOnly"]
        })
    },
    _render: function() {
        this.element().addClass(WIDGET_CLASS);
        this.callBase();
        this._toggleDisabledState(this.option("disabled"));
        this._toggleVisibility(this.option("visible"));
        this._renderHint();
        this._renderContent();
        this._renderFocusState();
        this._attachFeedbackEvents();
        this._attachHoverEvents()
    },
    _renderHint: function() {
        domUtils.toggleAttr(this.element(), "title", this.option("hint"))
    },
    _renderContent: function() {
        var that = this;
        commonUtils.deferRender(function() {
            that._renderContentImpl()
        });
        that._fireContentReadyAction()
    },
    _renderContentImpl: commonUtils.noop,
    _fireContentReadyAction: function() {
        this._contentReadyAction()
    },
    _dispose: function() {
        this._cleanTemplates();
        this._contentReadyAction = null;
        this.callBase()
    },
    _clean: function() {
        this._cleanFocusState();
        this.callBase();
        this.element().empty()
    },
    _toggleVisibility: function(visible) {
        this.element().toggleClass(INVISIBLE_STATE_CLASS, !visible);
        this.setAria("hidden", !visible || void 0)
    },
    _renderFocusState: function() {
        this._attachKeyboardEvents();
        if (!this.option("focusStateEnabled") || this.option("disabled")) {
            return
        }
        this._renderFocusTarget();
        this._attachFocusEvents();
        this._renderAccessKey()
    },
    _renderAccessKey: function() {
        var focusTarget = this._focusTarget();
        focusTarget.attr("accesskey", this.option("accessKey"));
        var clickNamespace = eventUtils.addNamespace(clickEvent.name, UI_FEEDBACK);
        focusTarget.off(clickNamespace);
        this.option("accessKey") && focusTarget.on(clickNamespace, function(e) {
            if (eventUtils.isFakeClickEvent(e)) {
                e.stopImmediatePropagation();
                this.focus()
            }
        }.bind(this))
    },
    _eventBindingTarget: function() {
        return this.element()
    },
    _focusTarget: function() {
        return this._getActiveElement()
    },
    _getActiveElement: function() {
        var activeElement = this._eventBindingTarget();
        if (this._activeStateUnit) {
            activeElement = activeElement.find(this._activeStateUnit).not("." + DISABLED_STATE_CLASS)
        }
        return activeElement
    },
    _renderFocusTarget: function() {
        this._focusTarget().attr("tabindex", this.option("tabIndex"))
    },
    _keyboardEventBindingTarget: function() {
        return this._eventBindingTarget()
    },
    _detachFocusEvents: function() {
        var $element = this._focusTarget(),
            namespace = this.NAME + FOCUS_NAMESPACE,
            focusEvents = eventUtils.addNamespace("focusin", namespace);
        focusEvents = focusEvents + " " + eventUtils.addNamespace("focusout", namespace);
        if (beforeActivateExists) {
            focusEvents = focusEvents + " " + eventUtils.addNamespace("beforeactivate", namespace)
        }
        $element.off(focusEvents)
    },
    _attachFocusEvents: function() {
        var namespace = this.NAME + FOCUS_NAMESPACE,
            focusInEvent = eventUtils.addNamespace("focusin", namespace),
            focusOutEvent = eventUtils.addNamespace("focusout", namespace);
        this._focusTarget().on(focusInEvent, this._focusInHandler.bind(this)).on(focusOutEvent, this._focusOutHandler.bind(this));
        if (beforeActivateExists) {
            var beforeActivateEvent = eventUtils.addNamespace("beforeactivate", namespace);
            this._focusTarget().on(beforeActivateEvent, function(e) {
                if (!$(e.target).is(selectors.focusable)) {
                    e.preventDefault()
                }
            })
        }
    },
    _refreshFocusEvent: function() {
        this._detachFocusEvents();
        this._attachFocusEvents()
    },
    _focusInHandler: function(e) {
        var that = this;
        that._createActionByOption("onFocusIn", {
            beforeExecute: function() {
                that._updateFocusState(e, true)
            },
            excludeValidators: ["readOnly"]
        })({
            jQueryEvent: e
        })
    },
    _focusOutHandler: function(e) {
        var that = this;
        that._createActionByOption("onFocusOut", {
            beforeExecute: function() {
                that._updateFocusState(e, false)
            },
            excludeValidators: ["readOnly", "disabled"]
        })({
            jQueryEvent: e
        })
    },
    _updateFocusState: function(e, isFocused) {
        var target = e.target;
        if (inArray(target, this._focusTarget()) !== -1) {
            this._toggleFocusClass(isFocused, $(target))
        }
    },
    _toggleFocusClass: function(isFocused, $element) {
        var $focusTarget = $element && $element.length ? $element : this._focusTarget();
        $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused)
    },
    _hasFocusClass: function(element) {
        var $focusTarget = $(element || this._focusTarget());
        return $focusTarget.hasClass(FOCUSED_STATE_CLASS)
    },
    _attachKeyboardEvents: function() {
        var processor = this.option("_keyboardProcessor");
        if (processor) {
            this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this)
        } else {
            if (this.option("focusStateEnabled")) {
                this._keyboardProcessor = new KeyboardProcessor({
                    element: this._keyboardEventBindingTarget(),
                    handler: this._keyboardHandler,
                    focusTarget: this._focusTarget(),
                    context: this
                })
            }
        }
    },
    _keyboardHandler: function(options) {
        var e = options.originalEvent,
            key = options.key;
        var keys = this._supportedKeys(),
            func = keys[key];
        if (void 0 !== func) {
            var handler = func.bind(this);
            return handler(e) || false
        } else {
            return true
        }
    },
    _refreshFocusState: function() {
        this._cleanFocusState();
        this._renderFocusState()
    },
    _cleanFocusState: function() {
        var $element = this._focusTarget();
        this._detachFocusEvents();
        this._toggleFocusClass(false);
        $element.removeAttr("tabindex");
        if (this._keyboardProcessor) {
            this._keyboardProcessor.dispose();
            delete this._keyboardProcessor
        }
    },
    _attachHoverEvents: function() {
        var that = this,
            hoverableSelector = that._activeStateUnit,
            nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),
            nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);
        that._eventBindingTarget().off(nameStart, hoverableSelector).off(nameEnd, hoverableSelector);
        if (that.option("hoverStateEnabled")) {
            var startAction = new Action(function(args) {
                that._hoverStartHandler(args.event);
                var $target = args.element;
                that._refreshHoveredElement($target)
            }, {
                excludeValidators: ["readOnly"]
            });
            that._eventBindingTarget().on(nameStart, hoverableSelector, function(e) {
                startAction.execute({
                    element: $(e.target),
                    event: e
                })
            }).on(nameEnd, hoverableSelector, function(e) {
                that._hoverEndHandler(e);
                that._forgetHoveredElement()
            })
        } else {
            that._toggleHoverClass(false)
        }
    },
    _hoverStartHandler: commonUtils.noop,
    _hoverEndHandler: commonUtils.noop,
    _attachFeedbackEvents: function() {
        var feedbackAction, feedbackActionDisabled, that = this,
            feedbackSelector = that._activeStateUnit,
            activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),
            inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK);
        that._eventBindingTarget().off(activeEventName, feedbackSelector).off(inactiveEventName, feedbackSelector);
        if (that.option("activeStateEnabled")) {
            var feedbackActionHandler = function(args) {
                var $element = args.element,
                    value = args.value,
                    jQueryEvent = args.jQueryEvent;
                that._toggleActiveState($element, value, jQueryEvent)
            };
            that._eventBindingTarget().on(activeEventName, feedbackSelector, {
                timeout: that._feedbackShowTimeout
            }, function(e) {
                feedbackAction = feedbackAction || new Action(feedbackActionHandler);
                feedbackAction.execute({
                    element: $(e.currentTarget),
                    value: true,
                    jQueryEvent: e
                })
            }).on(inactiveEventName, feedbackSelector, {
                timeout: that._feedbackHideTimeout
            }, function(e) {
                feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {
                    excludeValidators: ["disabled", "readOnly"]
                });
                feedbackActionDisabled.execute({
                    element: $(e.currentTarget),
                    value: false,
                    jQueryEvent: e
                })
            })
        }
    },
    _toggleActiveState: function($element, value) {
        this._toggleHoverClass(!value);
        $element.toggleClass(ACTIVE_STATE_CLASS, value)
    },
    _refreshHoveredElement: function(hoveredElement) {
        var selector = this._activeStateUnit || this._eventBindingTarget();
        this._forgetHoveredElement();
        this._hoveredElement = hoveredElement.closest(selector);
        this._toggleHoverClass(true)
    },
    _forgetHoveredElement: function() {
        this._toggleHoverClass(false);
        delete this._hoveredElement
    },
    _toggleHoverClass: function(value) {
        if (this._hoveredElement) {
            this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option("hoverStateEnabled"))
        }
    },
    _toggleDisabledState: function(value) {
        this.element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));
        this._toggleHoverClass(!value);
        this.setAria("disabled", value || void 0)
    },
    _setWidgetOption: function(widgetName, args) {
        if (!this[widgetName]) {
            return
        }
        if (typeUtils.isPlainObject(args[0])) {
            $.each(args[0], function(option, value) {
                this._setWidgetOption(widgetName, [option, value])
            }.bind(this));
            return
        }
        var optionName = args[0];
        var value = args[1];
        if (1 === args.length) {
            value = this.option(optionName)
        }
        var widgetOptionMap = this[widgetName + "OptionMap"];
        this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "disabled":
                this._toggleDisabledState(args.value);
                this._refreshFocusState();
                break;
            case "hint":
                this._renderHint();
                break;
            case "activeStateEnabled":
                this._attachFeedbackEvents();
                break;
            case "hoverStateEnabled":
                this._attachHoverEvents();
                break;
            case "tabIndex":
            case "_keyboardProcessor":
            case "focusStateEnabled":
                this._refreshFocusState();
                break;
            case "onFocusIn":
            case "onFocusOut":
                break;
            case "accessKey":
                this._renderAccessKey();
                break;
            case "visible":
                var visible = args.value;
                this._toggleVisibility(visible);
                if (this._isVisibilityChangeSupported()) {
                    this._checkVisibilityChanged(args.value ? "shown" : "hiding")
                }
                break;
            case "onContentReady":
                this._initContentReadyAction();
                break;
            default:
                this.callBase(args)
        }
    },
    _isVisible: function() {
        return this.callBase() && this.option("visible")
    },
    beginUpdate: function() {
        this._ready(false);
        this.callBase()
    },
    endUpdate: function() {
        this.callBase();
        if (this._initialized) {
            this._ready(true)
        }
    },
    _ready: function(value) {
        if (0 === arguments.length) {
            return this._isReady
        }
        this._isReady = value
    },
    setAria: function() {
        var setAttribute = function(option) {
            var attrName = "role" === option.name || "id" === option.name ? option.name : "aria-" + option.name,
                attrValue = option.value;
            if (null === attrValue || void 0 === attrValue) {
                attrValue = void 0
            } else {
                attrValue = attrValue.toString()
            }
            domUtils.toggleAttr(option.target, attrName, attrValue)
        };
        if (!typeUtils.isPlainObject(arguments[0])) {
            setAttribute({
                name: arguments[0],
                value: arguments[1],
                target: arguments[2] || this._getAriaTarget()
            })
        } else {
            var $target = arguments[1] || this._getAriaTarget();
            $.each(arguments[0], function(key, value) {
                setAttribute({
                    name: key,
                    value: value,
                    target: $target
                })
            })
        }
    },
    isReady: function() {
        return this._ready()
    },
    repaint: function() {
        this._refresh()
    },
    focus: function() {
        this._focusTarget().focus()
    },
    registerKeyHandler: function(key, handler) {
        var currentKeys = this._supportedKeys(),
            addingKeys = {};
        addingKeys[key] = handler;
        this._supportedKeys = function() {
            return extend(currentKeys, addingKeys)
        }
    }
});
module.exports = Widget;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    isFunction = __webpack_require__(2).isFunction,
    toComparable = __webpack_require__(14).toComparable;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
    return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
};
var normalizeSortingInfo = function(info) {
    if (!Array.isArray(info)) {
        info = [info]
    }
    return $.map(info, function(i) {
        var result = {
            selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
            desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
        };
        if (i.compare) {
            result.compare = i.compare
        }
        return result
    })
};
var errorMessageFromXhr = function() {
    var textStatusMessages = {
        timeout: "Network connection timeout",
        error: "Unspecified network error",
        parsererror: "Unexpected server response"
    };
    var explainTextStatus = function(textStatus) {
        var result = textStatusMessages[textStatus];
        if (!result) {
            return textStatus
        }
        return result
    };
    var unloading;
    window.addEventListener("beforeunload", function() {
        unloading = true
    });
    return function(xhr, textStatus) {
        if (unloading) {
            return XHR_ERROR_UNLOAD
        }
        if (xhr.status < 400) {
            return explainTextStatus(textStatus)
        }
        return xhr.statusText
    }
}();
var aggregators = {
    count: {
        seed: 0,
        step: function(count) {
            return 1 + count
        }
    },
    sum: {
        seed: 0,
        step: function(sum, item) {
            return sum + item
        }
    },
    min: {
        step: function(min, item) {
            return item < min ? item : min
        }
    },
    max: {
        step: function(max, item) {
            return item > max ? item : max
        }
    },
    avg: {
        seed: [0, 0],
        step: function(pair, value) {
            return [pair[0] + value, pair[1] + 1]
        },
        finalize: function(pair) {
            return pair[1] ? pair[0] / pair[1] : NaN
        }
    }
};
var processRequestResultLock = function() {
    var lockDeferred, lockCount = 0;
    var obtain = function() {
        if (0 === lockCount) {
            lockDeferred = $.Deferred()
        }
        lockCount++
    };
    var release = function() {
        lockCount--;
        if (lockCount < 1) {
            lockDeferred.resolve()
        }
    };
    var promise = function() {
        var deferred = 0 === lockCount ? $.Deferred().resolve() : lockDeferred;
        return deferred.promise()
    };
    var reset = function() {
        lockCount = 0;
        if (lockDeferred) {
            lockDeferred.resolve()
        }
    };
    return {
        obtain: obtain,
        release: release,
        promise: promise,
        reset: reset
    }
}();

function isDisjunctiveOperator(condition) {
    return /^(or|\|\||\|)$/i.test(condition)
}

function isConjunctiveOperator(condition) {
    return /^(and|\&\&|\&)$/i.test(condition)
}
var keysEqual = function(keyExpr, key1, key2) {
    if (Array.isArray(keyExpr)) {
        var name, names = $.map(key1, function(v, k) {
            return k
        });
        for (var i = 0; i < names.length; i++) {
            name = names[i];
            if (toComparable(key1[name], true) != toComparable(key2[name], true)) {
                return false
            }
        }
        return true
    }
    return toComparable(key1, true) == toComparable(key2, true)
};
var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64_encode = function(input) {
    if (!Array.isArray(input)) {
        input = stringToByteArray(String(input))
    }
    var result = "";

    function getBase64Char(index) {
        return BASE64_CHARS.charAt(index)
    }
    for (var i = 0; i < input.length; i += 3) {
        var octet1 = input[i],
            octet2 = input[i + 1],
            octet3 = input[i + 2];
        result += $.map([octet1 >> 2, (3 & octet1) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (15 & octet2) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : 63 & octet3], getBase64Char).join("")
    }
    return result
};
var stringToByteArray = function(str) {
    var code, i, bytes = [];
    for (i = 0; i < str.length; i++) {
        code = str.charCodeAt(i);
        if (code < 128) {
            bytes.push(code)
        } else {
            if (code < 2048) {
                bytes.push(192 + (code >> 6), 128 + (63 & code))
            } else {
                if (code < 65536) {
                    bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (63 & code))
                } else {
                    if (code < 2097152) {
                        bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (63 & code))
                    }
                }
            }
        }
    }
    return bytes
};
var isUnaryOperation = function(crit) {
    return "!" === crit[0] && Array.isArray(crit[1])
};
var utils = {
    XHR_ERROR_UNLOAD: XHR_ERROR_UNLOAD,
    normalizeBinaryCriterion: normalizeBinaryCriterion,
    normalizeSortingInfo: normalizeSortingInfo,
    errorMessageFromXhr: errorMessageFromXhr,
    aggregators: aggregators,
    keysEqual: keysEqual,
    isDisjunctiveOperator: isDisjunctiveOperator,
    isConjunctiveOperator: isConjunctiveOperator,
    processRequestResultLock: processRequestResultLock,
    isUnaryOperation: isUnaryOperation,
    base64_encode: base64_encode
};
module.exports = utils;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/errors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errorUtils = __webpack_require__(102),
    coreErrors = __webpack_require__(13),
    handlers = {};
var errors = errorUtils(coreErrors.ERROR_MESSAGES, {
    E4000: "[DevExpress.data]: {0}",
    E4001: "Unknown aggregating function is detected: '{0}'",
    E4002: "Unsupported OData protocol version is used",
    E4003: "Unknown filter operation is used: {0}",
    E4004: "The thenby() method is called before the sortby() method",
    E4005: "Store requires a key expression for this operation",
    E4006: "ArrayStore 'data' option must be an array",
    E4007: "Compound keys cannot be auto-generated",
    E4008: "Attempt to insert an item with the a duplicated key",
    E4009: "Data item cannot be found",
    E4010: "CustomStore does not support creating queries",
    E4011: "Custom Store method is not implemented or is not a function: {0}",
    E4012: "Custom Store method returns an invalid value: {0}",
    E4013: "Local Store requires the 'name' configuration option is specified",
    E4014: "Unknown data type is specified for ODataStore: {0}",
    E4015: "Unknown entity name or alias is used: {0}",
    E4017: "Keys cannot be modified",
    E4018: "The server has returned a non-numeric value in a response to an item count request",
    E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
    E4020: "Unknown store type is detected: {0}",
    E4021: "The server response does not provide the totalCount value",
    E4022: "The server response does not provide the groupCount value",
    W4000: "Data returned from the server has an incorrect structure",
    W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
    W4002: "Data loading has failed for some cells due to the following error: {0}"
});

function handleError(error) {
    var id = "E4000";
    if (error && "__id" in error) {
        id = error.__id
    }
    errors.log(id, error)
}
var errorHandler = null;
var _errorHandler = function(error) {
    if (handlers.errorHandler) {
        handlers.errorHandler(error)
    }
};
handlers = {
    errors: errors,
    errorHandler: errorHandler,
    _errorHandler: _errorHandler
};
module.exports = handlers;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/string.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2);
var encodeHtml = function() {
    var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
    return function(str) {
        return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;")
    }
}();
var pairToObject = function(raw) {
    var pair = commonUtils.splitPair(raw),
        h = parseInt(pair && pair[0], 10),
        v = parseInt(pair && pair[1], 10);
    if (!isFinite(h)) {
        h = 0
    }
    if (!isFinite(v)) {
        v = h
    }
    return {
        h: h,
        v: v
    }
};
var quadToObject = function(raw) {
    var quad = commonUtils.splitQuad(raw),
        left = parseInt(quad && quad[0], 10),
        top = parseInt(quad && quad[1], 10),
        right = parseInt(quad && quad[2], 10),
        bottom = parseInt(quad && quad[3], 10);
    if (!isFinite(left)) {
        left = 0
    }
    if (!isFinite(top)) {
        top = left
    }
    if (!isFinite(right)) {
        right = left
    }
    if (!isFinite(bottom)) {
        bottom = top
    }
    return {
        top: top,
        right: right,
        bottom: bottom,
        left: left
    }
};
var stringFormat = function() {
    var replaceDollarCount, reg, value, s = arguments[0],
        values = $.makeArray(arguments).slice(1);
    if (commonUtils.isFunction(s)) {
        return s.apply(this, values)
    }
    for (var i = 0; i < values.length; i++) {
        reg = new RegExp("\\{" + i + "\\}", "gm");
        value = values[i];
        if ("string" === commonUtils.type(value) && value.indexOf("$") >= 0) {
            replaceDollarCount = "$".replace("$", "$$").length;
            value = value.replace("$", 1 === replaceDollarCount ? "$$$$" : "$$")
        }
        s = s.replace(reg, value)
    }
    return s
};
var replaceAll = function() {
    var quote = function(str) {
        return (str + "").replace(/([\+\*\?\\\.\[\^\]\$\(\)\{\}\><\|\=\!\:])/g, "\\$1")
    };
    return function(text, searchToken, replacementToken) {
        return text.replace(new RegExp("(" + quote(searchToken) + ")", "gi"), replacementToken)
    }
}();
var isEmpty = function() {
    var SPACE_REGEXP = /\s/g;
    return function(text) {
        return !text || !text.replace(SPACE_REGEXP, "")
    }
}();
exports.encodeHtml = encodeHtml;
exports.pairToObject = pairToObject;
exports.quadToObject = quadToObject;
exports.format = stringFormat;
exports.replaceAll = replaceAll;
exports.isEmpty = isEmpty;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/config.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extendUtils = __webpack_require__(1),
    config = {
        rtlEnabled: false,
        defaultCurrency: "USD",
        designMode: false,
        serverDecimalSeparator: ".",
        forceIsoDateParsing: true,
        wrapActionsBeforeExecute: false
    };
module.exports = function() {
    if (!arguments.length) {
        return config
    }
    extendUtils.extend(config, arguments[0])
};
module.exports.default = module.exports;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/date.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    numberLocalization = __webpack_require__(44),
    dependencyInjector = __webpack_require__(72),
    isString = __webpack_require__(2).isString,
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(13);
__webpack_require__(60);
var FORMATS_TO_PATTERN_MAP = {
    shortdate: "M/d/y",
    shorttime: "h:mm a",
    longdate: "EEEE, MMMM d, y",
    longtime: "h:mm:ss a",
    monthandday: "MMMM d",
    monthandyear: "MMMM y",
    quarterandyear: "QQQ y",
    day: "d",
    year: "y",
    shortdateshorttime: "M/d/y, h:mm a",
    mediumdatemediumtime: "MMMM d, h:mm a",
    longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
    month: "LLLL",
    shortyear: "yy",
    dayofweek: "EEEE",
    quarter: "QQQ",
    hour: "HH",
    minute: "mm",
    second: "ss",
    millisecond: "SSS",
    "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
};
var parseTime = function(text) {
    var now = new Date,
        parts = text.split(" "),
        time = parts[0].split(":"),
        hours = Number(time[0]),
        minutes = Number(time[1]),
        second = Number(time[2]) || 0,
        pm = /^pm$/i.test(parts[1]),
        isValid = second < 60 && minutes < 60 && hours > 0 && hours < 13;
    if (!isValid) {
        return null
    }
    if (!pm && 12 === hours) {
        hours = 0
    }
    if (pm && 12 !== hours) {
        hours += 12
    }
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, second)
};
var removeTimezoneOffset = function(date) {
    return new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
};
var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var amPm = function(date) {
    return date.getHours() >= 12 ? "PM" : "AM"
};
var getTwelveHourTimeFormat = function(hours) {
    return hours % 12 || 12
};
var formatNumber = function(number, precision) {
    return numberLocalization.format(number, {
        type: "decimal",
        precision: precision
    })
};
var FORMATTERS = {
    millisecond: function(date) {
        return formatNumber(date.getMilliseconds(date), 3)
    },
    second: function(date) {
        return formatNumber(date.getSeconds(), 2)
    },
    minute: function(date) {
        return formatNumber(date.getMinutes(), 2)
    },
    h: function(date) {
        return formatNumber(getTwelveHourTimeFormat(date.getHours()), 1)
    },
    hh: function(date) {
        return formatNumber(getTwelveHourTimeFormat(date.getHours()), 2)
    },
    hour: function(date) {
        return formatNumber(date.getHours(), 2)
    },
    day: function(date) {
        return String(date.getDate())
    },
    dayofweek: function(date) {
        return days[date.getDay()]
    },
    M: function(date) {
        return date.getMonth() + 1
    },
    MM: function(date) {
        return formatNumber(date.getMonth() + 1, 2)
    },
    month: function(date) {
        return months[date.getMonth()]
    },
    year: function(date) {
        return String(date.getFullYear())
    },
    shortyear: function(date) {
        return String(date.getFullYear()).substr(2, 2)
    },
    shorttime: function(date) {
        return FORMATTERS.h(date) + ":" + FORMATTERS.minute(date) + " " + amPm(date)
    },
    shortdate: function(date) {
        return [FORMATTERS.M(date), FORMATTERS.day(date), FORMATTERS.year(date)].join("/")
    },
    shortdateshorttime: function(date) {
        return [FORMATTERS.shortdate(date), FORMATTERS.shorttime(date)].join(", ")
    },
    mediumdatemediumtime: function(date) {
        return [FORMATTERS.monthandday(date), FORMATTERS.shorttime(date)].join(", ")
    },
    monthandyear: function(date) {
        return [FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
    },
    monthandday: function(date) {
        return [FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
    },
    longdate: function(date) {
        return FORMATTERS.dayofweek(date) + ", " + FORMATTERS.month(date) + " " + FORMATTERS.day(date) + ", " + FORMATTERS.year(date)
    },
    longtime: function(date) {
        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + " " + amPm(date)
    },
    longdatelongtime: function(date) {
        return [FORMATTERS.longdate(date), FORMATTERS.longtime(date)].join(", ")
    },
    d: function(date) {
        return formatNumber(date.getDate(), 1)
    },
    dd: function(date) {
        return formatNumber(date.getDate(), 2)
    },
    "d MMMM": function(date) {
        return FORMATTERS.day(date) + " " + FORMATTERS.month(date)
    },
    "yyyy/M/d": function(date) {
        return [FORMATTERS.year(date), FORMATTERS.M(date), FORMATTERS.day(date)].join("/")
    },
    "yyyy/MM/dd": function(date) {
        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("/")
    },
    "dd.MM.yyyy": function(date) {
        return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join(".")
    },
    "HH:mm": function(date) {
        return [FORMATTERS.hour(date), FORMATTERS.minute(date)].join(":")
    },
    "HH:mm:ss": function(date) {
        return [FORMATTERS["HH:mm"](date), FORMATTERS.second(date)].join(":")
    },
    "h:mm:ss": function(date) {
        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":")
    },
    "h:mm:ss:SSS": function(date) {
        return [FORMATTERS.h(date), FORMATTERS.minute(date), FORMATTERS.second(date), FORMATTERS.SSS(date)].join(":")
    },
    "yyyy/MM/dd HH:mm:ss": function(date) {
        return [FORMATTERS["yyyy/MM/dd"](date), FORMATTERS["HH:mm:ss"](date)].join(" ")
    },
    "yyyy-MM-dd hh:mm:ss.SSS a": function(date) {
        return [
            [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-"), [FORMATTERS.hh(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join(":") + "." + FORMATTERS.SSS(date), amPm(date)
        ].join(" ")
    },
    "yyyy-MM-dd": function(date) {
        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date)].join("-")
    },
    yyyyMMddTHHmmss: function(date) {
        return [FORMATTERS.year(date), FORMATTERS.MM(date), FORMATTERS.dd(date), "T", FORMATTERS.hour(date), FORMATTERS.minute(date), FORMATTERS.second(date)].join("")
    },
    "datetime-local": function(date) {
        return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS["HH:mm:ss"](date)
    },
    "yyyy-MM-ddTHH:mm:ssZ": function(date) {
        return FORMATTERS["datetime-local"](date) + "Z"
    },
    "yyyy-MM-ddTHH:mmZ": function(date) {
        return FORMATTERS["yyyy-MM-dd"](date) + "T" + FORMATTERS.hour(date) + ":" + FORMATTERS.minute(date) + "Z"
    },
    "dd/MM/yyyy": function(date) {
        return [FORMATTERS.dd(date), FORMATTERS.MM(date), FORMATTERS.year(date)].join("/")
    },
    "yyyy MMMM d": function(date) {
        return [FORMATTERS.year(date), FORMATTERS.month(date), FORMATTERS.day(date)].join(" ")
    },
    "EEEE, d": function(date) {
        return [FORMATTERS.dayofweek(date), FORMATTERS.d(date)].join(", ")
    },
    "EEEE MM yy": function(date) {
        return [FORMATTERS.dayofweek(date), FORMATTERS.MM(date), FORMATTERS.shortyear(date)].join(" ")
    },
    "d MMMM yyyy": function(date) {
        return [FORMATTERS.day(date), FORMATTERS.month(date), FORMATTERS.year(date)].join(" ")
    },
    E: function(date) {
        return cutCaptions([FORMATTERS.dayofweek(date)], "abbreviated")[0]
    },
    EEE: function(date) {
        return FORMATTERS.E(date)
    },
    "EEE hh": function(date) {
        return [FORMATTERS.EEE(date), FORMATTERS.hh(date)].join(" ")
    },
    "ss SSS": function(date) {
        return [FORMATTERS.second(date), FORMATTERS.SSS(date)].join(" ")
    },
    quarter: function(date) {
        var month = date.getMonth();
        if (month >= 0 && month < 3) {
            return "Q1"
        }
        if (month > 2 && month < 6) {
            return "Q2"
        }
        if (month > 5 && month < 9) {
            return "Q3"
        }
        return "Q4"
    },
    quarterandyear: function(date) {
        return FORMATTERS.quarter(date) + " " + FORMATTERS.year(date)
    }
};
var parseWithoutTimezone = function(text) {
    if ("Z" !== text.slice(-1)) {
        text += "Z"
    }
    return removeTimezoneOffset(new Date(text))
};
var PARSERS = {
    day: function(text) {
        var now = new Date;
        return new Date(now.getFullYear(), now.getMonth(), Number(text))
    },
    hour: function(text) {
        var now = new Date;
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), Number(text))
    },
    minute: function(text) {
        var now = new Date;
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), Number(text))
    },
    month: function(text) {
        return new Date((new Date).getFullYear(), inArray(text, months))
    },
    monthandday: function(text) {
        var parts = text.split(" "),
            result = PARSERS.month(parts[0]);
        result.setDate(Number(parts[1]));
        return result
    },
    monthandyear: function(text) {
        var parts = text.split(" "),
            result = PARSERS.month(parts[0]);
        result.setYear(Number(parts[1]));
        return result
    },
    year: function(text) {
        var date = new Date(new Date(0));
        date.setUTCFullYear(Number(text));
        return removeTimezoneOffset(date)
    },
    second: function(text) {
        var now = new Date;
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), Number(text))
    },
    shortyear: function(text) {
        var MAX_YEAR_IN_XXI_CENTURY = 36;
        var year = Number(text);
        if (year > MAX_YEAR_IN_XXI_CENTURY) {
            year += 1900
        } else {
            year += 2e3
        }
        return PARSERS.year(year)
    },
    shortdate: function(text) {
        if (!/^(0?[1-9]|1[012])\/(0?[1-9]|[12][0-9]|3[01])\/\d{1,4}/.test(text)) {
            return
        }
        var parts = text.split("/");
        var date = new Date(Number(parts[2]), Number(parts[0]) - 1, Number(parts[1]));
        if (parts[2].length < 3) {
            date.setFullYear(Number(parts[2]), Number(parts[0]) - 1, Number(parts[1]))
        }
        return date
    },
    longtime: function(text) {
        return parseTime(text)
    },
    shorttime: function(text) {
        return parseTime(text)
    },
    millisecond: function(text) {
        return new Date(Number(text))
    },
    "yyyy MMMM d": function(text) {
        var parts = text.split(" ");
        if (3 !== parts.length) {
            return
        }
        return new Date(Number(parts[0]), inArray(parts[1], months), Number(parts[2]))
    },
    "HH:mm": function(text) {
        var parts = text.split(":");
        return new Date(0, 0, 0, Number(parts[0]), Number(parts[1]), 0, 0)
    },
    "yyyy-MM-ddTHH:mm:ssZ": parseWithoutTimezone,
    "yyyy-MM-ddTHH:mmZ": parseWithoutTimezone,
    "datetime-local": parseWithoutTimezone,
    mediumdatemediumtime: function(text) {
        var parts = text.split(", "),
            dateParts = parts[0].split(" "),
            timeParts = parts[1].split(" ");
        var amPm = 2 === timeParts.length ? timeParts.pop() : void 0;
        var result = PARSERS.month(dateParts[0]);
        result.setDate(Number(dateParts[1]));
        timeParts = timeParts[0].split(":");
        var hours = Number(timeParts[0]);
        switch (String(amPm).toLowerCase()) {
            case "am":
                hours = 12 === hours ? 0 : hours;
                break;
            case "pm":
                hours = 12 === hours ? 12 : hours + 12
        }
        result.setHours(hours);
        result.setMinutes(Number(timeParts[1]));
        return result
    }
};
$.each(FORMATS_TO_PATTERN_MAP, function(key, value) {
    value = value.replace(/'/g, "");
    FORMATTERS[value] = FORMATTERS[key];
    PARSERS[value] = PARSERS[key]
});
var getByFormat = function(obj, format) {
    return isString(format) && (obj[format.toLowerCase()] || obj[format.replace(/'/g, "")])
};
var cutCaptions = function(captions, format) {
    var lengthByFormat = {
        abbreviated: 3,
        "short": 2,
        narrow: 1
    };
    return $.map(captions, function(caption) {
        return caption.substr(0, lengthByFormat[format])
    })
};
var possiblePartPatterns = {
    year: ["y", "yy", "yyyy"],
    day: ["d", "dd"],
    month: ["M", "MM", "MMM", "MMMM"],
    hours: ["H", "HH", "h", "hh", "ah"],
    minutes: ["m", "mm"],
    seconds: ["s", "ss"],
    milliseconds: ["S", "SS", "SSS"]
};
var dateLocalization = dependencyInjector({
    _getPatternByFormat: function(format) {
        return FORMATS_TO_PATTERN_MAP[format.toLowerCase()]
    },
    _expandPattern: function(pattern) {
        return this._getPatternByFormat(pattern) || pattern
    },
    formatUsesMonthName: function(format) {
        return this._expandPattern(format).indexOf("MMMM") !== -1
    },
    formatUsesDayName: function(format) {
        return this._expandPattern(format).indexOf("EEEE") !== -1
    },
    getFormatParts: function(format) {
        var pattern = this._getPatternByFormat(format) || format,
            result = [];
        $.each(pattern.split(/\W+/), function(_, formatPart) {
            $.each(possiblePartPatterns, function(partName, possiblePatterns) {
                if (inArray(formatPart, possiblePatterns) > -1) {
                    result.push(partName)
                }
            })
        });
        return result
    },
    getMonthNames: function(format) {
        return cutCaptions(months, format)
    },
    getDayNames: function(format) {
        return cutCaptions(days, format)
    },
    getTimeSeparator: function() {
        return ":"
    },
    format: function(date, format) {
        if (!date) {
            return
        }
        if (!format) {
            return date
        }
        var formatter;
        if ("function" === typeof format) {
            formatter = format
        } else {
            if (format.formatter) {
                formatter = format.formatter
            } else {
                format = format.type || format;
                formatter = getByFormat(FORMATTERS, format)
            }
        }
        if (!formatter) {
            return
        }
        return formatter(date)
    },
    parse: function(text, format) {
        var result, parser;
        if (!text) {
            return
        }
        if (!format) {
            return new Date(text)
        }
        if (format.parser) {
            return format.parser(text)
        }
        if (format.type || format.formatter) {
            format = format.type
        }
        if (format && "function" !== typeof format) {
            parser = getByFormat(PARSERS, format)
        }
        if (parser) {
            result = parser(text)
        } else {
            errors.log("W0012");
            result = new Date(text)
        }
        if (!result || isNaN(result.getTime())) {
            return
        }
        return result
    },
    firstDayOfWeekIndex: function() {
        return 0
    }
});
module.exports = dateLocalization;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/editor/editor.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    extend = __webpack_require__(1).extend,
    Widget = __webpack_require__(27),
    ValidationMixin = __webpack_require__(114),
    Overlay = __webpack_require__(39);
var READONLY_STATE_CLASS = "dx-state-readonly",
    INVALID_CLASS = "dx-invalid",
    INVALID_MESSAGE = "dx-invalid-message",
    INVALID_MESSAGE_AUTO = "dx-invalid-message-auto",
    INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always",
    VALIDATION_TARGET = "dx-validation-target",
    VALIDATION_MESSAGE_MIN_WIDTH = 100;
var Editor = Widget.inherit({
    _init: function() {
        this.callBase();
        this.validationRequest = $.Callbacks();
        var $element = this.element();
        if ($element) {
            $.data($element[0], VALIDATION_TARGET, this)
        }
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: null,
            name: "",
            onValueChanged: null,
            readOnly: false,
            isValid: true,
            validationError: null,
            validationMessageMode: "auto",
            validationBoundary: void 0,
            validationMessageOffset: {
                h: 0,
                v: 0
            }
        })
    },
    _attachKeyboardEvents: function() {
        if (this.option("readOnly")) {
            return
        }
        this.callBase();
        if (this._keyboardProcessor) {
            this._attachChildKeyboardEvents()
        }
    },
    _attachChildKeyboardEvents: commonUtils.noop,
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            validationError: true
        })
    },
    _createValueChangeAction: function() {
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _suppressValueChangeAction: function() {
        this._valueChangeActionSuppressed = true
    },
    _resumeValueChangeAction: function() {
        this._valueChangeActionSuppressed = false
    },
    _render: function() {
        this.callBase();
        this._renderValidationState();
        this._toggleReadOnlyState();
        this._setSubmitElementName(this.option("name"))
    },
    _raiseValueChangeAction: function(value, previousValue) {
        if (!this._valueChangeAction) {
            this._createValueChangeAction()
        }
        this._valueChangeAction(this._valueChangeArgs(value, previousValue))
    },
    _valueChangeArgs: function(value, previousValue) {
        return {
            value: value,
            previousValue: previousValue,
            jQueryEvent: this._valueChangeEventInstance
        }
    },
    _saveValueChangeEvent: function(e) {
        this._valueChangeEventInstance = e
    },
    _renderValidationState: function() {
        var isValid = this.option("isValid"),
            validationError = this.option("validationError"),
            validationMessageMode = this.option("validationMessageMode"),
            $element = this.element();
        $element.toggleClass(INVALID_CLASS, !isValid);
        this.setAria("invalid", !isValid || void 0);
        if (this._$validationMessage) {
            this._$validationMessage.remove();
            this._$validationMessage = null
        }
        if (!isValid && validationError && validationError.message) {
            this._$validationMessage = $("<div/>", {
                "class": INVALID_MESSAGE
            }).html(validationError.message).appendTo($element);
            this._validationMessage = this._createComponent(this._$validationMessage, Overlay, {
                integrationOptions: {},
                templatesRenderAsynchronously: false,
                target: this._getValidationMessageTarget(),
                shading: false,
                width: "auto",
                height: "auto",
                container: $element,
                position: this._getValidationMessagePosition("below"),
                closeOnOutsideClick: false,
                closeOnTargetScroll: false,
                animation: null,
                visible: true,
                propagateOutsideClick: true,
                _checkParentVisibility: false
            });
            this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, "auto" === validationMessageMode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === validationMessageMode);
            this._setValidationMessageMaxWidth()
        }
    },
    _setValidationMessageMaxWidth: function() {
        if (!this._validationMessage) {
            return
        }
        if (0 === this._getValidationMessageTarget().outerWidth()) {
            this._validationMessage.option("maxWidth", "100%");
            return
        }
        var validationMessageMaxWidth = Math.max(VALIDATION_MESSAGE_MIN_WIDTH, this._getValidationMessageTarget().outerWidth());
        this._validationMessage.option("maxWidth", validationMessageMaxWidth)
    },
    _getValidationMessageTarget: function() {
        return this.element()
    },
    _getValidationMessagePosition: function(positionRequest) {
        var rtlEnabled = this.option("rtlEnabled"),
            messagePositionSide = getDefaultAlignment(rtlEnabled),
            messageOriginalOffset = this.option("validationMessageOffset"),
            messageOffset = {
                h: messageOriginalOffset.h,
                v: messageOriginalOffset.v
            },
            verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
        if (rtlEnabled) {
            messageOffset.h = -messageOffset.h
        }
        if ("below" !== positionRequest) {
            messageOffset.v = -messageOffset.v
        }
        return {
            offset: messageOffset,
            boundary: this.option("validationBoundary"),
            my: messagePositionSide + verticalPositions[0],
            at: messagePositionSide + verticalPositions[1],
            collision: "none flip"
        }
    },
    _toggleReadOnlyState: function() {
        this.element().toggleClass(READONLY_STATE_CLASS, !!this.option("readOnly"));
        this.setAria("readonly", this.option("readOnly") || void 0)
    },
    _dispose: function() {
        var element = this.element()[0];
        $.data(element, VALIDATION_TARGET, null);
        this.callBase()
    },
    _setSubmitElementName: function(name) {
        var $submitElement = this._getSubmitElement();
        if (!$submitElement) {
            return
        }
        if (name.length > 0) {
            $submitElement.attr("name", name)
        } else {
            $submitElement.removeAttr("name")
        }
    },
    _getSubmitElement: function() {
        return null
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onValueChanged":
                this._createValueChangeAction();
                break;
            case "isValid":
            case "validationError":
            case "validationBoundary":
            case "validationMessageMode":
                this._renderValidationState();
                break;
            case "readOnly":
                this._toggleReadOnlyState();
                this._refreshFocusState();
                break;
            case "value":
                if (!this._valueChangeActionSuppressed) {
                    this._raiseValueChangeAction(args.value, args.previousValue);
                    this._saveValueChangeEvent(void 0)
                }
                if (args.value != args.previousValue) {
                    this.validationRequest.fire({
                        value: args.value,
                        editor: this
                    })
                }
                break;
            case "width":
                this.callBase(args);
                this._setValidationMessageMaxWidth();
                break;
            case "name":
                this._setSubmitElementName(args.value);
                break;
            default:
                this.callBase(args)
        }
    },
    reset: function() {
        this.option("value", null)
    }
}).include(ValidationMixin);
module.exports = Editor;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/guid.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Class = __webpack_require__(5);
var Guid = Class.inherit({
    ctor: function(value) {
        if (value) {
            value = String(value)
        }
        this._value = this._normalize(value || this._generate())
    },
    _normalize: function(value) {
        value = value.replace(/[^a-f0-9]/gi, "").toLowerCase();
        while (value.length < 32) {
            value += "0"
        }
        return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
    },
    _generate: function() {
        var value = "";
        for (var i = 0; i < 32; i++) {
            value += Math.round(15 * Math.random()).toString(16)
        }
        return value
    },
    toString: function() {
        return this._value
    },
    valueOf: function() {
        return this._value
    },
    toJSON: function() {
        return this._value
    }
});
module.exports = Guid;
module.exports.default = module.exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/query.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var arrayQueryImpl = __webpack_require__(119),
    remoteQueryImpl = __webpack_require__(269);
var queryImpl = {
    array: arrayQueryImpl,
    remote: remoteQueryImpl
};
var query = function() {
    var impl = Array.isArray(arguments[0]) ? "array" : "remote";
    return queryImpl[impl].apply(this, arguments)
};
module.exports = query;
module.exports.queryImpl = queryImpl;
module.exports.default = module.exports;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/inflector.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var _normalize = function(text) {
    if (void 0 === text || null === text) {
        return ""
    }
    return String(text)
};
var _upperCaseFirst = function(text) {
    return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
};
var _chop = function(text) {
    return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
};
var dasherize = function(text) {
    return $.map(_chop(text), function(p) {
        return p.toLowerCase()
    }).join("-")
};
var underscore = function(text) {
    return dasherize(text).replace(/-/g, "_")
};
var camelize = function(text, upperFirst) {
    return $.map(_chop(text), function(p, i) {
        p = p.toLowerCase();
        if (upperFirst || i > 0) {
            p = _upperCaseFirst(p)
        }
        return p
    }).join("")
};
var humanize = function(text) {
    return _upperCaseFirst(dasherize(text).replace(/-/g, " "))
};
var titleize = function(text) {
    return $.map(_chop(text), function(p) {
        return _upperCaseFirst(p.toLowerCase())
    }).join(" ")
};
var captionize = function(name) {
    var i, char, captionList = [],
        isPrevCharNewWord = false,
        isNewWord = false;
    for (i = 0; i < name.length; i++) {
        char = name.charAt(i);
        isNewWord = char === char.toUpperCase() || char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        if ("_" === char || "." === char) {
            char = " ";
            isNewWord = true
        } else {
            if (0 === i) {
                char = char.toUpperCase();
                isNewWord = true
            } else {
                if (!isPrevCharNewWord && isNewWord) {
                    if (captionList.length > 0) {
                        captionList.push(" ")
                    }
                }
            }
        }
        captionList.push(char);
        isPrevCharNewWord = isNewWord
    }
    return captionList.join("")
};
exports.dasherize = dasherize;
exports.camelize = camelize;
exports.humanize = humanize;
exports.titleize = titleize;
exports.underscore = underscore;
exports.captionize = captionize;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/version.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.compare = function(x, y, maxLevel) {
    function normalizeArg(value) {
        if ("string" === typeof value) {
            return value.split(".")
        }
        if ("number" === typeof value) {
            return [value]
        }
        return value
    }
    x = normalizeArg(x);
    y = normalizeArg(y);
    var length = Math.max(x.length, y.length);
    if (isFinite(maxLevel)) {
        length = Math.min(length, maxLevel)
    }
    for (var i = 0; i < length; i++) {
        var xItem = parseInt(x[i] || 0, 10),
            yItem = parseInt(y[i] || 0, 10);
        if (xItem < yItem) {
            return -1
        }
        if (xItem > yItem) {
            return 1
        }
    }
    return 0
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/events_mixin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    DefaultEventsStrategy = __webpack_require__(249),
    isPlainObject = __webpack_require__(9).isPlainObject;
module.exports = {
    ctor: function() {
        this._events = {};
        this.setEventsStrategy(new DefaultEventsStrategy(this))
    },
    setEventsStrategy: function(strategy) {
        this._eventsStrategy = strategy
    },
    hasEvent: function(eventName) {
        return this._eventsStrategy.hasEvent(eventName)
    },
    fireEvent: function(eventName, eventArgs) {
        this._eventsStrategy.fireEvent(eventName, eventArgs);
        return this
    },
    on: function(eventName, eventHandler) {
        if (isPlainObject(eventName)) {
            $.each(eventName, function(e, h) {
                this.on(e, h)
            }.bind(this))
        } else {
            this._eventsStrategy.on(eventName, eventHandler)
        }
        return this
    },
    off: function(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this
    },
    _disposeEvents: function() {
        this._eventsStrategy.dispose()
    }
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/overlay.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    fx = __webpack_require__(22),
    translator = __webpack_require__(19),
    compareVersions = __webpack_require__(37).compare,
    viewPortUtils = __webpack_require__(54),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    viewPortChanged = viewPortUtils.changeCallback,
    hideTopOverlayCallback = __webpack_require__(108).hideCallback,
    positionUtils = __webpack_require__(46),
    fitIntoRange = __webpack_require__(56).fitIntoRange,
    domUtils = __webpack_require__(15),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    Widget = __webpack_require__(27),
    KeyboardProcessor = __webpack_require__(112),
    selectors = __webpack_require__(92),
    dragEvents = __webpack_require__(76),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    Resizable = __webpack_require__(174),
    EmptyTemplate = __webpack_require__(138);
var OVERLAY_CLASS = "dx-overlay",
    OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper",
    OVERLAY_CONTENT_CLASS = "dx-overlay-content",
    OVERLAY_SHADER_CLASS = "dx-overlay-shader",
    OVERLAY_MODAL_CLASS = "dx-overlay-modal",
    INVISIBLE_STATE_CLASS = "dx-state-invisible",
    ANONYMOUS_TEMPLATE_NAME = "content",
    RTL_DIRECTION_CLASS = "dx-rtl",
    ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"],
    FIRST_Z_INDEX = 1500,
    OVERLAY_STACK = [],
    DISABLED_STATE_CLASS = "dx-state-disabled",
    TAB_KEY = 9;
var realDevice = devices.real(),
    realVersion = realDevice.version,
    iOS = "ios" === realDevice.platform,
    iOS7_0andBelow = iOS && compareVersions(realVersion, [7, 1]) < 0,
    android4_0nativeBrowser = "android" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && navigator.userAgent.indexOf("Chrome") === -1;
var forceRepaint = function($element) {
    if (iOS7_0andBelow) {
        $element.width()
    }
    if (android4_0nativeBrowser) {
        var $parents = $element.parents(),
            inScrollView = $parents.is(".dx-scrollable-native");
        if (!inScrollView) {
            $parents.css("backface-visibility", "hidden");
            $parents.css("backface-visibility");
            $parents.css("backface-visibility", "visible")
        }
    }
};
var getElement = function(value) {
    return value && $(value instanceof $.Event ? value.target : value)
};
$(document).on(pointerEvents.down, function(e) {
    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
        if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
            return
        }
    }
});
var Overlay = Widget.inherit({
    _supportedKeys: function() {
        var offsetSize = 5,
            move = function(top, left, e) {
                if (!this.option("dragEnabled")) {
                    return
                }
                e.preventDefault();
                e.stopPropagation();
                var allowedOffsets = this._allowedOffsets();
                var offset = {
                    top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
                    left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
                };
                this._changePosition(offset)
            };
        return extend(this.callBase(), {
            escape: function() {
                this.hide()
            },
            upArrow: move.bind(this, -offsetSize, 0),
            downArrow: move.bind(this, offsetSize, 0),
            leftArrow: move.bind(this, 0, -offsetSize),
            rightArrow: move.bind(this, 0, offsetSize)
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            activeStateEnabled: false,
            visible: false,
            deferRendering: true,
            shading: true,
            shadingColor: "",
            position: {
                my: "center",
                at: "center"
            },
            width: function() {
                return .8 * $(window).width()
            },
            minWidth: null,
            maxWidth: null,
            height: function() {
                return .8 * $(window).height()
            },
            minHeight: null,
            maxHeight: null,
            animation: {
                show: {
                    type: "pop",
                    duration: 300,
                    from: {
                        scale: .55
                    }
                },
                hide: {
                    type: "pop",
                    duration: 300,
                    to: {
                        opacity: 0,
                        scale: .55
                    },
                    from: {
                        opacity: 1,
                        scale: 1
                    }
                }
            },
            closeOnOutsideClick: false,
            closeOnBackButton: true,
            onShowing: null,
            onShown: null,
            onHiding: null,
            onHidden: null,
            contentTemplate: "content",
            dragEnabled: false,
            resizeEnabled: false,
            onResizeStart: null,
            onResize: null,
            onResizeEnd: null,
            onContentReady: null,
            target: void 0,
            container: void 0,
            hideTopOverlayHandler: void 0,
            closeOnTargetScroll: false,
            onPositioned: null,
            boundaryOffset: {
                h: 0,
                v: 0
            },
            propagateOutsideClick: false,
            _checkParentVisibility: true
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var realDevice = devices.real(),
                    realPlatform = realDevice.platform,
                    realVersion = realDevice.version;
                return "android" === realPlatform && compareVersions(realVersion, [4, 2]) < 0
            },
            options: {
                animation: {
                    show: {
                        type: "fade",
                        duration: 400
                    },
                    hide: {
                        type: "fade",
                        duration: 400,
                        to: {
                            opacity: 0
                        },
                        from: {
                            opacity: 1
                        }
                    }
                }
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            animation: true
        })
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _wrapper: function() {
        return this._$wrapper
    },
    _container: function() {
        return this._$content
    },
    _eventBindingTarget: function() {
        return this._$content
    },
    _init: function() {
        this.callBase();
        this._initActions();
        this._initCloseOnOutsideClickHandler();
        this._initTabTerminatorHandler();
        this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
        this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
        var $element = this.element();
        this._$wrapper.addClass($element.attr("class"));
        $element.addClass(OVERLAY_CLASS);
        this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
        this._$wrapper.on("MSPointerDown", commonUtils.noop);
        this._$wrapper.on("focusin", function(e) {
            e.stopPropagation()
        });
        this._toggleViewPortSubscription(true)
    },
    _initOptions: function(options) {
        this._initTarget(options.target);
        this._initContainer(options.container);
        this._initHideTopOverlayHandler(options.hideTopOverlayHandler);
        this.callBase(options)
    },
    _initTarget: function(target) {
        if (!commonUtils.isDefined(target)) {
            return
        }
        var options = this.option();
        $.each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
            var pathParts = path.split(".");
            var option = options;
            while (option) {
                if (1 === pathParts.length) {
                    if (typeUtils.isPlainObject(option)) {
                        option[pathParts.shift()] = target
                    }
                    break
                } else {
                    option = option[pathParts.shift()]
                }
            }
        })
    },
    _initContainer: function(container) {
        container = void 0 === container ? viewPortUtils.value() : container;
        var $element = this.element(),
            $container = $element.closest(container);
        if (!$container.length) {
            $container = $(container).first()
        }
        this._$container = $container.length ? $container : $element.parent()
    },
    _initHideTopOverlayHandler: function(handler) {
        this._hideTopOverlayHandler = void 0 !== handler ? handler : this._defaultHideTopOverlayHandler.bind(this)
    },
    _defaultHideTopOverlayHandler: function() {
        this.hide()
    },
    _initActions: function() {
        this._actions = {};
        $.each(ACTIONS, function(_, action) {
            this._actions[action] = this._createActionByOption(action, {
                excludeValidators: ["disabled", "readOnly"]
            }) || commonUtils.noop
        }.bind(this))
    },
    _initCloseOnOutsideClickHandler: function() {
        var that = this;
        this._proxiedDocumentDownHandler = function() {
            return that._documentDownHandler.apply(that, arguments)
        }
    },
    _documentDownHandler: function(e) {
        if (this._showAnimationProcessing) {
            this._stopAnimation()
        }
        var closeOnOutsideClick = this.option("closeOnOutsideClick");
        if (commonUtils.isFunction(closeOnOutsideClick)) {
            closeOnOutsideClick = closeOnOutsideClick(e)
        }
        if (closeOnOutsideClick) {
            var $container = this._$content,
                outsideClick = !$container.is(e.target) && !$.contains($container.get(0), e.target) && $(e.target).closest(document).length;
            if (outsideClick) {
                if (this.option("shading")) {
                    e.preventDefault()
                }
                this.hide()
            }
        }
        return this.option("propagateOutsideClick")
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.content = new EmptyTemplate(this)
    },
    _isTopOverlay: function() {
        var overlayStack = this._overlayStack();
        for (var i = overlayStack.length - 1; i >= 0; i--) {
            var $tabbableElements = overlayStack[i]._findTabbableElements();
            if ($tabbableElements.length) {
                return overlayStack[i] === this
            }
        }
        return false
    },
    _overlayStack: function() {
        return OVERLAY_STACK
    },
    _zIndexInitValue: function() {
        return FIRST_Z_INDEX
    },
    _toggleViewPortSubscription: function(toggle) {
        viewPortChanged.remove(this._viewPortChangeHandle);
        if (toggle) {
            this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
            viewPortChanged.add(this._viewPortChangeHandle)
        }
    },
    _viewPortChangeHandler: function() {
        this._initContainer(this.option("container"));
        this._refresh()
    },
    _renderVisibilityAnimate: function(visible) {
        this._stopAnimation();
        return visible ? this._show() : this._hide()
    },
    _normalizePosition: function() {
        this._position = this.option("position")
    },
    _getAnimationConfig: function() {
        var animation = this.option("animation");
        if (commonUtils.isFunction(animation)) {
            animation = animation.call(this)
        }
        return animation
    },
    _show: function() {
        var that = this,
            deferred = $.Deferred();
        this._parentHidden = this._isParentHidden();
        deferred.done(function() {
            delete that._parentHidden
        });
        if (this._parentHidden) {
            return deferred.resolve()
        }
        if (this._currentVisible) {
            return $.Deferred().resolve().promise()
        }
        this._currentVisible = true;
        this._normalizePosition();
        var animation = that._getAnimationConfig() || {},
            showAnimation = this._normalizeAnimation(animation.show, "to"),
            startShowAnimation = showAnimation && showAnimation.start || commonUtils.noop,
            completeShowAnimation = showAnimation && showAnimation.complete || commonUtils.noop;
        if (this._isHidingActionCanceled) {
            delete this._isHidingActionCanceled;
            deferred.resolve()
        } else {
            var show = function() {
                this._renderVisibility(true);
                this._animate(showAnimation, function() {
                    if (that.option("focusStateEnabled")) {
                        that._focusTarget().focus()
                    }
                    completeShowAnimation.apply(this, arguments);
                    that._showAnimationProcessing = false;
                    that._actions.onShown();
                    deferred.resolve()
                }, function() {
                    startShowAnimation.apply(this, arguments);
                    that._showAnimationProcessing = true
                })
            }.bind(this);
            if (this.option("templatesRenderAsynchronously")) {
                this._asyncShowTimeout = setTimeout(show)
            } else {
                show()
            }
        }
        return deferred.promise()
    },
    _normalizeAnimation: function(animation, prop) {
        if (animation) {
            animation = extend({
                type: "slide"
            }, animation);
            if (animation[prop] && "object" === typeof animation[prop]) {
                extend(animation[prop], {
                    position: this._position
                })
            }
        }
        return animation
    },
    _hide: function() {
        if (!this._currentVisible) {
            return $.Deferred().resolve().promise()
        }
        this._currentVisible = false;
        var that = this,
            deferred = $.Deferred(),
            animation = that._getAnimationConfig() || {},
            hideAnimation = this._normalizeAnimation(animation.hide, "from"),
            startHideAnimation = hideAnimation && hideAnimation.start || commonUtils.noop,
            completeHideAnimation = hideAnimation && hideAnimation.complete || commonUtils.noop,
            hidingArgs = {
                cancel: false
            };
        this._actions.onHiding(hidingArgs);
        if (hidingArgs.cancel) {
            this._isHidingActionCanceled = true;
            this.option("visible", true);
            deferred.resolve()
        } else {
            this._forceFocusLost();
            this._toggleShading(false);
            this._toggleSubscriptions(false);
            this._animate(hideAnimation, function() {
                that._$content.css("pointer-events", "");
                that._renderVisibility(false);
                completeHideAnimation.apply(this, arguments);
                that._actions.onHidden();
                deferred.resolve()
            }, function() {
                that._$content.css("pointer-events", "none");
                startHideAnimation.apply(this, arguments)
            })
        }
        return deferred.promise()
    },
    _forceFocusLost: function() {
        document.activeElement && this._$content.find(document.activeElement).length && document.activeElement.blur()
    },
    _animate: function(animation, completeCallback, startCallback) {
        if (animation) {
            startCallback = startCallback || animation.start || commonUtils.noop;
            fx.animate(this._$content, extend({}, animation, {
                start: startCallback,
                complete: completeCallback
            }))
        } else {
            completeCallback()
        }
    },
    _stopAnimation: function() {
        fx.stop(this._$content, true)
    },
    _renderVisibility: function(visible) {
        if (visible && this._isParentHidden()) {
            return
        }
        this._currentVisible = visible;
        this._stopAnimation();
        clearTimeout(this._asyncShowTimeout);
        if (!visible) {
            domUtils.triggerHidingEvent(this._$content)
        }
        this._toggleVisibility(visible);
        this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
        this._updateZIndexStackPosition(visible);
        if (visible) {
            this._renderContent();
            this._actions.onShowing();
            this._moveToContainer();
            this._renderGeometry();
            domUtils.triggerShownEvent(this._$content);
            domUtils.triggerResizeEvent(this._$content)
        } else {
            this._moveFromContainer()
        }
        this._toggleShading(visible);
        this._toggleSubscriptions(visible)
    },
    _updateZIndexStackPosition: function(pushToStack) {
        var overlayStack = this._overlayStack(),
            index = inArray(this, overlayStack);
        if (pushToStack) {
            if (index === -1) {
                var length = overlayStack.length;
                this._zIndex = (length ? overlayStack[length - 1]._zIndex : this._zIndexInitValue()) + 1;
                overlayStack.push(this)
            }
            this._$wrapper.css("z-index", this._zIndex);
            this._$content.css("z-index", this._zIndex)
        } else {
            if (index !== -1) {
                overlayStack.splice(index, 1)
            }
        }
    },
    _toggleShading: function(visible) {
        this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
        this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
        this._$wrapper.css("background-color", this.option("shading") ? this.option("shadingColor") : "");
        this._toggleTabTerminator(visible && this.option("shading"))
    },
    _initTabTerminatorHandler: function() {
        var that = this;
        this._proxiedTabTerminatorHandler = function() {
            that._tabKeyHandler.apply(that, arguments)
        }
    },
    _toggleTabTerminator: function(enabled) {
        var eventName = eventUtils.addNamespace("keydown", this.NAME);
        if (enabled) {
            $(document).on(eventName, this._proxiedTabTerminatorHandler)
        } else {
            $(document).off(eventName, this._proxiedTabTerminatorHandler)
        }
    },
    _findTabbableElements: function() {
        return this._$wrapper.find("*").filter(selectors.tabbable)
    },
    _tabKeyHandler: function(e) {
        if (e.keyCode !== TAB_KEY || !this._isTopOverlay()) {
            return
        }
        var tabbableElements = this._findTabbableElements(),
            $firstTabbable = tabbableElements.first(),
            $lastTabbable = tabbableElements.last(),
            isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),
            isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),
            isEmptyTabList = 0 === tabbableElements.length,
            isOutsideTarget = inArray(e.target, tabbableElements) === -1;
        if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
            e.preventDefault();
            (e.shiftKey ? $lastTabbable : $firstTabbable).focusin().focus()
        }
    },
    _toggleSubscriptions: function(enabled) {
        this._toggleHideTopOverlayCallback(enabled);
        this._toggleParentsScrollSubscription(enabled)
    },
    _toggleHideTopOverlayCallback: function(subscribe) {
        if (!this._hideTopOverlayHandler) {
            return
        }
        if (subscribe && this.option("closeOnBackButton")) {
            hideTopOverlayCallback.add(this._hideTopOverlayHandler)
        } else {
            hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
        }
    },
    _toggleParentsScrollSubscription: function(subscribe) {
        if (!this._position) {
            return
        }
        var target = this._position.of || $(),
            closeOnScroll = this.option("closeOnTargetScroll"),
            $parents = getElement(target).parents(),
            scrollEvent = eventUtils.addNamespace("scroll", this.NAME);
        if ("generic" === devices.real().platform) {
            $parents = $parents.add(window)
        }
        this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function(e) {
            this._targetParentsScrollHandler(e)
        }.bind(this);
        $().add(this._$prevTargetParents).off(scrollEvent, this._proxiedTargetParentsScrollHandler);
        if (subscribe && closeOnScroll) {
            $parents.on(scrollEvent, this._proxiedTargetParentsScrollHandler);
            this._$prevTargetParents = $parents
        }
    },
    _targetParentsScrollHandler: function(e) {
        var closeHandled = false,
            closeOnScroll = this.option("closeOnTargetScroll");
        if (commonUtils.isFunction(closeOnScroll)) {
            closeHandled = closeOnScroll(e)
        }
        if (!closeHandled && !this._showAnimationProcessing) {
            this.hide()
        }
    },
    _render: function() {
        this.callBase();
        this._$content.appendTo(this.element());
        this._renderVisibilityAnimate(this.option("visible"))
    },
    _renderContent: function() {
        var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
        var isParentHidden = this.option("visible") && this._isParentHidden();
        if (isParentHidden) {
            this._isHidden = true;
            return
        }
        if (this._contentAlreadyRendered || shouldDeferRendering) {
            return
        }
        this._contentAlreadyRendered = true;
        this.callBase()
    },
    _isParentHidden: function() {
        if (!this.option("_checkParentVisibility")) {
            return false
        }
        if (void 0 !== this._parentHidden) {
            return this._parentHidden
        }
        var $parent = this.element().parent();
        if ($parent.is(":visible")) {
            return false
        }
        var isHidden = false;
        $parent.add($parent.parents()).each(function() {
            var $element = $(this);
            if ("none" === $element.css("display")) {
                isHidden = true;
                return false
            }
        });
        return isHidden || !$.contains(document, $parent.get(0))
    },
    _renderContentImpl: function() {
        var $element = this.element();
        this._$content.appendTo($element);
        var contentTemplate = this._getTemplate(this.option("contentTemplate"));
        contentTemplate && contentTemplate.render({
            container: this.content(),
            noModel: true
        });
        this._renderDrag();
        this._renderResize();
        this._renderScrollTerminator()
    },
    _renderDrag: function() {
        var $dragTarget = this._getDragTarget();
        if (!$dragTarget) {
            return
        }
        var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME),
            updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
        $dragTarget.off(startEventName).off(updateEventName);
        if (!this.option("dragEnabled")) {
            return
        }
        $dragTarget.on(startEventName, this._dragStartHandler.bind(this)).on(updateEventName, this._dragUpdateHandler.bind(this))
    },
    _renderResize: function() {
        this._resizable = this._createComponent(this._$content, Resizable, {
            handles: this.option("resizeEnabled") ? "all" : "none",
            onResizeEnd: this._resizeEndHandler.bind(this),
            onResize: this._actions.onResize.bind(this),
            onResizeStart: this._actions.onResizeStart.bind(this),
            minHeight: 100,
            minWidth: 100,
            area: this._getDragResizeContainer()
        })
    },
    _resizeEndHandler: function() {
        this._positionChangeHandled = true;
        var width = this._resizable.option("width"),
            height = this._resizable.option("height");
        width && this.option("width", width);
        height && this.option("height", height);
        this._actions.onResizeEnd()
    },
    _renderScrollTerminator: function() {
        var $scrollTerminator = this._wrapper();
        var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);
        $scrollTerminator.off(terminatorEventName).on(terminatorEventName, {
            validate: function() {
                return true
            },
            getDirection: function() {
                return "both"
            },
            _toggleGestureCover: commonUtils.noop,
            _clearSelection: commonUtils.noop,
            isNative: true
        }, function(e) {
            var originalEvent = e.originalEvent.originalEvent;
            e._cancelPreventDefault = true;
            if (originalEvent && "mousemove" !== originalEvent.type) {
                e.preventDefault()
            }
        })
    },
    _getDragTarget: function() {
        return this.content()
    },
    _dragStartHandler: function(e) {
        e.targetElements = [];
        this._prevOffset = {
            x: 0,
            y: 0
        };
        var allowedOffsets = this._allowedOffsets();
        e.maxTopOffset = allowedOffsets.top;
        e.maxBottomOffset = allowedOffsets.bottom;
        e.maxLeftOffset = allowedOffsets.left;
        e.maxRightOffset = allowedOffsets.right
    },
    _getDragResizeContainer: function() {
        var isContainerDefined = viewPortUtils.originalViewPort().get(0) || this.option("container"),
            $container = !isContainerDefined ? $(window) : this._$container;
        return $container
    },
    _deltaSize: function() {
        var $content = this._$content,
            $container = this._getDragResizeContainer();
        var contentWidth = $content.outerWidth(),
            contentHeight = $content.outerHeight(),
            containerWidth = $container.outerWidth(),
            containerHeight = $container.outerHeight();
        if (this._isWindow($container)) {
            var fullPageHeight = Math.max($(document).outerHeight(), containerHeight),
                fullPageWidth = Math.max($(document).outerWidth(), containerWidth);
            containerHeight = fullPageHeight;
            containerWidth = fullPageWidth
        }
        return {
            width: containerWidth - contentWidth,
            height: containerHeight - contentHeight
        }
    },
    _dragUpdateHandler: function(e) {
        var offset = e.offset,
            prevOffset = this._prevOffset,
            targetOffset = {
                top: offset.y - prevOffset.y,
                left: offset.x - prevOffset.x
            };
        this._changePosition(targetOffset);
        this._prevOffset = offset
    },
    _changePosition: function(offset) {
        var position = translator.locate(this._$content);
        translator.move(this._$content, {
            left: position.left + offset.left,
            top: position.top + offset.top
        });
        this._positionChangeHandled = true
    },
    _allowedOffsets: function() {
        var position = translator.locate(this._$content),
            deltaSize = this._deltaSize(),
            isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,
            shaderOffset = this.option("shading") && !this.option("container") && !this._isWindow(this._getContainer()) ? translator.locate(this._$wrapper) : {
                top: 0,
                left: 0
            },
            boundaryOffset = this.option("boundaryOffset");
        return {
            top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,
            bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
            left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,
            right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
        }
    },
    _fireContentReadyAction: function() {
        if (this.option("visible")) {
            this._moveToContainer()
        }
        this.callBase.apply(this, arguments)
    },
    _moveFromContainer: function() {
        this._$content.appendTo(this.element());
        this._detachWrapperToContainer()
    },
    _detachWrapperToContainer: function() {
        this._$wrapper.detach()
    },
    _moveToContainer: function() {
        this._attachWrapperToContainer();
        this._$content.appendTo(this._$wrapper)
    },
    _attachWrapperToContainer: function() {
        var $element = this.element();
        if (this._$container && this._$container[0] !== $element.parent()[0]) {
            this._$wrapper.appendTo(this._$container)
        } else {
            this._$wrapper.appendTo($element)
        }
    },
    _renderGeometry: function() {
        if (this.option("visible")) {
            this._renderGeometryImpl()
        }
    },
    _renderGeometryImpl: function() {
        this._stopAnimation();
        this._normalizePosition();
        this._renderShading();
        this._renderDimensions();
        var resultPosition = this._renderPosition();
        this._actions.onPositioned({
            position: resultPosition
        })
    },
    _renderShading: function() {
        var $wrapper = this._$wrapper,
            $container = this._getContainer();
        $wrapper.css("position", this._isWindow($container) && !iOS ? "fixed" : "absolute");
        this._renderShadingDimensions();
        this._renderShadingPosition()
    },
    _renderShadingPosition: function() {
        if (this.option("shading")) {
            var $container = this._getContainer();
            positionUtils.setup(this._$wrapper, {
                my: "top left",
                at: "top left",
                of: $container
            })
        }
    },
    _renderShadingDimensions: function() {
        var wrapperWidth, wrapperHeight;
        if (this.option("shading")) {
            var $container = this._getContainer();
            wrapperWidth = this._isWindow($container) ? "100%" : $container.outerWidth(), wrapperHeight = this._isWindow($container) ? "100%" : $container.outerHeight()
        } else {
            wrapperWidth = "";
            wrapperHeight = ""
        }
        this._$wrapper.css({
            width: wrapperWidth,
            height: wrapperHeight
        })
    },
    _isWindow: function($element) {
        return !!$element && commonUtils.isWindow($element.get(0))
    },
    _getContainer: function() {
        var position = this._position,
            container = this.option("container"),
            positionOf = position ? position.of || window : null;
        return getElement(container || positionOf)
    },
    _renderDimensions: function() {
        this._$content.css({
            minWidth: this.option("minWidth"),
            maxWidth: this.option("maxWidth"),
            minHeight: this.option("minHeight"),
            maxHeight: this.option("maxHeight")
        });
        this._$content.outerWidth(this.option("width")).outerHeight(this.option("height"))
    },
    _renderPosition: function() {
        if (this._positionChangeHandled) {
            var allowedOffsets = this._allowedOffsets();
            this._changePosition({
                top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
                left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
            })
        } else {
            this._renderOverlayBoundaryOffset();
            translator.resetPosition(this._$content);
            var resultPosition = positionUtils.setup(this._$content, this._position);
            forceRepaint(this._$content);
            this._actions.onPositioning();
            return resultPosition
        }
    },
    _renderOverlayBoundaryOffset: function() {
        var boundaryOffset = this.option("boundaryOffset");
        this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
    },
    _focusTarget: function() {
        return this._$content
    },
    _attachKeyboardEvents: function() {
        this._keyboardProcessor = new KeyboardProcessor({
            element: this._$content,
            handler: this._keyboardHandler,
            context: this
        })
    },
    _keyboardHandler: function(options) {
        var e = options.originalEvent,
            $target = $(e.target);
        if ($target.is(this._$content)) {
            this.callBase.apply(this, arguments)
        }
    },
    _isVisible: function() {
        return this.option("visible")
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            if (this.option("visible")) {
                this._renderVisibilityAnimate(visible)
            }
        } else {
            this._renderVisibilityAnimate(visible)
        }
    },
    _dimensionChanged: function() {
        this._renderGeometry()
    },
    _clean: function() {
        if (!this._contentAlreadyRendered) {
            this.content().empty()
        }
        this._renderVisibility(false);
        this._cleanFocusState()
    },
    _dispose: function() {
        fx.stop(this._$content, false);
        clearTimeout(this._deferShowTimer);
        this._toggleViewPortSubscription(false);
        this._toggleSubscriptions(false);
        this._updateZIndexStackPosition(false);
        this._toggleTabTerminator(false);
        this._actions = null;
        this.callBase();
        this._$wrapper.remove();
        this._$content.remove()
    },
    _toggleDisabledState: function(value) {
        this.callBase.apply(this, arguments);
        this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
    },
    _toggleRTLDirection: function(rtl) {
        this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
    },
    _optionChanged: function(args) {
        var value = args.value;
        if (inArray(args.name, ACTIONS) > -1) {
            this._initActions();
            return
        }
        switch (args.name) {
            case "dragEnabled":
                this._renderDrag();
                this._renderGeometry();
                break;
            case "resizeEnabled":
                this._renderResize();
                this._renderGeometry();
                break;
            case "shading":
            case "shadingColor":
                this._toggleShading(this.option("visible"));
                break;
            case "width":
            case "height":
            case "minWidth":
            case "maxWidth":
            case "minHeight":
            case "maxHeight":
            case "position":
            case "boundaryOffset":
                this._renderGeometry();
                break;
            case "visible":
                this._renderVisibilityAnimate(value).done(function() {
                    if (!this._animateDeferred) {
                        return
                    }
                    this._animateDeferred.resolveWith(this)
                }.bind(this));
                break;
            case "target":
                this._initTarget(value);
                this._invalidate();
                break;
            case "container":
                this._initContainer(value);
                this._invalidate();
                break;
            case "deferRendering":
            case "contentTemplate":
                this._contentAlreadyRendered = false;
                this._invalidate();
                break;
            case "closeOnBackButton":
                this._toggleHideTopOverlayCallback(this.option("visible"));
                break;
            case "closeOnTargetScroll":
                this._toggleParentsScrollSubscription(this.option("visible"));
                break;
            case "closeOnOutsideClick":
            case "animation":
            case "propagateOutsideClick":
                break;
            case "rtlEnabled":
                this._contentAlreadyRendered = false;
                this.option("visible", false);
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    toggle: function(showing) {
        showing = void 0 === showing ? !this.option("visible") : showing;
        if (showing === this.option("visible")) {
            return $.Deferred().resolve().promise()
        }
        var animateDeferred = $.Deferred();
        this._animateDeferred = animateDeferred;
        this.option("visible", showing);
        return animateDeferred.promise().done(function() {
            delete this._animateDeferred
        }.bind(this))
    },
    show: function() {
        return this.toggle(true)
    },
    hide: function() {
        return this.toggle(false)
    },
    content: function() {
        return this._$content
    },
    repaint: function() {
        this._renderGeometry()
    }
});
Overlay.baseZIndex = function(zIndex) {
    FIRST_Z_INDEX = zIndex
};
registerComponent("dxOverlay", Overlay);
module.exports = Overlay;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    BaseCollectionWidget = __webpack_require__(276),
    errors = __webpack_require__(16),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    PlainEditStrategy = __webpack_require__(149),
    compileGetter = __webpack_require__(14).compileGetter,
    DataSource = __webpack_require__(51).DataSource,
    Selection = __webpack_require__(189),
    when = __webpack_require__(10).when;
var ITEM_DELETING_DATA_KEY = "dxItemDeleting",
    NOT_EXISTING_INDEX = -1;
var indexExists = function(index) {
    return index !== NOT_EXISTING_INDEX
};
var CollectionWidget = BaseCollectionWidget.inherit({
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            selectedItem: true
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            selectionMode: "none",
            selectionRequired: false,
            selectionByClick: true,
            selectedItems: [],
            selectedItemKeys: [],
            maxFilterLengthInRequest: 1500,
            keyExpr: null,
            selectedIndex: NOT_EXISTING_INDEX,
            selectedItem: null,
            onSelectionChanged: null,
            onItemReordered: null,
            onItemDeleting: null,
            onItemDeleted: null
        })
    },
    ctor: function(element, options) {
        this._userOptions = options || {};
        this.callBase(element, options)
    },
    _init: function() {
        this._initEditStrategy();
        this.callBase();
        this._initKeyGetter();
        this._initSelectionModule();
        if ("multi" === this.option("selectionMode")) {
            this._showDeprecatedSelectionMode()
        }
    },
    _initKeyGetter: function() {
        this._keyGetter = compileGetter(this.option("keyExpr"))
    },
    _getKeysByItems: function(selectedItems) {
        return this._editStrategy.getKeysByItems(selectedItems)
    },
    _getItemsByKeys: function(selectedItemKeys, selectedItems) {
        return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems)
    },
    _getKeyByIndex: function(index) {
        return this._editStrategy.getKeyByIndex(index)
    },
    _getIndexByKey: function(key) {
        return this._editStrategy.getIndexByKey(key)
    },
    _getIndexByItemData: function(itemData) {
        return this._editStrategy.getIndexByItemData(itemData)
    },
    _isKeySpecified: function() {
        return !!(this._dataSource && this._dataSource.key())
    },
    keyOf: function(item) {
        var key = item,
            store = this._dataSource && this._dataSource.store();
        if (this.option("keyExpr")) {
            key = this._keyGetter(item)
        } else {
            if (store) {
                key = store.keyOf(item)
            }
        }
        return key
    },
    _initSelectionModule: function() {
        var that = this,
            itemsGetter = that._editStrategy.itemsGetter;
        this._selection = new Selection({
            mode: this.option("selectionMode"),
            maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
            equalByReference: !this._isKeySpecified(),
            onSelectionChanged: function(args) {
                if (args.addedItemKeys.length || args.removedItemKeys.length) {
                    that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
                    that._updateSelectedItems(args.addedItems, args.removedItems)
                }
            },
            filter: function() {
                return that._dataSource && that._dataSource.filter()
            },
            totalCount: function() {
                var items = that.option("items");
                var dataSource = that._dataSource;
                return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length
            },
            key: function() {
                if (that.option("keyExpr")) {
                    return that.option("keyExpr")
                }
                return that._dataSource && that._dataSource.key()
            },
            keyOf: that.keyOf.bind(that),
            load: function(options) {
                if (that._dataSource) {
                    var loadOptions = that._dataSource.loadOptions();
                    options.customQueryParams = loadOptions.customQueryParams;
                    options.userData = that._dataSource._userData
                }
                var store = that._dataSource && that._dataSource.store();
                return store ? store.load(options) : $.Deferred().resolve([])
            },
            dataFields: function() {
                return that._dataSource && that._dataSource.select()
            },
            plainItems: itemsGetter.bind(that._editStrategy)
        })
    },
    _initEditStrategy: function() {
        var Strategy = PlainEditStrategy;
        this._editStrategy = new Strategy(this)
    },
    _forgetNextPageLoading: function() {
        this.callBase()
    },
    _getSelectedItemIndices: function(keys) {
        var that = this,
            indices = [];
        keys = keys || this._selection.getSelectedItemKeys();
        $.each(keys, function(_, key) {
            var selectedIndex = that._getIndexByKey(key);
            if (indexExists(selectedIndex)) {
                indices.push(selectedIndex)
            }
        });
        return indices
    },
    _render: function() {
        this._rendering = true;
        if (!this._dataSource || !this._dataSource.isLoading()) {
            this._syncSelectionOptions();
            this._normalizeSelectedItems()
        }
        this.callBase();
        var selectedItemIndices = this._getSelectedItemIndices();
        this._renderSelection(selectedItemIndices, []);
        this._rendering = false
    },
    _fireContentReadyAction: function() {
        this._rendering = false;
        this._rendered = true;
        this.callBase.apply(this, arguments)
    },
    _syncSelectionOptions: function(byOption) {
        byOption = byOption || this._chooseSelectOption();
        var selectedItem, selectedItems, selectedIndex;
        switch (byOption) {
            case "selectedIndex":
                selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
                if (commonUtils.isDefined(selectedItem)) {
                    this._setOptionSilent("selectedItems", [selectedItem]);
                    this._setOptionSilent("selectedItem", selectedItem);
                    this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                } else {
                    this._setOptionSilent("selectedItems", []);
                    this._setOptionSilent("selectedItemKeys", []);
                    this._setOptionSilent("selectedItem", null)
                }
                break;
            case "selectedItems":
                selectedItems = this.option("selectedItems") || [];
                selectedIndex = this._editStrategy.getIndexByItemData(selectedItems[0]);
                if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                    this._syncSelectionOptions("selectedIndex");
                    return
                }
                this._setOptionSilent("selectedItem", selectedItems[0]);
                this._setOptionSilent("selectedIndex", selectedIndex);
                this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
                break;
            case "selectedItem":
                selectedItem = this.option("selectedItem");
                selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
                if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                    this._syncSelectionOptions("selectedIndex");
                    return
                }
                if (commonUtils.isDefined(selectedItem)) {
                    this._setOptionSilent("selectedItems", [selectedItem]);
                    this._setOptionSilent("selectedIndex", selectedIndex);
                    this._setOptionSilent("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                } else {
                    this._setOptionSilent("selectedItems", []);
                    this._setOptionSilent("selectedItemKeys", []);
                    this._setOptionSilent("selectedIndex", NOT_EXISTING_INDEX)
                }
                break;
            case "selectedItemKeys":
                var selectedItemKeys = this.option("selectedItemKeys");
                if (this.option("selectionRequired") && !indexExists(this._getIndexByKey(selectedItemKeys[0]))) {
                    this._syncSelectionOptions("selectedIndex");
                    return
                }
                this._selection.setSelection(selectedItemKeys)
        }
    },
    _chooseSelectOption: function() {
        var optionName = "selectedIndex";
        var arrayOptionsDefined = function(optionName) {
            var length = this.option(optionName).length;
            return length || !length && optionName in this._userOptions
        }.bind(this);
        if (arrayOptionsDefined("selectedItems")) {
            optionName = "selectedItems"
        } else {
            if (commonUtils.isDefined(this.option("selectedItem"))) {
                optionName = "selectedItem"
            } else {
                if (arrayOptionsDefined("selectedItemKeys")) {
                    optionName = "selectedItemKeys"
                }
            }
        }
        return optionName
    },
    _compareKeys: function(oldKeys, newKeys) {
        if (oldKeys.length !== newKeys.length) {
            return false
        }
        for (var i = 0; i < newKeys.length; i++) {
            if (oldKeys[i] !== newKeys[i]) {
                return false
            }
        }
        return true
    },
    _normalizeSelectedItems: function() {
        if ("none" === this.option("selectionMode")) {
            this._setOptionSilent("selectedItems", []);
            this._syncSelectionOptions("selectedItems")
        } else {
            if ("single" === this.option("selectionMode")) {
                var newSelection = this.option("selectedItems");
                if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                    var currentSelection = this._selection.getSelectedItems();
                    var normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
                    if (void 0 === normalizedSelection) {
                        normalizedSelection = this._editStrategy.itemsGetter()[0]
                    }
                    if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
                        normalizedSelection.items = [normalizedSelection.items[0]]
                    }
                    this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
                    this._setOptionSilent("selectedItems", [normalizedSelection]);
                    this._syncSelectionOptions("selectedItems")
                } else {
                    this._selection.setSelection(this._getKeysByItems(newSelection))
                }
            } else {
                var newKeys = this._getKeysByItems(this.option("selectedItems"));
                var oldKeys = this._selection.getSelectedItemKeys();
                if (!this._compareKeys(oldKeys, newKeys)) {
                    this._selection.setSelection(newKeys)
                }
            }
        }
    },
    _renderSelection: commonUtils.noop,
    _itemClickHandler: function(e) {
        this._createAction(function(e) {
            this._itemSelectHandler(e.jQueryEvent)
        }.bind(this), {
            validatingTargetName: "itemElement"
        })({
            itemElement: $(e.currentTarget),
            jQueryEvent: e
        });
        this.callBase.apply(this, arguments)
    },
    _itemSelectHandler: function(e) {
        if (!this.option("selectionByClick")) {
            return
        }
        var $itemElement = e.currentTarget;
        if (this.isItemSelected($itemElement)) {
            this.unselectItem(e.currentTarget)
        } else {
            this.selectItem(e.currentTarget)
        }
    },
    _selectedItemElement: function(index) {
        return this._itemElements().eq(index)
    },
    _postprocessRenderItem: function(args) {
        if ("none" === this.option("selectionMode")) {
            return
        }
        var $itemElement = $(args.itemElement);
        if (this._isItemSelected(this._editStrategy.getNormalizedIndex($itemElement))) {
            $itemElement.addClass(this._selectedItemClass());
            this._setAriaSelected($itemElement, "true")
        } else {
            this._setAriaSelected($itemElement, "false")
        }
    },
    _updateSelectedItems: function(addedItems, removedItems) {
        var that = this;
        if (that._rendered && (addedItems.length || removedItems.length)) {
            var selectionChangePromise = that._selectionChangePromise;
            if (!that._rendering) {
                var normalizedIndex, i, addedSelection = [],
                    removedSelection = [];
                for (i = 0; i < addedItems.length; i++) {
                    normalizedIndex = that._getIndexByItemData(addedItems[i]);
                    addedSelection.push(normalizedIndex);
                    that._addSelection(normalizedIndex)
                }
                for (i = 0; i < removedItems.length; i++) {
                    normalizedIndex = that._getIndexByItemData(removedItems[i]);
                    removedSelection.push(normalizedIndex);
                    that._removeSelection(normalizedIndex)
                }
                that._updateSelection(addedSelection, removedSelection)
            }
            when(selectionChangePromise).done(function() {
                that._fireSelectionChangeEvent(addedItems, removedItems)
            })
        }
    },
    _fireSelectionChangeEvent: function(addedItems, removedItems) {
        this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })({
            addedItems: addedItems,
            removedItems: removedItems
        })
    },
    _updateSelection: function() {
        this._renderSelection.apply(this, arguments)
    },
    _setAriaSelected: function($target, value) {
        this.setAria("selected", value, $target)
    },
    _removeSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
            $itemElement.removeClass(this._selectedItemClass());
            this._setAriaSelected($itemElement, "false");
            $itemElement.triggerHandler("stateChanged", false)
        }
    },
    _showDeprecatedSelectionMode: function() {
        errors.log("W0001", this.NAME, "selectionMode: 'multi'", "16.1", "Use selectionMode: 'multiple' instead");
        this.option("selectionMode", "multiple")
    },
    _addSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
            $itemElement.addClass(this._selectedItemClass());
            this._setAriaSelected($itemElement, "true");
            $itemElement.triggerHandler("stateChanged", true)
        }
    },
    _isItemSelected: function(index) {
        var key = this._getKeyByIndex(index);
        return this._selection.isItemSelected(key)
    },
    _optionChanged: function(args) {
        if (this._cancelOptionChange === args.name) {
            return
        }
        switch (args.name) {
            case "selectionMode":
                if ("multi" === args.value) {
                    this._showDeprecatedSelectionMode()
                } else {
                    this._invalidate()
                }
                break;
            case "selectedIndex":
            case "selectedItem":
            case "selectedItems":
            case "selectedItemKeys":
                this._syncSelectionOptions(args.name);
                this._normalizeSelectedItems();
                break;
            case "keyExpr":
                this._initKeyGetter();
                break;
            case "selectionRequired":
                this._normalizeSelectedItems();
                break;
            case "selectionByClick":
            case "onSelectionChanged":
            case "onItemDeleting":
            case "onItemDeleted":
            case "onItemReordered":
            case "maxFilterLengthInRequest":
                break;
            default:
                this.callBase(args)
        }
    },
    _clearSelectedItems: function() {
        this._setOptionSilent("selectedItems", []);
        this._syncSelectionOptions("selectedItems")
    },
    _setOptionSilent: function(name, value) {
        this._cancelOptionChange = name;
        this.option(name, value);
        this._cancelOptionChange = false
    },
    _waitDeletingPrepare: function($itemElement) {
        if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
            return $.Deferred().resolve().promise()
        }
        $itemElement.data(ITEM_DELETING_DATA_KEY, true);
        var deferred = $.Deferred(),
            deletingActionArgs = {
                cancel: false
            },
            deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
                excludeValidators: ["disabled", "readOnly"]
            });
        when(deletePromise).always(function(value) {
            var deletePromiseExists = !deletePromise,
                deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state(),
                argumentsSpecified = !!arguments.length,
                shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
            when(deletingActionArgs.cancel).always(function() {
                $itemElement.data(ITEM_DELETING_DATA_KEY, false)
            }).done(function(cancel) {
                shouldDelete && !cancel ? deferred.resolve() : deferred.reject()
            }).fail(deferred.reject)
        }.bind(this));
        return deferred.promise()
    },
    _deleteItemFromDS: function($item) {
        if (!this._dataSource) {
            return $.Deferred().resolve().promise()
        }
        var deferred = $.Deferred(),
            disabledState = this.option("disabled"),
            dataStore = this._dataSource.store();
        this.option("disabled", true);
        if (!dataStore.remove) {
            throw errors.Error("E1011")
        }
        dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
            if (void 0 !== key) {
                deferred.resolve()
            } else {
                deferred.reject()
            }
        }).fail(function() {
            deferred.reject()
        });
        deferred.always(function() {
            this.option("disabled", disabledState)
        }.bind(this));
        return deferred
    },
    _tryRefreshLastPage: function() {
        var deferred = $.Deferred();
        if (this._isLastPage() || this.option("grouped")) {
            deferred.resolve()
        } else {
            this._refreshLastPage().done(function() {
                deferred.resolve()
            })
        }
        return deferred.promise()
    },
    _refreshLastPage: function() {
        this._expectLastItemLoading();
        return this._dataSource.load()
    },
    _updateSelectionAfterDelete: function(index) {
        var key = this._getKeyByIndex(index);
        this._selection.deselect([key])
    },
    _simulateOptionChange: function(optionName) {
        var optionValue = this.option(optionName);
        if (optionValue instanceof DataSource) {
            return
        }
        this._optionChangedAction({
            name: optionName,
            fullName: optionName,
            value: optionValue
        })
    },
    isItemSelected: function(itemElement) {
        return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
    },
    selectItem: function(itemElement) {
        if ("none" === this.option("selectionMode")) {
            return
        }
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
            return
        }
        var key = this._getKeyByIndex(itemIndex);
        if (this._selection.isItemSelected(key)) {
            return
        }
        if ("single" === this.option("selectionMode")) {
            this._selection.setSelection([key])
        } else {
            var selectedItemKeys = this.option("selectedItemKeys");
            selectedItemKeys.push(key);
            this._selection.setSelection(selectedItemKeys)
        }
    },
    unselectItem: function(itemElement) {
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
            return
        }
        var selectedItemKeys = this._selection.getSelectedItemKeys();
        if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
            return
        }
        var key = this._getKeyByIndex(itemIndex);
        this._selection.deselect([key])
    },
    deleteItem: function(itemElement) {
        var that = this,
            deferred = $.Deferred(),
            $item = this._editStrategy.getItemElement(itemElement),
            index = this._editStrategy.getNormalizedIndex(itemElement),
            changingOption = this._dataSource ? "dataSource" : "items",
            itemResponseWaitClass = this._itemResponseWaitClass();
        if (indexExists(index)) {
            this._waitDeletingPrepare($item).done(function() {
                $item.addClass(itemResponseWaitClass);
                var deletedActionArgs = that._extendActionArgs($item);
                that._deleteItemFromDS($item).done(function() {
                    that._updateSelectionAfterDelete(index);
                    that._editStrategy.deleteItemAtIndex(index);
                    that._simulateOptionChange(changingOption);
                    that._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
                        beforeExecute: function() {
                            $item.detach()
                        },
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    that._renderEmptyMessage();
                    that._tryRefreshLastPage().done(function() {
                        deferred.resolveWith(that)
                    })
                }).fail(function() {
                    $item.removeClass(itemResponseWaitClass);
                    deferred.rejectWith(that)
                })
            }).fail(function() {
                deferred.rejectWith(that)
            })
        } else {
            deferred.rejectWith(that)
        }
        return deferred.promise()
    },
    reorderItem: function(itemElement, toItemElement) {
        var deferred = $.Deferred(),
            that = this,
            strategy = this._editStrategy,
            $movingItem = strategy.getItemElement(itemElement),
            $destinationItem = strategy.getItemElement(toItemElement),
            movingIndex = strategy.getNormalizedIndex(itemElement),
            destinationIndex = strategy.getNormalizedIndex(toItemElement),
            changingOption = this._dataSource ? "dataSource" : "items";
        var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
        if (canMoveItems) {
            deferred.resolveWith(this)
        } else {
            deferred.rejectWith(this)
        }
        return deferred.promise().done(function() {
            $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
            strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
            that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
            if ("items" === changingOption) {
                that._simulateOptionChange(changingOption)
            }
            that._itemEventHandler($movingItem, "onItemReordered", {
                fromIndex: strategy.getIndex(movingIndex),
                toIndex: strategy.getIndex(destinationIndex)
            }, {
                excludeValidators: ["disabled", "readOnly"]
            })
        })
    }
});
module.exports = CollectionWidget;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/variable_wrapper.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var logger = __webpack_require__(83).logger,
    dependencyInjector = __webpack_require__(72);
module.exports = dependencyInjector({
    isWrapped: function() {
        return false
    },
    isWritableWrapped: function() {
        return false
    },
    wrap: function(value) {
        return value
    },
    unwrap: function(value) {
        return value
    },
    assign: function() {
        logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.")
    }
});


/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = window.ko;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/utils.ink_ripple.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var INKRIPPLE_CLASS = "dx-inkripple",
    INKRIPPLE_WAVE_CLASS = "dx-inkripple-wave",
    INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing",
    INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
var DEFAULT_WAVE_SIZE_COEFFICIENT = 2,
    MAX_WAVE_SIZE = 4e3,
    ANIMATION_DURATION = 300,
    HOLD_ANIMATION_DURATION = 1e3,
    DEFAULT_WAVE_INDEX = 0;
var render = function(args) {
    args = args || {};
    if (void 0 === args.useHoldAnimation) {
        args.useHoldAnimation = true
    }
    var config = {
        waveSizeCoefficient: args.waveSizeCoefficient || DEFAULT_WAVE_SIZE_COEFFICIENT,
        isCentered: args.isCentered || false,
        wavesNumber: args.wavesNumber || 1,
        durations: getDurations(args.useHoldAnimation)
    };
    return {
        showWave: showWave.bind(this, config),
        hideWave: hideWave.bind(this, config)
    }
};
var getInkRipple = function(element) {
    var result = element.children("." + INKRIPPLE_CLASS);
    if (0 === result.length) {
        result = $("<div>").addClass(INKRIPPLE_CLASS).appendTo(element)
    }
    return result
};
var getWaves = function(element, wavesNumber) {
    var inkRipple = getInkRipple(element),
        result = inkRipple.children("." + INKRIPPLE_WAVE_CLASS).toArray();
    for (var i = result.length; i < wavesNumber; i++) {
        var $currentWave = $("<div>").appendTo(inkRipple).addClass(INKRIPPLE_WAVE_CLASS);
        result.push($currentWave[0])
    }
    return $(result)
};
var getWaveStyleConfig = function(args, config) {
    var left, top, element = config.element,
        elementWidth = element.outerWidth(),
        elementHeight = element.outerHeight(),
        elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight)),
        waveSize = Math.min(MAX_WAVE_SIZE, parseInt(elementDiagonal * args.waveSizeCoefficient));
    if (args.isCentered) {
        left = (elementWidth - waveSize) / 2;
        top = (elementHeight - waveSize) / 2
    } else {
        var event = config.jQueryEvent,
            position = config.element.offset(),
            x = event.pageX - position.left,
            y = event.pageY - position.top;
        left = x - waveSize / 2;
        top = y - waveSize / 2
    }
    return {
        left: left,
        top: top,
        height: waveSize,
        width: waveSize
    }
};
var showWave = function(args, config) {
    var $wave = getWaves(config.element, args.wavesNumber).eq(config.wave || DEFAULT_WAVE_INDEX);
    args.hidingTimeout && clearTimeout(args.hidingTimeout);
    hideSelectedWave($wave);
    $wave.css(getWaveStyleConfig(args, config));
    setTimeout(showingWaveHandler.bind(this, args, $wave), 0)
};
var showingWaveHandler = function(args, $wave) {
    var durationCss = args.durations.showingScale + "ms";
    $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transition-duration", durationCss)
};
var getDurations = function(useHoldAnimation) {
    return {
        showingScale: useHoldAnimation ? HOLD_ANIMATION_DURATION : ANIMATION_DURATION,
        hidingScale: ANIMATION_DURATION,
        hidingOpacity: ANIMATION_DURATION
    }
};
var hideSelectedWave = function($wave) {
    $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transition-duration", "")
};
var hideWave = function(args, config) {
    var $wave = getWaves(config.element, config.wavesNumber).eq(config.wave || DEFAULT_WAVE_INDEX),
        durations = args.durations,
        durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
    $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transition-duration", durationCss);
    var animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
    args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration)
};
module.exports = {
    render: render
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/number.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    dependencyInjector = __webpack_require__(72),
    inArray = __webpack_require__(7).inArray,
    isPlainObject = __webpack_require__(9).isPlainObject,
    errors = __webpack_require__(13);
var MAX_LARGE_NUMBER_POWER = 4,
    DECIMAL_BASE = 10;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
    1: "K",
    2: "M",
    3: "B",
    4: "T"
};
var LargeNumberFormatPowers = {
    largenumber: "auto",
    thousands: 1,
    millions: 2,
    billions: 3,
    trillions: 4
};
var numberLocalization = dependencyInjector({
    numericFormats: NUMERIC_FORMATS,
    defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
    _parseNumberFormatString: function(formatType) {
        var formatList, formatObject = {};
        if (!formatType || "string" !== typeof formatType) {
            return
        }
        formatList = formatType.split(" ");
        $.each(formatList, function(index, value) {
            if (inArray(value, NUMERIC_FORMATS) > -1) {
                formatObject.formatType = value
            } else {
                if (value in LargeNumberFormatPowers) {
                    formatObject.power = LargeNumberFormatPowers[value]
                }
            }
        });
        if (formatObject.power && !formatObject.formatType) {
            formatObject.formatType = "fixedpoint"
        }
        if (formatObject.formatType) {
            return formatObject
        }
    },
    _calculateNumberPower: function(value, base, minPower, maxPower) {
        var number = Math.abs(value),
            power = 0;
        if (number > 1) {
            while (number && number >= base && (void 0 === maxPower || power < maxPower)) {
                power++;
                number /= base
            }
        } else {
            if (number > 0 && number < 1) {
                while (number < 1 && (void 0 === minPower || power > minPower)) {
                    power--;
                    number *= base
                }
            }
        }
        return power
    },
    _getNumberByPower: function(number, power, base) {
        var result = number;
        while (power > 0) {
            result /= base;
            power--
        }
        while (power < 0) {
            result *= base;
            power++
        }
        return result
    },
    _formatNumber: function(value, formatObject, formatConfig) {
        var powerPostfix;
        var result;
        if ("auto" === formatObject.power) {
            formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER)
        }
        if (formatObject.power) {
            value = this._getNumberByPower(value, formatObject.power, 1e3)
        }
        powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
        result = this._formatNumberCore(value, formatObject.formatType, formatConfig);
        result = result.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
        return result
    },
    _formatNumberExponential: function(value, formatConfig) {
        var powString, power = this._calculateNumberPower(value, DECIMAL_BASE),
            number = this._getNumberByPower(value, power, DECIMAL_BASE);
        if (void 0 === formatConfig.precision) {
            formatConfig.precision = 1
        }
        if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
            power++;
            number /= DECIMAL_BASE
        }
        powString = (power >= 0 ? "+" : "") + power.toString();
        return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString
    },
    _addZeroes: function(value, precision) {
        var multiplier = Math.pow(10, precision);
        value = (value * multiplier >>> 0) / multiplier;
        var result = value.toString();
        while (result.length < precision) {
            result = "0" + result
        }
        return result
    },
    _addGroupSeparators: function(value) {
        var parts = value.toString().split(".");
        return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",") + (parts[1] ? "." + parts[1] : "")
    },
    _formatNumberCore: function(value, format, formatConfig) {
        if ("exponential" === format) {
            return this._formatNumberExponential(value, formatConfig)
        }
        if ("decimal" !== format && null !== formatConfig.precision) {
            formatConfig.precision = formatConfig.precision || 0
        }
        if ("percent" === format) {
            value = 100 * value
        }
        if (void 0 !== formatConfig.precision) {
            if ("decimal" === format) {
                value = this._addZeroes(value, formatConfig.precision)
            } else {
                value = null === formatConfig.precision ? value.toPrecision() : value.toFixed(formatConfig.precision)
            }
        }
        if ("decimal" !== format) {
            value = this._addGroupSeparators(value)
        }
        if ("percent" === format) {
            value += "%"
        }
        return value.toString()
    },
    _normalizeFormat: function(format) {
        if (!format) {
            return {}
        }
        if ("function" === typeof format) {
            return format
        }
        if (!isPlainObject(format)) {
            format = {
                type: format
            }
        }
        if (format.type) {
            format.type = format.type.toLowerCase()
        }
        return format
    },
    format: function(value, format) {
        if ("number" !== typeof value) {
            return value
        }
        if ("number" === typeof format) {
            return value
        }
        format = format && format.formatter || format;
        if ("function" === typeof format) {
            return format(value)
        }
        format = this._normalizeFormat(format);
        if (!format.type) {
            format.type = "decimal"
        }
        var numberConfig = this._parseNumberFormatString(format.type);
        if (!numberConfig) {
            return
        }
        return this._formatNumber(value, numberConfig, format)
    },
    parse: function(text, format) {
        if (!text) {
            return
        }
        if (format && format.parser) {
            return format.parser(text)
        }
        if (format) {
            errors.log("W0011")
        }
        return parseFloat(text.replace(/^\D+|,+/g, ""))
    }
});
module.exports = numberLocalization;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/dom_component.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    config = __webpack_require__(31),
    errors = __webpack_require__(13),
    windowResizeCallbacks = __webpack_require__(61).resizeCallbacks,
    commonUtils = __webpack_require__(2),
    inArray = __webpack_require__(7).inArray,
    publicComponentUtils = __webpack_require__(73),
    Component = __webpack_require__(106),
    abstract = Component.abstract;
var RTL_DIRECTION_CLASS = "dx-rtl",
    VISIBILITY_CHANGE_CLASS = "dx-visibility-change-handler",
    VISIBILITY_CHANGE_EVENTNAMESPACE = "VisibilityChange";
var DOMComponent = Component.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            width: void 0,
            height: void 0,
            rtlEnabled: config().rtlEnabled,
            elementAttr: {},
            disabled: false,
            integrationOptions: {}
        })
    },
    ctor: function(element, options) {
        this._$element = $(element);
        publicComponentUtils.attachInstanceToElement(this._$element, this, this._dispose);
        this.callBase(options)
    },
    _visibilityChanged: abstract,
    _dimensionChanged: abstract,
    _init: function() {
        this.callBase();
        this._attachWindowResizeCallback()
    },
    _setOptionsByDevice: function(instanceCustomRules) {
        this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []))
    },
    _isInitialOptionValue: function(name) {
        var isCustomOption = this.constructor._classCustomRules && this._convertRulesToOptions(this.constructor._classCustomRules).hasOwnProperty(name);
        return !isCustomOption && this.callBase(name)
    },
    _attachWindowResizeCallback: function() {
        if (this._isDimensionChangeSupported()) {
            var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
            windowResizeCallbacks.add(windowResizeCallBack)
        }
    },
    _isDimensionChangeSupported: function() {
        return this._dimensionChanged !== abstract
    },
    _render: function() {
        this._renderElementAttributes();
        this._toggleRTLDirection(this.option("rtlEnabled"));
        this._renderVisibilityChange();
        this._renderDimensions()
    },
    _renderElementAttributes: function() {
        var attributes = extend({}, this.option("elementAttr")),
            classNames = attributes.class;
        delete attributes.class;
        this.element().attr(attributes).addClass(classNames)
    },
    _renderVisibilityChange: function() {
        if (this._isDimensionChangeSupported()) {
            this._attachDimensionChangeHandlers()
        }
        if (!this._isVisibilityChangeSupported()) {
            return
        }
        this.element().addClass(VISIBILITY_CHANGE_CLASS);
        this._attachVisibilityChangeHandlers()
    },
    _renderDimensions: function() {
        var width = this.option("width"),
            height = this.option("height"),
            $element = this.element();
        $element.outerWidth(width);
        $element.outerHeight(height)
    },
    _attachDimensionChangeHandlers: function() {
        var that = this;
        var resizeEventName = "dxresize." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
        that.element().off(resizeEventName).on(resizeEventName, function() {
            that._dimensionChanged()
        })
    },
    _attachVisibilityChangeHandlers: function() {
        var that = this;
        var hidingEventName = "dxhiding." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
        var shownEventName = "dxshown." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
        that._isHidden = !that._isVisible();
        that.element().off(hidingEventName).on(hidingEventName, function() {
            that._checkVisibilityChanged("hiding")
        }).off(shownEventName).on(shownEventName, function() {
            that._checkVisibilityChanged("shown")
        })
    },
    _isVisible: function() {
        return this.element().is(":visible")
    },
    _checkVisibilityChanged: function(event) {
        if ("hiding" === event && this._isVisible() && !this._isHidden) {
            this._visibilityChanged(false);
            this._isHidden = true
        } else {
            if ("shown" === event && this._isVisible() && this._isHidden) {
                this._isHidden = false;
                this._visibilityChanged(true)
            }
        }
    },
    _isVisibilityChangeSupported: function() {
        return this._visibilityChanged !== abstract
    },
    _clean: commonUtils.noop,
    _modelByElement: function() {
        var modelByElement = this.option("modelByElement") || commonUtils.noop;
        return modelByElement(this.element())
    },
    _invalidate: function() {
        if (!this._updateLockCount) {
            throw errors.Error("E0007")
        }
        this._requireRefresh = true
    },
    _refresh: function() {
        this._clean();
        this._render()
    },
    _dispose: function() {
        this.callBase();
        this._clean();
        this._detachWindowResizeCallback()
    },
    _detachWindowResizeCallback: function() {
        if (this._isDimensionChangeSupported()) {
            windowResizeCallbacks.remove(this._windowResizeCallBack)
        }
    },
    _toggleRTLDirection: function(rtl) {
        this.element().toggleClass(RTL_DIRECTION_CLASS, rtl)
    },
    _createComponent: function(element, component, config) {
        var that = this;
        config = config || {};
        var synchronizableOptions = commonUtils.grep(["rtlEnabled", "disabled"], function(value) {
            return !(value in config)
        });
        var nestedComponentOptions = that.option("nestedComponentOptions") || commonUtils.noop;
        that._extendConfig(config, extend({
            integrationOptions: this.option("integrationOptions"),
            rtlEnabled: this.option("rtlEnabled"),
            disabled: this.option("disabled")
        }, nestedComponentOptions(this)));
        var instance;
        if (commonUtils.isString(component)) {
            var $element = $(element)[component](config);
            instance = $element[component]("instance")
        } else {
            if (element) {
                instance = component.getInstance(element);
                if (instance) {
                    instance.option(config)
                } else {
                    instance = new component(element, config)
                }
            }
        }
        if (instance) {
            var optionChangedHandler = function(args) {
                if (inArray(args.name, synchronizableOptions) >= 0) {
                    instance.option(args.name, args.value)
                }
            };
            that.on("optionChanged", optionChangedHandler);
            instance.on("disposing", function() {
                that.off("optionChanged", optionChangedHandler)
            })
        }
        return instance
    },
    _extendConfig: function(config, extendConfig) {
        $.each(extendConfig, function(key, value) {
            config[key] = config.hasOwnProperty(key) ? config[key] : value
        })
    },
    _defaultActionConfig: function() {
        return extend(this.callBase(), {
            context: this._modelByElement(this.element())
        })
    },
    _defaultActionArgs: function() {
        var element = this.element(),
            model = this._modelByElement(this.element());
        return extend(this.callBase(), {
            element: element,
            model: model
        })
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "width":
            case "height":
                this._renderDimensions();
                break;
            case "rtlEnabled":
            case "elementAttr":
                this._invalidate();
                break;
            case "disabled":
            case "integrationOptions":
                break;
            default:
                this.callBase(args)
        }
    },
    endUpdate: function() {
        var requireRender = !this._initializing && !this._initialized;
        this.callBase.apply(this, arguments);
        if (!this._updateLockCount) {
            if (requireRender) {
                this._render()
            } else {
                if (this._requireRefresh) {
                    this._requireRefresh = false;
                    this._refresh()
                }
            }
        }
    },
    element: function() {
        return this._$element
    }
});
DOMComponent.getInstance = function($element) {
    return publicComponentUtils.getInstanceByElement($($element), this)
};
DOMComponent.defaultOptions = function(rule) {
    this._classCustomRules = this._classCustomRules || [];
    this._classCustomRules.push(rule)
};
module.exports = DOMComponent;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/position.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    stringUtils = __webpack_require__(30),
    extend = __webpack_require__(1).extend,
    translator = __webpack_require__(19),
    support = __webpack_require__(24);
var horzRe = /left|right/,
    vertRe = /top|bottom/,
    collisionRe = /fit|flip|none/;
var normalizeAlign = function(raw) {
    var result = {
        h: "center",
        v: "center"
    };
    var pair = commonUtils.splitPair(raw);
    if (pair) {
        $.each(pair, function() {
            var w = String(this).toLowerCase();
            if (horzRe.test(w)) {
                result.h = w
            } else {
                if (vertRe.test(w)) {
                    result.v = w
                }
            }
        })
    }
    return result
};
var normalizeOffset = function(raw) {
    return stringUtils.pairToObject(raw)
};
var normalizeCollision = function(raw) {
    var pair = commonUtils.splitPair(raw),
        h = String(pair && pair[0]).toLowerCase(),
        v = String(pair && pair[1]).toLowerCase();
    if (!collisionRe.test(h)) {
        h = "none"
    }
    if (!collisionRe.test(v)) {
        v = h
    }
    return {
        h: h,
        v: v
    }
};
var getAlignFactor = function(align) {
    switch (align) {
        case "center":
            return .5;
        case "right":
        case "bottom":
            return 1;
        default:
            return 0
    }
};
var inverseAlign = function(align) {
    switch (align) {
        case "left":
            return "right";
        case "right":
            return "left";
        case "top":
            return "bottom";
        case "bottom":
            return "top";
        default:
            return align
    }
};
var calculateOversize = function(data, bounds) {
    var oversize = 0;
    if (data.myLocation < bounds.min) {
        oversize += bounds.min - data.myLocation
    }
    if (data.myLocation > bounds.max) {
        oversize += data.myLocation - bounds.max
    }
    return oversize
};
var collisionSide = function(direction, data, bounds) {
    if (data.myLocation < bounds.min) {
        return "h" === direction ? "left" : "top"
    }
    if (data.myLocation > bounds.max) {
        return "h" === direction ? "right" : "bottom"
    }
    return "none"
};
var initMyLocation = function(data) {
    data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
};
var collisionResolvers = {
    fit: function(data, bounds) {
        var result = false;
        if (data.myLocation > bounds.max) {
            data.myLocation = bounds.max;
            result = true
        }
        if (data.myLocation < bounds.min) {
            data.myLocation = bounds.min;
            result = true
        }
        data.fit = result
    },
    flip: function(data, bounds) {
        data.flip = false;
        if ("center" === data.myAlign && "center" === data.atAlign) {
            return
        }
        if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
            var inverseData = extend({}, data, {
                myAlign: inverseAlign(data.myAlign),
                atAlign: inverseAlign(data.atAlign),
                offset: -data.offset
            });
            initMyLocation(inverseData);
            inverseData.oversize = calculateOversize(inverseData, bounds);
            if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
                data.myLocation = inverseData.myLocation;
                data.oversize = inverseData.oversize;
                data.flip = true
            }
        }
    },
    flipfit: function(data, bounds) {
        this.flip(data, bounds);
        this.fit(data, bounds)
    },
    none: function(data) {
        data.oversize = 0
    }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
    var $scrollDiv = $("<div>").css({
            width: 100,
            height: 100,
            overflow: "scroll",
            position: "absolute",
            top: -9999
        }).appendTo($("body")),
        result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
    $scrollDiv.remove();
    scrollbarWidth = result
};
var defaultPositionResult = {
    h: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
    },
    v: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
    }
};
var calculatePosition = function(what, options) {
    var $what = $(what),
        currentOffset = $what.offset(),
        result = extend(true, {}, defaultPositionResult, {
            h: {
                location: currentOffset.left
            },
            v: {
                location: currentOffset.top
            }
        });
    if (!options) {
        return result
    }
    var my = normalizeAlign(options.my),
        at = normalizeAlign(options.at),
        of = options.of || window,
        offset = normalizeOffset(options.offset),
        collision = normalizeCollision(options.collision),
        boundary = options.boundary,
        boundaryOffset = normalizeOffset(options.boundaryOffset);
    var h = {
        mySize: $what.outerWidth(),
        myAlign: my.h,
        atAlign: at.h,
        offset: offset.h,
        collision: collision.h,
        boundaryOffset: boundaryOffset.h
    };
    var v = {
        mySize: $what.outerHeight(),
        myAlign: my.v,
        atAlign: at.v,
        offset: offset.v,
        collision: collision.v,
        boundaryOffset: boundaryOffset.v
    };
    if ( of .preventDefault) {
        h.atLocation = of .pageX;
        v.atLocation = of .pageY;
        h.atSize = 0;
        v.atSize = 0
    } else { of = $( of );
        if (commonUtils.isWindow( of [0])) {
            h.atLocation = of .scrollLeft();
            v.atLocation = of .scrollTop();
            h.atSize = of [0].innerWidth > of [0].outerWidth ? of [0].innerWidth : of .width();
            v.atSize = of [0].innerHeight > of [0].outerHeight ? of [0].innerHeight : of .height()
        } else {
            if (9 === of [0].nodeType) {
                h.atLocation = 0;
                v.atLocation = 0;
                h.atSize = of .width();
                v.atSize = of .height()
            } else {
                var o = of .offset();
                h.atLocation = o.left;
                v.atLocation = o.top;
                h.atSize = of .outerWidth();
                v.atSize = of .outerHeight()
            }
        }
    }
    initMyLocation(h);
    initMyLocation(v);
    var bounds = function() {
        var win = $(window),
            windowWidth = win.width(),
            windowHeight = win.height(),
            left = win.scrollLeft(),
            top = win.scrollTop(),
            hScrollbar = document.width > document.documentElement.clientWidth,
            vScrollbar = document.height > document.documentElement.clientHeight,
            hZoomLevel = support.touch ? document.documentElement.clientWidth / (vScrollbar ? windowWidth - scrollbarWidth : windowWidth) : 1,
            vZoomLevel = support.touch ? document.documentElement.clientHeight / (hScrollbar ? windowHeight - scrollbarWidth : windowHeight) : 1;
        if (void 0 === scrollbarWidth) {
            calculateScrollbarWidth()
        }
        var boundaryWidth = windowWidth,
            boundaryHeight = windowHeight;
        if (boundary) {
            var $boundary = $(boundary),
                boundaryPosition = $boundary.offset();
            left = boundaryPosition.left;
            top = boundaryPosition.top;
            boundaryWidth = $boundary.width();
            boundaryHeight = $boundary.height()
        }
        return {
            h: {
                min: left + h.boundaryOffset,
                max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
            },
            v: {
                min: top + v.boundaryOffset,
                max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
            }
        }
    }();
    h.oversize = calculateOversize(h, bounds.h);
    v.oversize = calculateOversize(v, bounds.v);
    h.collisionSide = collisionSide("h", h, bounds.h);
    v.collisionSide = collisionSide("v", v, bounds.v);
    if (collisionResolvers[h.collision]) {
        collisionResolvers[h.collision](h, bounds.h)
    }
    if (collisionResolvers[v.collision]) {
        collisionResolvers[v.collision](v, bounds.v)
    }
    var preciser = function(number) {
        return options.precise ? number : Math.round(number)
    };
    extend(true, result, {
        h: {
            location: preciser(h.myLocation),
            oversize: preciser(h.oversize),
            fit: h.fit,
            flip: h.flip,
            collisionSide: h.collisionSide
        },
        v: {
            location: preciser(v.myLocation),
            oversize: preciser(v.oversize),
            fit: v.fit,
            flip: v.flip,
            collisionSide: v.collisionSide
        },
        precise: options.precise
    });
    return result
};
var position = function(what, options) {
    var $what = $(what);
    if (!options) {
        return $what.offset()
    }
    translator.resetPosition($what);
    var offset = $what.offset(),
        targetPosition = options.h && options.v ? options : calculatePosition($what, options);
    var preciser = function(number) {
        return options.precise ? number : Math.round(number)
    };
    translator.move($what, {
        left: targetPosition.h.location - preciser(offset.left),
        top: targetPosition.v.location - preciser(offset.top)
    });
    return targetPosition
};
var offset = function(element) {
    element = $(element).get(0);
    if (commonUtils.isWindow(element)) {
        return null
    } else {
        if (element instanceof $.Event) {
            return {
                top: element.pageY,
                left: element.pageX
            }
        }
    }
    return $(element).offset()
};
if (!position.inverseAlign) {
    position.inverseAlign = inverseAlign
}
if (!position.normalizeAlign) {
    position.normalizeAlign = normalizeAlign
}
module.exports = {
    calculateScrollbarWidth: calculateScrollbarWidth,
    calculate: calculatePosition,
    setup: position,
    offset: offset
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/event_registrator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    MemorizedCallbacks = __webpack_require__(165);
var callbacks = new MemorizedCallbacks;
var registerEvent = function(name, eventObject) {
    var strategy = {};
    if ("noBubble" in eventObject) {
        strategy.noBubble = eventObject.noBubble
    }
    if ("bindType" in eventObject) {
        strategy.bindType = eventObject.bindType
    }
    if ("delegateType" in eventObject) {
        strategy.delegateType = eventObject.delegateType
    }
    $.each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
        if (!eventObject[methodName]) {
            return
        }
        strategy[methodName] = function() {
            var args = $.makeArray(arguments);
            args.unshift(this);
            return eventObject[methodName].apply(eventObject, args)
        }
    });
    callbacks.fire(name, strategy)
};
registerEvent.callbacks = callbacks;
var registerJQueryEvent = function(name, eventObject) {
    $.event.special[name] = eventObject
};
callbacks.add(registerJQueryEvent);
module.exports = registerEvent;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/errors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errorUtils = __webpack_require__(102),
    errors = __webpack_require__(13);
module.exports = errorUtils(errors.ERROR_MESSAGES, {
    E3001: "Routing rule is not found for the '{0}' URI.",
    E3002: "The passed object cannot be formatted into a URI string by the application's router. An appropriate route should be registered.",
    E3003: "Unable to navigate. Application is being initialized.",
    E3004: "Cannot execute the command: {0}.",
    E3005: "The '{0}' command {1} is not registered in the application's command mapping. Go to http://dxpr.es/1bTjfj1 for more details.",
    E3006: "Unknown navigation target: '{0}'. Use the 'current', 'back' or 'blank' values.",
    E3007: "Error while restoring the application state. The state has been cleared. Refresh the page.",
    E3008: "Unable to go back.",
    E3009: "Unable to go forward.",
    E3010: "The command's 'id' option should be specified.\r\nProcessed markup: {0}\n",
    E3011: "Layout controller cannot be resolved. There are no appropriate layout controllers for the current context. Check browser console for details.",
    E3012: "Layout controller cannot be resolved. Two or more layout controllers suit the current context. Check browser console for details.",
    E3013: "The '{0}' template with the '{1}' name is not found. Make sure the case is correct in the specified view name and the template fits the current context.",
    E3014: "All the children of the dxView element should be either of the dxCommand or dxContent type.\r\nProcessed markup: {0}",
    E3015: "The 'exec' method should be called before the 'finalize' method.",
    E3016: "Unknown transition type '{0}'.",
    E3018: "Unable to parse options.\nMessage: {0};\nOptions value: {1}.",
    E3019: "View templates should be updated according to the 13.1 changes. Go to http://dxpr.es/15ikrJA for more details.",
    E3020: "Concurrent templates are found:\r\n{0}Target device:\r\n{1}.",
    E3021: "Remote template cannot be loaded.\r\nUrl:{0}\r\nError:{1}.",
    E3022: "Cannot initialize the HtmlApplication component.",
    E3023: "Navigation item is not found",
    E3024: "Layout controller is not initialized",
    W3001: "A view with the '{0}' key doesn't exist.",
    W3002: "A view with the '{0}' key has already been released.",
    W3003: "Layout resolving context:\n{0}\nAvailable layout controller registrations:\n{1}\n",
    W3004: "Layout resolving context:\n{0}\nConcurent layout controller registrations for the context:\n{1}\n",
    W3005: 'Direct hash-based navigation is detected in a mobile application. Use data-bind="dxAction: url" instead of href="#url" to avoid navigation issues.\nFound markup:\n{0}\n'
});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/view_engine_components.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errors = __webpack_require__(48),
    domUtils = __webpack_require__(15),
    registerComponent = __webpack_require__(4),
    MarkupComponent = __webpack_require__(142).MarkupComponent;
__webpack_require__(90);
var View = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            name: null,
            title: null
        })
    },
    ctor: function() {
        this._id = domUtils.uniqueId();
        this.callBase.apply(this, arguments)
    },
    _render: function() {
        this.callBase();
        this.element().addClass("dx-view");
        this.element().attr("dx-data-template-id", this._id)
    },
    getId: function() {
        return this._id
    }
});
var Layout = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            name: null
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass("dx-layout")
    }
});
var ViewPlaceholder = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            viewName: null
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass("dx-view-placeholder")
    }
});
var setupTransitionElement = function($element, transitionType, transitionName, contentCssPosition) {
    if ("absolute" === contentCssPosition) {
        $element.addClass("dx-transition-absolute")
    } else {
        $element.addClass("dx-transition-static")
    }
    $element.addClass("dx-transition").addClass("dx-transition-" + transitionName).addClass("dx-transition-" + transitionType).attr("data-dx-transition-type", transitionType).attr("data-dx-transition-name", transitionName)
};
var setupTransitionInnerElement = function($element) {
    $element.addClass("dx-transition-inner-wrapper")
};
var Transition = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            name: null,
            type: void 0,
            animation: "slide"
        })
    },
    _render: function() {
        this.callBase();
        var element = this.element();
        setupTransitionElement(element, this.option("type") || this.option("animation"), this.option("name"), "absolute");
        element.wrapInner("<div/>");
        setupTransitionInnerElement(element.children());
        if (this.option("type")) {
            errors.log("W0003", "dxTransition", "type", "15.1", "Use the 'animation' property instead")
        }
    },
    _clean: function() {
        this.callBase();
        this.element().empty()
    }
});
var ContentPlaceholder = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            name: null,
            transition: void 0,
            animation: "none",
            contentCssPosition: "absolute"
        })
    },
    _render: function() {
        this.callBase();
        var $element = this.element();
        $element.addClass("dx-content-placeholder").addClass("dx-content-placeholder-" + this.option("name"));
        $element.attr("data-dx-content-placeholder-name", this.option("name"));
        setupTransitionElement($element, this.option("transition") || this.option("animation"), this.option("name"), this.option("contentCssPosition"));
        if (this.option("transition")) {
            errors.log("W0003", "dxContentPlaceholder", "transition", "15.1", "Use the 'animation' property instead")
        }
    }
});
var Content = MarkupComponent.inherit({
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            targetPlaceholder: null
        })
    },
    _optionChanged: function() {
        this._refresh()
    },
    _clean: function() {
        this.callBase();
        this.element().removeClass(this._currentClass)
    },
    _render: function() {
        this.callBase();
        var element = this.element();
        element.addClass("dx-content");
        this._currentClass = "dx-content-" + this.option("targetPlaceholder");
        element.attr("data-dx-target-placeholder-id", this.option("targetPlaceholder"));
        element.addClass(this._currentClass);
        setupTransitionInnerElement(element)
    }
});
registerComponent("dxView", View);
registerComponent("dxLayout", Layout);
registerComponent("dxViewPlaceholder", ViewPlaceholder);
registerComponent("dxContentPlaceholder", ContentPlaceholder);
registerComponent("dxTransition", Transition);
registerComponent("dxContent", Content);
exports.dxView = View;
exports.dxLayout = Layout;
exports.dxViewPlaceholder = ViewPlaceholder;
exports.dxContentPlaceholder = ContentPlaceholder;
exports.dxTransition = Transition;
exports.dxContent = Content;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = window.Globalize;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/data_source/data_source.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    dataUtils = __webpack_require__(28),
    Store = __webpack_require__(96),
    ArrayStore = __webpack_require__(67),
    CustomStore = __webpack_require__(148),
    EventsMixin = __webpack_require__(38),
    errors = __webpack_require__(29).errors,
    array = __webpack_require__(7),
    queue = __webpack_require__(136),
    when = __webpack_require__(10).when,
    __isString = commonUtils.isString,
    __isNumber = commonUtils.isNumeric,
    __isBoolean = commonUtils.isBoolean,
    __isDefined = commonUtils.isDefined;
var CANCELED_TOKEN = "canceled";

function OperationManager() {
    this._counter = -1;
    this._deferreds = {}
}
OperationManager.prototype.constructor = OperationManager;
OperationManager.prototype.add = function(deferred) {
    this._counter += 1;
    this._deferreds[this._counter] = deferred;
    return this._counter
};
OperationManager.prototype.remove = function(operationId) {
    return delete this._deferreds[operationId]
};
OperationManager.prototype.cancel = function(operationId) {
    if (operationId in this._deferreds) {
        this._deferreds[operationId].reject(CANCELED_TOKEN);
        return true
    }
    return false
};
OperationManager.prototype.cancelAll = function() {
    while (this._counter > -1) {
        this.cancel(this._counter);
        this._counter--
    }
};

function isPending(deferred) {
    return "pending" === deferred.state()
}

function normalizeDataSourceOptions(options, normalizationOptions) {
    var store;

    function createCustomStoreFromLoadFunc() {
        var storeConfig = {};
        $.each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
            storeConfig[this] = options[this];
            delete options[this]
        });
        return new CustomStore(storeConfig)
    }

    function createStoreFromConfig(storeConfig) {
        var alias = storeConfig.type;
        delete storeConfig.type;
        return Store.create(alias, storeConfig)
    }

    function createCustomStoreFromUrl(url) {
        return new CustomStore({
            load: function() {
                return $.getJSON(url)
            },
            loadMode: normalizationOptions && normalizationOptions.fromUrlLoadMode
        })
    }
    if ("string" === typeof options) {
        options = {
            paginate: false,
            store: createCustomStoreFromUrl(options)
        }
    }
    if (void 0 === options) {
        options = []
    }
    if (Array.isArray(options) || options instanceof Store) {
        options = {
            store: options
        }
    } else {
        options = extend({}, options)
    }
    if (void 0 === options.store) {
        options.store = []
    }
    store = options.store;
    if ("load" in options) {
        store = createCustomStoreFromLoadFunc()
    } else {
        if (Array.isArray(store)) {
            store = new ArrayStore(store)
        } else {
            if (typeUtils.isPlainObject(store)) {
                store = createStoreFromConfig(extend({}, store))
            }
        }
    }
    options.store = store;
    return options
}

function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
    switch (originalArguments.length) {
        case 0:
            return;
        case 1:
            return originalArguments[0]
    }
    return $.makeArray(originalArguments)
}

function generateStoreLoadOptionAccessor(optionName) {
    return function() {
        var args = normalizeStoreLoadOptionAccessorArguments(arguments);
        if (void 0 === args) {
            return this._storeLoadOptions[optionName]
        }
        this._storeLoadOptions[optionName] = args
    }
}

function mapDataRespectingGrouping(items, mapper, groupInfo) {
    function mapRecursive(items, level) {
        if (!Array.isArray(items)) {
            return items
        }
        return level ? mapGroup(items, level) : $.map(items, mapper)
    }

    function mapGroup(group, level) {
        return $.map(group, function(item) {
            var result = {
                key: item.key,
                items: mapRecursive(item.items, level - 1)
            };
            if ("aggregates" in item) {
                result.aggregates = item.aggregates
            }
            return result
        })
    }
    return mapRecursive(items, groupInfo ? dataUtils.normalizeSortingInfo(groupInfo).length : 0)
}
var DataSource = Class.inherit({
    ctor: function(options) {
        var that = this;
        options = normalizeDataSourceOptions(options);
        this._store = options.store;
        this._storeLoadOptions = this._extractLoadOptions(options);
        this._mapFunc = options.map;
        this._postProcessFunc = options.postProcess;
        this._pageIndex = void 0 !== options.pageIndex ? options.pageIndex : 0;
        this._pageSize = void 0 !== options.pageSize ? options.pageSize : 20;
        this._loadingCount = 0;
        this._loadQueue = this._createLoadQueue();
        this._searchValue = "searchValue" in options ? options.searchValue : null;
        this._searchOperation = options.searchOperation || "contains";
        this._searchExpr = options.searchExpr;
        this._paginate = options.paginate;
        $.each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], function(_, optionName) {
            if (optionName in options) {
                that.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName])
            }
        });
        this._operationManager = new OperationManager;
        this._init()
    },
    _init: function() {
        this._items = [];
        this._userData = {};
        this._totalCount = -1;
        this._isLoaded = false;
        if (!__isDefined(this._paginate)) {
            this._paginate = !this.group()
        }
        this._isLastPage = !this._paginate
    },
    dispose: function() {
        this._disposeEvents();
        delete this._store;
        if (this._delayedLoadTask) {
            this._delayedLoadTask.abort()
        }
        this._operationManager.cancelAll();
        this._disposed = true
    },
    _extractLoadOptions: function(options) {
        var result = {},
            names = ["sort", "filter", "select", "group", "requireTotalCount"],
            customNames = this._store._customLoadOptions();
        if (customNames) {
            names = names.concat(customNames)
        }
        $.each(names, function() {
            result[this] = options[this]
        });
        return result
    },
    loadOptions: function() {
        return this._storeLoadOptions
    },
    items: function() {
        return this._items
    },
    pageIndex: function(newIndex) {
        if (!__isNumber(newIndex)) {
            return this._pageIndex
        }
        this._pageIndex = newIndex;
        this._isLastPage = !this._paginate
    },
    paginate: function(value) {
        if (!__isBoolean(value)) {
            return this._paginate
        }
        if (this._paginate !== value) {
            this._paginate = value;
            this.pageIndex(0)
        }
    },
    pageSize: function(value) {
        if (!__isNumber(value)) {
            return this._pageSize
        }
        this._pageSize = value
    },
    isLastPage: function() {
        return this._isLastPage
    },
    sort: generateStoreLoadOptionAccessor("sort"),
    filter: function() {
        var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
        if (void 0 === newFilter) {
            return this._storeLoadOptions.filter
        }
        this._storeLoadOptions.filter = newFilter;
        this.pageIndex(0)
    },
    group: generateStoreLoadOptionAccessor("group"),
    select: generateStoreLoadOptionAccessor("select"),
    requireTotalCount: function(value) {
        if (!__isBoolean(value)) {
            return this._storeLoadOptions.requireTotalCount
        }
        this._storeLoadOptions.requireTotalCount = value
    },
    searchValue: function(value) {
        if (arguments.length < 1) {
            return this._searchValue
        }
        this._searchValue = value;
        this.pageIndex(0)
    },
    searchOperation: function(op) {
        if (!__isString(op)) {
            return this._searchOperation
        }
        this._searchOperation = op;
        this.pageIndex(0)
    },
    searchExpr: function(expr) {
        var argc = arguments.length;
        if (0 === argc) {
            return this._searchExpr
        }
        if (argc > 1) {
            expr = $.makeArray(arguments)
        }
        this._searchExpr = expr;
        this.pageIndex(0)
    },
    store: function() {
        return this._store
    },
    key: function() {
        return this._store && this._store.key()
    },
    totalCount: function() {
        return this._totalCount
    },
    isLoaded: function() {
        return this._isLoaded
    },
    isLoading: function() {
        return this._loadingCount > 0
    },
    beginLoading: function() {
        this._changeLoadingCount(1)
    },
    endLoading: function() {
        this._changeLoadingCount(-1)
    },
    _createLoadQueue: function() {
        return queue.create()
    },
    _changeLoadingCount: function(increment) {
        var newLoading, oldLoading = this.isLoading();
        this._loadingCount += increment;
        newLoading = this.isLoading();
        if (oldLoading ^ newLoading) {
            this.fireEvent("loadingChanged", [newLoading])
        }
    },
    _scheduleLoadCallbacks: function(deferred) {
        var that = this;
        that.beginLoading();
        deferred.always(function() {
            that.endLoading()
        })
    },
    _scheduleFailCallbacks: function(deferred) {
        var that = this;
        deferred.fail(function() {
            if (arguments[0] === CANCELED_TOKEN) {
                return
            }
            that.fireEvent("loadError", arguments)
        })
    },
    _scheduleChangedCallbacks: function(deferred) {
        var that = this;
        deferred.done(function() {
            that.fireEvent("changed")
        })
    },
    loadSingle: function(propName, propValue) {
        var that = this;
        var d = $.Deferred(),
            key = this.key(),
            store = this._store,
            options = this._createStoreLoadOptions(),
            handleDone = function(data) {
                if (!__isDefined(data) || array.isEmpty(data)) {
                    d.reject(new errors.Error("E4009"))
                } else {
                    d.resolve(that._applyMapFunction($.makeArray(data))[0])
                }
            };
        this._scheduleFailCallbacks(d);
        if (arguments.length < 2) {
            propValue = propName;
            propName = key
        }
        delete options.skip;
        delete options.group;
        delete options.refresh;
        delete options.pageIndex;
        delete options.searchString;

        function shouldForceByKey() {
            return store instanceof CustomStore && !store._byKeyViaLoad()
        }(function() {
            if (propName === key || shouldForceByKey()) {
                return store.byKey(propValue, options)
            }
            options.take = 1;
            options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
            return store.load(options)
        })().fail(d.reject).done(handleDone);
        return d.promise()
    },
    load: function() {
        var loadOperation, that = this,
            d = $.Deferred();

        function loadTask() {
            if (that._disposed) {
                return
            }
            if (!isPending(d)) {
                return
            }
            return that._loadFromStore(loadOperation, d)
        }
        this._scheduleLoadCallbacks(d);
        this._scheduleFailCallbacks(d);
        this._scheduleChangedCallbacks(d);
        loadOperation = this._createLoadOperation(d);
        this.fireEvent("customizeStoreLoadOptions", [loadOperation]);
        this._loadQueue.add(function() {
            if ("number" === typeof loadOperation.delay) {
                that._delayedLoadTask = commonUtils.executeAsync(loadTask, loadOperation.delay)
            } else {
                loadTask()
            }
            return d.promise()
        });
        return d.promise({
            operationId: loadOperation.operationId
        })
    },
    _createLoadOperation: function(deferred) {
        var id = this._operationManager.add(deferred),
            options = this._createStoreLoadOptions();
        deferred.always(function() {
            this._operationManager.remove(id)
        }.bind(this));
        return {
            operationId: id,
            storeLoadOptions: options
        }
    },
    reload: function() {
        var store = this.store();
        if (store instanceof CustomStore) {
            store.clearRawDataCache()
        }
        this._init();
        return this.load()
    },
    cancel: function(operationId) {
        return this._operationManager.cancel(operationId)
    },
    _addSearchOptions: function(storeLoadOptions) {
        if (this._disposed) {
            return
        }
        if (this.store()._useDefaultSearch) {
            this._addSearchFilter(storeLoadOptions)
        } else {
            storeLoadOptions.searchOperation = this._searchOperation;
            storeLoadOptions.searchValue = this._searchValue;
            storeLoadOptions.searchExpr = this._searchExpr
        }
    },
    _createStoreLoadOptions: function() {
        var result = extend({}, this._storeLoadOptions);
        this._addSearchOptions(result);
        if (this._paginate) {
            if (this._pageSize) {
                result.skip = this._pageIndex * this._pageSize;
                result.take = this._pageSize
            }
        }
        result.userData = this._userData;
        return result
    },
    _addSearchFilter: function(storeLoadOptions) {
        var value = this._searchValue,
            op = this._searchOperation,
            selector = this._searchExpr,
            searchFilter = [];
        if (!value) {
            return
        }
        if (!selector) {
            selector = "this"
        }
        if (!Array.isArray(selector)) {
            selector = [selector]
        }
        $.each(selector, function(i, item) {
            if (searchFilter.length) {
                searchFilter.push("or")
            }
            searchFilter.push([item, op, value])
        });
        if (storeLoadOptions.filter) {
            storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter]
        } else {
            storeLoadOptions.filter = searchFilter
        }
    },
    _loadFromStore: function(loadOptions, pendingDeferred) {
        var that = this;

        function handleSuccess(data, extra) {
            function processResult() {
                var loadResult;
                if (data && !Array.isArray(data) && data.data) {
                    extra = data;
                    data = data.data
                }
                if (!Array.isArray(data)) {
                    data = $.makeArray(data)
                }
                loadResult = extend({
                    data: data,
                    extra: extra
                }, loadOptions);
                that.fireEvent("customizeLoadResult", [loadResult]);
                when(loadResult.data).done(function(data) {
                    loadResult.data = data;
                    that._processStoreLoadResult(loadResult, pendingDeferred)
                }).fail(pendingDeferred.reject)
            }
            if (that._disposed) {
                return
            }
            if (!isPending(pendingDeferred)) {
                return
            }
            processResult()
        }
        if (loadOptions.data) {
            return $.Deferred().resolve(loadOptions.data).done(handleSuccess)
        }
        return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
    },
    _processStoreLoadResult: function(loadResult, pendingDeferred) {
        var that = this,
            data = loadResult.data,
            extra = loadResult.extra,
            storeLoadOptions = loadResult.storeLoadOptions;

        function resolvePendingDeferred() {
            that._isLoaded = true;
            that._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
            return pendingDeferred.resolve(data, extra)
        }

        function proceedLoadingTotalCount() {
            that.store().totalCount(storeLoadOptions).done(function(count) {
                extra.totalCount = count;
                resolvePendingDeferred()
            }).fail(pendingDeferred.reject)
        }
        if (that._disposed) {
            return
        }
        data = that._applyPostProcessFunction(that._applyMapFunction(data));
        if (!typeUtils.isPlainObject(extra)) {
            extra = {}
        }
        that._items = data;
        if (!data.length || !that._paginate || that._pageSize && data.length < that._pageSize) {
            that._isLastPage = true
        }
        if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
            proceedLoadingTotalCount()
        } else {
            resolvePendingDeferred()
        }
    },
    _applyMapFunction: function(data) {
        if (this._mapFunc) {
            return mapDataRespectingGrouping(data, this._mapFunc, this.group())
        }
        return data
    },
    _applyPostProcessFunction: function(data) {
        if (this._postProcessFunc) {
            return this._postProcessFunc(data)
        }
        return data
    }
}).include(EventsMixin);
exports.DataSource = DataSource;
exports.normalizeDataSourceOptions = normalizeDataSourceOptions;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/bindable_template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    TemplateBase = __webpack_require__(64),
    removeEvent = __webpack_require__(86),
    commonUtils = __webpack_require__(2);
var watchChanges = function() {
    var start = function(rawData, watchMethod, fields, fieldsMap, callback) {
        var globalDispose, fieldsDispose;
        globalDispose = globalWatch(rawData, watchMethod, function(dataWithRawFields) {
            fieldsDispose && fieldsDispose();
            if (commonUtils.isPrimitive(dataWithRawFields)) {
                callback(dataWithRawFields);
                return
            }
            fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, function(data) {
                callback(data)
            })
        });
        return function() {
            fieldsDispose && fieldsDispose();
            globalDispose && globalDispose()
        }
    };
    var globalWatch = function(data, watchMethod, callback) {
        return watchMethod(function() {
            return data
        }, callback)
    };
    var fieldsWatch = function(data, watchMethod, fields, fieldsMap, callback) {
        var resolvedData = {},
            missedFields = fields.slice();
        var watchHandlers = $.map(fields, function(name) {
            var fieldGetter = fieldsMap[name];
            return watchMethod(fieldGetter ? function() {
                return fieldGetter(data)
            } : function() {
                return data[name]
            }, function(value) {
                resolvedData[name] = value;
                if (missedFields.length) {
                    var index = missedFields.indexOf(name);
                    if (index >= 0) {
                        missedFields.splice(index, 1)
                    }
                }
                if (!missedFields.length) {
                    callback(resolvedData)
                }
            })
        });
        return function() {
            $.each(watchHandlers, function(_, dispose) {
                dispose()
            })
        }
    };
    return start
}();
module.exports = TemplateBase.inherit({
    ctor: function(render, fields, watchMethod, fieldsMap) {
        this._render = render;
        this._fields = fields;
        this._fieldsMap = fieldsMap || {};
        this._watchMethod = watchMethod
    },
    _renderCore: function(options) {
        var $container = options.container;
        var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function(data) {
            $container.empty();
            this._render($container, data, options.model)
        }.bind(this));
        $container.on(removeEvent, dispose);
        return $container.contents()
    }
});


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/load_indicator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    themes = __webpack_require__(20),
    browser = __webpack_require__(21),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    Widget = __webpack_require__(27);
var LOADINDICATOR_CLASS = "dx-loadindicator",
    LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper",
    LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content",
    LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon",
    LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment",
    LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner",
    LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
var LoadIndicator = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            indicatorSrc: "",
            activeStateEnabled: false,
            hoverStateEnabled: false,
            _animatingSegmentCount: 1,
            _animatingSegmentInner: false
        })
    },
    _defaultOptionsRules: function() {
        var themeName = function() {
            var currentTheme = themes.current();
            return currentTheme && currentTheme.split(".")[0]
        };
        return this.callBase().concat([{
            device: function() {
                var realDevice = devices.real(),
                    obsoleteAndroid = "android" === realDevice.platform && !/chrome/i.test(navigator.userAgent);
                return browser.msie && browser.version < 10 || obsoleteAndroid
            },
            options: {
                viaImage: true
            }
        }, {
            device: function() {
                return "win8" === themeName() || "win10" === themeName()
            },
            options: {
                _animatingSegmentCount: 5
            }
        }, {
            device: function() {
                return "ios7" === themeName()
            },
            options: {
                _animatingSegmentCount: 11
            }
        }, {
            device: function() {
                return "android5" === themeName()
            },
            options: {
                _animatingSegmentCount: 2,
                _animatingSegmentInner: true
            }
        }, {
            device: function() {
                return "generic" === themeName()
            },
            options: {
                _animatingSegmentCount: 7
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.element().addClass(LOADINDICATOR_CLASS)
    },
    _render: function() {
        this._renderWrapper();
        this._renderIndicatorContent();
        this._renderMarkup();
        this.callBase()
    },
    _renderWrapper: function() {
        this._$wrapper = $("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
        this.element().append(this._$wrapper)
    },
    _renderIndicatorContent: function() {
        this._$content = $("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
        this._$wrapper.append(this._$content)
    },
    _renderMarkup: function() {
        if (support.animation && !this.option("viaImage") && !this.option("indicatorSrc")) {
            this._renderMarkupForAnimation()
        } else {
            this._renderMarkupForImage()
        }
    },
    _renderMarkupForAnimation: function() {
        var animatingSegmentInner = this.option("_animatingSegmentInner");
        this._$indicator = $("<div>").addClass(LOADINDICATOR_ICON_CLASS);
        this._$content.append(this._$indicator);
        for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
            var $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
            if (animatingSegmentInner) {
                $segment.append($("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS))
            }
            this._$indicator.append($segment)
        }
    },
    _renderMarkupForImage: function() {
        var indicatorSrc = this.option("indicatorSrc");
        this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
        if (indicatorSrc) {
            this._$wrapper.css("background-image", "url(" + indicatorSrc + ")")
        }
    },
    _renderDimensions: function() {
        this.callBase();
        this._updateContentSizeForAnimation()
    },
    _updateContentSizeForAnimation: function() {
        if (!this._$indicator) {
            return
        }
        var width = this.option("width"),
            height = this.option("height");
        if (width || height) {
            width = this.element().width();
            height = this.element().height();
            var minDimension = Math.min(height, width);
            this._$wrapper.css({
                height: minDimension,
                width: minDimension,
                "font-size": minDimension
            })
        }
    },
    _clean: function() {
        this.callBase();
        this._removeMarkupForAnimation();
        this._removeMarkupForImage()
    },
    _removeMarkupForAnimation: function() {
        if (!this._$indicator) {
            return
        }
        this._$indicator.remove();
        delete this._$indicator
    },
    _removeMarkupForImage: function() {
        this._$wrapper.css("background-image", "none")
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "_animatingSegmentCount":
            case "_animatingSegmentInner":
            case "indicatorSrc":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxLoadIndicator", LoadIndicator);
module.exports = LoadIndicator;
module.exports.default = module.exports;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/view_port.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ready = __webpack_require__(135),
    changeCallback = $.Callbacks(),
    $originalViewPort = $();
var value = function() {
    var $current;
    return function(element) {
        if (!arguments.length) {
            return $current
        }
        var $element = $(element);
        $originalViewPort = $element;
        var isNewViewportFound = !!$element.length;
        var prevViewPort = value();
        $current = isNewViewportFound ? $element : $("body");
        changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort)
    }
}();
ready(function() {
    value(".dx-viewport")
});
exports.value = value;
exports.changeCallback = changeCallback;
exports.originalViewPort = function() {
    return $originalViewPort
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/date.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    camelize = __webpack_require__(36).camelize,
    isObject = commonUtils.isObject,
    isString = commonUtils.isString,
    isDate = commonUtils.isDate,
    isDefined = commonUtils.isDefined;
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var toMilliseconds = function(value) {
    switch (value) {
        case "millisecond":
            return 1;
        case "second":
            return 1e3 * toMilliseconds("millisecond");
        case "minute":
            return 60 * toMilliseconds("second");
        case "hour":
            return 60 * toMilliseconds("minute");
        case "day":
            return 24 * toMilliseconds("hour");
        case "week":
            return 7 * toMilliseconds("day");
        case "month":
            return 30 * toMilliseconds("day");
        case "quarter":
            return 3 * toMilliseconds("month");
        case "year":
            return 365 * toMilliseconds("day");
        default:
            return 0
    }
};
var getDatesInterval = function(startDate, endDate, intervalUnit) {
    var delta = endDate.getTime() - startDate.getTime(),
        millisecondCount = toMilliseconds(intervalUnit) || 1;
    return Math.floor(delta / millisecondCount)
};
var getNextDateUnit = function(unit, withWeeks) {
    var interval = getDateUnitInterval(unit);
    switch (interval) {
        case "millisecond":
            return "second";
        case "second":
            return "minute";
        case "minute":
            return "hour";
        case "hour":
            return "day";
        case "day":
            return withWeeks ? "week" : "month";
        case "week":
            return "month";
        case "month":
            return "quarter";
        case "quarter":
            return "year";
        case "year":
            return "year";
        default:
            return 0
    }
};
var convertMillisecondsToDateUnits = function(value) {
    var i, dateUnitCount, dateUnitInterval, dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"],
        result = {};
    for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
        dateUnitInterval = dateUnitIntervals[i];
        dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
        if (dateUnitCount > 0) {
            result[dateUnitInterval + "s"] = dateUnitCount;
            value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
        }
    }
    return result
};
var dateToMilliseconds = function(tickInterval) {
    var milliseconds = 0;
    if (isObject(tickInterval)) {
        $.each(tickInterval, function(key, value) {
            milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
        })
    }
    if (isString(tickInterval)) {
        milliseconds = convertDateUnitToMilliseconds(tickInterval, 1)
    }
    return milliseconds
};
var convertDateUnitToMilliseconds = function(dateUnit, count) {
    return toMilliseconds(dateUnit) * count
};
var getDateUnitInterval = function(tickInterval) {
    var i, maxInterval = -1;
    if (isString(tickInterval)) {
        return tickInterval
    }
    if (isObject(tickInterval)) {
        $.each(tickInterval, function(key, value) {
            for (i = 0; i < dateUnitIntervals.length; i++) {
                if (value && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
                    maxInterval = i
                }
            }
        });
        return dateUnitIntervals[maxInterval]
    }
    return ""
};
var tickIntervalToFormatMap = {
    millisecond: "millisecond",
    second: "longtime",
    minute: "shorttime",
    hour: "shorttime",
    day: "day",
    week: "day",
    month: "month",
    quarter: "quarter",
    year: "year"
};

function getDateFormatByTickInterval(tickInterval) {
    return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || ""
}
var getQuarter = function(month) {
    return Math.floor(month / 3)
};
var getFirstQuarterMonth = function(month) {
    return 3 * getQuarter(month)
};
var correctDateWithUnitBeginning = function(date, dateInterval, withCorrection) {
    date = new Date(date.getTime());
    var firstQuarterMonth, oldDate = new Date(date.getTime()),
        dateUnitInterval = getDateUnitInterval(dateInterval);
    switch (dateUnitInterval) {
        case "second":
            date.setMilliseconds(0);
            break;
        case "minute":
            date.setSeconds(0, 0);
            break;
        case "hour":
            date.setMinutes(0, 0, 0);
            break;
        case "year":
            date.setMonth(0);
        case "month":
            date.setDate(1);
        case "day":
            date.setHours(0, 0, 0, 0);
            break;
        case "week":
            date.setDate(date.getDate() - date.getDay());
            date.setHours(0, 0, 0, 0);
            break;
        case "quarter":
            firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
            if (date.getMonth() !== firstQuarterMonth) {
                date.setMonth(firstQuarterMonth)
            }
            date.setDate(1);
            date.setHours(0, 0, 0, 0)
    }
    if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
        fixTimezoneGap(oldDate, date)
    }
    return date
};
var trimTime = function(date) {
    return dateUtils.correctDateWithUnitBeginning(date, "day")
};
var getDatesDifferences = function(date1, date2) {
    var differences, counter = 0;
    differences = {
        year: date1.getFullYear() !== date2.getFullYear(),
        month: date1.getMonth() !== date2.getMonth(),
        day: date1.getDate() !== date2.getDate(),
        hour: date1.getHours() !== date2.getHours(),
        minute: date1.getMinutes() !== date2.getMinutes(),
        second: date1.getSeconds() !== date2.getSeconds(),
        millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
    };
    $.each(differences, function(key, value) {
        if (value) {
            counter++
        }
    });
    differences.count = counter;
    return differences
};

function addDateInterval(value, interval, dir) {
    var result = new Date(value.getTime()),
        intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
    if (intervalObject.years) {
        result.setFullYear(result.getFullYear() + intervalObject.years * dir)
    }
    if (intervalObject.quarters) {
        result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir)
    }
    if (intervalObject.months) {
        result.setMonth(result.getMonth() + intervalObject.months * dir)
    }
    if (intervalObject.weeks) {
        result.setDate(result.getDate() + 7 * intervalObject.weeks * dir)
    }
    if (intervalObject.days) {
        result.setDate(result.getDate() + intervalObject.days * dir)
    }
    if (intervalObject.hours) {
        result.setHours(result.getHours() + intervalObject.hours * dir)
    }
    if (intervalObject.minutes) {
        result.setMinutes(result.getMinutes() + intervalObject.minutes * dir)
    }
    if (intervalObject.seconds) {
        result.setSeconds(result.getSeconds() + intervalObject.seconds * dir)
    }
    if (intervalObject.milliseconds) {
        result.setMilliseconds(value.getMilliseconds() + intervalObject.milliseconds * dir)
    }
    return result
}
var addInterval = function(value, interval, isNegative) {
    var dir = isNegative ? -1 : 1;
    return isDate(value) ? addDateInterval(value, interval, dir) : value + interval * dir
};
var getSequenceByInterval = function(min, max, interval) {
    var cur, intervals = [];
    intervals.push(isDate(min) ? new Date(min.getTime()) : min);
    cur = min;
    while (cur < max) {
        cur = addInterval(cur, interval);
        intervals.push(cur)
    }
    return intervals
};
var getViewFirstCellDate = function(viewType, date) {
    if ("month" === viewType) {
        return new Date(date.getFullYear(), date.getMonth(), 1)
    }
    if ("year" === viewType) {
        return new Date(date.getFullYear(), 0, date.getDate())
    }
    if ("decade" === viewType) {
        return new Date(getFirstYearInDecade(date), date.getMonth(), date.getDate())
    }
    if ("century" === viewType) {
        return new Date(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
    }
};
var getViewLastCellDate = function(viewType, date) {
    if ("month" === viewType) {
        return new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date))
    }
    if ("year" === viewType) {
        return new Date(date.getFullYear(), 11, date.getDate())
    }
    if ("decade" === viewType) {
        return new Date(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate())
    }
    if ("century" === viewType) {
        return new Date(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
    }
};
var getViewMinBoundaryDate = function(viewType, date) {
    var resultDate = new Date(date.getFullYear(), date.getMonth(), 1);
    if ("month" === viewType) {
        return resultDate
    }
    resultDate.setMonth(0);
    if ("year" === viewType) {
        return resultDate
    }
    if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date))
    }
    if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date))
    }
    return resultDate
};
var getViewMaxBoundaryDate = function(viewType, date) {
    var resultDate = new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
    if ("month" === viewType) {
        return resultDate
    }
    resultDate.setMonth(11);
    resultDate.setDate(getLastMonthDay(resultDate));
    if ("year" === viewType) {
        return resultDate
    }
    if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date) + 9)
    }
    if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date) + 99)
    }
    return resultDate
};
var getLastMonthDay = function(date) {
    var resultDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    return resultDate.getDate()
};
var sameView = function(view, date1, date2) {
    return dateUtils[camelize("same " + view)](date1, date2)
};
var getViewUp = function(typeView) {
    switch (typeView) {
        case "month":
            return "year";
        case "year":
            return "decade";
        case "decade":
            return "century"
    }
};
var getViewDown = function(typeView) {
    switch (typeView) {
        case "century":
            return "decade";
        case "decade":
            return "year";
        case "year":
            return "month"
    }
};
var getDifferenceInMonth = function(typeView) {
    var difference = 1;
    if ("year" === typeView) {
        difference = 12
    }
    if ("decade" === typeView) {
        difference = 120
    }
    if ("century" === typeView) {
        difference = 1200
    }
    return difference
};
var getDifferenceInMonthForCells = function(typeView) {
    var difference = 1;
    if ("decade" === typeView) {
        difference = 12
    }
    if ("century" === typeView) {
        difference = 120
    }
    return difference
};
var getDateIntervalByString = function(intervalString) {
    var result = {};
    switch (intervalString) {
        case "year":
            result.years = 1;
            break;
        case "month":
            result.months = 1;
            break;
        case "quarter":
            result.months = 3;
            break;
        case "week":
            result.days = 7;
            break;
        case "day":
            result.days = 1;
            break;
        case "hour":
            result.hours = 1;
            break;
        case "minute":
            result.minutes = 1;
            break;
        case "second":
            result.seconds = 1;
            break;
        case "millisecond":
            result.milliseconds = 1
    }
    return result
};
var sameDate = function(date1, date2) {
    return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate()
};
var sameMonthAndYear = function(date1, date2) {
    return sameYear(date1, date2) && date1.getMonth() === date2.getMonth()
};
var sameYear = function(date1, date2) {
    return date1 && date2 && date1.getFullYear() === date2.getFullYear()
};
var sameDecade = function(date1, date2) {
    if (!isDefined(date1) || !isDefined(date2)) {
        return
    }
    var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10,
        startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
    return date1 && date2 && startDecadeDate1 === startDecadeDate2
};
var sameCentury = function(date1, date2) {
    if (!isDefined(date1) || !isDefined(date2)) {
        return
    }
    var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100,
        startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
    return date1 && date2 && startCenturyDate1 === startCenturyDate2
};
var getFirstDecadeInCentury = function(date) {
    return date && date.getFullYear() - date.getFullYear() % 100
};
var getFirstYearInDecade = function(date) {
    return date && date.getFullYear() - date.getFullYear() % 10
};
var getShortDateFormat = function() {
    return "yyyy/MM/dd"
};
var getFirstMonthDate = function(date) {
    if (!isDefined(date)) {
        return
    }
    var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
    return newDate
};
var getLastMonthDate = function(date) {
    if (!isDefined(date)) {
        return
    }
    var newDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    return newDate
};
var getFirstWeekDate = function(date, firstDayOfWeek) {
    var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
    var result = new Date(date);
    result.setDate(date.getDate() - delta);
    return result
};
var normalizeDateByWeek = function(date, currentDate) {
    var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day"),
        resultDate = new Date(date);
    if (differenceInDays >= 6) {
        resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7))
    }
    return resultDate
};
var dateInRange = function(date, min, max, format) {
    if ("date" === format) {
        min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
        max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
        date = date && dateUtils.correctDateWithUnitBeginning(date, "day")
    }
    return normalizeDate(date, min, max) === date
};
var normalizeDate = function(date, min, max) {
    var normalizedDate = date;
    if (!isDefined(date)) {
        return date
    }
    if (isDefined(min) && date < min) {
        normalizedDate = min
    }
    if (isDefined(max) && date > max) {
        normalizedDate = max
    }
    return normalizedDate
};
var fixTimezoneGap = function(oldDate, newDate) {
    if (!isDefined(oldDate)) {
        return
    }
    var sign, trial, diff = newDate.getHours() - oldDate.getHours();
    if (0 === diff) {
        return
    }
    sign = 1 === diff || diff === -23 ? -1 : 1;
    trial = new Date(newDate.getTime() + 36e5 * sign);
    if (sign > 0 || trial.getDate() === newDate.getDate()) {
        newDate.setTime(trial.getTime())
    }
};
var roundToHour = function(date) {
    date.setHours(date.getHours() + 1);
    date.setMinutes(0);
    return date
};
var getTimezonesDifference = function(min, max) {
    return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3
};
var makeDate = function(date) {
    return new Date(date)
};
var dateUtils = {
    dateUnitIntervals: dateUnitIntervals,
    convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
    dateToMilliseconds: dateToMilliseconds,
    getNextDateUnit: getNextDateUnit,
    convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
    getDateUnitInterval: getDateUnitInterval,
    getDateFormatByTickInterval: getDateFormatByTickInterval,
    getDatesDifferences: getDatesDifferences,
    correctDateWithUnitBeginning: correctDateWithUnitBeginning,
    trimTime: trimTime,
    addDateInterval: addDateInterval,
    addInterval: addInterval,
    getSequenceByInterval: getSequenceByInterval,
    getDateIntervalByString: getDateIntervalByString,
    sameDate: sameDate,
    sameMonthAndYear: sameMonthAndYear,
    sameMonth: sameMonthAndYear,
    sameYear: sameYear,
    sameDecade: sameDecade,
    sameCentury: sameCentury,
    sameView: sameView,
    getDifferenceInMonth: getDifferenceInMonth,
    getDifferenceInMonthForCells: getDifferenceInMonthForCells,
    getFirstYearInDecade: getFirstYearInDecade,
    getFirstDecadeInCentury: getFirstDecadeInCentury,
    getShortDateFormat: getShortDateFormat,
    getViewFirstCellDate: getViewFirstCellDate,
    getViewLastCellDate: getViewLastCellDate,
    getViewDown: getViewDown,
    getViewUp: getViewUp,
    getLastMonthDay: getLastMonthDay,
    getLastMonthDate: getLastMonthDate,
    getFirstMonthDate: getFirstMonthDate,
    getFirstWeekDate: getFirstWeekDate,
    normalizeDateByWeek: normalizeDateByWeek,
    getQuarter: getQuarter,
    getFirstQuarterMonth: getFirstQuarterMonth,
    dateInRange: dateInRange,
    roundToHour: roundToHour,
    normalizeDate: normalizeDate,
    getViewMinBoundaryDate: getViewMinBoundaryDate,
    getViewMaxBoundaryDate: getViewMaxBoundaryDate,
    fixTimezoneGap: fixTimezoneGap,
    getTimezonesDifference: getTimezonesDifference,
    makeDate: makeDate,
    getDatesInterval: getDatesInterval
};
module.exports = dateUtils;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/math.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var sign = function(value) {
    if (0 === value) {
        return 0
    }
    return value / Math.abs(value)
};
var fitIntoRange = function(value, minValue, maxValue) {
    var isMinValueUndefined = !minValue && 0 !== minValue,
        isMaxValueUndefined = !maxValue && 0 !== maxValue;
    isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);
    isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);
    return Math.min(Math.max(value, minValue), maxValue)
};
var inRange = function(value, minValue, maxValue) {
    return value >= minValue && value <= maxValue
};
exports.sign = sign;
exports.fitIntoRange = fitIntoRange;
exports.inRange = inRange;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/position.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var config = __webpack_require__(31);
var getDefaultAlignment = function(isRtlEnabled) {
    var rtlEnabled = isRtlEnabled || config().rtlEnabled;
    return rtlEnabled ? "right" : "left"
};
exports.getDefaultAlignment = getDefaultAlignment;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validation_engine.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    EventsMixin = __webpack_require__(38),
    errors = __webpack_require__(13),
    commonUtils = __webpack_require__(2),
    numberLocalization = __webpack_require__(44),
    messageLocalization = __webpack_require__(8);
var BaseRuleValidator = Class.inherit({
    NAME: "base",
    defaultMessage: function(value) {
        return messageLocalization.getFormatter("validation-" + this.NAME)(value)
    },
    defaultFormattedMessage: function(value) {
        return messageLocalization.getFormatter("validation-" + this.NAME + "-formatted")(value)
    },
    validate: function(value, rule) {
        var valueArray = Array.isArray(value) ? value : [value],
            result = true;
        if (valueArray.length) {
            valueArray.every(function(itemValue) {
                result = this._validate(itemValue, rule);
                return result
            }, this)
        } else {
            result = this._validate(null, rule)
        }
        return result
    }
});
var RequiredRuleValidator = BaseRuleValidator.inherit({
    NAME: "required",
    _validate: function(value, rule) {
        if (!commonUtils.isDefined(value)) {
            return false
        }
        if (false === value) {
            return false
        }
        value = String(value);
        if (rule.trim || !commonUtils.isDefined(rule.trim)) {
            value = $.trim(value)
        }
        return "" !== value
    }
});
var NumericRuleValidator = BaseRuleValidator.inherit({
    NAME: "numeric",
    _validate: function(value, rule) {
        if (!rulesValidators.required.validate(value, {})) {
            return true
        }
        if (rule.useCultureSettings && commonUtils.isString(value)) {
            return !isNaN(numberLocalization.parse(value))
        } else {
            return commonUtils.isNumeric(value)
        }
    }
});
var RangeRuleValidator = BaseRuleValidator.inherit({
    NAME: "range",
    _validate: function(value, rule) {
        if (!rulesValidators.required.validate(value, {})) {
            return true
        }
        var validNumber = rulesValidators.numeric.validate(value, rule),
            validValue = commonUtils.isDefined(value),
            number = validNumber ? parseFloat(value) : validValue && value.valueOf(),
            min = rule.min,
            max = rule.max;
        if (!(validNumber || commonUtils.isDate(value)) && !validValue) {
            return false
        }
        if (commonUtils.isDefined(min)) {
            if (commonUtils.isDefined(max)) {
                return number >= min && number <= max
            }
            return number >= min
        } else {
            if (commonUtils.isDefined(max)) {
                return number <= max
            } else {
                throw errors.Error("E0101")
            }
        }
    }
});
var StringLengthRuleValidator = BaseRuleValidator.inherit({
    NAME: "stringLength",
    _validate: function(value, rule) {
        value = commonUtils.isDefined(value) ? String(value) : "";
        if (rule.trim || !commonUtils.isDefined(rule.trim)) {
            value = $.trim(value)
        }
        return rulesValidators.range.validate(value.length, extend({}, rule))
    }
});
var CustomRuleValidator = BaseRuleValidator.inherit({
    NAME: "custom",
    validate: function(value, rule) {
        return rule.validationCallback({
            value: value,
            validator: rule.validator,
            rule: rule
        })
    }
});
var CompareRuleValidator = BaseRuleValidator.inherit({
    NAME: "compare",
    _validate: function(value, rule) {
        if (!rule.comparisonTarget) {
            throw errors.Error("E0102")
        }
        extend(rule, {
            reevaluate: true
        });
        var otherValue = rule.comparisonTarget(),
            type = rule.comparisonType || "==";
        switch (type) {
            case "==":
                return value == otherValue;
            case "!=":
                return value != otherValue;
            case "===":
                return value === otherValue;
            case "!==":
                return value !== otherValue;
            case ">":
                return value > otherValue;
            case ">=":
                return value >= otherValue;
            case "<":
                return value < otherValue;
            case "<=":
                return value <= otherValue
        }
    }
});
var PatternRuleValidator = BaseRuleValidator.inherit({
    NAME: "pattern",
    _validate: function(value, rule) {
        if (!rulesValidators.required.validate(value, {})) {
            return true
        }
        var pattern = rule.pattern;
        if (commonUtils.isString(pattern)) {
            pattern = new RegExp(pattern)
        }
        return pattern.test(value)
    }
});
var EmailRuleValidator = BaseRuleValidator.inherit({
    NAME: "email",
    _validate: function(value, rule) {
        if (!rulesValidators.required.validate(value, {})) {
            return true
        }
        return rulesValidators.pattern.validate(value, extend({}, rule, {
            pattern: /^[\d\w\._\-]+@([\d\w\._\-]+\.)+[\w]+$/i
        }))
    }
});
var rulesValidators = {
    required: new RequiredRuleValidator,
    numeric: new NumericRuleValidator,
    range: new RangeRuleValidator,
    stringLength: new StringLengthRuleValidator,
    custom: new CustomRuleValidator,
    compare: new CompareRuleValidator,
    pattern: new PatternRuleValidator,
    email: new EmailRuleValidator
};
var GroupConfig = Class.inherit({
    ctor: function(group) {
        this.group = group;
        this.validators = []
    },
    validate: function() {
        var result = {
            isValid: true,
            brokenRules: [],
            validators: []
        };
        $.each(this.validators, function(_, validator) {
            var validatorResult = validator.validate();
            result.isValid = result.isValid && validatorResult.isValid;
            if (validatorResult.brokenRule) {
                result.brokenRules.push(validatorResult.brokenRule)
            }
            result.validators.push(validator)
        });
        this.fireEvent("validated", [{
            validators: result.validators,
            brokenRules: result.brokenRules,
            isValid: result.isValid
        }]);
        return result
    },
    reset: function() {
        $.each(this.validators, function(_, validator) {
            validator.reset()
        })
    }
}).include(EventsMixin);
var ValidationEngine = {
    groups: [],
    getGroupConfig: function(group) {
        var result = commonUtils.grep(this.groups, function(config) {
            return config.group === group
        });
        if (result.length) {
            return result[0]
        }
    },
    initGroups: function() {
        this.groups = [];
        this.addGroup()
    },
    addGroup: function(group) {
        var config = this.getGroupConfig(group);
        if (!config) {
            config = new GroupConfig(group);
            this.groups.push(config)
        }
        return config
    },
    removeGroup: function(group) {
        var config = this.getGroupConfig(group),
            index = inArray(config, this.groups);
        if (index > -1) {
            this.groups.splice(index, 1)
        }
        return config
    },
    _setDefaultMessage: function(rule, validator, name) {
        if (!commonUtils.isDefined(rule.message)) {
            if (validator.defaultFormattedMessage && commonUtils.isDefined(name)) {
                rule.message = validator.defaultFormattedMessage(name)
            } else {
                rule.message = validator.defaultMessage()
            }
        }
    },
    validate: function(value, rules, name) {
        var result = {
                name: name,
                value: value,
                brokenRule: null,
                isValid: true,
                validationRules: rules
            },
            that = this;
        $.each(rules || [], function(_, rule) {
            var ruleValidationResult, ruleValidator = rulesValidators[rule.type];
            if (ruleValidator) {
                if (commonUtils.isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {
                    if (!rule.isValid) {
                        result.isValid = false;
                        result.brokenRule = rule;
                        return false
                    }
                    return true
                }
                rule.value = value;
                ruleValidationResult = ruleValidator.validate(value, rule);
                rule.isValid = ruleValidationResult;
                if (!ruleValidationResult) {
                    result.isValid = false;
                    that._setDefaultMessage(rule, ruleValidator, name);
                    result.brokenRule = rule
                }
                if (!rule.isValid) {
                    return false
                }
            } else {
                throw errors.Error("E0100")
            }
        });
        return result
    },
    registerValidatorInGroup: function(group, validator) {
        var groupConfig = ValidationEngine.addGroup(group);
        if (inArray(validator, groupConfig.validators) < 0) {
            groupConfig.validators.push(validator)
        }
    },
    _shouldRemoveGroup: function(group, validatorsInGroup) {
        var isDefaultGroup = void 0 === group,
            isValidationGroupInstance = group && "dxValidationGroup" === group.NAME;
        return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length
    },
    removeRegisteredValidator: function(group, validator) {
        var config = ValidationEngine.getGroupConfig(group),
            validatorsInGroup = config && config.validators;
        var index = inArray(validator, validatorsInGroup);
        if (index > -1) {
            validatorsInGroup.splice(index, 1);
            if (this._shouldRemoveGroup(group, validatorsInGroup)) {
                this.removeGroup(group)
            }
        }
    },
    validateGroup: function(group) {
        var groupConfig = ValidationEngine.getGroupConfig(group);
        if (!groupConfig) {
            throw errors.Error("E0110")
        }
        return groupConfig.validate()
    },
    resetGroup: function(group) {
        var groupConfig = ValidationEngine.getGroupConfig(group);
        if (!groupConfig) {
            throw errors.Error("E0110")
        }
        return groupConfig.reset()
    }
};
ValidationEngine.initGroups();
module.exports = ValidationEngine;
module.exports.default = module.exports;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator_registry.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend;
exports.registry = {};
exports.register = function(option, type, decoratorClass) {
    var decoratorsRegistry = exports.registry;
    var decoratorConfig = {};
    decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
    decoratorConfig[option][type] = decoratorClass;
    decoratorsRegistry = extend(decoratorsRegistry, decoratorConfig)
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var dependencyInjector = __webpack_require__(72);
module.exports = dependencyInjector({
    locale: function() {
        var currentLocale = "en";
        return function(locale) {
            if (!locale) {
                return currentLocale
            }
            currentLocale = locale
        }
    }()
});


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/window.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var resizeCallbacks = function() {
    var prevSize, callbacks = $.Callbacks(),
        jqWindow = $(window),
        resizeEventHandlerAttached = false,
        originalCallbacksAdd = callbacks.add,
        originalCallbacksRemove = callbacks.remove;
    var formatSize = function() {
        return {
            width: jqWindow.width(),
            height: jqWindow.height()
        }
    };
    var handleResize = function() {
        var now = formatSize();
        if (now.width === prevSize.width && now.height === prevSize.height) {
            return
        }
        var changedDimension;
        if (now.width === prevSize.width) {
            changedDimension = "height"
        }
        if (now.height === prevSize.height) {
            changedDimension = "width"
        }
        prevSize = now;
        setTimeout(function() {
            callbacks.fire(changedDimension)
        })
    };
    prevSize = formatSize();
    callbacks.add = function() {
        var result = originalCallbacksAdd.apply(callbacks, arguments);
        if (!resizeEventHandlerAttached && callbacks.has()) {
            jqWindow.on("resize", handleResize);
            resizeEventHandlerAttached = true
        }
        return result
    };
    callbacks.remove = function() {
        var result = originalCallbacksRemove.apply(callbacks, arguments);
        if (!callbacks.has() && resizeEventHandlerAttached) {
            jqWindow.off("resize", handleResize);
            resizeEventHandlerAttached = false
        }
        return result
    };
    return callbacks
}();
var defaultScreenFactorFunc = function(width) {
    if (width < 768) {
        return "xs"
    } else {
        if (width < 992) {
            return "sm"
        } else {
            if (width < 1200) {
                return "md"
            } else {
                return "lg"
            }
        }
    }
};
var getCurrentScreenFactor = function(screenFactorCallback) {
    var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
    return screenFactorFunc($(window).width())
};
exports.resizeCallbacks = resizeCallbacks;
exports.defaultScreenFactorFunc = defaultScreenFactorFunc;
exports.getCurrentScreenFactor = getCurrentScreenFactor;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/action.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    config = __webpack_require__(31),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    Class = __webpack_require__(5);
var Action = Class.inherit({
    ctor: function(action, config) {
        config = config || {};
        this._action = action;
        this._context = config.context || window;
        this._beforeExecute = config.beforeExecute;
        this._afterExecute = config.afterExecute;
        this._component = config.component;
        this._validatingTargetName = config.validatingTargetName;
        var excludeValidators = this._excludeValidators = {};
        if (config.excludeValidators) {
            for (var i = 0; i < config.excludeValidators.length; i++) {
                excludeValidators[config.excludeValidators[i]] = true
            }
        }
    },
    execute: function() {
        var e = {
            action: this._action,
            args: Array.prototype.slice.call(arguments),
            context: this._context,
            component: this._component,
            validatingTargetName: this._validatingTargetName,
            cancel: false,
            handled: false
        };
        var beforeExecute = this._beforeExecute,
            afterExecute = this._afterExecute;
        if (!this._validateAction(e)) {
            return
        }
        beforeExecute && beforeExecute.call(this._context, e);
        if (e.cancel) {
            return
        }
        var result = this._executeAction(e);
        var argsBag = e.args[0];
        if (argsBag && argsBag.cancel) {
            return
        }
        afterExecute && afterExecute.call(this._context, e);
        return result
    },
    _validateAction: function(e) {
        var excludeValidators = this._excludeValidators,
            executors = Action.executors;
        for (var name in executors) {
            if (!excludeValidators[name]) {
                var executor = executors[name];
                if (executor.validate) {
                    executor.validate(e)
                }
                if (e.cancel) {
                    return false
                }
            }
        }
        return true
    },
    _executeAction: function(e) {
        var result, executors = Action.executors;
        for (var name in executors) {
            var executor = executors[name];
            if (executor.execute) {
                executor.execute(e)
            }
            if (e.handled) {
                result = e.result;
                break
            }
        }
        return result
    }
});
Action.executors = {};
Action.registerExecutor = function(name, executor) {
    if (typeUtils.isPlainObject(name)) {
        $.each(name, Action.registerExecutor);
        return
    }
    Action.executors[name] = executor
};
Action.unregisterExecutor = function() {
    var args = $.makeArray(arguments);
    $.each(args, function() {
        delete Action.executors[this]
    })
};
Action.registerExecutor({
    undefined: {
        execute: function(e) {
            if (!e.action) {
                e.result = void 0;
                e.handled = true
            }
        }
    },
    func: {
        execute: function(e) {
            if (commonUtils.isFunction(e.action)) {
                e.result = e.action.call(e.context, e.args[0]);
                e.handled = true
            }
        }
    }
});
var createValidatorByTargetElement = function(condition) {
    return function(e) {
        if (!e.args.length) {
            return
        }
        var args = e.args[0],
            element = args[e.validatingTargetName] || args.element;
        if (element && condition(element)) {
            e.cancel = true
        }
    }
};
Action.registerExecutor({
    designMode: {
        validate: function(e) {
            if (config().designMode) {
                e.cancel = true
            }
        }
    },
    disabled: {
        validate: createValidatorByTargetElement(function($target) {
            return $target.is(".dx-state-disabled, .dx-state-disabled *")
        })
    },
    readOnly: {
        validate: createValidatorByTargetElement(function($target) {
            return $target.is(".dx-state-readonly, .dx-state-readonly *")
        })
    }
});
module.exports = Action;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/emitter_registrator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    registerEvent = __webpack_require__(47),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    wheelEvent = __webpack_require__(137);
var MANAGER_EVENT = "dxEventManager",
    EMITTER_DATA = "dxEmitter";
var EventManager = Class.inherit({
    ctor: function() {
        this._attachHandlers();
        this.reset();
        this._proxiedCancelHandler = this._cancelHandler.bind(this);
        this._proxiedAcceptHandler = this._acceptHandler.bind(this)
    },
    _attachHandlers: function() {
        $(document).on(eventUtils.addNamespace(pointerEvents.down, MANAGER_EVENT), this._pointerDownHandler.bind(this)).on(eventUtils.addNamespace(pointerEvents.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this)).on(eventUtils.addNamespace([pointerEvents.up, pointerEvents.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this)).on(eventUtils.addNamespace(wheelEvent.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this))
    },
    _eachEmitter: function(callback) {
        var activeEmitters = this._activeEmitters || [];
        var i = 0;
        while (activeEmitters.length > i) {
            var emitter = activeEmitters[i];
            if (false === callback(emitter)) {
                break
            }
            if (activeEmitters[i] === emitter) {
                i++
            }
        }
    },
    _applyToEmitters: function(method, arg) {
        this._eachEmitter(function(emitter) {
            emitter[method].call(emitter, arg)
        })
    },
    reset: function() {
        this._eachEmitter(this._proxiedCancelHandler);
        this._activeEmitters = []
    },
    resetEmitter: function(emitter) {
        this._proxiedCancelHandler(emitter)
    },
    _pointerDownHandler: function(e) {
        if (eventUtils.isMouseEvent(e) && e.which > 1) {
            return
        }
        this._updateEmitters(e)
    },
    _updateEmitters: function(e) {
        if (!this._isSetChanged(e)) {
            return
        }
        this._cleanEmitters(e);
        this._fetchEmitters(e)
    },
    _isSetChanged: function(e) {
        var currentSet = this._closestEmitter(e);
        var previousSet = this._emittersSet || [];
        var setChanged = currentSet.length !== previousSet.length;
        $.each(currentSet, function(index, emitter) {
            setChanged = setChanged || previousSet[index] !== emitter;
            return !setChanged
        });
        this._emittersSet = currentSet;
        return setChanged
    },
    _closestEmitter: function(e) {
        var that = this,
            result = [],
            $element = $(e.target);

        function handleEmitter(_, emitter) {
            if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                emitter.addCancelCallback(that._proxiedCancelHandler);
                emitter.addAcceptCallback(that._proxiedAcceptHandler);
                result.push(emitter)
            }
        }
        while ($element.length) {
            var emitters = $.data($element.get(0), EMITTER_DATA) || [];
            $.each(emitters, handleEmitter);
            $element = $element.parent()
        }
        return result
    },
    _acceptHandler: function(acceptedEmitter, e) {
        var that = this;
        this._eachEmitter(function(emitter) {
            if (emitter !== acceptedEmitter) {
                that._cancelEmitter(emitter, e)
            }
        })
    },
    _cancelHandler: function(canceledEmitter, e) {
        this._cancelEmitter(canceledEmitter, e)
    },
    _cancelEmitter: function(emitter, e) {
        var activeEmitters = this._activeEmitters;
        if (e) {
            emitter.cancel(e)
        } else {
            emitter.reset()
        }
        emitter.removeCancelCallback();
        emitter.removeAcceptCallback();
        var emitterIndex = inArray(emitter, activeEmitters);
        if (emitterIndex > -1) {
            activeEmitters.splice(emitterIndex, 1)
        }
    },
    _cleanEmitters: function(e) {
        this._applyToEmitters("end", e);
        this.reset(e)
    },
    _fetchEmitters: function(e) {
        this._activeEmitters = this._emittersSet.slice();
        this._applyToEmitters("start", e)
    },
    _pointerMoveHandler: function(e) {
        this._applyToEmitters("move", e)
    },
    _pointerUpHandler: function(e) {
        this._updateEmitters(e)
    },
    _mouseWheelHandler: function(e) {
        if (!this._allowInterruptionByMouseWheel()) {
            return
        }
        e.pointers = [null];
        this._pointerDownHandler(e);
        this._adjustWheelEvent(e);
        this._pointerMoveHandler(e);
        e.pointers = [];
        this._pointerUpHandler(e)
    },
    _allowInterruptionByMouseWheel: function() {
        var allowInterruption = true;
        this._eachEmitter(function(emitter) {
            allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
            return allowInterruption
        });
        return allowInterruption
    },
    _adjustWheelEvent: function(e) {
        var closestGestureEmitter = null;
        this._eachEmitter(function(emitter) {
            if (!emitter.gesture) {
                return
            }
            var direction = emitter.getDirection(e);
            if ("horizontal" !== direction && !e.shiftKey || "vertical" !== direction && e.shiftKey) {
                closestGestureEmitter = emitter;
                return false
            }
        });
        if (!closestGestureEmitter) {
            return
        }
        var direction = closestGestureEmitter.getDirection(e),
            verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction,
            prop = verticalGestureDirection ? "pageY" : "pageX";
        e[prop] += e.delta
    },
    isActive: function(element) {
        var result = false;
        this._eachEmitter(function(emitter) {
            result = result || emitter.getElement().is(element)
        });
        return result
    }
});
var eventManager = new EventManager;
var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
var registerEmitter = function(emitterConfig) {
    var emitterClass = emitterConfig.emitter,
        emitterName = emitterConfig.events[0],
        emitterEvents = emitterConfig.events;
    $.each(emitterEvents, function(_, eventName) {
        registerEvent(eventName, {
            noBubble: !emitterConfig.bubble,
            setup: function(element) {
                var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA) || {},
                    emitters = $.data(element, EMITTER_DATA) || {},
                    emitter = emitters[emitterName] || new emitterClass(element);
                subscriptions[eventName] = true;
                emitters[emitterName] = emitter;
                $.data(element, EMITTER_DATA, emitters);
                $.data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions)
            },
            add: function(element, handleObj) {
                var emitters = $.data(element, EMITTER_DATA),
                    emitter = emitters[emitterName];
                emitter.configure(extend({
                    delegateSelector: handleObj.selector
                }, handleObj.data), handleObj.type)
            },
            teardown: function(element) {
                var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA),
                    emitters = $.data(element, EMITTER_DATA),
                    emitter = emitters[emitterName];
                delete subscriptions[eventName];
                var disposeEmitter = true;
                $.each(emitterEvents, function(_, eventName) {
                    disposeEmitter = disposeEmitter && !subscriptions[eventName];
                    return disposeEmitter
                });
                if (disposeEmitter) {
                    if (eventManager.isActive(element)) {
                        eventManager.resetEmitter(emitter)
                    }
                    emitter && emitter.dispose();
                    delete emitters[emitterName]
                }
            }
        })
    })
};
module.exports = registerEmitter;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/ui.template_base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    triggerShownEvent = __webpack_require__(15).triggerShownEvent,
    Class = __webpack_require__(5),
    abstract = Class.abstract;
var renderedCallbacks = $.Callbacks();
var TemplateBase = Class.inherit({
    render: function(options) {
        options = options || {};
        var $result = this._renderCore(options);
        this._ensureResultInContainer($result, options.container);
        renderedCallbacks.fire($result, options.container);
        return $result
    },
    _ensureResultInContainer: function($result, $container) {
        if (!$container) {
            return
        }
        var resultInContainer = $.contains($container.get(0), $result.get(0));
        $container.append($result);
        if (resultInContainer) {
            return
        }
        var resultInBody = $.contains(document.body, $container.get(0));
        if (!resultInBody) {
            return
        }
        triggerShownEvent($result)
    },
    _renderCore: abstract
});
module.exports = TemplateBase;
module.exports.renderedCallbacks = renderedCallbacks;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/view_cache.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    inArray = __webpack_require__(7).inArray,
    Class = __webpack_require__(5),
    EventsMixin = __webpack_require__(38);
var ViewCache = Class.inherit({
    ctor: function() {
        this._cache = {}
    },
    setView: function(key, viewInfo) {
        this._cache[key] = viewInfo
    },
    getView: function(key) {
        return this._cache[key]
    },
    removeView: function(key) {
        var result = this._cache[key];
        if (result) {
            delete this._cache[key];
            this.fireEvent("viewRemoved", [{
                viewInfo: result
            }])
        }
        return result
    },
    clear: function() {
        var that = this;
        $.each(this._cache, function(key) {
            that.removeView(key)
        })
    },
    hasView: function(key) {
        return key in this._cache
    }
}).include(EventsMixin);
var NullViewCache = ViewCache.inherit({
    setView: function(key, viewInfo) {
        this.callBase(key, viewInfo);
        this.removeView(key)
    }
});

function delegateEvent(eventName, source, target) {
    source.on(eventName, function() {
        target.fireEvent(eventName, arguments)
    })
}
var ConditionalViewCacheDecorator = Class.inherit({
    ctor: function(options) {
        this._filter = options.filter;
        this._viewCache = options.viewCache;
        this.viewRemoved = this._viewCache.viewRemoved;
        delegateEvent("viewRemoved", this._viewCache, this)
    },
    setView: function(key, viewInfo) {
        this._viewCache.setView(key, viewInfo);
        if (!this._filter(key, viewInfo)) {
            this._viewCache.removeView(key)
        }
    },
    getView: function(key) {
        return this._viewCache.getView(key)
    },
    removeView: function(key) {
        return this._viewCache.removeView(key)
    },
    clear: function() {
        return this._viewCache.clear()
    },
    hasView: function(key) {
        return this._viewCache.hasView(key)
    }
}).include(EventsMixin);
var DEFAULT_VIEW_CACHE_CAPACITY = 5;
var CapacityViewCacheDecorator = Class.inherit({
    ctor: function(options) {
        this._keys = [];
        this._size = options.size || DEFAULT_VIEW_CACHE_CAPACITY;
        this._viewCache = options.viewCache;
        this.viewRemoved = this._viewCache.viewRemoved;
        delegateEvent("viewRemoved", this._viewCache, this)
    },
    setView: function(key, viewInfo) {
        if (!this.hasView(key)) {
            if (this._keys.length === this._size) {
                this.removeView(this._keys[0])
            }
            this._keys.push(key)
        }
        this._viewCache.setView(key, viewInfo)
    },
    getView: function(key) {
        var index = inArray(key, this._keys);
        if (index < 0) {
            return null
        }
        this._keys.push(key);
        this._keys.splice(index, 1);
        return this._viewCache.getView(key)
    },
    removeView: function(key) {
        var index = inArray(key, this._keys);
        if (index > -1) {
            this._keys.splice(index, 1)
        }
        return this._viewCache.removeView(key)
    },
    clear: function() {
        this._keys = [];
        return this._viewCache.clear()
    },
    hasView: function(key) {
        return this._viewCache.hasView(key)
    }
}).include(EventsMixin);
var HistoryDependentViewCacheDecorator = Class.inherit({
    ctor: function(options) {
        this._viewCache = options.viewCache || new ViewCache;
        this._navigationManager = options.navigationManager;
        this._navigationManager.on("itemRemoved", this._onNavigationItemRemoved.bind(this));
        this.viewRemoved = this._viewCache.viewRemoved;
        delegateEvent("viewRemoved", this._viewCache, this)
    },
    _onNavigationItemRemoved: function(item) {
        this.removeView(item.key)
    },
    setView: function(key, viewInfo) {
        this._viewCache.setView(key, viewInfo)
    },
    getView: function(key) {
        return this._viewCache.getView(key)
    },
    removeView: function(key) {
        return this._viewCache.removeView(key)
    },
    clear: function() {
        return this._viewCache.clear()
    },
    hasView: function(key) {
        return this._viewCache.hasView(key)
    }
}).include(EventsMixin);
module.exports = ViewCache;
module.exports.NullViewCache = NullViewCache;
module.exports.ConditionalViewCacheDecorator = ConditionalViewCacheDecorator;
module.exports.CapacityViewCacheDecorator = CapacityViewCacheDecorator;
module.exports.HistoryDependentViewCacheDecorator = HistoryDependentViewCacheDecorator;
module.exports.default = module.exports;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/hold.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var eventUtils = __webpack_require__(3),
    Emitter = __webpack_require__(89),
    registerEmitter = __webpack_require__(63),
    abs = Math.abs;
var HOLD_EVENT_NAME = "dxhold",
    HOLD_TIMEOUT = 750,
    TOUCH_BOUNDARY = 5;
var HoldEmitter = Emitter.inherit({
    start: function(e) {
        this._startEventData = eventUtils.eventData(e);
        this._startTimer(e)
    },
    _startTimer: function(e) {
        var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
        this._holdTimer = setTimeout(function() {
            this._requestAccept(e);
            this._fireEvent(HOLD_EVENT_NAME, e, {
                target: e.target
            });
            this._forgetAccept()
        }.bind(this), holdTimeout)
    },
    move: function(e) {
        if (this._touchWasMoved(e)) {
            this._cancel(e)
        }
    },
    _touchWasMoved: function(e) {
        var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
        return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
    },
    end: function() {
        this._stopTimer()
    },
    _stopTimer: function() {
        clearTimeout(this._holdTimer)
    },
    cancel: function() {
        this._stopTimer()
    },
    dispose: function() {
        this._stopTimer()
    }
});
registerEmitter({
    emitter: HoldEmitter,
    bubble: true,
    events: [HOLD_EVENT_NAME]
});
module.exports = {
    name: HOLD_EVENT_NAME
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/array_store.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    typeUtils = __webpack_require__(9),
    Guid = __webpack_require__(34),
    objectUtils = __webpack_require__(84),
    keysEqual = __webpack_require__(28).keysEqual,
    Query = __webpack_require__(35),
    errors = __webpack_require__(29).errors,
    Store = __webpack_require__(96);
var hasKey = function(target, keyOrKeys) {
    var key, keys = $.makeArray(keyOrKeys);
    while (keys.length) {
        key = keys.shift();
        if (key in target) {
            return true
        }
    }
    return false
};
var trivialPromise = function() {
    var d = $.Deferred();
    return d.resolve.apply(d, arguments).promise()
};
var rejectedPromise = function() {
    var d = $.Deferred();
    return d.reject.apply(d, arguments).promise()
};
var ArrayStore = Store.inherit({
    ctor: function(options) {
        if (Array.isArray(options)) {
            options = {
                data: options
            }
        } else {
            options = options || {}
        }
        this.callBase(options);
        var initialArray = options.data;
        if (initialArray && !Array.isArray(initialArray)) {
            throw errors.Error("E4006")
        }
        this._array = initialArray || []
    },
    createQuery: function() {
        return Query(this._array, {
            errorHandler: this._errorHandler
        })
    },
    _byKeyImpl: function(key) {
        var index = this._indexByKey(key);
        if (index === -1) {
            return rejectedPromise(errors.Error("E4009"))
        }
        return trivialPromise(this._array[index])
    },
    _insertImpl: function(values) {
        var keyValue, obj, keyExpr = this.key();
        if (typeUtils.isPlainObject(values)) {
            obj = extend({}, values)
        } else {
            obj = values
        }
        if (keyExpr) {
            keyValue = this.keyOf(obj);
            if (void 0 === keyValue || "object" === typeof keyValue && typeUtils.isEmptyObject(keyValue)) {
                if (Array.isArray(keyExpr)) {
                    throw errors.Error("E4007")
                }
                keyValue = obj[keyExpr] = String(new Guid)
            } else {
                if (void 0 !== this._array[this._indexByKey(keyValue)]) {
                    return rejectedPromise(errors.Error("E4008"))
                }
            }
        } else {
            keyValue = obj
        }
        this._array.push(obj);
        return trivialPromise(values, keyValue)
    },
    _updateImpl: function(key, values) {
        var index, target, keyExpr = this.key(),
            extendComplexObject = true;
        if (keyExpr) {
            if (hasKey(values, keyExpr) && !keysEqual(keyExpr, key, this.keyOf(values))) {
                return rejectedPromise(errors.Error("E4017"))
            }
            index = this._indexByKey(key);
            if (index < 0) {
                return rejectedPromise(errors.Error("E4009"))
            }
            target = this._array[index]
        } else {
            target = key
        }
        objectUtils.deepExtendArraySafe(target, values, extendComplexObject);
        return trivialPromise(key, values)
    },
    _removeImpl: function(key) {
        var index = this._indexByKey(key);
        if (index > -1) {
            this._array.splice(index, 1)
        }
        return trivialPromise(key)
    },
    _indexByKey: function(key) {
        for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++) {
            if (keysEqual(this.key(), this.keyOf(this._array[i]), key)) {
                return i
            }
        }
        return -1
    },
    clear: function() {
        this.fireEvent("modifying");
        this._array = [];
        this.fireEvent("modified")
    }
}, "array");
module.exports = ArrayStore;
module.exports.default = module.exports;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/popup.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    camelize = __webpack_require__(36).camelize,
    commonUtils = __webpack_require__(2),
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    Button = __webpack_require__(25),
    themes = __webpack_require__(20),
    Overlay = __webpack_require__(39),
    EmptyTemplate = __webpack_require__(138),
    domUtils = __webpack_require__(15);
__webpack_require__(188);
var POPUP_CLASS = "dx-popup",
    POPUP_WRAPPER_CLASS = "dx-popup-wrapper",
    POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen",
    POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width",
    POPUP_NORMAL_CLASS = "dx-popup-normal",
    POPUP_CONTENT_CLASS = "dx-popup-content",
    POPUP_DRAGGABLE_CLASS = "dx-popup-draggable",
    POPUP_TITLE_CLASS = "dx-popup-title",
    POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton",
    POPUP_BOTTOM_CLASS = "dx-popup-bottom",
    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
    ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var getButtonPlace = function(name) {
    var device = devices.current(),
        platform = device.platform,
        toolbar = "bottom",
        location = "before";
    if ("ios" === platform) {
        switch (name) {
            case "cancel":
                toolbar = "top";
                break;
            case "clear":
                toolbar = "top";
                location = "after";
                break;
            case "done":
                location = "after"
        }
    } else {
        if ("win" === platform) {
            location = "after"
        } else {
            if ("android" === platform && device.version && parseInt(device.version[0]) > 4) {
                switch (name) {
                    case "cancel":
                        location = "after";
                        break;
                    case "done":
                        location = "after"
                }
            } else {
                if ("android" === platform) {
                    location = "center"
                }
            }
        }
    }
    return {
        toolbar: toolbar,
        location: location
    }
};
var Popup = Overlay.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            fullScreen: false,
            title: "",
            showTitle: true,
            titleTemplate: "title",
            onTitleRendered: null,
            dragEnabled: false,
            toolbarItems: [],
            showCloseButton: false,
            bottomTemplate: "bottom"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var currentTheme = (themes.current() || "").split(".")[0];
                return "win8" === currentTheme
            },
            options: {
                width: function() {
                    return $(window).width()
                }
            }
        }, {
            device: function(device) {
                var currentTheme = (themes.current() || "").split(".")[0];
                return device.phone && "win8" === currentTheme
            },
            options: {
                position: {
                    my: "top center",
                    at: "top center",
                    offset: "0 0"
                }
            }
        }, {
            device: {
                platform: "ios"
            },
            options: {
                animation: this._iosAnimation
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                animation: this._androidAnimation
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                showCloseButton: true
            }
        }, {
            device: function(device) {
                return "generic" === devices.real().platform && "generic" === device.platform
            },
            options: {
                dragEnabled: true
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            buttons: {
                since: "16.1",
                alias: "toolbarItems"
            }
        })
    },
    _iosAnimation: {
        show: {
            type: "slide",
            duration: 400,
            from: {
                position: {
                    my: "top",
                    at: "bottom"
                }
            },
            to: {
                position: {
                    my: "center",
                    at: "center"
                }
            }
        },
        hide: {
            type: "slide",
            duration: 400,
            from: {
                opacity: 1,
                position: {
                    my: "center",
                    at: "center"
                }
            },
            to: {
                opacity: 1,
                position: {
                    my: "top",
                    at: "bottom"
                }
            }
        }
    },
    _androidAnimation: function() {
        var fullScreenConfig = {
                show: {
                    type: "slide",
                    duration: 300,
                    from: {
                        top: "30%",
                        opacity: 0
                    },
                    to: {
                        top: 0,
                        opacity: 1
                    }
                },
                hide: {
                    type: "slide",
                    duration: 300,
                    from: {
                        top: 0,
                        opacity: 1
                    },
                    to: {
                        top: "30%",
                        opacity: 0
                    }
                }
            },
            defaultConfig = {
                show: {
                    type: "fade",
                    duration: 400,
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    duration: 400,
                    from: 1,
                    to: 0
                }
            };
        return this.option("fullScreen") ? fullScreenConfig : defaultConfig
    },
    _init: function() {
        this.callBase();
        this.element().addClass(POPUP_CLASS);
        this._wrapper().addClass(POPUP_WRAPPER_CLASS);
        this._$popupContent = this._$content.wrapInner($("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0)
    },
    _render: function() {
        var isFullscreen = this.option("fullScreen");
        this._toggleFullScreenClass(isFullscreen);
        this.callBase()
    },
    _toggleFullScreenClass: function(value) {
        this._$content.toggleClass(POPUP_FULL_SCREEN_CLASS, value).toggleClass(POPUP_NORMAL_CLASS, !value)
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.title = new EmptyTemplate(this);
        this._defaultTemplates.bottom = new EmptyTemplate(this)
    },
    _renderContentImpl: function() {
        this.callBase();
        this._renderTitle();
        this._renderBottom()
    },
    _renderTitle: function() {
        var items = this._getToolbarItems("top"),
            titleText = this.option("title"),
            showTitle = this.option("showTitle");
        if (showTitle && !!titleText) {
            items.unshift({
                location: devices.current().ios ? "center" : "before",
                text: titleText
            })
        }
        if (showTitle || items.length > 0) {
            this._$title && this._$title.remove();
            var $title = $("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.content());
            this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
            this._renderDrag();
            this._executeTitleRenderAction(this._$title)
        } else {
            if (this._$title) {
                this._$title.detach()
            }
        }
    },
    _renderTemplateByType: function(optionName, data, $container) {
        var template = this._getTemplateByOption(optionName),
            toolbarTemplate = template instanceof EmptyTemplate;
        if (toolbarTemplate) {
            var toolbarOptions = {
                items: data,
                rtlEnabled: this.option("rtlEnabled")
            };
            this._getTemplate("dx-polymorph-widget").render({
                container: $container,
                model: {
                    widget: "dxToolbarBase",
                    options: toolbarOptions
                }
            });
            var $toolbar = $container.children("div");
            $container.replaceWith($toolbar);
            return $toolbar
        } else {
            var $result = template.render({
                container: $container
            });
            if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                $container.replaceWith($result);
                $container = $result
            }
            return $container
        }
    },
    _executeTitleRenderAction: function(titleElement) {
        this._getTitleRenderAction()({
            titleElement: titleElement
        })
    },
    _getTitleRenderAction: function() {
        return this._titleRenderAction || this._createTitleRenderAction()
    },
    _createTitleRenderAction: function() {
        return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
            element: this.element(),
            excludeValidators: ["designMode", "disabled", "readOnly"]
        })
    },
    _getCloseButton: function() {
        return {
            toolbar: "top",
            location: "after",
            template: this._getCloseButtonRenderer()
        }
    },
    _getCloseButtonRenderer: function() {
        return function(_, __, $container) {
            var $button = $("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
            this._createComponent($button, Button, {
                icon: "close",
                onClick: this._createToolbarItemAction(void 0),
                integrationOptions: {}
            });
            $container.append($button)
        }.bind(this)
    },
    _getToolbarItems: function(toolbar) {
        var toolbarItems = this.option("toolbarItems");
        var toolbarsItems = [];
        this._toolbarItemClasses = [];
        var currentPlatform = devices.current().platform,
            index = 0;
        $.each(toolbarItems, function(_, data) {
            var isShortcut = commonUtils.isDefined(data.shortcut),
                item = isShortcut ? getButtonPlace(data.shortcut) : data;
            if (isShortcut && "ios" === currentPlatform && index < 2) {
                item.toolbar = "top";
                index++
            }
            item.toolbar = data.toolbar || item.toolbar || "top";
            if (item && item.toolbar === toolbar) {
                if (isShortcut) {
                    extend(item, {
                        location: data.location
                    }, this._getToolbarItemByAlias(data))
                }
                var isLTROrder = "win" === currentPlatform || "generic" === currentPlatform;
                if ("done" === data.shortcut && isLTROrder || "cancel" === data.shortcut && !isLTROrder) {
                    toolbarsItems.unshift(item)
                } else {
                    toolbarsItems.push(item)
                }
            }
        }.bind(this));
        if ("top" === toolbar && this.option("showCloseButton") && this.option("showTitle")) {
            toolbarsItems.push(this._getCloseButton())
        }
        return toolbarsItems
    },
    _getToolbarItemByAlias: function(data) {
        var that = this,
            itemType = data.shortcut;
        if (inArray(itemType, ALLOWED_TOOLBAR_ITEM_ALIASES) < 0) {
            return false
        }
        var itemConfig = extend({
            text: messageLocalization.format(camelize(itemType, true)),
            onClick: this._createToolbarItemAction(data.onClick),
            integrationOptions: {}
        }, data.options || {});
        var itemClass = POPUP_CLASS + "-" + itemType;
        this._toolbarItemClasses.push(itemClass);
        return {
            template: function(_, __, $container) {
                var $toolbarItem = $("<div>").addClass(itemClass).appendTo($container);
                that._createComponent($toolbarItem, Button, itemConfig)
            }
        }
    },
    _createToolbarItemAction: function(clickAction) {
        return this._createAction(clickAction, {
            afterExecute: function(e) {
                e.component.hide()
            }
        })
    },
    _renderBottom: function() {
        var items = this._getToolbarItems("bottom");
        if (items.length) {
            this._$bottom && this._$bottom.remove();
            var $bottom = $("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.content());
            this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom).addClass(POPUP_BOTTOM_CLASS);
            this._toggleClasses()
        } else {
            this._$bottom && this._$bottom.detach()
        }
    },
    _toggleClasses: function() {
        var aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
        $.each(aliases, function(_, alias) {
            var className = POPUP_CLASS + "-" + alias;
            if (inArray(className, this._toolbarItemClasses) >= 0) {
                this._wrapper().addClass(className + "-visible");
                this._$bottom.addClass(className)
            } else {
                this._wrapper().removeClass(className + "-visible");
                this._$bottom.removeClass(className)
            }
        }.bind(this))
    },
    _getDragTarget: function() {
        return this._$title
    },
    _renderGeometryImpl: function() {
        this._resetContentHeight();
        this.callBase.apply(this, arguments);
        this._setContentHeight()
    },
    _resetContentHeight: function() {
        this._$popupContent.css({
            height: "auto"
        })
    },
    _renderDrag: function() {
        this.callBase();
        this._$content.toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"))
    },
    _renderResize: function() {
        this.callBase();
        this._$content.dxResizable("option", "onResize", function() {
            this._setContentHeight();
            this._actions.onResize(arguments)
        }.bind(this))
    },
    _setContentHeight: function() {
        (this.option("forceApplyBindings") || $.noop)();
        if (this._disallowUpdateContentHeight()) {
            return
        }
        var contentPaddings = this._$content.outerHeight() - this._$content.height(),
            contentHeight = this._$content.get(0).getBoundingClientRect().height - contentPaddings;
        if (this._$title && this._$title.is(":visible")) {
            contentHeight -= this._$title.get(0).getBoundingClientRect().height || 0
        }
        if (this._$bottom && this._$bottom.is(":visible")) {
            contentHeight -= this._$bottom.get(0).getBoundingClientRect().height || 0
        }
        this._$popupContent.css({
            height: contentHeight
        })
    },
    _disallowUpdateContentHeight: function() {
        var isHeightAuto = "auto" === this._$content.get(0).style.height,
            maxHeightSpecified = "none" !== this._$content.css("maxHeight"),
            minHeightSpecified = parseInt(this._$content.css("minHeight")) > 0;
        return isHeightAuto && !(maxHeightSpecified || minHeightSpecified)
    },
    _renderDimensions: function() {
        if (this.option("fullScreen")) {
            this._$content.css({
                width: "100%",
                height: "100%"
            })
        } else {
            this.callBase.apply(this, arguments)
        }
        this._renderFullscreenWidthClass()
    },
    _renderFullscreenWidthClass: function() {
        this.overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.overlayContent().outerWidth() === $(window).width())
    },
    _renderShadingDimensions: function() {
        if (this.option("fullScreen")) {
            this._wrapper().css({
                width: "100%",
                height: "100%"
            })
        } else {
            this.callBase.apply(this, arguments)
        }
    },
    refreshPosition: function() {
        this._renderPosition()
    },
    _renderPosition: function() {
        if (this.option("fullScreen")) {
            translator.move(this._$content, {
                top: 0,
                left: 0
            })
        } else {
            (this.option("forceApplyBindings") || $.noop)();
            return this.callBase.apply(this, arguments)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "showTitle":
            case "title":
            case "titleTemplate":
                this._renderTitle();
                this._renderGeometry();
                break;
            case "bottomTemplate":
                this._renderBottom();
                this._renderGeometry();
                break;
            case "onTitleRendered":
                this._createTitleRenderAction(args.value);
                break;
            case "toolbarItems":
                this._renderTitle();
                this._renderBottom();
                this._renderGeometry();
                break;
            case "dragEnabled":
                this._renderDrag();
                break;
            case "fullScreen":
                this._toggleFullScreenClass(args.value);
                this._renderGeometry();
                domUtils.triggerResizeEvent(this._$content);
                break;
            case "showCloseButton":
                this._renderTitle();
                break;
            default:
                this.callBase(args)
        }
    },
    bottomToolbar: function() {
        return this._$bottom
    },
    content: function() {
        return this._$popupContent
    },
    overlayContent: function() {
        return this._$content
    }
});
registerComponent("dxPopup", Popup);
module.exports = Popup;
module.exports.default = module.exports;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(282);
module.exports.default = module.exports;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scrollable.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    browser = __webpack_require__(21),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    DOMComponent = __webpack_require__(45),
    selectors = __webpack_require__(92),
    eventUtils = __webpack_require__(3),
    scrollEvents = __webpack_require__(300),
    simulatedStrategy = __webpack_require__(199),
    NativeStrategy = __webpack_require__(125),
    when = __webpack_require__(10).when;
var SCROLLABLE = "dxScrollable",
    SCROLLABLE_STRATEGY = "dxScrollableStrategy",
    SCROLLABLE_CLASS = "dx-scrollable",
    SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled",
    SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container",
    SCROLLABLE_WRAPPER_CLASS = "dx-scrollable-wrapper",
    SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal",
    BOTH = "both";
var beforeActivateExists = void 0 !== document.onbeforeactivate;
var deviceDependentOptions = function() {
    return [{
        device: function() {
            return !support.nativeScrolling
        },
        options: {
            useNative: false
        }
    }, {
        device: function(device) {
            return !devices.isSimulator() && "generic" === devices.real().platform && "generic" === device.platform
        },
        options: {
            bounceEnabled: false,
            scrollByThumb: true,
            scrollByContent: support.touch,
            showScrollbar: "onHover"
        }
    }]
};
var Scrollable = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            disabled: false,
            onScroll: null,
            direction: VERTICAL,
            showScrollbar: "onScroll",
            useNative: true,
            bounceEnabled: true,
            scrollByContent: true,
            scrollByThumb: false,
            onUpdated: null,
            onStart: null,
            onEnd: null,
            onBounce: null,
            onStop: null,
            useSimulatedScrollbar: false,
            useKeyboard: true,
            inertiaEnabled: true,
            pushBackValue: 0,
            updateManually: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat(deviceDependentOptions(), [{
            device: function() {
                return support.nativeScrolling && "android" === devices.real().platform
            },
            options: {
                useSimulatedScrollbar: true
            }
        }, {
            device: function() {
                return "ios" === devices.real().platform
            },
            options: {
                pushBackValue: 1
            }
        }])
    },
    _initOptions: function(options) {
        this.callBase(options);
        if (!("useSimulatedScrollbar" in options)) {
            this._setUseSimulatedScrollbar()
        }
    },
    _setUseSimulatedScrollbar: function() {
        if (!this.initialOption("useSimulatedScrollbar")) {
            this.option("useSimulatedScrollbar", !this.option("useNative"))
        }
    },
    _init: function() {
        this.callBase();
        this._initMarkup();
        this._attachNativeScrollbarsCustomizationCss();
        this._locked = false
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this.update();
            this._toggleRTLDirection(this.option("rtlEnabled"));
            this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
            delete this._savedScrollOffset
        } else {
            this._savedScrollOffset = this.scrollOffset()
        }
    },
    _initMarkup: function() {
        var $element = this.element().addClass(SCROLLABLE_CLASS),
            $container = this._$container = $("<div>").addClass(SCROLLABLE_CONTAINER_CLASS),
            $wrapper = this._$wrapper = $("<div>").addClass(SCROLLABLE_WRAPPER_CLASS),
            $content = this._$content = $("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
        if (beforeActivateExists) {
            $element.on(eventUtils.addNamespace("beforeactivate", SCROLLABLE), function(e) {
                if (!$(e.target).is(selectors.focusable)) {
                    e.preventDefault()
                }
            })
        }
        $content.append($element.contents()).appendTo($container);
        $container.appendTo($wrapper);
        $wrapper.appendTo($element)
    },
    _dimensionChanged: function() {
        this.update()
    },
    _attachNativeScrollbarsCustomizationCss: function() {
        if ("desktop" === devices.real().deviceType && !(navigator.platform.indexOf("Mac") > -1 && browser.webkit)) {
            this.element().addClass("dx-scrollable-customizable-scrollbars")
        }
    },
    _render: function() {
        this._renderDirection();
        this._renderStrategy();
        this._attachEventHandlers();
        this._renderDisabledState();
        this._createActions();
        this.update();
        this.callBase();
        this._toggleRTLDirection(this.option("rtlEnabled"))
    },
    _toggleRTLDirection: function(rtl) {
        var that = this;
        this.callBase(rtl);
        this._updateBounds();
        if (rtl && this.option("direction") !== VERTICAL) {
            commonUtils.deferUpdate(function() {
                var left = that.scrollWidth() - that.clientWidth();
                commonUtils.deferRender(function() {
                    that.scrollTo({
                        left: left
                    })
                })
            })
        }
    },
    _updateBounds: function() {
        this._strategy.updateBounds()
    },
    _attachEventHandlers: function() {
        var strategy = this._strategy;
        var initEventData = {
            getDirection: strategy.getDirection.bind(strategy),
            validate: this._validate.bind(this),
            isNative: this.option("useNative"),
            scrollTarget: this._$container
        };
        this._$wrapper.off("." + SCROLLABLE).on(eventUtils.addNamespace(scrollEvents.init, SCROLLABLE), initEventData, this._initHandler.bind(this)).on(eventUtils.addNamespace(scrollEvents.start, SCROLLABLE), strategy.handleStart.bind(strategy)).on(eventUtils.addNamespace(scrollEvents.move, SCROLLABLE), strategy.handleMove.bind(strategy)).on(eventUtils.addNamespace(scrollEvents.end, SCROLLABLE), strategy.handleEnd.bind(strategy)).on(eventUtils.addNamespace(scrollEvents.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy)).on(eventUtils.addNamespace(scrollEvents.stop, SCROLLABLE), strategy.handleStop.bind(strategy));
        this._$container.off("." + SCROLLABLE).on(eventUtils.addNamespace("scroll", SCROLLABLE), strategy.handleScroll.bind(strategy))
    },
    _validate: function(e) {
        if (this._isLocked()) {
            return false
        }
        this._updateIfNeed();
        return this._strategy.validate(e)
    },
    _initHandler: function() {
        var strategy = this._strategy;
        strategy.handleInit.apply(strategy, arguments)
    },
    _renderDisabledState: function() {
        this.element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
        if (this.option("disabled")) {
            this._lock()
        } else {
            this._unlock()
        }
    },
    _renderDirection: function() {
        this.element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"))
    },
    _renderStrategy: function() {
        this._createStrategy();
        this._strategy.render();
        this.element().data(SCROLLABLE_STRATEGY, this._strategy)
    },
    _createStrategy: function() {
        this._strategy = this.option("useNative") ? new NativeStrategy(this) : new simulatedStrategy.SimulatedStrategy(this)
    },
    _createActions: function() {
        this._strategy.createActions()
    },
    _clean: function() {
        this._strategy.dispose()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onStart":
            case "onEnd":
            case "onStop":
            case "onUpdated":
            case "onScroll":
            case "onBounce":
                this._createActions();
                break;
            case "direction":
                this._resetInactiveDirection();
                this._invalidate();
                break;
            case "useNative":
                this._setUseSimulatedScrollbar();
                this._invalidate();
                break;
            case "inertiaEnabled":
            case "scrollByContent":
            case "scrollByThumb":
            case "bounceEnabled":
            case "useKeyboard":
            case "showScrollbar":
            case "useSimulatedScrollbar":
            case "pushBackValue":
                this._invalidate();
                break;
            case "disabled":
                this._renderDisabledState();
                break;
            case "updateManually":
                break;
            default:
                this.callBase(args)
        }
    },
    _resetInactiveDirection: function() {
        var inactiveProp = this._getInactiveProp();
        if (!inactiveProp) {
            return
        }
        var scrollOffset = this.scrollOffset();
        scrollOffset[inactiveProp] = 0;
        this.scrollTo(scrollOffset)
    },
    _getInactiveProp: function() {
        var direction = this.option("direction");
        if (direction === VERTICAL) {
            return "left"
        }
        if (direction === HORIZONTAL) {
            return "top"
        }
    },
    _location: function() {
        return this._strategy.location()
    },
    _normalizeLocation: function(location) {
        if (typeUtils.isPlainObject(location)) {
            var left = commonUtils.ensureDefined(location.left, location.x);
            var top = commonUtils.ensureDefined(location.top, location.y);
            return {
                left: commonUtils.isDefined(left) ? -left : void 0,
                top: commonUtils.isDefined(top) ? -top : void 0
            }
        } else {
            var direction = this.option("direction");
            return {
                left: direction !== VERTICAL ? -location : void 0,
                top: direction !== HORIZONTAL ? -location : void 0
            }
        }
    },
    _isLocked: function() {
        return this._locked
    },
    _lock: function() {
        this._locked = true
    },
    _unlock: function() {
        if (!this.option("disabled")) {
            this._locked = false
        }
    },
    _isDirection: function(direction) {
        var current = this.option("direction");
        if (direction === VERTICAL) {
            return current !== HORIZONTAL
        }
        if (direction === HORIZONTAL) {
            return current !== VERTICAL
        }
        return current === direction
    },
    _updateAllowedDirection: function() {
        var allowedDirections = this._strategy._allowedDirections();
        if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
            this._allowedDirectionValue = BOTH
        } else {
            if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
                this._allowedDirectionValue = HORIZONTAL
            } else {
                if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
                    this._allowedDirectionValue = VERTICAL
                } else {
                    this._allowedDirectionValue = null
                }
            }
        }
    },
    _allowedDirection: function() {
        return this._allowedDirectionValue
    },
    _container: function() {
        return this._$container
    },
    content: function() {
        return this._$content
    },
    scrollOffset: function() {
        var location = this._location();
        return {
            top: -location.top,
            left: -location.left
        }
    },
    scrollTop: function() {
        return this.scrollOffset().top
    },
    scrollLeft: function() {
        return this.scrollOffset().left
    },
    clientHeight: function() {
        return this._$container.height()
    },
    scrollHeight: function() {
        return this.content().outerHeight() - 2 * this._strategy.verticalOffset()
    },
    clientWidth: function() {
        return this._$container.width()
    },
    scrollWidth: function() {
        return this.content().outerWidth()
    },
    update: function() {
        var that = this;
        return when(that._strategy.update()).done(function() {
            that._updateAllowedDirection()
        })
    },
    scrollBy: function(distance) {
        distance = this._normalizeLocation(distance);
        if (!distance.top && !distance.left) {
            return
        }
        this._updateIfNeed();
        this._strategy.scrollBy(distance)
    },
    scrollTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        this._updateIfNeed();
        var location = this._location();
        var distance = this._normalizeLocation({
            left: location.left - commonUtils.ensureDefined(targetLocation.left, location.left),
            top: location.top - commonUtils.ensureDefined(targetLocation.top, location.top)
        });
        if (!distance.top && !distance.left) {
            return
        }
        this._strategy.scrollBy(distance)
    },
    scrollToElement: function(element, offset) {
        offset = offset || {};
        var $element = $(element);
        var elementInsideContent = this.content().find(element).length;
        var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
        if (!elementInsideContent || !elementIsInsideContent) {
            return
        }
        var scrollPosition = {
            top: 0,
            left: 0
        };
        var direction = this.option("direction");
        if (direction !== VERTICAL) {
            scrollPosition.left = this._scrollToElementPosition($element, HORIZONTAL, offset)
        }
        if (direction !== HORIZONTAL) {
            scrollPosition.top = this._scrollToElementPosition($element, VERTICAL, offset)
        }
        this.scrollTo(scrollPosition)
    },
    _scrollToElementPosition: function($element, direction, offset) {
        var isVertical = direction === VERTICAL;
        var startOffset = (isVertical ? offset.top : offset.left) || 0;
        var endOffset = (isVertical ? offset.bottom : offset.right) || 0;
        var pushBackOffset = isVertical ? this._strategy.verticalOffset() : 0;
        var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? "top" : "left");
        var elementPosition = elementPositionRelativeToContent - pushBackOffset;
        var elementSize = $element[isVertical ? "outerHeight" : "outerWidth"]();
        var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();
        var clientSize = isVertical ? this.clientHeight() : this.clientWidth();
        var startDistance = scrollLocation - elementPosition + startOffset;
        var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;
        if (startDistance <= 0 && endDistance >= 0) {
            return scrollLocation
        }
        return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance)
    },
    _elementPositionRelativeToContent: function($element, prop) {
        var result = 0;
        while (this._hasScrollContent($element)) {
            result += $element.position()[prop];
            $element = $element.offsetParent()
        }
        return result
    },
    _hasScrollContent: function($element) {
        var $content = this.content();
        return $element.closest($content).length && !$element.is($content)
    },
    _updateIfNeed: function() {
        if (!this.option("updateManually")) {
            this.update()
        }
    }
});
registerComponent(SCROLLABLE, Scrollable);
module.exports = Scrollable;
module.exports.deviceDependentOptions = deviceDependentOptions;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/date_serialization.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var config = __webpack_require__(31),
    commonUtils = __webpack_require__(2),
    isString = commonUtils.isString,
    isDate = commonUtils.isDate,
    isNumber = commonUtils.isNumeric;
var NUMBER_SERIALIZATION_FORMAT = "number",
    DATE_SERIALIZATION_FORMAT = "yyyy/MM/dd",
    DATETIME_SERIALIZATION_FORMAT = "yyyy/MM/dd HH:mm:ss";
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([\+\-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];

function leftPad(text, length) {
    while (text.length < length) {
        text = "0" + text
    }
    return text
}
var LDML_FORMATTERS = {
    y: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCFullYear" : "getFullYear"]().toString(), count)
    },
    M: function(date, count, useUtc) {
        return leftPad((date[useUtc ? "getUTCMonth" : "getMonth"]() + 1).toString(), Math.min(count, 2))
    },
    d: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2))
    },
    H: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2))
    },
    m: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2))
    },
    s: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2))
    },
    S: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count)
    },
    x: function(date, count, useUtc) {
        var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset(),
            signPart = timezoneOffset > 0 ? "-" : "+",
            timezoneOffsetAbs = Math.abs(timezoneOffset),
            hours = Math.floor(timezoneOffsetAbs / 60),
            minutes = timezoneOffsetAbs % 60,
            hoursPart = leftPad(hours.toString(), 2),
            minutesPart = leftPad(minutes.toString(), 2);
        return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "")
    },
    X: function(date, count, useUtc) {
        if (useUtc || !date.getTimezoneOffset()) {
            return "Z"
        }
        return LDML_FORMATTERS.x(date, count, useUtc)
    },
    Z: function(date, count, useUtc) {
        return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc)
    }
};
var formatDate = function(date, format) {
    var charIndex, formatter, char, isCurrentCharEqualsNext, charCount = 0,
        separator = "'",
        isEscaping = false,
        result = "";
    if (!date) {
        return null
    }
    if (!format) {
        return date
    }
    var useUtc = "Z" === format[format.length - 1] || "'Z'" === format.slice(-3);
    for (charIndex = 0; charIndex < format.length; charIndex++) {
        char = format[charIndex];
        formatter = LDML_FORMATTERS[char];
        isCurrentCharEqualsNext = char === format[charIndex + 1];
        charCount++;
        if (!isCurrentCharEqualsNext) {
            if (formatter && !isEscaping) {
                result += formatter(date, charCount, useUtc)
            }
            charCount = 0
        }
        if (char === separator && !isCurrentCharEqualsNext) {
            isEscaping = !isEscaping
        } else {
            if (isEscaping || !formatter) {
                result += char
            }
        }
        if (char === separator && isCurrentCharEqualsNext) {
            charIndex++
        }
    }
    return result
};
var dateParser = function(text, skipISO8601Parsing) {
    var result;
    var parsedValue;
    if (isString(text) && !skipISO8601Parsing) {
        result = parseISO8601String(text)
    }
    if (!result) {
        parsedValue = !isDate(text) && Date.parse(text);
        result = isNumber(parsedValue) ? new Date(parsedValue) : text
    }
    return result
};
var parseISO8601String = function(text) {
    var parts = text.match(ISO8601_PATTERN);
    var timePart = function(part) {
        return +part || 0
    };
    if (!parts) {
        parts = text.match(ISO8601_TIME_PATTERN);
        if (parts) {
            return new Date(0, 0, 0, timePart(parts[1]), timePart(parts[2]), timePart(parts[4]))
        }
        return
    }
    var year = parts[1],
        month = --parts[3],
        day = parts[5],
        timeZoneHour = 0,
        timeZoneMinute = 0;
    timeZoneHour = timePart(parts[14]);
    timeZoneMinute = timePart(parts[16]);
    if ("-" === parts[13]) {
        timeZoneHour = -timeZoneHour;
        timeZoneMinute = -timeZoneMinute
    }
    var hour = timePart(parts[6]) - timeZoneHour,
        minute = timePart(parts[8]) - timeZoneMinute,
        second = timePart(parts[10]),
        millisecond = timePart(parts[11]);
    if (!!parts[12]) {
        return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond))
    }
    return new Date(year, month, day, hour, minute, second, millisecond)
};
var getIso8601Format = function(text, useUtc) {
    var parts = text.match(ISO8601_PATTERN),
        result = "";
    if (!parts) {
        parts = text.match(ISO8601_TIME_PATTERN);
        if (parts) {
            return parts[3] ? "HH:mm:ss" : "HH:mm"
        }
        return
    }
    for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
        if (parts[i]) {
            result += ISO8601_PATTERN_PARTS[i] || parts[i]
        }
    }
    if ("Z" === parts[12]) {
        result += "'Z'"
    }
    if (parts[14]) {
        if (parts[15]) {
            result += "xxx"
        } else {
            if (parts[16]) {
                result += "xx"
            } else {
                result += "x"
            }
        }
    }
    return result
};
var deserializeDate = function(value) {
    if ("number" === typeof value) {
        return new Date(value)
    }
    return dateParser(value, !config().forceIsoDateParsing)
};
var serializeDate = function(value, serializationFormat) {
    if (!serializationFormat) {
        return value
    }
    if (!isDate(value)) {
        return null
    }
    if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
        return value && value.valueOf ? value.valueOf() : null
    }
    return formatDate(value, serializationFormat)
};
var getDateSerializationFormat = function(value) {
    if ("number" === typeof value) {
        return NUMBER_SERIALIZATION_FORMAT
    } else {
        if (isString(value)) {
            var format;
            if (config().forceIsoDateParsing) {
                format = getIso8601Format(value)
            }
            if (format) {
                return format
            } else {
                if (value.indexOf(":") >= 0) {
                    return DATETIME_SERIALIZATION_FORMAT
                } else {
                    return DATE_SERIALIZATION_FORMAT
                }
            }
        } else {
            if (value) {
                return null
            }
        }
    }
};
module.exports = {
    dateParser: dateParser,
    deserializeDate: deserializeDate,
    serializeDate: serializeDate,
    getDateSerializationFormat: getDateSerializationFormat
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/dependency_injector.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = function(object) {
    var $ = __webpack_require__(0),
        extend = __webpack_require__(1).extend,
        isFunction = __webpack_require__(2).isFunction,
        Class = __webpack_require__(5);
    var BaseClass = Class.inherit(object),
        InjectedClass = BaseClass,
        instance = new InjectedClass(object),
        initialFields = {};
    var injectFields = function(injectionObject, initial) {
        $.each(injectionObject, function(key) {
            if (isFunction(instance[key])) {
                if (initial || !object[key]) {
                    object[key] = function() {
                        return instance[key].apply(object, arguments)
                    }
                }
            } else {
                if (initial) {
                    initialFields[key] = object[key]
                }
                object[key] = instance[key]
            }
        })
    };
    injectFields(object, true);
    object.inject = function(injectionObject) {
        InjectedClass = InjectedClass.inherit(injectionObject);
        instance = new InjectedClass;
        injectFields(injectionObject)
    };
    object.resetInjection = function() {
        extend(object, initialFields);
        InjectedClass = BaseClass;
        instance = new BaseClass
    };
    return object
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/public_component.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    WeakMap = __webpack_require__(248),
    commonUtils = __webpack_require__(2),
    removeEvent = __webpack_require__(86);
var COMPONENT_NAMES_DATA_KEY = "dxComponents",
    ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
var componentNames = new WeakMap,
    nextAnonymousComponent = 0;
var getName = exports.name = function(componentClass, newName) {
    if (commonUtils.isDefined(newName)) {
        componentNames.set(componentClass, newName);
        return
    }
    if (!componentNames.has(componentClass)) {
        var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
        componentNames.set(componentClass, generatedName);
        return generatedName
    }
    return componentNames.get(componentClass)
};
exports.attachInstanceToElement = function($element, componentInstance, disposeFn) {
    var data = $.data($element.get(0)),
        name = getName(componentInstance.constructor);
    data[name] = componentInstance;
    if (disposeFn) {
        $element.one(removeEvent, function() {
            disposeFn.call(componentInstance)
        })
    }
    if (!data[COMPONENT_NAMES_DATA_KEY]) {
        data[COMPONENT_NAMES_DATA_KEY] = []
    }
    data[COMPONENT_NAMES_DATA_KEY].push(name)
};
exports.getInstanceByElement = function($element, componentClass) {
    var name = getName(componentClass);
    return $.data($element.get(0), name)
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/child_default_template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var TemplateBase = __webpack_require__(64);
module.exports = TemplateBase.inherit({
    ctor: function(name) {
        this.name = name
    }
});


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/emitter.feedback.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    devices = __webpack_require__(6),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    Emitter = __webpack_require__(89),
    registerEmitter = __webpack_require__(63);
var ACTIVE_EVENT_NAME = "dxactive",
    INACTIVE_EVENT_NAME = "dxinactive",
    ACTIVE_TIMEOUT = 30,
    INACTIVE_TIMEOUT = 400;
var FeedbackEvent = Class.inherit({
    ctor: function(timeout, fire) {
        this._timeout = timeout;
        this._fire = fire
    },
    start: function() {
        var that = this;
        this._schedule(function() {
            that.force()
        })
    },
    _schedule: function(fn) {
        this.stop();
        this._timer = window.setTimeout(fn, this._timeout)
    },
    stop: function() {
        clearTimeout(this._timer)
    },
    force: function() {
        if (this._fired) {
            return
        }
        this.stop();
        this._fire();
        this._fired = true
    },
    fired: function() {
        return this._fired
    }
});
var activeFeedback;
var FeedbackEmitter = Emitter.inherit({
    ctor: function() {
        this.callBase.apply(this, arguments);
        this._active = new FeedbackEvent(0, commonUtils.noop);
        this._inactive = new FeedbackEvent(0, commonUtils.noop)
    },
    configure: function(data, eventName) {
        switch (eventName) {
            case ACTIVE_EVENT_NAME:
                data.activeTimeout = data.timeout;
                break;
            case INACTIVE_EVENT_NAME:
                data.inactiveTimeout = data.timeout
        }
        this.callBase(data)
    },
    start: function(e) {
        if (activeFeedback) {
            var activeChildExists = $.contains(this.getElement().get(0), activeFeedback.getElement().get(0));
            var childJustActivated = !activeFeedback._active.fired();
            if (activeChildExists && childJustActivated) {
                this._cancel();
                return
            }
            activeFeedback._inactive.force()
        }
        activeFeedback = this;
        this._initEvents(e);
        this._active.start()
    },
    _initEvents: function(e) {
        var that = this,
            eventTarget = this._getEmitterTarget(e),
            mouseEvent = eventUtils.isMouseEvent(e),
            isSimulator = devices.isSimulator(),
            deferFeedback = isSimulator || !mouseEvent,
            activeTimeout = commonUtils.ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT),
            inactiveTimeout = commonUtils.ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
        this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
            that._fireEvent(ACTIVE_EVENT_NAME, e, {
                target: eventTarget
            })
        });
        this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
            that._fireEvent(INACTIVE_EVENT_NAME, e, {
                target: eventTarget
            });
            activeFeedback = null
        })
    },
    cancel: function(e) {
        this.end(e)
    },
    end: function(e) {
        var skipTimers = e.type !== pointerEvents.up;
        if (skipTimers) {
            this._active.stop()
        } else {
            this._active.force()
        }
        this._inactive.start();
        if (skipTimers) {
            this._inactive.force()
        }
    },
    dispose: function() {
        this._active.stop();
        this._inactive.stop();
        this.callBase()
    },
    lockInactive: function() {
        this._active.force();
        this._inactive.stop();
        activeFeedback = null;
        this._cancel();
        return this._inactive.force.bind(this._inactive)
    }
});
FeedbackEmitter.lock = function(deferred) {
    var lockInactive = activeFeedback ? activeFeedback.lockInactive() : commonUtils.noop;
    deferred.done(lockInactive)
};
registerEmitter({
    emitter: FeedbackEmitter,
    events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
});
exports.lock = FeedbackEmitter.lock;
exports.active = ACTIVE_EVENT_NAME;
exports.inactive = INACTIVE_EVENT_NAME;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/drag.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    wrapToArray = __webpack_require__(7).wrapToArray,
    inArray = __webpack_require__(7).inArray,
    registerEvent = __webpack_require__(47),
    eventUtils = __webpack_require__(3),
    GestureEmitter = __webpack_require__(111),
    registerEmitter = __webpack_require__(63);
var DRAG_START_EVENT = "dxdragstart",
    DRAG_EVENT = "dxdrag",
    DRAG_END_EVENT = "dxdragend",
    DRAG_ENTER_EVENT = "dxdragenter",
    DRAG_LEAVE_EVENT = "dxdragleave",
    DROP_EVENT = "dxdrop";
var knownDropTargets = [],
    knownDropTargetSelectors = [],
    knownDropTargetConfigs = [];
var dropTargetRegistration = {
    setup: function(element, data) {
        var knownDropTarget = inArray(element, knownDropTargets) !== -1;
        if (!knownDropTarget) {
            knownDropTargets.push(element);
            knownDropTargetSelectors.push([]);
            knownDropTargetConfigs.push(data || {})
        }
    },
    add: function(element, handleObj) {
        var index = inArray(element, knownDropTargets);
        var selector = handleObj.selector;
        if (inArray(selector, knownDropTargetSelectors[index]) === -1) {
            knownDropTargetSelectors[index].push(selector)
        }
    },
    teardown: function(element) {
        var elementEvents = $._data(element, "events"),
            handlersCount = 0;
        $.each([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT], function(_, eventName) {
            var eventHandlers = elementEvents[eventName];
            if (eventHandlers) {
                handlersCount += eventHandlers.length
            }
        });
        if (!handlersCount) {
            var index = inArray(element, knownDropTargets);
            knownDropTargets.splice(index, 1);
            knownDropTargetSelectors.splice(index, 1);
            knownDropTargetConfigs.splice(index, 1)
        }
    }
};
registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
registerEvent(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
    var dropTargetIndex = inArray($element.get(0), knownDropTargets),
        dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex];
    var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
    if (inArray(void 0, dropTargetSelectors) !== -1) {
        $delegatedTargets = $delegatedTargets.add($element)
    }
    return $delegatedTargets
};
var getItemConfig = function($element) {
    var dropTargetIndex = inArray($element.get(0), knownDropTargets);
    return knownDropTargetConfigs[dropTargetIndex]
};
var getItemPosition = function(dropTargetConfig, $element) {
    if (dropTargetConfig.itemPositionFunc) {
        return dropTargetConfig.itemPositionFunc($element)
    } else {
        return $element.offset()
    }
};
var getItemSize = function(dropTargetConfig, $element) {
    if (dropTargetConfig.itemSizeFunc) {
        return dropTargetConfig.itemSizeFunc($element)
    }
    return {
        width: $element.width(),
        height: $element.height()
    }
};
var DragEmitter = GestureEmitter.inherit({
    ctor: function(element) {
        this.callBase(element);
        this.direction = "both"
    },
    _init: function(e) {
        this._initEvent = e
    },
    _start: function(e) {
        e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
        this._maxLeftOffset = e.maxLeftOffset;
        this._maxRightOffset = e.maxRightOffset;
        this._maxTopOffset = e.maxTopOffset;
        this._maxBottomOffset = e.maxBottomOffset;
        var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
        this._dropTargets = $.map(dropTargets, function(element) {
            return $(element).get(0)
        })
    },
    _move: function(e) {
        var eventData = eventUtils.eventData(e),
            dragOffset = this._calculateOffset(eventData);
        e = this._fireEvent(DRAG_EVENT, e, {
            offset: dragOffset
        });
        this._processDropTargets(e);
        if (!e._cancelPreventDefault) {
            e.preventDefault()
        }
    },
    _calculateOffset: function(eventData) {
        return {
            x: this._calculateXOffset(eventData),
            y: this._calculateYOffset(eventData)
        }
    },
    _calculateXOffset: function(eventData) {
        if ("vertical" !== this.direction) {
            var offset = eventData.x - this._startEventData.x;
            return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
        }
        return 0
    },
    _calculateYOffset: function(eventData) {
        if ("horizontal" !== this.direction) {
            var offset = eventData.y - this._startEventData.y;
            return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
        }
        return 0
    },
    _fitOffset: function(offset, minOffset, maxOffset) {
        if (null != minOffset) {
            offset = Math.max(offset, -minOffset)
        }
        if (null != maxOffset) {
            offset = Math.min(offset, maxOffset)
        }
        return offset
    },
    _processDropTargets: function(e) {
        var target = this._findDropTarget(e),
            sameTarget = target === this._currentDropTarget;
        if (!sameTarget) {
            this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
            this._currentDropTarget = target;
            this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
        }
    },
    _fireDropTargetEvent: function(event, eventName) {
        if (!this._currentDropTarget) {
            return
        }
        var eventData = {
            type: eventName,
            originalEvent: event,
            draggingElement: this._$element.get(0),
            target: this._currentDropTarget
        };
        eventUtils.fireEvent(eventData)
    },
    _findDropTarget: function(e) {
        var result, that = this;
        $.each(knownDropTargets, function(_, target) {
            if (!that._checkDropTargetActive(target)) {
                return
            }
            var $target = $(target);
            $.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
                var $delegatedTarget = $(delegatedTarget);
                if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, e)) {
                    result = delegatedTarget
                }
            })
        });
        return result
    },
    _checkDropTargetActive: function(target) {
        var active = false;
        $.each(this._dropTargets, function(_, activeTarget) {
            active = active || activeTarget === target || $.contains(activeTarget, target);
            return !active
        });
        return active
    },
    _checkDropTarget: function(config, $target, e) {
        var isDraggingElement = $target.get(0) === this._$element.get(0);
        if (isDraggingElement) {
            return false
        }
        var targetPosition = getItemPosition(config, $target);
        if (e.pageX < targetPosition.left) {
            return false
        }
        if (e.pageY < targetPosition.top) {
            return false
        }
        var targetSize = getItemSize(config, $target);
        if (e.pageX > targetPosition.left + targetSize.width) {
            return false
        }
        if (e.pageY > targetPosition.top + targetSize.height) {
            return false
        }
        return $target
    },
    _end: function(e) {
        var eventData = eventUtils.eventData(e);
        this._fireEvent(DRAG_END_EVENT, e, {
            offset: this._calculateOffset(eventData)
        });
        this._fireDropTargetEvent(e, DROP_EVENT);
        delete this._currentDropTarget
    }
});
registerEmitter({
    emitter: DragEmitter,
    events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});
exports.move = DRAG_EVENT;
exports.start = DRAG_START_EVENT;
exports.end = DRAG_END_EVENT;
exports.enter = DRAG_ENTER_EVENT;
exports.leave = DRAG_LEAVE_EVENT;
exports.drop = DROP_EVENT;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/icon.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var getImageSourceType = function(source) {
    if (!source || "string" !== typeof source) {
        return false
    }
    if (/data:.*base64|\.|\//.test(source)) {
        return "image"
    }
    if (/^[\w-_]+$/.test(source)) {
        return "dxIcon"
    }
    return "fontIcon"
};
var getImageContainer = function(source) {
    var imageType = getImageSourceType(source),
        ICON_CLASS = "dx-icon";
    switch (imageType) {
        case "image":
            return $("<img>", {
                src: source
            }).addClass(ICON_CLASS);
        case "fontIcon":
            return $("<i>", {
                "class": ICON_CLASS + " " + source
            });
        case "dxIcon":
            return $("<i>", {
                "class": ICON_CLASS + " " + ICON_CLASS + "-" + source
            });
        default:
            return null
    }
};
exports.getImageSourceType = getImageSourceType;
exports.getImageContainer = getImageContainer;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/odata/utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    Guid = __webpack_require__(34),
    isDefined = commonUtils.isDefined,
    errors = __webpack_require__(29).errors,
    dataUtils = __webpack_require__(28);
var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;
var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";

function formatISO8601(date, skipZeroTime, skipTimezone) {
    var bag = [];
    var pad = function(n) {
        if (n < 10) {
            return "0".concat(n)
        }
        return String(n)
    };
    var isZeroTime = function() {
        return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
    };
    bag.push(date.getFullYear());
    bag.push("-");
    bag.push(pad(date.getMonth() + 1));
    bag.push("-");
    bag.push(pad(date.getDate()));
    if (!(skipZeroTime && isZeroTime())) {
        bag.push("T");
        bag.push(pad(date.getHours()));
        bag.push(":");
        bag.push(pad(date.getMinutes()));
        bag.push(":");
        bag.push(pad(date.getSeconds()));
        if (date.getMilliseconds()) {
            bag.push(".");
            bag.push(date.getMilliseconds())
        }
        if (!skipTimezone) {
            bag.push("Z")
        }
    }
    return bag.join("")
}

function parseISO8601(isoString) {
    var result = new Date(60 * new Date(0).getTimezoneOffset() * 1e3),
        chunks = isoString.replace("Z", "").split("T"),
        date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]),
        time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
    result.setFullYear(Number(date[1]));
    result.setMonth(Number(date[2]) - 1);
    result.setDate(Number(date[3]));
    if (Array.isArray(time) && time.length) {
        result.setHours(Number(time[1]));
        result.setMinutes(Number(time[2]));
        result.setSeconds(Number(time[3]));
        result.setMilliseconds(Number(String(time[4]).substr(0, 3)) || 0)
    }
    return result
}

function isAbsoluteUrl(url) {
    return /^(?:[a-z]+:)?\/\//i.test(url)
}

function toAbsoluteUrl(basePath, relativePath) {
    var part;
    var baseParts = stripParams(basePath).split("/");
    var relativeParts = relativePath.split("/");

    function stripParams(url) {
        var index = url.indexOf("?");
        if (index > -1) {
            return url.substr(0, index)
        }
        return url
    }
    baseParts.pop();
    while (relativeParts.length) {
        part = relativeParts.shift();
        if (".." === part) {
            baseParts.pop()
        } else {
            baseParts.push(part)
        }
    }
    return baseParts.join("/")
}
var ajaxOptionsForRequest = function(protocolVersion, request, options) {
    request = extend({
        async: true,
        method: "get",
        url: "",
        params: {},
        payload: null,
        headers: {},
        timeout: 3e4
    }, request);
    options = options || {};
    var beforeSend = options.beforeSend;
    if (beforeSend) {
        beforeSend(request)
    }
    var method = (request.method || "get").toLowerCase(),
        isGet = "get" === method,
        useJsonp = isGet && options.jsonp,
        params = extend({}, request.params),
        ajaxData = isGet ? params : formatPayload(request.payload),
        qs = !isGet && $.param(params),
        url = request.url,
        contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
    if (qs) {
        url += (url.indexOf("?") > -1 ? "&" : "?") + qs
    }
    if (useJsonp) {
        ajaxData.$format = "json"
    }
    return {
        url: url,
        data: ajaxData,
        dataType: useJsonp ? "jsonp" : "json",
        jsonp: useJsonp && "$callback",
        type: method,
        async: request.async,
        timeout: request.timeout,
        headers: request.headers,
        contentType: contentType,
        accepts: {
            json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()
        },
        xhrFields: {
            withCredentials: options.withCredentials
        }
    };

    function formatPayload(payload) {
        return JSON.stringify(payload, function(key, value) {
            if (!(this[key] instanceof Date)) {
                return value
            }
            value = formatISO8601(this[key]);
            switch (protocolVersion) {
                case 2:
                    return value.substr(0, value.length - 1);
                case 3:
                case 4:
                    return value;
                default:
                    throw errors.Error("E4002")
            }
        })
    }
};
var sendRequest = function(protocolVersion, request, options) {
    var d = $.Deferred();
    var ajaxOptions = ajaxOptionsForRequest(protocolVersion, request, options);
    $.ajax(ajaxOptions).always(function(obj, textStatus) {
        var extra, transformOptions = {
                deserializeDates: options.deserializeDates,
                fieldTypes: options.fieldTypes
            },
            tuple = interpretJsonFormat(obj, textStatus, transformOptions),
            error = tuple.error,
            data = tuple.data,
            nextUrl = tuple.nextUrl;
        if (error) {
            if (error.message !== dataUtils.XHR_ERROR_UNLOAD) {
                d.reject(error)
            }
        } else {
            if (options.countOnly) {
                if (isFinite(tuple.count)) {
                    d.resolve(tuple.count)
                } else {
                    d.reject(new errors.Error("E4018"))
                }
            } else {
                if (nextUrl) {
                    if (!isAbsoluteUrl(nextUrl)) {
                        nextUrl = toAbsoluteUrl(ajaxOptions.url, nextUrl)
                    }
                    sendRequest(protocolVersion, {
                        url: nextUrl
                    }, options).fail(d.reject).done(function(nextData) {
                        d.resolve(data.concat(nextData))
                    })
                } else {
                    if (isFinite(tuple.count)) {
                        extra = {
                            totalCount: tuple.count
                        }
                    }
                    d.resolve(data, extra)
                }
            }
        }
    });
    return d.promise()
};
var formatDotNetError = function(errorObj) {
    var message, currentError = errorObj;
    if ("message" in errorObj) {
        if (errorObj.message.value) {
            message = errorObj.message.value
        } else {
            message = errorObj.message
        }
    }
    while (currentError = currentError.innererror || currentError.internalexception) {
        message = currentError.message;
        if (currentError.internalexception && message.indexOf("inner exception") === -1) {
            break
        }
    }
    return message
};
var errorFromResponse = function(obj, textStatus) {
    if ("nocontent" === textStatus) {
        return null
    }
    var httpStatus = 200,
        message = "Unknown error",
        response = obj;
    if ("success" !== textStatus) {
        httpStatus = obj.status;
        message = dataUtils.errorMessageFromXhr(obj, textStatus);
        try {
            response = JSON.parse(obj.responseText)
        } catch (x) {}
    }
    var errorObj = response && (response.then && response || response.error || response["odata.error"] || response["@odata.error"]);
    if (errorObj) {
        message = formatDotNetError(errorObj) || message;
        if (200 === httpStatus) {
            httpStatus = 500
        }
        if (errorObj.code) {
            httpStatus = Number(errorObj.code)
        }
        return extend(Error(message), {
            httpStatus: httpStatus,
            errorDetails: errorObj
        })
    } else {
        if (200 !== httpStatus) {
            return extend(Error(message), {
                httpStatus: httpStatus
            })
        }
    }
};
var interpretJsonFormat = function(obj, textStatus, transformOptions) {
    var value, error = errorFromResponse(obj, textStatus);
    if (error) {
        return {
            error: error
        }
    }
    if (!typeUtils.isPlainObject(obj)) {
        return {
            data: obj
        }
    }
    if ("d" in obj && (Array.isArray(obj.d) || commonUtils.isObject(obj.d))) {
        value = interpretVerboseJsonFormat(obj, textStatus)
    } else {
        value = interpretLightJsonFormat(obj, textStatus)
    }
    transformTypes(value, transformOptions);
    return value
};
var interpretVerboseJsonFormat = function(obj) {
    var data = obj.d;
    if (!isDefined(data)) {
        return {
            error: Error("Malformed or unsupported JSON response received")
        }
    }
    data = data;
    if (isDefined(data.results)) {
        data = data.results
    }
    return {
        data: data,
        nextUrl: obj.d.__next,
        count: parseInt(obj.d.__count, 10)
    }
};
var interpretLightJsonFormat = function(obj) {
    var data = obj;
    if (isDefined(data.value)) {
        data = data.value
    }
    return {
        data: data,
        nextUrl: obj["@odata.nextLink"],
        count: parseInt(obj["@odata.count"], 10)
    }
};
var EdmLiteral = Class.inherit({
    ctor: function(value) {
        this._value = value
    },
    valueOf: function() {
        return this._value
    }
});
var transformTypes = function(obj, options) {
    options = options || {};
    $.each(obj, function(key, value) {
        if (null !== value && "object" === typeof value) {
            if ("results" in value) {
                obj[key] = value.results
            }
            transformTypes(obj[key], options)
        } else {
            if ("string" === typeof value) {
                var fieldTypes = options.fieldTypes,
                    canBeGuid = !fieldTypes || "String" !== fieldTypes[key];
                if (canBeGuid && GUID_REGEX.test(value)) {
                    obj[key] = new Guid(value)
                }
                if (false !== options.deserializeDates) {
                    if (value.match(VERBOSE_DATE_REGEX)) {
                        var date = new Date(Number(RegExp.$1) + 60 * RegExp.$2 * 1e3);
                        obj[key] = new Date(date.valueOf() + 60 * date.getTimezoneOffset() * 1e3)
                    } else {
                        if (ISO8601_DATE_REGEX.test(value)) {
                            obj[key] = new Date(parseISO8601(obj[key]).valueOf())
                        }
                    }
                }
            }
        }
    })
};
var serializeDate = function(date) {
    return "datetime'" + formatISO8601(date, true, true) + "'"
};
var serializeString = function(value) {
    return "'" + value.replace(/'/g, "''") + "'"
};
var serializePropName = function(propName) {
    if (propName instanceof EdmLiteral) {
        return propName.valueOf()
    }
    return propName.replace(/\./g, "/")
};
var serializeValueV4 = function(value) {
    if (value instanceof Date) {
        return formatISO8601(value, false, false)
    }
    if (value instanceof Guid) {
        return value.valueOf()
    }
    if (Array.isArray(value)) {
        return "[" + value.map(function(item) {
            return serializeValueV4(item)
        }).join(",") + "]"
    }
    return serializeValueV2(value)
};
var serializeValueV2 = function(value) {
    if (value instanceof Date) {
        return serializeDate(value)
    }
    if (value instanceof Guid) {
        return "guid'" + value + "'"
    }
    if (value instanceof EdmLiteral) {
        return value.valueOf()
    }
    if ("string" === typeof value) {
        return serializeString(value)
    }
    return String(value)
};
var serializeValue = function(value, protocolVersion) {
    switch (protocolVersion) {
        case 2:
        case 3:
            return serializeValueV2(value);
        case 4:
            return serializeValueV4(value);
        default:
            throw errors.Error("E4002")
    }
};
var serializeKey = function(key, protocolVersion) {
    if (typeUtils.isPlainObject(key)) {
        var parts = [];
        $.each(key, function(k, v) {
            parts.push(serializePropName(k) + "=" + serializeValue(v, protocolVersion))
        });
        return parts.join()
    }
    return serializeValue(key, protocolVersion)
};
var keyConverters = {
    String: function(value) {
        return value + ""
    },
    Int32: function(value) {
        return Math.floor(value)
    },
    Int64: function(value) {
        if (value instanceof EdmLiteral) {
            return value
        }
        return new EdmLiteral(value + "L")
    },
    Guid: function(value) {
        if (value instanceof Guid) {
            return value
        }
        return new Guid(value)
    },
    Boolean: function(value) {
        return !!value
    },
    Single: function(value) {
        if (value instanceof EdmLiteral) {
            return value
        }
        return new EdmLiteral(value + "f")
    },
    Decimal: function(value) {
        if (value instanceof EdmLiteral) {
            return value
        }
        return new EdmLiteral(value + "m")
    }
};
var convertPrimitiveValue = function(type, value) {
    var converter = keyConverters[type];
    if (!converter) {
        throw errors.Error("E4014", type)
    }
    return converter(value)
};
exports.sendRequest = sendRequest;
exports.serializePropName = serializePropName;
exports.serializeValue = serializeValue;
exports.serializeKey = serializeKey;
exports.keyConverters = keyConverters;
exports.convertPrimitiveValue = convertPrimitiveValue;
exports.EdmLiteral = EdmLiteral;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ListEdit = __webpack_require__(286),
    registerComponent = __webpack_require__(4);
registerComponent("dxList", ListEdit);
module.exports = ListEdit;
module.exports.default = module.exports;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    swipeEvents = __webpack_require__(118),
    eventUtils = __webpack_require__(3);
var LIST_EDIT_DECORATOR = "dxListEditDecorator",
    SWIPE_START_EVENT_NAME = eventUtils.addNamespace(swipeEvents.start, LIST_EDIT_DECORATOR),
    SWIPE_UPDATE_EVENT_NAME = eventUtils.addNamespace(swipeEvents.swipe, LIST_EDIT_DECORATOR),
    SWIPE_END_EVENT_NAME = eventUtils.addNamespace(swipeEvents.end, LIST_EDIT_DECORATOR);
var EditDecorator = Class.inherit({
    ctor: function(list) {
        this._list = list;
        this._init()
    },
    _init: noop,
    _shouldHandleSwipe: false,
    _attachSwipeEvent: function(config) {
        var swipeConfig = {
            itemSizeFunc: function() {
                if (this._clearSwipeCache) {
                    this._itemWidthCache = this._list.element().width();
                    this._clearSwipeCache = false
                }
                return this._itemWidthCache
            }.bind(this)
        };
        config.$itemElement.on(SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this)).on(SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this)).on(SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this))
    },
    _itemSwipeStartHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        this._swipeStartHandler($itemElement, e)
    },
    _itemSwipeUpdateHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        this._swipeUpdateHandler($itemElement, e)
    },
    _itemSwipeEndHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        this._swipeEndHandler($itemElement, e);
        this._clearSwipeCache = true
    },
    beforeBag: noop,
    afterBag: noop,
    _commonOptions: function() {
        return {
            activeStateEnabled: this._list.option("activeStateEnabled"),
            hoverStateEnabled: this._list.option("hoverStateEnabled"),
            focusStateEnabled: this._list.option("focusStateEnabled")
        }
    },
    modifyElement: function(config) {
        if (this._shouldHandleSwipe) {
            this._attachSwipeEvent(config);
            this._clearSwipeCache = true
        }
    },
    afterRender: noop,
    handleClick: noop,
    handleContextMenu: noop,
    _swipeStartHandler: noop,
    _swipeUpdateHandler: noop,
    _swipeEndHandler: noop,
    visibilityChange: noop,
    dispose: noop
});
module.exports = EditDecorator;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/number_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(307);
module.exports.default = module.exports;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DevExpress = window.DevExpress = window.DevExpress || {};
var errors = DevExpress.errors = __webpack_require__(13);
if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
    throw errors.Error("E0024")
}
DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
DevExpress.clientExporter = __webpack_require__(133);
DevExpress.VERSION = __webpack_require__(104);
DevExpress.Class = __webpack_require__(5);
DevExpress.DOMComponent = __webpack_require__(45);
DevExpress.registerComponent = __webpack_require__(4);
DevExpress.devices = __webpack_require__(6);
DevExpress.Color = __webpack_require__(85);
var $ = __webpack_require__(0);
var compareVersions = __webpack_require__(37).compare;
if (compareVersions($.fn.jquery, [1, 10]) < 0) {
    throw errors.Error("E0012")
}
var animationFrame = __webpack_require__(87);
DevExpress.requestAnimationFrame = function() {
    errors.log("W0000", "DevExpress.requestAnimationFrame", "15.2", "Use the 'DevExpress.utils.requestAnimationFrame' method instead.");
    return animationFrame.requestAnimationFrame.apply(animationFrame, arguments)
};
DevExpress.cancelAnimationFrame = function() {
    errors.log("W0000", "DevExpress.cancelAnimationFrame", "15.2", "Use the 'DevExpress.utils.cancelAnimationFrame' method instead.");
    return animationFrame.cancelAnimationFrame.apply(animationFrame, arguments)
};
DevExpress.EventsMixin = __webpack_require__(38);
DevExpress.utils = {};
DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
DevExpress.utils.initMobileViewport = __webpack_require__(166).initMobileViewport;
DevExpress.utils.extendFromObject = __webpack_require__(1).extendFromObject;
DevExpress.utils.createComponents = __webpack_require__(15).createComponents;
DevExpress.utils.triggerShownEvent = __webpack_require__(15).triggerShownEvent;
DevExpress.utils.triggerHidingEvent = __webpack_require__(15).triggerHidingEvent;
DevExpress.utils.resetActiveElement = __webpack_require__(15).resetActiveElement;
DevExpress.utils.findBestMatches = __webpack_require__(2).findBestMatches;
DevExpress.createQueue = __webpack_require__(136).create;
DevExpress.utils.dom = __webpack_require__(15);
DevExpress.utils.common = __webpack_require__(2);
DevExpress.utils.date = __webpack_require__(55);
DevExpress.utils.browser = __webpack_require__(21);
DevExpress.utils.inflector = __webpack_require__(36);
DevExpress.utils.resizeCallbacks = __webpack_require__(61).resizeCallbacks;
DevExpress.utils.console = __webpack_require__(83);
DevExpress.utils.string = __webpack_require__(30);
DevExpress.utils.support = __webpack_require__(24);
DevExpress.processHardwareBackButton = __webpack_require__(167);
DevExpress.viewPort = __webpack_require__(54).value;
DevExpress.hideTopOverlay = __webpack_require__(108);
DevExpress.formatHelper = __webpack_require__(168);
var config = DevExpress.config = __webpack_require__(31);
Object.defineProperty(DevExpress, "rtlEnabled", {
    get: function() {
        errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
        return config().rtlEnabled
    },
    set: function(value) {
        errors.log("W0003", "DevExpress", "rtlEnabled", "16.1", "Use the 'DevExpress.config' method instead");
        config({
            rtlEnabled: value
        })
    }
});
Object.defineProperty(DevExpress, "designMode", {
    get: function() {
        return config().designMode
    },
    set: function(value) {
        config({
            designMode: value
        })
    }
});
DevExpress.animationPresets = __webpack_require__(109).presets;
DevExpress.fx = __webpack_require__(22);
DevExpress.TransitionExecutor = __webpack_require__(88).TransitionExecutor;
DevExpress.AnimationPresetCollection = __webpack_require__(109).PresetCollection;
module.exports = DevExpress.events = {};
DevExpress.events.click = __webpack_require__(11);
DevExpress.events.utils = __webpack_require__(3);
DevExpress.events.GestureEmitter = __webpack_require__(111);
DevExpress.localization = __webpack_require__(253);
module.exports = DevExpress;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/console.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var isFunction = __webpack_require__(2).isFunction;
var logger = function() {
    var console = window.console;

    function info(text) {
        if (!console || !isFunction(console.info)) {
            return
        }
        console.info(text)
    }

    function warn(text) {
        if (!console || !isFunction(console.warn)) {
            return
        }
        console.warn(text)
    }

    function error(text) {
        if (!console || !isFunction(console.error)) {
            return
        }
        console.error(text)
    }
    return {
        info: info,
        warn: warn,
        error: error
    }
}();
var debug = function() {
    function assert(condition, message) {
        if (!condition) {
            throw new Error(message)
        }
    }

    function assertParam(parameter, message) {
        assert(null !== parameter && void 0 !== parameter, message)
    }
    return {
        assert: assert,
        assertParam: assertParam
    }
}();
exports.logger = logger;
exports.debug = debug;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/object.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    variableWrapper = __webpack_require__(41);
var clone = function() {
    function Clone() {}
    return function(obj) {
        Clone.prototype = obj;
        return new Clone
    }
}();
var orderEach = function(map, func) {
    var key, i, keys = [];
    for (key in map) {
        if (map.hasOwnProperty(key)) {
            keys.push(key)
        }
    }
    keys.sort(function(x, y) {
        var isNumberX = commonUtils.isNumeric(x),
            isNumberY = commonUtils.isNumeric(y);
        if (isNumberX && isNumberY) {
            return x - y
        }
        if (isNumberX && !isNumberY) {
            return -1
        }
        if (!isNumberX && isNumberY) {
            return 1
        }
        if (x < y) {
            return -1
        }
        if (x > y) {
            return 1
        }
        return 0
    });
    for (i = 0; i < keys.length; i++) {
        key = keys[i];
        func(key, map[key])
    }
};
var assignValueToProperty = function(target, property, value, assignByReference) {
    if (!assignByReference && variableWrapper.isWrapped(target[property])) {
        variableWrapper.assign(target[property], value)
    } else {
        target[property] = value
    }
};
var deepExtendArraySafe = function(target, changes, extendComplexObject, assignByReference) {
    var prevValue, newValue;
    for (var name in changes) {
        prevValue = target[name];
        newValue = changes[name];
        if (target === newValue) {
            continue
        }
        if (typeUtils.isPlainObject(newValue) && !(newValue instanceof $.Event)) {
            var goDeeper = extendComplexObject ? commonUtils.isObject(prevValue) : typeUtils.isPlainObject(prevValue);
            newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference)
        }
        if (void 0 !== newValue) {
            assignValueToProperty(target, name, newValue, assignByReference)
        }
    }
    return target
};
exports.clone = clone;
exports.orderEach = orderEach;
exports.deepExtendArraySafe = deepExtendArraySafe;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (color.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var standardColorNames = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
};
var standardColorTypes = [{
    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    process: function(colorString) {
        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
    }
}, {
    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
    process: function(colorString) {
        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
    }
}, {
    re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
    process: function(colorString) {
        return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
    }
}, {
    re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
    process: function(colorString) {
        return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
    }
}, {
    re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    process: function(colorString) {
        var h = parseInt(colorString[1], 10),
            s = parseInt(colorString[2], 10),
            v = parseInt(colorString[3], 10),
            rgb = hsvToRgb(h, s, v);
        return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
    }
}, {
    re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
    process: function(colorString) {
        var h = parseInt(colorString[1], 10),
            s = parseInt(colorString[2], 10),
            l = parseInt(colorString[3], 10),
            rgb = hslToRgb(h, s, l);
        return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
    }
}];

function Color(value) {
    this.baseColor = value;
    var color;
    if (value) {
        color = String(value).toLowerCase().replace(/ /g, "");
        color = standardColorNames[color] ? "#" + standardColorNames[color] : color;
        color = parseColor(color)
    }
    if (!color) {
        this.colorIsInvalid = true
    }
    color = color || {};
    this.r = normalize(color[0]);
    this.g = normalize(color[1]);
    this.b = normalize(color[2]);
    this.a = normalize(color[3], 1, 1);
    if (color[4]) {
        this.hsv = {
            h: color[4][0],
            s: color[4][1],
            v: color[4][2]
        }
    } else {
        this.hsv = toHsvFromRgb(this.r, this.g, this.b)
    }
    if (color[5]) {
        this.hsl = {
            h: color[5][0],
            s: color[5][1],
            l: color[5][2]
        }
    } else {
        this.hsl = toHslFromRgb(this.r, this.g, this.b)
    }
}

function parseColor(color) {
    if ("transparent" === color) {
        return [0, 0, 0, 0]
    }
    var str, i = 0,
        ii = standardColorTypes.length;
    for (; i < ii; ++i) {
        str = standardColorTypes[i].re.exec(color);
        if (str) {
            return standardColorTypes[i].process(str)
        }
    }
    return null
}

function normalize(colorComponent, def, max) {
    def = def || 0;
    max = max || 255;
    return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
}

function toHexFromRgb(r, g, b) {
    return "#" + (16777216 | r << 16 | g << 8 | b).toString(16).slice(1)
}

function toHsvFromRgb(r, g, b) {
    var H, S, V, max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        delta = max - min;
    V = max;
    S = 0 === max ? 0 : 1 - min / max;
    if (max === min) {
        H = 0
    } else {
        switch (max) {
            case r:
                H = 60 * ((g - b) / delta);
                if (g < b) {
                    H += 360
                }
                break;
            case g:
                H = 60 * ((b - r) / delta) + 120;
                break;
            case b:
                H = 60 * ((r - g) / delta) + 240
        }
    }
    S *= 100;
    V *= 100 / 255;
    return {
        h: Math.round(H),
        s: Math.round(S),
        v: Math.round(V)
    }
}

function hsvToRgb(h, s, v) {
    var vDec, vInc, vMin, index, a, r, g, b;
    index = Math.floor(h % 360 / 60);
    vMin = (100 - s) * v / 100;
    a = (v - vMin) * (h % 60 / 60);
    vInc = vMin + a;
    vDec = v - a;
    switch (index) {
        case 0:
            r = v;
            g = vInc;
            b = vMin;
            break;
        case 1:
            r = vDec;
            g = v;
            b = vMin;
            break;
        case 2:
            r = vMin;
            g = v;
            b = vInc;
            break;
        case 3:
            r = vMin;
            g = vDec;
            b = v;
            break;
        case 4:
            r = vInc;
            g = vMin;
            b = v;
            break;
        case 5:
            r = v;
            g = vMin;
            b = vDec
    }
    return [Math.round(2.55 * r), Math.round(2.55 * g), Math.round(2.55 * b)]
}

function calculateHue(r, g, b, delta) {
    var max = Math.max(r, g, b);
    switch (max) {
        case r:
            return (g - b) / delta + (g < b ? 6 : 0);
        case g:
            return (b - r) / delta + 2;
        case b:
            return (r - g) / delta + 4
    }
}

function toHslFromRgb(r, g, b) {
    r = convertTo01Bounds(r, 255);
    g = convertTo01Bounds(g, 255);
    b = convertTo01Bounds(b, 255);
    var h, s, max = Math.max(r, g, b),
        min = Math.min(r, g, b),
        maxMinSum = max + min,
        l = maxMinSum / 2;
    if (max === min) {
        h = s = 0
    } else {
        var delta = max - min;
        if (l > .5) {
            s = delta / (2 - maxMinSum)
        } else {
            s = delta / maxMinSum
        }
        h = calculateHue(r, g, b, delta);
        h /= 6
    }
    return {
        h: _round(360 * h),
        s: _round(100 * s),
        l: _round(100 * l)
    }
}

function makeColorTint(colorPart, h) {
    var colorTint = h;
    if ("r" === colorPart) {
        colorTint = h + 1 / 3
    }
    if ("b" === colorPart) {
        colorTint = h - 1 / 3
    }
    return colorTint
}

function modifyColorTint(colorTint) {
    if (colorTint < 0) {
        colorTint += 1
    }
    if (colorTint > 1) {
        colorTint -= 1
    }
    return colorTint
}

function hueToRgb(p, q, colorTint) {
    colorTint = modifyColorTint(colorTint);
    if (colorTint < 1 / 6) {
        return p + 6 * (q - p) * colorTint
    }
    if (colorTint < .5) {
        return q
    }
    if (colorTint < 2 / 3) {
        return p + (q - p) * (2 / 3 - colorTint) * 6
    }
    return p
}

function hslToRgb(h, s, l) {
    var r, g, b;
    h = convertTo01Bounds(h, 360);
    s = convertTo01Bounds(s, 100);
    l = convertTo01Bounds(l, 100);
    if (0 === s) {
        r = g = b = l
    } else {
        var q = l < .5 ? l * (1 + s) : l + s - l * s,
            p = 2 * l - q;
        r = hueToRgb(p, q, makeColorTint("r", h));
        g = hueToRgb(p, q, makeColorTint("g", h));
        b = hueToRgb(p, q, makeColorTint("b", h))
    }
    return [_round(255 * r), _round(255 * g), _round(255 * b)]
}

function convertTo01Bounds(n, max) {
    n = Math.min(max, Math.max(0, parseFloat(n)));
    if (Math.abs(n - max) < 1e-6) {
        return 1
    }
    return n % max / parseFloat(max)
}

function isIntegerBetweenMinAndMax(number, min, max) {
    min = min || 0;
    max = max || 255;
    if (number % 1 !== 0 || number < min || number > max || "number" !== typeof number || isNaN(number)) {
        return false
    }
    return true
}
var _round = Math.round;
Color.prototype = {
    constructor: Color,
    highlight: function(step) {
        step = step || 10;
        return this.alter(step).toHex()
    },
    darken: function(step) {
        step = step || 10;
        return this.alter(-step).toHex()
    },
    alter: function(step) {
        var result = new Color;
        result.r = normalize(this.r + step);
        result.g = normalize(this.g + step);
        result.b = normalize(this.b + step);
        return result
    },
    blend: function(blendColor, opacity) {
        var other = blendColor instanceof Color ? blendColor : new Color(blendColor),
            result = new Color;
        result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
        result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
        result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
        return result
    },
    toHex: function() {
        return toHexFromRgb(this.r, this.g, this.b)
    },
    getPureColor: function() {
        var rgb = hsvToRgb(this.hsv.h, 100, 100);
        return new Color("rgb(" + rgb.join(",") + ")")
    },
    isValidHex: function(hex) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
    },
    isValidRGB: function(r, g, b) {
        if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
            return false
        }
        return true
    },
    isValidAlpha: function(a) {
        if (isNaN(a) || a < 0 || a > 1 || "number" !== typeof a) {
            return false
        }
        return true
    },
    colorIsInvalid: false
};
module.exports = Color;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/remove_event.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    jQuery = __webpack_require__(103),
    cleanData = jQuery.cleanData,
    specialEvents = $.event.special;
var eventName = "dxremove",
    eventPropName = "dxRemoveEvent";
jQuery.cleanData = function(elements) {
    elements = [].slice.call(elements);
    for (var i = 0; i < elements.length; i++) {
        var $element = $(elements[i]);
        if ($element.prop(eventPropName)) {
            $element.removeProp(eventPropName);
            $element.triggerHandler(eventName)
        }
    }
    return cleanData(elements)
};
specialEvents[eventName] = {
    noBubble: true,
    setup: function() {
        $(this).prop(eventPropName, true)
    }
};
module.exports = eventName;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/frame.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var FRAME_ANIMATION_STEP_TIME = 1e3 / 60,
    request = function(callback) {
        return this.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
    },
    cancel = function(requestID) {
        this.clearTimeout(requestID)
    },
    nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
    nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel
}
if (nativeRequest && !nativeCancel) {
    var canceledRequests = {};
    request = function(callback) {
        var requestId = nativeRequest.call(window, function() {
            try {
                if (requestId in canceledRequests) {
                    return
                }
                callback.apply(this, arguments)
            } finally {
                delete canceledRequests[requestId]
            }
        });
        return requestId
    };
    cancel = function(requestId) {
        canceledRequests[requestId] = true
    }
}
exports.requestAnimationFrame = request.bind(window);
exports.cancelAnimationFrame = cancel.bind(window);


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/transition_executor/transition_executor.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    fx = __webpack_require__(22),
    animationPresetsModule = __webpack_require__(109),
    when = __webpack_require__(10).when;
var directionPostfixes = {
        forward: " dx-forward",
        backward: " dx-backward",
        none: " dx-no-direction",
        undefined: " dx-no-direction"
    },
    DX_ANIMATING_CLASS = "dx-animating";
var TransitionExecutor = Class.inherit({
    ctor: function() {
        this._accumulatedDelays = {
            enter: 0,
            leave: 0
        };
        this._animations = [];
        this.reset()
    },
    _createAnimations: function($elements, initialConfig, configModifier, type) {
        var animationConfig, that = this,
            result = [];
        configModifier = configModifier || {};
        animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
        if (animationConfig) {
            $elements.each(function() {
                var animation = that._createAnimation($(this), animationConfig, configModifier);
                if (animation) {
                    animation.element.addClass(DX_ANIMATING_CLASS);
                    animation.setup();
                    result.push(animation)
                }
            })
        }
        return result
    },
    _prepareElementAnimationConfig: function(config, configModifier, type) {
        var result;
        if ("string" === typeof config) {
            var presetName = config;
            config = animationPresetsModule.presets.getPreset(presetName)
        }
        if (!config) {
            result = void 0
        } else {
            if (commonUtils.isFunction(config[type])) {
                result = config[type]
            } else {
                result = extend({
                    skipElementInitialStyles: true,
                    cleanupWhen: this._completePromise
                }, config, configModifier);
                if (!result.type || "css" === result.type) {
                    var cssClass = "dx-" + type,
                        extraCssClasses = (result.extraCssClasses ? " " + result.extraCssClasses : "") + directionPostfixes[result.direction];
                    result.type = "css";
                    result.from = (result.from || cssClass) + extraCssClasses;
                    result.to = result.to || cssClass + "-active"
                }
                result.staggerDelay = result.staggerDelay || 0;
                result.delay = result.delay || 0;
                if (result.staggerDelay) {
                    result.delay += this._accumulatedDelays[type];
                    this._accumulatedDelays[type] += result.staggerDelay
                }
            }
        }
        return result
    },
    _createAnimation: function($element, animationConfig, configModifier) {
        var result;
        if (typeUtils.isPlainObject(animationConfig)) {
            result = fx.createAnimation($element, animationConfig)
        } else {
            if (commonUtils.isFunction(animationConfig)) {
                result = animationConfig($element, configModifier)
            }
        }
        return result
    },
    _startAnimations: function() {
        var animations = this._animations;
        for (var i = 0; i < animations.length; i++) {
            animations[i].start()
        }
    },
    _stopAnimations: function(jumpToEnd) {
        var animations = this._animations;
        for (var i = 0; i < animations.length; i++) {
            animations[i].stop(jumpToEnd)
        }
    },
    _clearAnimations: function() {
        var animations = this._animations;
        for (var i = 0; i < animations.length; i++) {
            animations[i].element.removeClass(DX_ANIMATING_CLASS)
        }
        this._animations.length = 0
    },
    reset: function() {
        this._accumulatedDelays.enter = 0;
        this._accumulatedDelays.leave = 0;
        this._clearAnimations();
        this._completeDeferred = $.Deferred();
        this._completePromise = this._completeDeferred.promise()
    },
    enter: function($elements, animationConfig, configModifier) {
        var animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
        this._animations.push.apply(this._animations, animations)
    },
    leave: function($elements, animationConfig, configModifier) {
        var animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
        this._animations.push.apply(this._animations, animations)
    },
    start: function() {
        var result, that = this;
        if (!this._animations.length) {
            that.reset();
            result = $.Deferred().resolve().promise()
        } else {
            var animationDeferreds = $.map(this._animations, function(animation) {
                var result = $.Deferred();
                animation.deferred.always(function() {
                    result.resolve()
                });
                return result.promise()
            });
            result = when.apply($, animationDeferreds).always(function() {
                that._completeDeferred.resolve();
                that.reset()
            });
            commonUtils.executeAsync(function() {
                that._startAnimations()
            })
        }
        return result
    },
    stop: function(jumpToEnd) {
        this._stopAnimations(jumpToEnd)
    }
});
exports.TransitionExecutor = TransitionExecutor;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/emitter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3);
var Emitter = Class.inherit({
    ctor: function(element) {
        this._$element = $(element);
        this._cancelCallback = $.Callbacks();
        this._acceptCallback = $.Callbacks()
    },
    getElement: function() {
        return this._$element
    },
    validate: function(e) {
        return "dxmousewheel" !== e.type
    },
    validatePointers: function(e) {
        return 1 === eventUtils.hasTouches(e)
    },
    allowInterruptionByMouseWheel: function() {
        return true
    },
    configure: function(data) {
        extend(this, data)
    },
    addCancelCallback: function(callback) {
        this._cancelCallback.add(callback)
    },
    removeCancelCallback: function() {
        this._cancelCallback.empty()
    },
    _cancel: function(e) {
        this._cancelCallback.fire(this, e)
    },
    addAcceptCallback: function(callback) {
        this._acceptCallback.add(callback)
    },
    removeAcceptCallback: function() {
        this._acceptCallback.empty()
    },
    _accept: function(e) {
        this._acceptCallback.fire(this, e)
    },
    _requestAccept: function(e) {
        this._acceptRequestEvent = e
    },
    _forgetAccept: function() {
        this._accept(this._acceptRequestEvent);
        this._acceptRequestEvent = null
    },
    start: noop,
    move: noop,
    end: noop,
    cancel: noop,
    reset: function() {
        if (this._acceptRequestEvent) {
            this._accept(this._acceptRequestEvent)
        }
    },
    _fireEvent: function(eventName, e, params) {
        var eventData = extend({
            type: eventName,
            originalEvent: e,
            target: this._getEmitterTarget(e),
            delegateTarget: this.getElement().get(0)
        }, params);
        e = eventUtils.fireEvent(eventData);
        if (e.cancel) {
            this._cancel(e)
        }
        return e
    },
    _getEmitterTarget: function(e) {
        return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
    },
    dispose: noop
});
module.exports = Emitter;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ko = __webpack_require__(42);
if (ko) {
    var errors = __webpack_require__(13),
        compareVersion = __webpack_require__(37).compare;
    if (compareVersion(ko.version, [2, 3]) < 0) {
        throw errors.Error("E0013")
    }
    __webpack_require__(256);
    __webpack_require__(258);
    __webpack_require__(259);
    __webpack_require__(260);
    __webpack_require__(261);
    __webpack_require__(262);
    __webpack_require__(263)
}


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/function_template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var TemplateBase = __webpack_require__(64),
    domUtils = __webpack_require__(15);
var FunctionTemplate = TemplateBase.inherit({
    ctor: function(render) {
        this._render = render
    },
    _renderCore: function(options) {
        return domUtils.normalizeTemplateElement(this._render(options))
    }
});
module.exports = FunctionTemplate;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/jquery.selectors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var focusable = function(element, tabIndex) {
    if (!visible(element)) {
        return false
    }
    var nodeName = element.nodeName.toLowerCase(),
        isTabIndexNotNaN = !isNaN(tabIndex),
        isDisabled = element.disabled,
        isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName),
        isHyperlink = "a" === nodeName,
        isFocusable = true;
    if (isDefaultFocus) {
        isFocusable = !isDisabled
    } else {
        if (isHyperlink) {
            isFocusable = element.href || isTabIndexNotNaN
        } else {
            isFocusable = isTabIndexNotNaN
        }
    }
    return isFocusable
};
var visible = function(element) {
    var $element = $(element);
    return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility")
};
module.exports = {
    focusable: function(index, element) {
        return focusable(element, $(element).attr("tabindex"))
    },
    tabbable: function(index, element) {
        var tabIndex = $(element).attr("tabindex");
        return (isNaN(tabIndex) || tabIndex >= 0) && focusable(element, tabIndex)
    }
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ko = __webpack_require__(42),
    KoTemplate = __webpack_require__(173);
var mergeWithReplace = function(targetArray, arrayToMerge, needReplaceFn) {
    var result = [];
    for (var i = 0, length = targetArray.length; i < length; i++) {
        if (!needReplaceFn(targetArray[i], arrayToMerge)) {
            result.push(targetArray[i])
        }
    }
    result.push.apply(result, arrayToMerge);
    return result
};
var prepareCommandToReplace = function(targetCommand, commandsToMerge) {
    var needToReplace = false;
    $.each(commandsToMerge, function(_, commandToMerge) {
        var idEqual = targetCommand.option("id") === commandToMerge.option("id") && commandToMerge.option("id"),
            behaviorEqual = targetCommand.option("behavior") === commandToMerge.option("behavior") && targetCommand.option("behavior");
        needToReplace = idEqual || behaviorEqual;
        if (behaviorEqual && null === commandToMerge.option("onExecute")) {
            commandToMerge.option("onExecute", targetCommand.option("onExecute"))
        }
        if (needToReplace) {
            targetCommand.element().remove();
            return false
        }
    });
    return needToReplace
};
var mergeCommands = function(targetCommands, commandsToMerge) {
    return mergeWithReplace(targetCommands, commandsToMerge, prepareCommandToReplace)
};
var resolvePropertyValue = function(command, containerOptions, propertyName, defaultValue) {
    var containerOption = containerOptions ? containerOptions[propertyName] : void 0,
        defaultOption = void 0 === containerOption ? defaultValue : containerOption,
        commandOption = command.option(propertyName);
    return void 0 === commandOption || commandOption === defaultValue ? defaultOption : commandOption
};
var resolveTextValue = function(command, containerOptions) {
    var showText = resolvePropertyValue(command, containerOptions, "showText"),
        hasIcon = !!command.option("icon"),
        titleValue = resolvePropertyValue(command, containerOptions, "title", "");
    return showText || !hasIcon ? titleValue : ""
};
var resolveIconValue = function(command, containerOptions) {
    var showIcon = resolvePropertyValue(command, containerOptions, "showIcon"),
        hasText = !!command.option("title"),
        iconValue = resolvePropertyValue(command, containerOptions, "icon", "");
    return showIcon || !hasText ? iconValue : ""
};
exports.utils = {
    mergeCommands: mergeCommands,
    commandToContainer: {
        resolveIconValue: resolveIconValue,
        resolveTextValue: resolveTextValue,
        resolvePropertyValue: resolvePropertyValue
    }
};
exports.templateProvider = {
    createTemplate: function(element) {
        return new KoTemplate(element)
    },
    applyTemplate: function(element, model) {
        ko.applyBindings(model, element)
    }
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/navigation_manager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    isPlainObject = __webpack_require__(9).isPlainObject,
    extend = __webpack_require__(1).extend,
    navigationDevices = __webpack_require__(116),
    EventsMixin = __webpack_require__(38),
    errors = __webpack_require__(48),
    hardwareBackButton = __webpack_require__(167).processCallback,
    hideTopOverlay = __webpack_require__(108),
    when = __webpack_require__(10).when;
var NAVIGATION_TARGETS = {
        current: "current",
        blank: "blank",
        back: "back"
    },
    STORAGE_HISTORY_KEY = "__history";
var HistoryBasedNavigationManager = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this._currentItem = void 0;
        this._previousItem = void 0;
        this._createNavigationDevice(options)
    },
    _createNavigationDevice: function(options) {
        this._navigationDevice = options.navigationDevice || new navigationDevices.HistoryBasedNavigationDevice;
        this._navigationDevice.uriChanged.add(this._uriChangedHandler.bind(this))
    },
    _uriChangedHandler: function(uri) {
        while (hideTopOverlay()) {}
        this.navigate(uri)
    },
    _syncUriWithCurrentNavigationItem: function() {
        var currentUri = this._currentItem && this._currentItem.uri;
        this._navigationDevice.setUri(currentUri, true)
    },
    _cancelNavigation: function(args) {
        this._syncUriWithCurrentNavigationItem();
        this.fireEvent("navigationCanceled", [args])
    },
    _getDefaultOptions: function() {
        return {
            direction: "none",
            target: NAVIGATION_TARGETS.blank
        }
    },
    _updateHistory: function(uri, options) {
        this._previousItem = this._currentItem;
        this._currentItem = {
            uri: uri,
            key: uri
        };
        this._navigationDevice.setUri(uri, options.target === NAVIGATION_TARGETS.current)
    },
    _setCurrentItem: function(item) {
        this._currentItem = item
    },
    navigate: function(uri, options) {
        options = options || {};
        var args, that = this,
            isFirstNavigate = !that._currentItem,
            currentItem = that._currentItem || {},
            targetItem = options.item || {},
            currentUri = currentItem.uri,
            currentKey = currentItem.key,
            targetKey = targetItem.key;
        if (void 0 === uri) {
            uri = that._navigationDevice.getUri()
        }
        if (/^_back$/.test(uri)) {
            that.back();
            return
        }
        options = extend(that._getDefaultOptions(), options || {});
        if (isFirstNavigate) {
            options.target = NAVIGATION_TARGETS.current
        }
        args = {
            currentUri: currentUri,
            uri: uri,
            cancel: false,
            navigateWhen: [],
            options: options
        };
        that.fireEvent("navigating", [args]);
        uri = args.uri;
        if (args.cancel || currentUri === uri && (void 0 === targetKey || targetKey === currentKey) && !that._forceNavigate) {
            that._cancelNavigation(args)
        } else {
            that._forceNavigate = false;
            when.apply($, args.navigateWhen).done(function() {
                commonUtils.executeAsync(function() {
                    that._updateHistory(uri, options);
                    that.fireEvent("navigated", [{
                        uri: uri,
                        previousUri: currentUri,
                        options: options,
                        item: that._currentItem
                    }])
                })
            })
        }
    },
    back: function() {
        return this._navigationDevice.back()
    },
    previousItem: function() {
        return this._previousItem
    },
    currentItem: function(item) {
        if (arguments.length > 0) {
            if (!item) {
                throw errors.Error("E3023")
            }
            this._setCurrentItem(item)
        } else {
            return this._currentItem
        }
    },
    rootUri: function() {
        return this._currentItem && this._currentItem.uri
    },
    canBack: function() {
        return true
    },
    saveState: commonUtils.noop,
    restoreState: commonUtils.noop,
    removeState: commonUtils.noop
}).include(EventsMixin);
var StackBasedNavigationManager = HistoryBasedNavigationManager.inherit({
    ctor: function(options) {
        options = options || {};
        this.callBase(options);
        this._createNavigationStacks(options);
        hardwareBackButton.add(this._deviceBackInitiated.bind(this));
        this._stateStorageKey = options.stateStorageKey || STORAGE_HISTORY_KEY
    },
    init: function() {
        return this._navigationDevice.init()
    },
    _createNavigationDevice: function(options) {
        if (!options.navigationDevice) {
            options.navigationDevice = new navigationDevices.StackBasedNavigationDevice
        }
        this.callBase(options);
        this._navigationDevice.backInitiated.add(this._deviceBackInitiated.bind(this))
    },
    _uriChangedHandler: function(uri) {
        this.navigate(uri)
    },
    _createNavigationStacks: function(options) {
        this.navigationStacks = {};
        this._keepPositionInStack = options.keepPositionInStack;
        this.currentStack = new NavigationStack
    },
    _deviceBackInitiated: function() {
        if (!hideTopOverlay()) {
            this.back({
                isHardwareButton: true
            })
        } else {
            this._syncUriWithCurrentNavigationItem()
        }
    },
    _getDefaultOptions: function() {
        return {
            target: NAVIGATION_TARGETS.blank
        }
    },
    _createNavigationStack: function() {
        var result = new NavigationStack;
        result.itemsRemoved.add(this._removeItems.bind(this));
        return result
    },
    _setCurrentItem: function(item) {
        this._setCurrentStack(item.stack);
        this.currentStack.currentItem(item);
        this.callBase(item);
        this._syncUriWithCurrentNavigationItem()
    },
    _setCurrentStack: function(stackOrStackKey) {
        var stack, stackKey;
        if ("string" === typeof stackOrStackKey) {
            stackKey = stackOrStackKey;
            if (!(stackKey in this.navigationStacks)) {
                this.navigationStacks[stackKey] = this._createNavigationStack()
            }
            stack = this.navigationStacks[stackKey]
        } else {
            stack = stackOrStackKey;
            stackKey = $.map(this.navigationStacks, function(stack, key) {
                if (stack === stackOrStackKey) {
                    return key
                }
                return null
            })[0]
        }
        this.currentStack = stack;
        this.currentStackKey = stackKey
    },
    _getViewTargetStackKey: function(uri, isRoot) {
        var result;
        if (isRoot) {
            if (void 0 !== this.navigationStacks[uri]) {
                result = uri
            } else {
                for (var stackKey in this.navigationStacks) {
                    if (this.navigationStacks[stackKey].items[0].uri === uri) {
                        result = stackKey;
                        break
                    }
                }
                result = result || uri
            }
        } else {
            result = this.currentStackKey || uri
        }
        return result
    },
    _updateHistory: function(uri, options) {
        var isRoot = options.root,
            forceIsRoot = isRoot,
            forceToRoot = false,
            previousStack = this.currentStack,
            keepPositionInStack = void 0 !== options.keepPositionInStack ? options.keepPositionInStack : this._keepPositionInStack;
        options.stack = options.stack || this._getViewTargetStackKey(uri, isRoot);
        this._setCurrentStack(options.stack);
        if (isRoot || !this.currentStack.items.length) {
            forceToRoot = this.currentStack === previousStack;
            forceIsRoot = true
        }
        if (isRoot && this.currentStack.items.length) {
            if (!keepPositionInStack || forceToRoot) {
                this.currentStack.currentIndex = 0;
                if (this.currentItem().uri !== uri) {
                    this.currentStack.navigate(uri, true)
                }
            }
            options.direction = options.direction || "none"
        } else {
            var prevIndex = this.currentStack.currentIndex,
                prevItem = this.currentItem() || {};
            switch (options.target) {
                case NAVIGATION_TARGETS.blank:
                    this.currentStack.navigate(uri);
                    break;
                case NAVIGATION_TARGETS.current:
                    this.currentStack.navigate(uri, true);
                    break;
                case NAVIGATION_TARGETS.back:
                    if (this.currentStack.currentIndex > 0) {
                        this.currentStack.back(uri)
                    } else {
                        this.currentStack.navigate(uri, true)
                    }
                    break;
                default:
                    throw errors.Error("E3006", options.target)
            }
            if (void 0 === options.direction) {
                var indexDelta = this.currentStack.currentIndex - prevIndex;
                if (indexDelta < 0) {
                    options.direction = this.currentStack.currentItem().backDirection || "backward"
                } else {
                    if (indexDelta > 0 && this.currentStack.currentIndex > 0) {
                        options.direction = "forward"
                    } else {
                        options.direction = "none"
                    }
                }
            }
            prevItem.backDirection = "forward" === options.direction ? "backward" : "none"
        }
        options.root = forceIsRoot;
        this._currentItem = this.currentStack.currentItem();
        this._syncUriWithCurrentNavigationItem()
    },
    _removeItems: function(items) {
        var that = this;
        $.each(items, function(index, item) {
            that.fireEvent("itemRemoved", [item])
        })
    },
    back: function(options) {
        options = options || {};
        var navigatingBackArgs = extend({
            cancel: false
        }, options);
        this.fireEvent("navigatingBack", [navigatingBackArgs]);
        if (navigatingBackArgs.cancel) {
            this._syncUriWithCurrentNavigationItem();
            return
        }
        var item = this.previousItem(navigatingBackArgs.stack);
        if (item) {
            this.navigate(item.uri, {
                stack: navigatingBackArgs.stack,
                target: NAVIGATION_TARGETS.back,
                item: item
            })
        } else {
            this.callBase()
        }
    },
    rootUri: function() {
        return this.currentStack.items.length ? this.currentStack.items[0].uri : this.callBase()
    },
    canBack: function(stackKey) {
        var stack = stackKey ? this.navigationStacks[stackKey] : this.currentStack;
        return stack ? stack.canBack() : false
    },
    saveState: function(storage) {
        if (this.currentStack.items.length) {
            var state = {
                navigationStacks: {},
                currentStackKey: this.currentStackKey
            };
            $.each(this.navigationStacks, function(stackKey, stack) {
                var stackState = {};
                state.navigationStacks[stackKey] = stackState;
                stackState.currentIndex = stack.currentIndex;
                stackState.items = $.map(stack.items, function(item) {
                    return {
                        key: item.key,
                        uri: item.uri
                    }
                })
            });
            var json = JSON.stringify(state);
            storage.setItem(this._stateStorageKey, json)
        } else {
            this.removeState(storage)
        }
    },
    restoreState: function(storage) {
        if (this.disableRestoreState) {
            return
        }
        var json = storage.getItem(this._stateStorageKey);
        if (json) {
            try {
                var that = this,
                    state = JSON.parse(json);
                $.each(state.navigationStacks, function(stackKey, stackState) {
                    var stack = that._createNavigationStack();
                    that.navigationStacks[stackKey] = stack;
                    stack.currentIndex = stackState.currentIndex;
                    stack.items = $.map(stackState.items, function(item) {
                        item.stack = stack;
                        return item
                    })
                });
                this.currentStackKey = state.currentStackKey;
                this.currentStack = this.navigationStacks[this.currentStackKey];
                this._currentItem = this.currentStack.currentItem();
                this._navigationDevice.setUri(this.currentItem().uri);
                this._forceNavigate = true
            } catch (e) {
                this.removeState(storage);
                throw errors.Error("E3007")
            }
        }
    },
    removeState: function(storage) {
        storage.removeItem(this._stateStorageKey)
    },
    currentIndex: function() {
        return this.currentStack.currentIndex
    },
    previousItem: function(stackKey) {
        var stack = this.navigationStacks[stackKey] || this.currentStack;
        return stack.previousItem()
    },
    getItemByIndex: function(index) {
        return this.currentStack.items[index]
    },
    clearHistory: function() {
        this._createNavigationStacks({
            keepPositionInStack: this._keepPositionInStack
        })
    },
    itemByKey: function(itemKey) {
        var result;
        $.each(this.navigationStacks, function(stackKey, stack) {
            var item = stack.itemByKey(itemKey);
            if (item) {
                result = item;
                return false
            }
        });
        return result
    },
    currentItem: function(itemOrItemKey) {
        var item;
        if (arguments.length > 0) {
            if ("string" === typeof itemOrItemKey) {
                item = this.itemByKey(itemOrItemKey)
            } else {
                if (isPlainObject(itemOrItemKey)) {
                    item = itemOrItemKey
                }
            }
            this.callBase(item)
        } else {
            return this.callBase()
        }
    }
});
var NavigationStack = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this.itemsRemoved = $.Callbacks();
        this.clear()
    },
    currentItem: function(item) {
        if (item) {
            for (var i = 0; i < this.items.length; i++) {
                if (item === this.items[i]) {
                    this.currentIndex = i;
                    break
                }
            }
        } else {
            return this.items[this.currentIndex]
        }
    },
    previousItem: function() {
        return this.items.length > 1 ? this.items[this.currentIndex - 1] : void 0
    },
    canBack: function() {
        return this.currentIndex > 0
    },
    clear: function() {
        this._deleteItems(this.items);
        this.items = [];
        this.currentIndex = -1
    },
    back: function(uri) {
        this.currentIndex--;
        if (this.currentIndex < 0) {
            throw errors.Error("E3008")
        }
        var currentItem = this.currentItem();
        if (currentItem.uri !== uri) {
            this._updateItem(this.currentIndex, uri)
        }
    },
    forward: function() {
        this.currentIndex++;
        if (this.currentIndex >= this.items.length) {
            throw errors.Error("E3009")
        }
    },
    navigate: function(uri, replaceCurrent) {
        if (this.currentIndex < this.items.length && this.currentIndex > -1 && this.items[this.currentIndex].uri === uri) {
            return
        }
        if (replaceCurrent && this.currentIndex > -1) {
            this.currentIndex--
        }
        if (this.currentIndex + 1 < this.items.length && this.items[this.currentIndex + 1].uri === uri) {
            this.currentIndex++
        } else {
            var toDelete = this.items.splice(this.currentIndex + 1, this.items.length - this.currentIndex - 1);
            this.items.push({
                stack: this
            });
            this.currentIndex++;
            this._updateItem(this.currentIndex, uri);
            this._deleteItems(toDelete)
        }
        return this.currentItem()
    },
    itemByKey: function(key) {
        for (var i = 0; i < this.items.length; i++) {
            var item = this.items[i];
            if (item.key === key) {
                return item
            }
        }
    },
    _updateItem: function(index, uri) {
        var item = this.items[index];
        item.uri = uri;
        item.key = this.items[0].uri + "_" + index + "_" + uri
    },
    _deleteItems: function(items) {
        if (items) {
            this.itemsRemoved.fire(items)
        }
    }
});
exports.HistoryBasedNavigationManager = HistoryBasedNavigationManager;
exports.StackBasedNavigationManager = StackBasedNavigationManager;
exports.NavigationStack = NavigationStack;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/globalize/core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Globalize = __webpack_require__(50),
    coreLocalization = __webpack_require__(60);
if (Globalize && Globalize.load) {
    var likelySubtags = {
        supplemental: {
            version: {
                _cldrVersion: "28",
                _unicodeVersion: "8.0.0",
                _number: "$Revision: 11965 $"
            },
            likelySubtags: {
                en: "en-Latn-US",
                de: "de-Latn-DE",
                ru: "ru-Cyrl-RU",
                ja: "ja-Jpan-JP"
            }
        }
    };
    if (!Globalize.locale()) {
        Globalize.load(likelySubtags);
        Globalize.locale("en")
    }
    coreLocalization.inject({
        locale: function(locale) {
            if (!locale) {
                return Globalize.locale().locale
            }
            Globalize.locale(locale)
        }
    })
}


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/abstract_store.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    abstract = Class.abstract,
    EventsMixin = __webpack_require__(38),
    errorsModule = __webpack_require__(29),
    dataUtils = __webpack_require__(28),
    compileGetter = __webpack_require__(14).compileGetter,
    storeHelper = __webpack_require__(97),
    queryByOptions = storeHelper.queryByOptions,
    storeImpl = {};
var Store = Class.inherit({
    ctor: function(options) {
        var that = this;
        options = options || {};
        $.each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
            if (optionName in options) {
                that.on(optionName.slice(2).toLowerCase(), options[optionName])
            }
        });
        this._key = options.key;
        this._errorHandler = options.errorHandler;
        this._useDefaultSearch = true
    },
    _customLoadOptions: function() {
        return null
    },
    key: function() {
        return this._key
    },
    keyOf: function(obj) {
        if (!this._keyGetter) {
            this._keyGetter = compileGetter(this.key())
        }
        return this._keyGetter(obj)
    },
    _requireKey: function() {
        if (!this.key()) {
            throw errorsModule.errors.Error("E4005")
        }
    },
    load: function(options) {
        var that = this;
        options = options || {};
        this.fireEvent("loading", [options]);
        return this._withLock(this._loadImpl(options)).done(function(result) {
            that.fireEvent("loaded", [result, options])
        })
    },
    _loadImpl: function(options) {
        return queryByOptions(this.createQuery(options), options).enumerate()
    },
    _withLock: function(task) {
        var result = $.Deferred();
        task.done(function() {
            var that = this,
                args = arguments;
            dataUtils.processRequestResultLock.promise().done(function() {
                result.resolveWith(that, args)
            })
        }).fail(function() {
            result.rejectWith(this, arguments)
        });
        return result
    },
    createQuery: abstract,
    totalCount: function(options) {
        return this._totalCountImpl(options)
    },
    _totalCountImpl: function(options) {
        return queryByOptions(this.createQuery(options), options, true).count()
    },
    byKey: function(key, extraOptions) {
        return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)))
    },
    _byKeyImpl: abstract,
    insert: function(values) {
        var that = this;
        that.fireEvent("modifying");
        that.fireEvent("inserting", [values]);
        return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
            that.fireEvent("inserted", [callbackValues, callbackKey]);
            that.fireEvent("modified")
        }))
    },
    _insertImpl: abstract,
    update: function(key, values) {
        var that = this;
        that.fireEvent("modifying");
        that.fireEvent("updating", [key, values]);
        return that._addFailHandlers(that._updateImpl(key, values).done(function(callbackKey, callbackValues) {
            that.fireEvent("updated", [callbackKey, callbackValues]);
            that.fireEvent("modified")
        }))
    },
    _updateImpl: abstract,
    remove: function(key) {
        var that = this;
        that.fireEvent("modifying");
        that.fireEvent("removing", [key]);
        return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
            that.fireEvent("removed", [callbackKey]);
            that.fireEvent("modified")
        }))
    },
    _removeImpl: abstract,
    _addFailHandlers: function(deferred) {
        return deferred.fail(this._errorHandler, errorsModule._errorHandler)
    }
}).include(EventsMixin);
Store.create = function(alias, options) {
    if (!(alias in storeImpl)) {
        throw errorsModule.errors.Error("E4020", alias)
    }
    return new storeImpl[alias](options)
};
Store.inherit = function(inheritor) {
    return function(members, alias) {
        var type = inheritor.apply(this, [members]);
        if (alias) {
            storeImpl[alias] = type
        }
        return type
    }
}(Store.inherit);
module.exports = Store;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/store_helper.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    grep = __webpack_require__(2).grep,
    extend = __webpack_require__(1).extend,
    arrayQuery = __webpack_require__(119),
    normalizeSortingInfo = __webpack_require__(28).normalizeSortingInfo;

function multiLevelGroup(query, groupInfo) {
    query = query.groupBy(groupInfo[0].selector);
    if (groupInfo.length > 1) {
        query = query.select(function(g) {
            return extend({}, g, {
                items: multiLevelGroup(arrayQuery(g.items), groupInfo.slice(1)).toArray()
            })
        })
    }
    return query
}

function arrangeSortingInfo(groupInfo, sortInfo) {
    var filteredGroup = [];
    $.each(groupInfo, function(_, group) {
        var collision = grep(sortInfo, function(sort) {
            return group.selector === sort.selector
        });
        if (collision.length < 1) {
            filteredGroup.push(group)
        }
    });
    return filteredGroup.concat(sortInfo)
}

function queryByOptions(query, options, isCountQuery) {
    options = options || {};
    var filter = options.filter,
        sort = options.sort,
        select = options.select,
        group = options.group,
        skip = options.skip,
        take = options.take;
    if (filter) {
        query = query.filter(filter)
    }
    if (group) {
        group = normalizeSortingInfo(group)
    }
    if (!isCountQuery) {
        if (sort || group) {
            sort = normalizeSortingInfo(sort || []);
            if (group) {
                sort = arrangeSortingInfo(group, sort)
            }
            $.each(sort, function(index) {
                query = query[index ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare)
            })
        }
        if (select) {
            query = query.select(select)
        }
    }
    if (group) {
        query = multiLevelGroup(query, group)
    }
    if (!isCountQuery) {
        if (take || skip) {
            query = query.slice(skip || 0, take)
        }
    }
    return query
}
module.exports = {
    multiLevelGroup: multiLevelGroup,
    arrangeSortingInfo: arrangeSortingInfo,
    queryByOptions: queryByOptions
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/popover.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    stringUtils = __webpack_require__(30),
    extend = __webpack_require__(1).extend,
    translator = __webpack_require__(19),
    positionUtils = __webpack_require__(46),
    commonUtils = __webpack_require__(2),
    mathUtils = __webpack_require__(56),
    eventUtils = __webpack_require__(3),
    Popup = __webpack_require__(68);
var POPOVER_CLASS = "dx-popover",
    POPOVER_WRAPPER_CLASS = "dx-popover-wrapper",
    POPOVER_ARROW_CLASS = "dx-popover-arrow",
    POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title",
    POSITION_FLIP_MAP = {
        left: "right",
        top: "bottom",
        right: "left",
        bottom: "top",
        center: "center"
    },
    WEIGHT_OF_SIDES = {
        left: -1,
        top: -1,
        center: 0,
        right: 1,
        bottom: 1
    },
    POSITION_ALIASES = {
        top: {
            my: "bottom center",
            at: "top center",
            collision: "fit flip"
        },
        bottom: {
            my: "top center",
            at: "bottom center",
            collision: "fit flip"
        },
        right: {
            my: "left center",
            at: "right center",
            collision: "flip fit"
        },
        left: {
            my: "right center",
            at: "left center",
            collision: "flip fit"
        }
    },
    getEventName = function(that, optionName) {
        var optionValue = that.option(optionName);
        return commonUtils.isObject(optionValue) ? optionValue.name : optionValue
    },
    getEventDelay = function(that, optionName) {
        var optionValue = that.option(optionName);
        return commonUtils.isObject(optionValue) && optionValue.delay
    },
    attachEvent = function(that, name) {
        var delay, action, handler, eventName, target = that.option("target"),
            event = getEventName(that, name + "Event");
        if (!event || that.option("disabled")) {
            return
        }
        eventName = eventUtils.addNamespace(event, that.NAME);
        action = that._createAction(function() {
            delay = getEventDelay(that, name + "Event");
            this._clearEventTimeout("hide" === name);
            if (delay) {
                this._timeouts[name] = setTimeout(function() {
                    that[name]()
                }, delay)
            } else {
                that[name]()
            }
        }.bind(that), {
            validatingTargetName: "target"
        });
        handler = function(e) {
            action({
                jQueryEvent: e,
                target: $(e.currentTarget)
            })
        };
        if (target.jquery || target.nodeType || commonUtils.isWindow(target)) {
            that["_" + name + "EventHandler"] = void 0;
            $(target).on(eventName, handler)
        } else {
            that["_" + name + "EventHandler"] = handler;
            $(document).on(eventName, target, handler)
        }
    },
    detachEvent = function(that, target, name) {
        var eventName, event = getEventName(that, name + "Event");
        if (!event) {
            return
        }
        eventName = eventUtils.addNamespace(event, that.NAME);
        if (that["_" + name + "EventHandler"]) {
            $(document).off(eventName, target, that["_" + name + "EventHandler"])
        } else {
            $(target).off(eventName)
        }
    };
var Popover = Popup.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            target: window,
            shading: false,
            position: "bottom",
            closeOnOutsideClick: true,
            animation: {
                show: {
                    type: "fade",
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    to: 0
                }
            },
            showTitle: false,
            width: "auto",
            height: "auto",
            dragEnabled: false,
            resizeEnabled: false,
            fullScreen: false,
            closeOnTargetScroll: true,
            arrowPosition: "",
            arrowOffset: 0,
            boundaryOffset: {
                h: 10,
                v: 10
            }
        })
    },
    _defaultOptionsRules: function() {
        return [{
            device: {
                platform: "ios"
            },
            options: {
                arrowPosition: {
                    boundaryOffset: {
                        h: 20,
                        v: -10
                    },
                    collision: "fit"
                }
            }
        }]
    },
    _init: function() {
        this.callBase();
        this._renderArrow();
        this._timeouts = {};
        this.element().addClass(POPOVER_CLASS);
        this._wrapper().addClass(POPOVER_WRAPPER_CLASS)
    },
    _render: function() {
        this.callBase.apply(this, arguments);
        this._detachEvents(this.option("target"));
        this._attachEvents()
    },
    _detachEvents: function(target) {
        detachEvent(this, target, "show");
        detachEvent(this, target, "hide")
    },
    _attachEvents: function() {
        attachEvent(this, "show");
        attachEvent(this, "hide")
    },
    _renderArrow: function() {
        this._$arrow = $("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.overlayContent())
    },
    _documentDownHandler: function(e) {
        if (this._isOutsideClick(e)) {
            return this.callBase(e)
        }
        return true
    },
    _isOutsideClick: function(e) {
        return !$(e.target).closest(this.option("target")).length
    },
    _animate: function(animation) {
        if (animation && animation.to && "object" === typeof animation.to) {
            extend(animation.to, {
                position: this._getContainerPosition()
            })
        }
        this.callBase.apply(this, arguments)
    },
    _stopAnimation: function() {
        this.callBase.apply(this, arguments)
    },
    _renderTitle: function() {
        this._wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
        this.callBase()
    },
    _renderPosition: function() {
        this.callBase();
        this._renderOverlayPosition()
    },
    _renderOverlayBoundaryOffset: commonUtils.noop,
    _renderOverlayPosition: function() {
        this._resetOverlayPosition();
        this._updateContentSize();
        var contentPosition = this._getContainerPosition();
        var resultLocation = positionUtils.setup(this._$content, contentPosition);
        var positionSide = this._getSideByLocation(resultLocation);
        this._togglePositionClass("dx-position-" + positionSide);
        this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
        this._renderArrowPosition(positionSide)
    },
    _resetOverlayPosition: function() {
        this._setContentHeight(true);
        this._togglePositionClass("dx-position-" + this._positionSide);
        translator.move(this._$content, {
            left: 0,
            top: 0
        });
        this._$arrow.css({
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        })
    },
    _updateContentSize: function() {
        if (!this._$popupContent) {
            return
        }
        var containerLocation = positionUtils.calculate(this._$content, this._getContainerPosition());
        if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
            var newContainerWidth = this._$content.width() - containerLocation.h.oversize;
            this._$content.width(newContainerWidth)
        }
        if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
            var newOverlayContentHeight = this._$content.height() - containerLocation.v.oversize,
                newPopupContentHeight = this._$popupContent.height() - containerLocation.v.oversize;
            this._$content.height(newOverlayContentHeight);
            this._$popupContent.height(newPopupContentHeight)
        }
    },
    _getContainerPosition: function() {
        var offset = stringUtils.pairToObject(this._position.offset || "");
        var hOffset = offset.h;
        var vOffset = offset.v;
        var isPopoverInside = this._isPopoverInside();
        var sign = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
        var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
        if (this._isVerticalSide()) {
            vOffset += sign * (this._$arrow.height() - arrowSizeCorrection)
        } else {
            if (this._isHorizontalSide()) {
                hOffset += sign * (this._$arrow.width() - arrowSizeCorrection)
            }
        }
        return extend({}, this._position, {
            offset: hOffset + " " + vOffset
        })
    },
    _getContentBorderWidth: function(side) {
        var borderWidth = this._$content.css("border-" + side + "-width");
        return parseInt(borderWidth) || 0
    },
    _getSideByLocation: function(location) {
        var isFlippedByVertical = location.v.flip;
        var isFlippedByHorizontal = location.h.flip;
        return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide
    },
    _togglePositionClass: function(positionClass) {
        this._$wrapper.removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass)
    },
    _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
        this._$wrapper.toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical)
    },
    _renderArrowPosition: function(side) {
        this._$arrow.css(POSITION_FLIP_MAP[side], -(this._isVerticalSide(side) ? this._$arrow.height() : this._$arrow.width()));
        var axis = this._isVerticalSide(side) ? "left" : "top";
        var sizeProperty = this._isVerticalSide(side) ? "outerWidth" : "outerHeight";
        var $target = $(this._position.of);
        var targetOffset = positionUtils.offset($target) || {
            top: 0,
            left: 0
        };
        var contentOffset = positionUtils.offset(this._$content);
        var arrowSize = this._$arrow[sizeProperty]();
        var contentLocation = contentOffset[axis];
        var contentSize = this._$content[sizeProperty]();
        var targetLocation = targetOffset[axis];
        var targetSize = $target.get(0).preventDefault ? 0 : $target[sizeProperty]();
        var min = Math.max(contentLocation, targetLocation);
        var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
        var arrowLocation;
        if ("start" === this.option("arrowPosition")) {
            arrowLocation = min - contentLocation
        } else {
            if ("end" === this.option("arrowPosition")) {
                arrowLocation = max - contentLocation - arrowSize
            } else {
                arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2
            }
        }
        var borderWidth = this._getContentBorderWidth(side);
        var finalArrowLocation = mathUtils.fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
        this._$arrow.css(axis, finalArrowLocation)
    },
    _isPopoverInside: function() {
        var position = this._getPosition();
        var my = positionUtils.setup.normalizeAlign(position.my);
        var at = positionUtils.setup.normalizeAlign(position.at);
        return my.h === at.h && my.v === at.v
    },
    _getPosition: function() {
        var position = this.option("position");
        if (commonUtils.isString(position)) {
            position = extend({}, POSITION_ALIASES[position])
        }
        return position
    },
    _setContentHeight: function(fullUpdate) {
        if (fullUpdate) {
            this.callBase()
        }
    },
    _renderShadingPosition: function() {
        if (this.option("shading")) {
            this._$wrapper.css({
                top: 0,
                left: 0
            })
        }
    },
    _renderShadingDimensions: function() {
        if (this.option("shading")) {
            this._$wrapper.css({
                width: "100%",
                height: "100%"
            })
        }
    },
    _normalizePosition: function() {
        var position = extend({}, this._getPosition());
        if (!position.of) {
            position.of = this.option("target")
        }
        if (!position.collision) {
            position.collision = "flip"
        }
        if (!position.boundaryOffset) {
            position.boundaryOffset = this.option("boundaryOffset")
        }
        this._positionSide = this._getDisplaySide(position);
        this._position = position
    },
    _getDisplaySide: function(position) {
        var my = positionUtils.setup.normalizeAlign(position.my),
            at = positionUtils.setup.normalizeAlign(position.at);
        var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1,
            horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]),
            verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
        return horizontalWeight > verticalWeight ? at.h : at.v
    },
    _isVerticalSide: function(side) {
        side = side || this._positionSide;
        return "top" === side || "bottom" === side
    },
    _isHorizontalSide: function(side) {
        side = side || this._positionSide;
        return "left" === side || "right" === side
    },
    _clearEventTimeout: function(visibility) {
        clearTimeout(this._timeouts[visibility ? "show" : "hide"])
    },
    _clean: function() {
        this._detachEvents(this.option("target"));
        this.callBase.apply(this, arguments)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "showTitle":
            case "title":
            case "titleTemplate":
                this.callBase(args);
                this._renderGeometry();
                break;
            case "boundaryOffset":
            case "arrowPosition":
            case "arrowOffset":
                this._renderGeometry();
                break;
            case "fullScreen":
                if (args.value) {
                    this.option("fullScreen", false)
                }
                break;
            case "target":
                args.previousValue && this._detachEvents(args.previousValue);
                this.callBase(args);
                break;
            case "showEvent":
            case "hideEvent":
                this._invalidate();
                break;
            case "visible":
                this._clearEventTimeout(args.value);
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    show: function(target) {
        if (target) {
            this.option("target", target)
        }
        return this.callBase()
    }
});
registerComponent("dxPopover", Popover);
module.exports = Popover;
module.exports.default = module.exports;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/check_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    inkRipple = __webpack_require__(43),
    Editor = __webpack_require__(33),
    registerComponent = __webpack_require__(4),
    eventUtils = __webpack_require__(3),
    themes = __webpack_require__(20),
    clickEvent = __webpack_require__(11);
var CHECKBOX_CLASS = "dx-checkbox",
    CHECKBOX_ICON_CLASS = "dx-checkbox-icon",
    CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked",
    CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container",
    CHECKBOX_TEXT_CLASS = "dx-checkbox-text",
    CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text",
    CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate",
    CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
var CheckBox = Editor.inherit({
    _supportedKeys: function() {
        var click = function(e) {
            e.preventDefault();
            this._clickAction({
                jQueryEvent: e
            })
        };
        return extend(this.callBase(), {
            space: click
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            value: false,
            text: "",
            useInkRipple: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _feedbackHideTimeout: CHECKBOX_FEEDBACK_HIDE_TIMEOUT,
    _render: function() {
        this._renderSubmitElement();
        this.callBase();
        this._$container = $("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
        this.setAria("role", "checkbox");
        this._renderClick();
        this._renderValue();
        this._renderIcon();
        this._renderText();
        this.option("useInkRipple") && this._renderInkRipple();
        this.element().addClass(CHECKBOX_CLASS).append(this._$container)
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render({
            waveSizeCoefficient: 2.5,
            useHoldAnimation: false,
            wavesNumber: 2,
            isCentered: true
        })
    },
    _renderInkWave: function(element, jQueryEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: element,
            jQueryEvent: jQueryEvent,
            wave: waveIndex
        };
        if (doRender) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _updateFocusState: function(e, value) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 0)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 1)
    },
    _renderIcon: function() {
        this._$icon = $("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container)
    },
    _renderText: function() {
        var textValue = this.option("text");
        if (!textValue) {
            if (this._$text) {
                this._$text.remove();
                this.element().removeClass(CHECKBOX_HAS_TEXT_CLASS)
            }
            return
        }
        if (!this._$text) {
            this._$text = $("<span>").addClass(CHECKBOX_TEXT_CLASS)
        }
        this._$text.text(textValue);
        this._$container.append(this._$text);
        this.element().addClass(CHECKBOX_HAS_TEXT_CLASS)
    },
    _renderClick: function() {
        var that = this,
            eventName = eventUtils.addNamespace(clickEvent.name, that.NAME);
        that._clickAction = that._createAction(that._clickHandler);
        that.element().off(eventName).on(eventName, function(e) {
            that._clickAction({
                jQueryEvent: e
            })
        })
    },
    _clickHandler: function(args) {
        var that = args.component;
        that._saveValueChangeEvent(args.jQueryEvent);
        that.option("value", !that.option("value"))
    },
    _renderValue: function() {
        var $element = this.element(),
            checked = this.option("value"),
            indeterminate = void 0 === checked;
        $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
        $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
        this._$submitElement.val(checked);
        this.setAria("checked", indeterminate ? "mixed" : checked || "false")
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
                this._invalidate();
                break;
            case "value":
                this._renderValue();
                this.callBase(args);
                break;
            case "text":
                this._renderText();
                this._renderDimensions();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxCheckBox", CheckBox);
module.exports = CheckBox;
module.exports.default = module.exports;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    dateSerialization = __webpack_require__(71),
    commonUtils = __webpack_require__(2),
    dateLocalization = __webpack_require__(32);
var dateComponents = function() {
    return ["year", "day", "month", "day"]
};
var ONE_MINUTE = 6e4;
var ONE_DAY = 60 * ONE_MINUTE * 24;
var ONE_YEAR = 365 * ONE_DAY;
var getStringFormat = function(format) {
    var formatType = typeof format;
    if ("string" === formatType) {
        return "format"
    }
    if ("object" === formatType && void 0 !== format.type) {
        return format.type
    }
    return null
};
var dateUtils = {
    SUPPORTED_FORMATS: ["date", "time", "datetime"],
    DEFAULT_FORMATTER: function(value) {
        return value
    },
    DATE_COMPONENT_TEXT_FORMATTER: function(value, name) {
        var $container = $("<div>").addClass("dx-dateview-formatter-container");
        $("<span>").text(value).addClass("dx-dateview-value-formatter").appendTo($container);
        $("<span>").text(name).addClass("dx-dateview-name-formatter").appendTo($container);
        return $container
    },
    ONE_MINUTE: ONE_MINUTE,
    ONE_DAY: ONE_DAY,
    ONE_YEAR: ONE_YEAR,
    MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
    MAX_DATEVIEW_DEFAULT_DATE: function() {
        var newDate = new Date;
        return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59)
    }(),
    FORMATS_INFO: {
        date: {
            getStandardPattern: function() {
                return "yyyy-MM-dd"
            },
            components: dateComponents()
        },
        time: {
            getStandardPattern: function() {
                return "HH:mm"
            },
            components: ["hours", "minutes", "seconds", "milliseconds"]
        },
        datetime: {
            getStandardPattern: function() {
                var standardPattern;
                ! function() {
                    var androidFormatPattern = "yyyy-MM-ddTHH:mmZ",
                        testDateString = "2000-01-01T01:01Z";
                    var $input = $("<input>").attr("type", "datetime");
                    $input.val(testDateString);
                    if ($input.val()) {
                        standardPattern = androidFormatPattern
                    }
                }();
                if (!standardPattern) {
                    standardPattern = "yyyy-MM-ddTHH:mm:ssZ"
                }
                dateUtils.FORMATS_INFO.datetime.getStandardPattern = function() {
                    return standardPattern
                };
                return standardPattern
            },
            components: dateComponents().concat(["hours", "minutes", "seconds", "milliseconds"])
        },
        "datetime-local": {
            getStandardPattern: function() {
                return "yyyy-MM-ddTHH:mm:ss"
            },
            components: dateComponents().concat(["hours", "minutes", "seconds"])
        }
    },
    FORMATS_MAP: {
        date: "shortdate",
        time: "shorttime",
        datetime: "shortdateshorttime"
    },
    SUBMIT_FORMATS_MAP: {
        date: "date",
        time: "time",
        datetime: "datetime-local"
    },
    toStandardDateFormat: function(date, type) {
        var pattern = dateUtils.FORMATS_INFO[type].getStandardPattern();
        return dateSerialization.serializeDate(date, pattern)
    },
    fromStandardDateFormat: function(text) {
        var date = dateSerialization.dateParser(text);
        return commonUtils.isDate(date) ? date : void 0
    },
    getMaxMonthDay: function(year, month) {
        return new Date(year, month + 1, 0).getDate()
    },
    mergeDates: function(oldValue, newValue, format) {
        if (!newValue) {
            return newValue || null
        }
        if (!oldValue || isNaN(oldValue.getTime())) {
            var now = new Date(null);
            oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate())
        }
        var result = new Date(oldValue.valueOf());
        var formatInfo = dateUtils.FORMATS_INFO[format];
        $.each(formatInfo.components, function() {
            var componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
            result[componentInfo.setter](newValue[componentInfo.getter]())
        });
        return result
    },
    getLongestCaptionIndex: function(captionArray) {
        var i, longestIndex = 0,
            longestCaptionLength = 0;
        for (i = 0; i < captionArray.length; ++i) {
            if (captionArray[i].length > longestCaptionLength) {
                longestIndex = i;
                longestCaptionLength = captionArray[i].length
            }
        }
        return longestIndex
    },
    formatUsesMonthName: function(format) {
        return dateLocalization.formatUsesMonthName(format)
    },
    formatUsesDayName: function(format) {
        return dateLocalization.formatUsesDayName(format)
    },
    getLongestDate: function(format, monthNames, dayNames) {
        var stringFormat = getStringFormat(format),
            month = 9;
        if (!stringFormat || dateUtils.formatUsesMonthName(stringFormat)) {
            month = dateUtils.getLongestCaptionIndex(monthNames)
        }
        var longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
        if (!stringFormat || dateUtils.formatUsesDayName(stringFormat)) {
            var date = longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames);
            longestDate.setDate(date)
        }
        return longestDate
    }
};
dateUtils.DATE_COMPONENTS_INFO = {
    year: {
        getter: "getFullYear",
        setter: "setFullYear",
        formatter: dateUtils.DEFAULT_FORMATTER,
        startValue: void 0,
        endValue: void 0
    },
    day: {
        getter: "getDate",
        setter: "setDate",
        formatter: function(value, showNames, date) {
            if (!showNames) {
                return value
            }
            var formatDate = new Date(date.getTime());
            formatDate.setDate(value);
            return dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value, dateLocalization.getDayNames()[formatDate.getDay()])
        },
        startValue: 1,
        endValue: void 0
    },
    month: {
        getter: "getMonth",
        setter: "setMonth",
        formatter: function(value, showNames) {
            var monthName = dateLocalization.getMonthNames()[value];
            return showNames ? dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value + 1, monthName) : monthName
        },
        startValue: 0,
        endValue: 11
    },
    hours: {
        getter: "getHours",
        setter: "setHours",
        formatter: function(value) {
            return dateLocalization.format(new Date(0, 0, 0, value), "hour")
        },
        startValue: 0,
        endValue: 23
    },
    minutes: {
        getter: "getMinutes",
        setter: "setMinutes",
        formatter: function(value) {
            return dateLocalization.format(new Date(0, 0, 0, 0, value), "minute")
        },
        startValue: 0,
        endValue: 59
    },
    seconds: {
        getter: "getSeconds",
        setter: "setSeconds",
        formatter: function(value) {
            return dateLocalization.format(new Date(0, 0, 0, 0, 0, value), "second")
        },
        startValue: 0,
        endValue: 59
    },
    milliseconds: {
        getter: "getMilliseconds",
        setter: "setMilliseconds",
        formatter: function(value) {
            return dateLocalization.format(new Date(0, 0, 0, 0, 0, 0, value), "millisecond")
        },
        startValue: 0,
        endValue: 999
    }
};
module.exports = dateUtils;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    clickEvent = __webpack_require__(11),
    browser = __webpack_require__(21),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    devices = __webpack_require__(6),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    columnStateMixin = __webpack_require__(350);
var SCROLL_CONTAINER_CLASS = "scroll-container",
    GROUP_SPACE_CLASS = "group-space",
    CONTENT_CLASS = "content",
    TABLE_CLASS = "table",
    TABLE_FIXED_CLASS = "table-fixed",
    CONTENT_FIXED_CLASS = "content-fixed",
    ROW_CLASS = "dx-row",
    GROUP_ROW_CLASS = "dx-group-row",
    DETAIL_ROW_CLASS = "dx-master-detail-row",
    HIDDEN_COLUMNS_WIDTH = "0.0001px",
    CELL_HINT_VISIBLE = "dxCellHintVisible",
    FORM_FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var appendElementTemplate = {
    render: function(options) {
        options.container.append(options.content)
    }
};
exports.ColumnsView = modules.View.inherit(columnStateMixin).inherit({
    _createScrollableOptions: function() {
        var that = this,
            scrollingOptions = that.option("scrolling"),
            useNativeScrolling = that.option("scrolling.useNative");
        var options = extend({}, scrollingOptions, {
            direction: "both",
            bounceEnabled: false,
            useKeyboard: false
        });
        if (void 0 === useNativeScrolling) {
            useNativeScrolling = true
        }
        if ("auto" === useNativeScrolling) {
            delete options.useNative;
            delete options.useSimulatedScrollbar
        } else {
            options.useNative = !!useNativeScrolling;
            options.useSimulatedScrollbar = !useNativeScrolling
        }
        return options
    },
    _updateCell: function($cell, parameters) {
        if (parameters.rowType) {
            this._cellPrepared($cell, parameters)
        }
    },
    _createCell: function(options) {
        var column = options.column,
            alignment = column.alignment || getDefaultAlignment(this.option("rtlEnabled"));
        var cell = window.document.createElement("td");
        cell.style.textAlign = alignment;
        var $cell = $(cell);
        this.setAria("role", "gridcell", $cell);
        if (!commonUtils.isDefined(column.groupIndex) && column.cssClass) {
            $cell.addClass(column.cssClass)
        }
        if ("expand" === column.command) {
            $cell.addClass(this.addWidgetPrefix(GROUP_SPACE_CLASS))
        }
        column.colspan > 1 && $cell.attr("colspan", column.colspan);
        return $cell
    },
    _createRow: function() {
        return $("<tr />").addClass(ROW_CLASS).attr("role", "row")
    },
    _getTableRoleName: function() {
        return "grid"
    },
    _createTable: function(columns) {
        var that = this,
            $table = $("<table />").addClass(that.addWidgetPrefix(TABLE_CLASS)).addClass(that.addWidgetPrefix(TABLE_FIXED_CLASS)).attr("role", that._getTableRoleName());
        if (columns) {
            $table.append(that._createColGroup(columns));
            if (devices.real().ios) {
                $table.append("<thead><tr></tr></thead>")
            }
        }
        $table.append("<tbody />");
        if (browser.mozilla) {
            $table.on("mousedown", "td", function(e) {
                if (e.ctrlKey) {
                    e.preventDefault()
                }
            })
        }
        if (that.option("cellHintEnabled")) {
            $table.on("mousemove", ".dx-row > td", this.createAction(function(args) {
                var e = args.jQueryEvent,
                    $element = $(e.target),
                    $cell = $(e.currentTarget),
                    $row = $cell.parent(),
                    isDataRow = $row.hasClass("dx-data-row"),
                    isHeaderRow = $row.hasClass("dx-header-row"),
                    isGroupRow = $row.hasClass("dx-group-row"),
                    visibleColumns = that._columnsController.getVisibleColumns(),
                    rowOptions = $row.data("options"),
                    columnIndex = $cell.index(),
                    cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex],
                    column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
                if ((!isDataRow || isDataRow && column && !column.cellTemplate) && (!isHeaderRow || isHeaderRow && column && !column.headerCellTemplate) && (!isGroupRow || isGroupRow && column && (void 0 === column.groupIndex || !column.groupCellTemplate))) {
                    if ($element.data(CELL_HINT_VISIBLE)) {
                        $element.removeAttr("title");
                        $element.data(CELL_HINT_VISIBLE, false)
                    }
                    if ($element[0].scrollWidth > $element[0].clientWidth && !commonUtils.isDefined($element.attr("title"))) {
                        $element.attr("title", $element.text());
                        $element.data(CELL_HINT_VISIBLE, true)
                    }
                }
            }))
        }
        var getOptions = function(event) {
            var formItemOptions, resultOptions, $cell = $(event.currentTarget),
                $fieldItemContent = $(event.target).closest("." + FORM_FIELD_ITEM_CONTENT_CLASS),
                rowOptions = $cell.parent().data("options"),
                options = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
            resultOptions = extend({}, options, {
                cellElement: $cell,
                jQueryEvent: event,
                eventType: event.type
            });
            if ($fieldItemContent.length) {
                formItemOptions = $fieldItemContent.data("dxFormItem");
                if (formItemOptions.column) {
                    resultOptions.column = formItemOptions.column;
                    resultOptions.columnIndex = that._columnsController.getVisibleIndex(resultOptions.column.index)
                }
            }
            return resultOptions
        };
        $table.on("mouseover", ".dx-row > td", function(e) {
            that.executeAction("onCellHoverChanged", getOptions(e))
        });
        $table.on("mouseout", ".dx-row > td", function(e) {
            that.executeAction("onCellHoverChanged", getOptions(e))
        });
        $table.on(clickEvent.name, ".dx-row > td", function(e) {
            that.executeAction("onCellClick", getOptions(e))
        });
        $table.on(clickEvent.name, ".dx-row", {
            useNative: that._isNativeClick()
        }, that.createAction(function(e) {
            var jQueryEvent = e.jQueryEvent;
            if (!$(jQueryEvent.target).closest("a").length) {
                e.rowIndex = that.getRowIndex(jQueryEvent.currentTarget);
                if (e.rowIndex >= 0) {
                    e.rowElement = $(jQueryEvent.currentTarget);
                    e.columns = that.getColumns();
                    that._rowClick(e)
                }
            }
        }));
        return $table
    },
    _isNativeClick: commonUtils.noop,
    _rowClick: commonUtils.noop,
    _createColGroup: function(columns) {
        var i, j, colspan, colgroupElement = $("<colgroup />");
        for (i = 0; i < columns.length; i++) {
            colspan = columns[i].colspan || 1;
            for (j = 0; j < colspan; j++) {
                colgroupElement.append(this._createCol(columns[i]))
            }
        }
        return colgroupElement
    },
    _createCol: function(column) {
        var width = column.visibleWidth || column.width;
        if ("adaptiveHidden" === width) {
            width = HIDDEN_COLUMNS_WIDTH
        }
        return $("<col />").width(width)
    },
    renderDelayedTemplates: function() {
        var templateParameters, delayedTemplates = this._delayedTemplates;
        while (delayedTemplates.length) {
            templateParameters = delayedTemplates.shift();
            templateParameters.template.render(templateParameters.options);
            if (templateParameters.options.model && templateParameters.options.model.column) {
                this._updateCell(templateParameters.options.container, templateParameters.options.model)
            }
        }
    },
    _processTemplate: function(template) {
        var templateID, renderingTemplate, that = this;
        if (template && template.render && !template.jquery) {
            renderingTemplate = {
                allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
                render: function(options) {
                    template.render(options.container, options.model)
                }
            }
        } else {
            if (commonUtils.isFunction(template)) {
                renderingTemplate = {
                    render: function(options) {
                        var renderedTemplate = template(options.container, options.model);
                        if (renderedTemplate && (renderedTemplate.jquery || renderedTemplate.nodeType)) {
                            options.container.append(renderedTemplate)
                        }
                    }
                }
            } else {
                templateID = commonUtils.isString(template) ? template : $(template).attr("id");
                if (!templateID) {
                    renderingTemplate = that.getTemplate(template)
                } else {
                    if (!that._templatesCache[templateID]) {
                        that._templatesCache[templateID] = that.getTemplate(template)
                    }
                    renderingTemplate = that._templatesCache[templateID]
                }
            }
        }
        return renderingTemplate
    },
    renderTemplate: function(container, template, options, allowRenderToDetachedContainer) {
        var that = this,
            renderingTemplate = that._processTemplate(template, options);
        if (renderingTemplate) {
            options.component = that.component;
            if (renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) {
                renderingTemplate.render({
                    container: container,
                    model: options
                });
                return true
            } else {
                that._delayedTemplates.push({
                    template: renderingTemplate,
                    options: {
                        container: container,
                        model: options
                    }
                })
            }
        }
        return false
    },
    _appendRow: function($table, $row, appendTemplate) {
        appendTemplate = appendTemplate || appendElementTemplate;
        appendTemplate.render({
            content: $row,
            container: $table
        })
    },
    _resizeCore: function() {
        var that = this,
            scrollLeft = that._scrollLeft;
        if (scrollLeft >= 0) {
            that._scrollLeft = 0;
            that.scrollTo({
                left: scrollLeft
            })
        }
    },
    _renderCore: function() {
        var $root = this.element().parent();
        if (!$root || $root.parent().length) {
            this.renderDelayedTemplates()
        }
    },
    _renderTable: function(options) {
        options = options || {};
        var $table, that = this;
        options.columns = that._columnsController.getVisibleColumns();
        $table = that._createTable(options.columns);
        that._renderRows($table, options);
        return $table
    },
    _renderRows: function($table, options) {
        var i, that = this,
            rows = that._getRows(options.change);
        for (i = 0; i < rows.length; i++) {
            that._renderRow($table, extend({
                row: rows[i]
            }, options))
        }
    },
    _renderRow: function($table, options) {
        var $row, that = this;
        options.row.cells = [];
        $row = that._createRow(options.row);
        that._renderCells($row, options);
        that._appendRow($table, $row);
        that._rowPrepared($row, extend({
            columns: options.columns
        }, options.row))
    },
    _renderCells: function($row, options) {
        var i, that = this,
            columnIndex = 0,
            row = options.row,
            columns = options.columns;
        for (i = 0; i < columns.length; i++) {
            that._renderCell($row, extend({
                column: columns[i],
                columnIndex: columnIndex,
                value: row.values && row.values[columnIndex]
            }, options));
            if (columns[i].colspan > 1) {
                columnIndex += columns[i].colspan
            } else {
                columnIndex++
            }
        }
    },
    _renderCell: function($row, options) {
        var $cell, that = this,
            cellOptions = that._getCellOptions(options),
            column = options.column;
        options.row.cells.push(cellOptions);
        $cell = that._createCell(cellOptions);
        if (!column.command) {
            that.setAria("label", that.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + that.localize("dxDataGrid-ariaValue") + " " + cellOptions.text, $cell)
        }
        that._renderCellContent($cell, cellOptions);
        $row.get(0).appendChild($cell.get(0));
        return $cell
    },
    _renderCellContent: function($cell, options) {
        var template = this._getCellTemplate(options);
        if (!template || this.renderTemplate($cell, template, options)) {
            this._updateCell($cell, options)
        }
    },
    _getCellTemplate: function() {},
    _getRows: function() {
        return []
    },
    _getCellOptions: function(options) {
        return {
            column: options.column,
            columnIndex: options.columnIndex,
            rowType: options.row.rowType
        }
    },
    _cellPrepared: function($cell, options) {
        options.cellElement = $cell;
        this.executeAction("onCellPrepared", options)
    },
    _rowPrepared: function($row, options) {
        $.data($row.get(0), "options", options);
        options.rowElement = $row;
        this.executeAction("onRowPrepared", options)
    },
    _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (gridCoreUtils.checkChanges(optionNames, ["width", "visibleWidth"])) {
            var visibleColumns = this._columnsController.getVisibleColumns();
            var widths = $.map(visibleColumns, function(column) {
                return column.visibleWidth || column.width || "auto"
            });
            this.setColumnWidths(widths);
            return
        }
        if (!this._requireReady) {
            this.render()
        }
    },
    getTableElements: function() {
        return this._tableElement || $()
    },
    _getTableElement: function() {
        return this._tableElement
    },
    _setTableElement: function(tableElement) {
        this._tableElement = tableElement
    },
    optionChanged: function(args) {
        this.callBase(args);
        switch (args.name) {
            case "cellHintEnabled":
            case "onCellPrepared":
            case "onRowPrepared":
            case "onCellHoverChanged":
                this._invalidate(true, true);
                args.handled = true
        }
    },
    init: function() {
        var that = this;
        that._scrollLeft = -1;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._delayedTemplates = [];
        that._templatesCache = {};
        that.createAction("onCellClick");
        that.createAction("onRowClick");
        that.createAction("onCellHoverChanged", {
            excludeValidators: ["disabled", "readOnly"]
        });
        that.createAction("onCellPrepared", {
            excludeValidators: ["designMode", "disabled", "readOnly"],
            category: "rendering"
        });
        that.createAction("onRowPrepared", {
            excludeValidators: ["designMode", "disabled", "readOnly"],
            category: "rendering",
            afterExecute: function(e) {
                that._afterRowPrepared(e)
            }
        });
        that._columnsController.columnsChanged.add(that._columnOptionChanged.bind(that));
        that._dataController && that._dataController.changed.add(that._handleDataChanged.bind(that))
    },
    _afterRowPrepared: commonUtils.noop,
    _handleDataChanged: function() {},
    callbackNames: function() {
        return ["scrollChanged"]
    },
    scrollTo: function(pos) {
        var that = this,
            $element = that.element(),
            $scrollContainer = $element && $element.children("." + that.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).not("." + that.addWidgetPrefix(CONTENT_FIXED_CLASS));
        that._skipScrollChanged = false;
        if (commonUtils.isDefined(pos) && commonUtils.isDefined(pos.left) && that._scrollLeft !== pos.left) {
            that._scrollLeft = pos.left;
            $scrollContainer && $scrollContainer.scrollLeft(Math.round(pos.left));
            that._skipScrollChanged = true
        }
    },
    _wrapTableInScrollContainer: function($table) {
        var $scrollContainer, that = this;
        $scrollContainer = $("<div/>").on("scroll", function() {
            !that._skipScrollChanged && that.scrollChanged.fire({
                left: $scrollContainer.scrollLeft()
            }, that.name);
            that._skipScrollChanged = false
        }).addClass(that.addWidgetPrefix(CONTENT_CLASS)).addClass(that.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).append($table).appendTo(that.element());
        return $scrollContainer
    },
    _updateContent: function($newTableElement) {
        this._setTableElement($newTableElement);
        this._wrapTableInScrollContainer($newTableElement)
    },
    _findContentElement: commonUtils.noop,
    _getWidths: function($cellElements) {
        var width, clientRect, result = [];
        if ($cellElements) {
            $.each($cellElements, function(index, item) {
                width = item.offsetWidth;
                if (item.getBoundingClientRect) {
                    clientRect = item.getBoundingClientRect();
                    if (clientRect.width > width) {
                        width = Math.ceil(clientRect.width)
                    }
                }
                result.push(width)
            })
        }
        return result
    },
    getColumnWidths: function($tableElement) {
        var $cells, that = this,
            result = [];
        (this.option("forceApplyBindings") || $.noop)();
        $tableElement = $tableElement || that._getTableElement();
        if ($tableElement) {
            $cells = $tableElement.children("tbody").children();
            for (var i = 0; i < $cells.length; i++) {
                var $cell = $cells.eq(i);
                if (!$cell.is("." + GROUP_ROW_CLASS) && !$cell.is("." + DETAIL_ROW_CLASS)) {
                    $cells = $cell.children("td");
                    break
                }
            }
            result = that._getWidths($cells)
        }
        return result
    },
    setColumnWidths: function(widths, $tableElement, columns) {
        var $cols, i, width, columnIndex;
        $tableElement = $tableElement || this._getTableElement();
        if ($tableElement && $tableElement.length && widths) {
            columnIndex = 0;
            $cols = $tableElement.find("col");
            columns = columns || this.getColumns(null, $tableElement);
            for (i = 0; i < columns.length; i++) {
                if (columns[i].colspan) {
                    columnIndex += columns[i].colspan;
                    continue
                }
                width = widths[columnIndex];
                if ("adaptiveHidden" === width) {
                    width = HIDDEN_COLUMNS_WIDTH
                }
                $cols.eq(columnIndex).css("width", width || "auto");
                columnIndex++
            }
        }
    },
    getCellElements: function(rowIndex) {
        return this._getCellElementsCore(rowIndex)
    },
    _getCellElementsCore: function(rowIndex) {
        var $row = this._getRowElements().eq(rowIndex);
        return $row.children()
    },
    getCellElement: function(rowIndex, columnIdentifier) {
        var $cell, that = this,
            $cells = that.getCellElements(rowIndex),
            columnVisibleIndex = that._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
        if ($cells.length && columnVisibleIndex >= 0) {
            $cell = $cells.eq(columnVisibleIndex)
        }
        if ($cell && $cell.length) {
            return $cell
        }
    },
    getRowElement: function(rowIndex) {
        var that = this,
            $rowElement = $(),
            $tableElements = that.getTableElements();
        $.each($tableElements, function(_, tableElement) {
            $rowElement = $rowElement.add(that._getRowElements($(tableElement)).eq(rowIndex))
        });
        if ($rowElement.length) {
            return $rowElement
        }
    },
    _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
        var columnIndex;
        if (commonUtils.isString(columnIdentifier)) {
            columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
            return this._columnsController.getVisibleIndex(columnIndex)
        }
        return columnIdentifier
    },
    getColumnElements: function() {},
    getColumns: function(rowIndex) {
        return this._columnsController.getVisibleColumns(rowIndex)
    },
    getCell: function(cellPosition, rows) {
        var $cells, $rows = rows || this._getRowElements();
        if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
            if ("virtual" !== this.option("scrolling.mode")) {
                cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1
            }
            $cells = this.getCellElements(cellPosition.rowIndex);
            if ($cells && $cells.length > 0) {
                return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1)
            }
        }
    },
    getRowsCount: function() {
        var tableElement = this._getTableElement();
        if (tableElement && 1 === tableElement.length) {
            return tableElement[0].rows.length
        }
        return 0
    },
    _getRowElements: function(tableElement) {
        tableElement = tableElement || this._getTableElement();
        return tableElement && tableElement.children("tbody").children("." + ROW_CLASS) || $()
    },
    getRowIndex: function($row) {
        return this._getRowElements().index($row)
    },
    getBoundingRect: function() {},
    getName: function() {},
    setScrollerSpacing: function(width) {
        var that = this,
            $element = that.element(),
            rtlEnabled = that.option("rtlEnabled");
        $element && $element.css(rtlEnabled ? {
            paddingLeft: width
        } : {
            paddingRight: width
        })
    },
    isScrollbarVisible: function(isHorizontal) {
        var $element = this.element(),
            $tableElement = this._tableElement;
        if ($element && $tableElement) {
            return isHorizontal ? $tableElement.outerWidth() - $element.width() > 0 : $tableElement.outerHeight() - $element.height() > 0
        }
        return false
    }
});


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/error.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    consoleUtils = __webpack_require__(83),
    stringUtils = __webpack_require__(30),
    version = __webpack_require__(104);
var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
module.exports = function(baseErrors, errors) {
    var exports = {
        ERROR_MESSAGES: extend(errors, baseErrors),
        Error: function() {
            return makeError($.makeArray(arguments))
        },
        log: function(id) {
            var method = "log";
            if (/^E\d+$/.test(id)) {
                method = "error"
            } else {
                if (/^W\d+$/.test(id)) {
                    method = "warn"
                }
            }
            consoleUtils.logger[method]("log" === method ? id : combineMessage($.makeArray(arguments)))
        }
    };
    var combineMessage = function(args) {
        var id = args[0];
        args = args.slice(1);
        return formatMessage(id, formatDetails(id, args))
    };
    var formatDetails = function(id, args) {
        args = [exports.ERROR_MESSAGES[id]].concat(args);
        return stringUtils.format.apply(this, args).replace(/\.*\s*?$/, "")
    };
    var formatMessage = function(id, details) {
        return stringUtils.format.apply(this, ["{0} - {1}. See:\n{2}", id, details, ERROR_URL + id])
    };
    var makeError = function(args) {
        var id, details, message;
        id = args[0];
        args = args.slice(1);
        details = formatDetails(id, args);
        message = formatMessage(id, details);
        return extend(new Error(message), {
            __id: id,
            __details: details
        })
    };
    return exports
};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/version.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = "17.1.7";


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/currency.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    numberLocalization = __webpack_require__(44);
numberLocalization.inject({
    _formatNumberCore: function(value, format, formatConfig) {
        if ("currency" === format) {
            formatConfig.precision = formatConfig.precision || 0;
            return this.getCurrencySymbol().symbol + this.format(value, extend({}, formatConfig, {
                type: "fixedpoint"
            }))
        }
        return this.callBase.apply(this, arguments)
    },
    getCurrencySymbol: function() {
        return {
            symbol: "$"
        }
    },
    getOpenXmlCurrencyFormat: function() {
        return "$#,##0{0}_);\\($#,##0{0}\\)"
    }
});


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/component.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Config = __webpack_require__(31),
    extend = __webpack_require__(1).extend,
    Class = __webpack_require__(5),
    Action = __webpack_require__(62),
    errors = __webpack_require__(13),
    coreDataUtils = __webpack_require__(14),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    EventsMixin = __webpack_require__(38),
    publicComponentUtils = __webpack_require__(73),
    devices = __webpack_require__(6),
    isFunction = commonUtils.isFunction,
    noop = commonUtils.noop;
var cachedGetters = {};
var cachedSetters = {};
var Component = Class.inherit({
    _setDeprecatedOptions: function() {
        this._deprecatedOptions = {}
    },
    _getDeprecatedOptions: function() {
        return this._deprecatedOptions
    },
    _getOptionAliasesByName: function(optionName) {
        return $.map(this._deprecatedOptions, function(deprecate, aliasName) {
            return optionName === deprecate.alias ? aliasName : void 0
        })
    },
    _getDefaultOptions: function() {
        return {
            onInitialized: null,
            onOptionChanged: null,
            onDisposing: null,
            defaultOptionsRules: null
        }
    },
    _setDefaultOptions: function() {
        this._options = this._getDefaultOptions()
    },
    _defaultOptionsRules: function() {
        return []
    },
    _setOptionsByDevice: function(customRules) {
        var rules = this._defaultOptionsRules();
        if (Array.isArray(customRules)) {
            rules = rules.concat(customRules)
        }
        var rulesOptions = this._convertRulesToOptions(rules);
        extend(true, this._options, rulesOptions);
        for (var fieldName in this._optionsByReference) {
            if (rulesOptions.hasOwnProperty(fieldName)) {
                this._options[fieldName] = rulesOptions[fieldName]
            }
        }
    },
    _convertRulesToOptions: function(rules) {
        var options = {};
        var currentDevice = devices.current();
        var deviceMatch = function(device, filter) {
            filter = $.makeArray(filter);
            return 1 === filter.length && typeUtils.isEmptyObject(filter[0]) || commonUtils.findBestMatches(device, filter).length > 0
        };
        for (var i = 0; i < rules.length; i++) {
            var match, rule = rules[i],
                deviceFilter = rule.device || {};
            if (isFunction(deviceFilter)) {
                match = deviceFilter(currentDevice)
            } else {
                match = deviceMatch(currentDevice, deviceFilter)
            }
            if (match) {
                extend(options, rule.options)
            }
        }
        return options
    },
    _isInitialOptionValue: function(name) {
        var optionValue = this.option(name),
            initialOptionValue = this.initialOption(name),
            isInitialOption = isFunction(optionValue) && isFunction(initialOptionValue) ? optionValue.toString() === initialOptionValue.toString() : commonUtils.equalByValue(optionValue, initialOptionValue);
        return isInitialOption
    },
    _setOptionsByReference: function() {
        this._optionsByReference = {}
    },
    _getOptionsByReference: function() {
        return this._optionsByReference
    },
    ctor: function(options) {
        this.NAME = publicComponentUtils.name(this.constructor);
        options = options || {};
        if (options.eventsStrategy) {
            this.setEventsStrategy(options.eventsStrategy)
        }
        this._options = {};
        this._updateLockCount = 0;
        this._optionChangedCallbacks = options._optionChangedCallbacks || $.Callbacks();
        this._disposingCallbacks = options._disposingCallbacks || $.Callbacks();
        this.beginUpdate();
        try {
            this._suppressDeprecatedWarnings();
            this._setOptionsByReference();
            this._setDeprecatedOptions();
            this._setDefaultOptions();
            if (options && options.onInitializing) {
                options.onInitializing.apply(this, [options])
            }
            this._setOptionsByDevice(options.defaultOptionsRules);
            this._resumeDeprecatedWarnings();
            this._initOptions(options)
        } finally {
            this.endUpdate()
        }
    },
    _initOptions: function(options) {
        this.option(options)
    },
    _optionValuesEqual: function(name, oldValue, newValue) {
        oldValue = coreDataUtils.toComparable(oldValue, true);
        newValue = coreDataUtils.toComparable(newValue, true);
        if (oldValue && newValue && oldValue.jquery && newValue.jquery) {
            return newValue.is(oldValue)
        }
        var oldValueIsNaN = oldValue !== oldValue,
            newValueIsNaN = newValue !== newValue;
        if (oldValueIsNaN && newValueIsNaN) {
            return true
        }
        if (null === oldValue || "object" !== typeof oldValue) {
            return oldValue === newValue
        }
        return false
    },
    _init: function() {
        this._createOptionChangedAction();
        this.on("disposing", function(args) {
            this._disposingCallbacks.fireWith(this, [args])
        }.bind(this))
    },
    _createOptionChangedAction: function() {
        this._optionChangedAction = this._createActionByOption("onOptionChanged", {
            excludeValidators: ["disabled", "readOnly", "designMode"]
        })
    },
    _createDisposingAction: function() {
        this._disposingAction = this._createActionByOption("onDisposing", {
            excludeValidators: ["disabled", "readOnly", "designMode"]
        })
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onDisposing":
            case "onInitialized":
                break;
            case "onOptionChanged":
                this._createOptionChangedAction();
                break;
            case "defaultOptionsRules":
        }
    },
    _dispose: function() {
        this._optionChangedCallbacks.empty();
        this._createDisposingAction();
        this._disposingAction();
        this._disposeEvents();
        this._disposed = true
    },
    instance: function() {
        return this
    },
    beginUpdate: function() {
        this._updateLockCount++
    },
    endUpdate: function() {
        this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
        if (!this._updateLockCount) {
            if (!this._initializing && !this._initialized) {
                this._initializing = true;
                try {
                    this._init()
                } finally {
                    this._initializing = false;
                    this._updateLockCount++;
                    this._createActionByOption("onInitialized", {
                        excludeValidators: ["disabled", "readOnly", "designMode"]
                    })();
                    this._updateLockCount--;
                    this._initialized = true
                }
            }
        }
    },
    _logWarningIfDeprecated: function(option) {
        var info = this._deprecatedOptions[option];
        if (info && !this._deprecatedOptionsSuppressed) {
            this._logDeprecatedWarning(option, info)
        }
    },
    _logDeprecatedWarningCount: 0,
    _logDeprecatedWarning: function(option, info) {
        var message = info.message || "Use the '" + info.alias + "' option instead";
        errors.log("W0001", this.NAME, option, info.since, message);
        ++this._logDeprecatedWarningCount
    },
    _suppressDeprecatedWarnings: function() {
        this._deprecatedOptionsSuppressed = true
    },
    _resumeDeprecatedWarnings: function() {
        this._deprecatedOptionsSuppressed = false
    },
    _optionChanging: noop,
    _notifyOptionChanged: function(option, value, previousValue) {
        var that = this;
        if (this._initialized) {
            var optionNames = [option].concat(that._getOptionAliasesByName(option));
            for (var i = 0; i < optionNames.length; i++) {
                var name = optionNames[i],
                    args = {
                        name: name.split(/[.\[]/)[0],
                        fullName: name,
                        value: value,
                        previousValue: previousValue
                    };
                that._optionChangedCallbacks.fireWith(that, [extend(that._defaultActionArgs(), args)]);
                that._optionChangedAction(extend({}, args));
                if (!that._disposed) {
                    that._optionChanged(args)
                }
            }
        }
    },
    initialOption: function(optionName) {
        var currentOptions, currentInitialized = this._initialized;
        if (!this._initialOptions) {
            currentOptions = this._options;
            this._options = {};
            this._initialized = false;
            this._setDefaultOptions();
            this._setOptionsByDevice(currentOptions.defaultOptionsRules);
            this._initialOptions = this._options;
            this._options = currentOptions;
            this._initialized = currentInitialized
        }
        return this._initialOptions[optionName]
    },
    _defaultActionConfig: function() {
        return {
            context: this,
            component: this
        }
    },
    _defaultActionArgs: function() {
        return {
            component: this
        }
    },
    _createAction: function(actionSource, config) {
        var action, that = this;
        return function(e) {
            if (!arguments.length) {
                e = {}
            }
            if (!typeUtils.isPlainObject(e)) {
                e = {
                    actionValue: e
                }
            }
            action = action || new Action(actionSource, extend(config, that._defaultActionConfig()));
            return action.execute.call(action, extend(e, that._defaultActionArgs()))
        }
    },
    _createActionByOption: function(optionName, config) {
        var action, eventName, actionFunc, that = this;
        var result = function() {
            if (!eventName) {
                config = config || {};
                if ("string" !== typeof optionName) {
                    throw errors.Error("E0008")
                }
                if (0 === optionName.indexOf("on")) {
                    eventName = that._getEventName(optionName)
                }
                actionFunc = that.option(optionName)
            }
            if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !that.hasEvent(eventName)) {
                return
            }
            if (!action) {
                var beforeExecute = config.beforeExecute;
                config.beforeExecute = function(args) {
                    that.fireEvent(eventName, args.args);
                    beforeExecute && beforeExecute.apply(that, arguments)
                };
                that._suppressDeprecatedWarnings();
                action = that._createAction(actionFunc, config);
                that._resumeDeprecatedWarnings()
            }
            if (Config().wrapActionsBeforeExecute) {
                var beforeActionExecute = that.option("beforeActionExecute") || noop;
                action = beforeActionExecute(that, action, config) || action
            }
            return action.apply(that, arguments)
        };
        if (!Config().wrapActionsBeforeExecute) {
            var onActionCreated = that.option("onActionCreated") || noop;
            result = onActionCreated(that, result, config) || result
        }
        return result
    },
    _getEventName: function(actionName) {
        return actionName.charAt(2).toLowerCase() + actionName.substr(3)
    },
    hasActionSubscription: function(actionName) {
        return !!this.option(actionName) || this.hasEvent(this._getEventName(actionName))
    },
    isOptionDeprecated: function(name) {
        var deprecatedOptions = this._getDeprecatedOptions();
        return deprecatedOptions.hasOwnProperty(name)
    },
    option: function() {
        var normalizeOptionName = function(that, name) {
            var deprecate;
            if (name) {
                if (!that._cachedDeprecateNames) {
                    that._cachedDeprecateNames = [];
                    for (var optionName in that._deprecatedOptions) {
                        that._cachedDeprecateNames.push(optionName)
                    }
                }
                for (var i = 0; i < that._cachedDeprecateNames.length; i++) {
                    if (that._cachedDeprecateNames[i] === name) {
                        deprecate = that._deprecatedOptions[name];
                        break
                    }
                }
                if (deprecate) {
                    that._logWarningIfDeprecated(name);
                    var alias = deprecate.alias;
                    if (alias) {
                        name = alias
                    }
                }
            }
            return name
        };
        var getPreviousName = function(fullName) {
            var splitNames = fullName.split(".");
            splitNames.pop();
            return splitNames.join(".")
        };
        var getFieldName = function(fullName) {
            var splitNames = fullName.split(".");
            return splitNames[splitNames.length - 1]
        };
        var getOptionValue = function(options, name, unwrapObservables) {
            var getter = cachedGetters[name];
            if (!getter) {
                getter = cachedGetters[name] = coreDataUtils.compileGetter(name)
            }
            return getter(options, {
                functionsAsIs: true,
                unwrapObservables: unwrapObservables
            })
        };
        var clearOptionsField = function(options, name) {
            delete options[name];
            var previousFieldName = getPreviousName(name),
                fieldName = getFieldName(name),
                fieldObject = previousFieldName ? getOptionValue(options, previousFieldName, false) : options;
            if (fieldObject) {
                delete fieldObject[fieldName]
            }
        };
        var setOptionsField = function(options, fullName, value) {
            var fieldObject, fieldName = "";
            do {
                if (fieldName) {
                    fieldName = "." + fieldName
                }
                fieldName = getFieldName(fullName) + fieldName;
                fullName = getPreviousName(fullName);
                fieldObject = fullName ? getOptionValue(options, fullName, false) : options
            } while (!fieldObject);
            fieldObject[fieldName] = value
        };
        var normalizeOptionValue = function(that, options, name, value) {
            if (name) {
                var alias = normalizeOptionName(that, name);
                if (alias && alias !== name) {
                    setOptionsField(options, alias, value);
                    clearOptionsField(options, name)
                }
            }
        };
        var prepareOption = function(that, options, name, value) {
            if (typeUtils.isPlainObject(value)) {
                for (var valueName in value) {
                    prepareOption(that, options, name + "." + valueName, value[valueName])
                }
            }
            normalizeOptionValue(that, options, name, value)
        };
        var setOptionValue = function(that, name, value) {
            if (!cachedSetters[name]) {
                cachedSetters[name] = coreDataUtils.compileSetter(name)
            }
            var path = name.split(/[.\[]/);
            cachedSetters[name](that._options, value, {
                functionsAsIs: true,
                merge: !that._getOptionsByReference()[name],
                unwrapObservables: path.length > 1 && !!that._getOptionsByReference()[path[0]]
            })
        };
        var setOption = function(that, name, value) {
            var previousValue = getOptionValue(that._options, name, false);
            if (that._optionValuesEqual(name, previousValue, value)) {
                return
            }
            if (that._initialized) {
                that._optionChanging(name, previousValue, value)
            }
            setOptionValue(that, name, value);
            that._notifyOptionChanged(name, value, previousValue)
        };
        return function(options, value) {
            var that = this,
                name = options;
            if (arguments.length < 2 && "object" !== commonUtils.type(name)) {
                name = normalizeOptionName(that, name);
                return getOptionValue(that._options, name)
            }
            if ("string" === typeof name) {
                options = {};
                options[name] = value
            }
            that.beginUpdate();
            try {
                var optionName;
                for (optionName in options) {
                    prepareOption(that, options, optionName, options[optionName])
                }
                for (optionName in options) {
                    setOption(that, optionName, options[optionName])
                }
            } finally {
                that.endUpdate()
            }
        }
    }()
}).include(EventsMixin);
module.exports = Component;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/storage.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var getSessionStorage = function() {
    var sessionStorage;
    try {
        sessionStorage = window.sessionStorage
    } catch (e) {}
    return sessionStorage
};
exports.sessionStorage = getSessionStorage;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (mobile/hide_top_overlay.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var inArray = __webpack_require__(7).inArray;
var hideCallback = function() {
    var callbacks = [];
    return {
        add: function(callback) {
            var indexOfCallback = inArray(callback, callbacks);
            if (indexOfCallback === -1) {
                callbacks.push(callback)
            }
        },
        remove: function(callback) {
            var indexOfCallback = inArray(callback, callbacks);
            if (indexOfCallback !== -1) {
                callbacks.splice(indexOfCallback, 1)
            }
        },
        fire: function() {
            var callback = callbacks.pop(),
                result = !!callback;
            if (result) {
                callback()
            }
            return result
        },
        hasCallback: function() {
            return callbacks.length > 0
        }
    }
}();
module.exports = function() {
    return hideCallback.fire()
};
module.exports.hideCallback = hideCallback;
module.exports.default = module.exports;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (animation/presets/presets.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Component = __webpack_require__(106),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    fx = __webpack_require__(22);
var directionPostfixes = {
    forward: " dx-forward",
    backward: " dx-backward",
    none: " dx-no-direction",
    undefined: " dx-no-direction"
};
var optionPrefix = "preset_";
var AnimationPresetCollection = Component.inherit({
    ctor: function() {
        this.callBase.apply(this, arguments);
        this._registeredPresets = [];
        this.resetToDefaults()
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            defaultAnimationDuration: 400,
            defaultAnimationDelay: 0,
            defaultStaggerAnimationDuration: 300,
            defaultStaggerAnimationDelay: 40,
            defaultStaggerAnimationStartDelay: 500
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return device.phone
            },
            options: {
                defaultStaggerAnimationDuration: 350,
                defaultStaggerAnimationDelay: 50,
                defaultStaggerAnimationStartDelay: 0
            }
        }, {
            device: function() {
                return devices.current().android || devices.real.android
            },
            options: {
                defaultAnimationDelay: 100
            }
        }])
    },
    _getPresetOptionName: function(animationName) {
        return optionPrefix + animationName
    },
    _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
        var that = this;
        var createBaseConfig = function(configModifier) {
            return {
                type: "slide",
                delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
            }
        };
        return {
            enter: function($element, configModifier) {
                var width = $element.parent().width() * widthMultiplier,
                    direction = configModifier.direction,
                    config = createBaseConfig(configModifier);
                config.to = {
                    left: 0,
                    opacity: 1
                };
                if ("forward" === direction) {
                    config.from = {
                        left: width,
                        opacity: throughOpacity
                    }
                } else {
                    if ("backward" === direction) {
                        config.from = {
                            left: -width,
                            opacity: throughOpacity
                        }
                    } else {
                        config.from = {
                            left: 0,
                            opacity: 0
                        }
                    }
                }
                return fx.createAnimation($element, config)
            },
            leave: function($element, configModifier) {
                var width = $element.parent().width() * widthMultiplier,
                    direction = configModifier.direction,
                    config = createBaseConfig(configModifier);
                config.from = {
                    left: 0,
                    opacity: 1
                };
                if ("forward" === direction) {
                    config.to = {
                        left: -width,
                        opacity: throughOpacity
                    }
                } else {
                    if ("backward" === direction) {
                        config.to = {
                            left: width,
                            opacity: throughOpacity
                        }
                    } else {
                        config.to = {
                            left: 0,
                            opacity: 0
                        }
                    }
                }
                return fx.createAnimation($element, config)
            }
        }
    },
    _createOpenDoorConfig: function() {
        var that = this;
        var createBaseConfig = function(configModifier) {
            return {
                type: "css",
                extraCssClasses: "dx-opendoor-animation",
                delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
                duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
            }
        };
        return {
            enter: function($element, configModifier) {
                var direction = configModifier.direction,
                    config = createBaseConfig(configModifier);
                config.delay = "none" === direction ? config.delay : config.duration;
                config.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
                config.to = "dx-enter-active";
                return fx.createAnimation($element, config)
            },
            leave: function($element, configModifier) {
                var direction = configModifier.direction,
                    config = createBaseConfig(configModifier);
                config.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
                config.to = "dx-leave-active";
                return fx.createAnimation($element, config)
            }
        }
    },
    _createWinPopConfig: function() {
        var that = this,
            baseConfig = {
                type: "css",
                extraCssClasses: "dx-win-pop-animation",
                duration: that.option("defaultAnimationDuration")
            };
        return {
            enter: function($element, configModifier) {
                var config = baseConfig,
                    direction = configModifier.direction;
                config.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
                config.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
                config.to = "dx-enter-active";
                return fx.createAnimation($element, config)
            },
            leave: function($element, configModifier) {
                var config = baseConfig,
                    direction = configModifier.direction;
                config.delay = that.option("defaultAnimationDelay");
                config.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
                config.to = "dx-leave-active";
                return fx.createAnimation($element, config)
            }
        }
    },
    resetToDefaults: function() {
        this.clear();
        this.registerDefaultPresets();
        this.applyChanges()
    },
    clear: function(name) {
        var that = this,
            newRegisteredPresets = [];
        $.each(this._registeredPresets, function(index, preset) {
            if (!name || name === preset.name) {
                that.option(that._getPresetOptionName(preset.name), void 0)
            } else {
                newRegisteredPresets.push(preset)
            }
        });
        this._registeredPresets = newRegisteredPresets;
        this.applyChanges()
    },
    registerPreset: function(name, config) {
        this._registeredPresets.push({
            name: name,
            config: config
        })
    },
    applyChanges: function() {
        var that = this;
        var customRules = [];
        $.each(this._registeredPresets, function(index, preset) {
            var rule = {
                device: preset.config.device,
                options: {}
            };
            rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
            customRules.push(rule)
        });
        this._setOptionsByDevice(customRules)
    },
    getPreset: function(name) {
        var result = name;
        while ("string" === typeof result) {
            result = this.option(this._getPresetOptionName(result))
        }
        return result
    },
    registerDefaultPresets: function() {
        this.registerPreset("pop", {
            animation: {
                extraCssClasses: "dx-android-pop-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("openDoor", {
            animation: this._createOpenDoorConfig()
        });
        this.registerPreset("win-pop", {
            animation: this._createWinPopConfig()
        });
        this.registerPreset("fade", {
            animation: {
                extraCssClasses: "dx-fade-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("slide", {
            device: function() {
                return devices.current().android || devices.real.android
            },
            animation: this._createAndroidSlideAnimationConfig(1, 1)
        });
        this.registerPreset("slide", {
            device: function() {
                return !devices.current().android && !devices.real.android
            },
            animation: {
                extraCssClasses: "dx-slide-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("ios7-slide", {
            animation: {
                extraCssClasses: "dx-ios7-slide-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("overflow", {
            animation: {
                extraCssClasses: "dx-overflow-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("ios7-toolbar", {
            device: function() {
                return !devices.current().android && !devices.real.android
            },
            animation: {
                extraCssClasses: "dx-ios7-toolbar-animation",
                delay: this.option("defaultAnimationDelay"),
                duration: this.option("defaultAnimationDuration")
            }
        });
        this.registerPreset("ios7-toolbar", {
            device: function() {
                return devices.current().android || devices.real.android
            },
            animation: this._createAndroidSlideAnimationConfig(0, .4)
        });
        this.registerPreset("stagger-fade", {
            animation: {
                extraCssClasses: "dx-fade-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-slide", {
            animation: {
                extraCssClasses: "dx-slide-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-fade-slide", {
            animation: {
                extraCssClasses: "dx-fade-slide-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-drop", {
            animation: {
                extraCssClasses: "dx-drop-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-fade-drop", {
            animation: {
                extraCssClasses: "dx-fade-drop-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-fade-rise", {
            animation: {
                extraCssClasses: "dx-fade-rise-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-3d-drop", {
            animation: {
                extraCssClasses: "dx-3d-drop-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        });
        this.registerPreset("stagger-fade-zoom", {
            animation: {
                extraCssClasses: "dx-fade-zoom-animation",
                staggerDelay: this.option("defaultStaggerAnimationDelay"),
                duration: this.option("defaultStaggerAnimationDuration"),
                delay: this.option("defaultStaggerAnimationStartDelay")
            }
        })
    }
});
exports.PresetCollection = AnimationPresetCollection;
var animationPresets = new AnimationPresetCollection;
exports.presets = animationPresets;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    browser = __webpack_require__(21),
    Class = __webpack_require__(5),
    eventUtils = __webpack_require__(3);
var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
var BaseStrategy = Class.inherit({
    ctor: function(eventName, originalEvents) {
        this._eventName = eventName;
        this._originalEvents = eventUtils.addNamespace(originalEvents, POINTER_EVENTS_NAMESPACE);
        this._handlerCount = 0;
        this.noBubble = this._isNoBubble()
    },
    _isNoBubble: function() {
        var eventName = this._eventName;
        return "dxpointerenter" === eventName || "dxpointerleave" === eventName
    },
    _handler: function(e) {
        var delegateTarget = this._getDelegateTarget(e);
        return this._fireEvent({
            type: this._eventName,
            pointerType: e.pointerType || eventUtils.eventSource(e),
            originalEvent: e,
            delegateTarget: delegateTarget,
            timeStamp: browser.mozilla ? (new Date).getTime() : e.timeStamp
        })
    },
    _getDelegateTarget: function(e) {
        var delegateTarget;
        if (this.noBubble) {
            delegateTarget = e.delegateTarget
        }
        return delegateTarget
    },
    _fireEvent: function(args) {
        return eventUtils.fireEvent(args)
    },
    setup: function() {
        return true
    },
    add: function(element, handleObj) {
        if (this._handlerCount <= 0 || this.noBubble) {
            this._selector = handleObj.selector;
            element = this.noBubble ? element : document;
            var that = this;
            $(element).on(this._originalEvents, this._selector, function(e) {
                that._handler(e)
            })
        }
        if (!this.noBubble) {
            this._handlerCount++
        }
    },
    remove: function() {
        if (!this.noBubble) {
            this._handlerCount--
        }
    },
    teardown: function(element) {
        if (this._handlerCount && !this.noBubble) {
            return
        }
        element = this.noBubble ? element : document;
        if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
            $(element).off(this._originalEvents, this._selector)
        }
    },
    dispose: function(element) {
        element = this.noBubble ? element : document;
        $(element).off(this._originalEvents)
    }
});
module.exports = BaseStrategy;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/gesture/emitter.gesture.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    support = __webpack_require__(24),
    browser = __webpack_require__(21),
    domUtils = __webpack_require__(15),
    ready = __webpack_require__(135),
    mathUtils = __webpack_require__(56),
    commonUtils = __webpack_require__(2),
    eventUtils = __webpack_require__(3),
    Emitter = __webpack_require__(89),
    sign = mathUtils.sign,
    abs = Math.abs;
var SLEEP = 0,
    INITED = 1,
    STARTED = 2,
    TOUCH_BOUNDARY = 10,
    IMMEDIATE_TOUCH_BOUNDARY = 0,
    IMMEDIATE_TIMEOUT = 180;
var isMouseWheelEvent = function(e) {
    return e && "dxmousewheel" === e.type
};
var supportPointerEvents = function() {
    var cssSupport = support.styleProp("pointer-events");
    var msieLess11 = browser.msie && parseInt(browser.version, 10) < 11;
    return cssSupport && !msieLess11
};
var gestureCover = function() {
    var GESTURE_COVER_CLASS = "dx-gesture-cover";
    var isDesktop = "generic" === devices.real().platform;
    if (!supportPointerEvents() || !isDesktop) {
        return commonUtils.noop
    }
    var $cover = $("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
    $cover.on("dxmousewheel", function(e) {
        e.preventDefault()
    });
    ready(function() {
        $cover.appendTo("body")
    });
    return function(toggle, cursor) {
        $cover.css("pointerEvents", toggle ? "all" : "none");
        toggle && $cover.css("cursor", cursor)
    }
}();
var GestureEmitter = Emitter.inherit({
    gesture: true,
    configure: function(data) {
        this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
        this.callBase(data)
    },
    allowInterruptionByMouseWheel: function() {
        return this._stage !== STARTED
    },
    getDirection: function() {
        return this.direction
    },
    _cancel: function() {
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false);
        this._stage = SLEEP
    },
    start: function(e) {
        if (eventUtils.needSkipEvent(e)) {
            this._cancel(e);
            return
        }
        this._startEvent = eventUtils.createEvent(e);
        this._startEventData = eventUtils.eventData(e);
        this._stage = INITED;
        this._init(e);
        this._setupImmediateTimer()
    },
    _setupImmediateTimer: function() {
        clearTimeout(this._immediateTimer);
        this._immediateAccepted = false;
        if (!this.immediate) {
            return
        }
        this._immediateTimer = setTimeout(function() {
            this._immediateAccepted = true
        }.bind(this), IMMEDIATE_TIMEOUT)
    },
    move: function(e) {
        if (this._stage === INITED && this._directionConfirmed(e)) {
            this._stage = STARTED;
            this._resetActiveElement();
            this._toggleGestureCover(true);
            this._clearSelection(e);
            this._adjustStartEvent(e);
            this._start(this._startEvent);
            if (this._stage === SLEEP) {
                return
            }
            this._requestAccept(e);
            this._move(e);
            this._forgetAccept()
        } else {
            if (this._stage === STARTED) {
                this._clearSelection(e);
                this._move(e)
            }
        }
    },
    _directionConfirmed: function(e) {
        var touchBoundary = this._getTouchBoundary(e),
            delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e)),
            deltaX = abs(delta.x),
            deltaY = abs(delta.y);
        var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),
            verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
        var direction = this.getDirection(e),
            bothAccepted = "both" === direction && (horizontalMove || verticalMove),
            horizontalAccepted = "horizontal" === direction && horizontalMove,
            verticalAccepted = "vertical" === direction && verticalMove;
        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted
    },
    _validateMove: function(touchBoundary, mainAxis, crossAxis) {
        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
    },
    _getTouchBoundary: function(e) {
        return this.immediate || isMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
    },
    _adjustStartEvent: function(e) {
        var touchBoundary = this._getTouchBoundary(e),
            delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
        this._startEvent.pageX += sign(delta.x) * touchBoundary;
        this._startEvent.pageY += sign(delta.y) * touchBoundary
    },
    _resetActiveElement: function() {
        if ("ios" === devices.real().platform && $(":focus", this.getElement()).length) {
            domUtils.resetActiveElement()
        }
    },
    _toggleGestureCover: function(toggle) {
        var isStarted = this._stage === STARTED;
        if (isStarted) {
            gestureCover(toggle, this.getElement().css("cursor"))
        }
    },
    _clearSelection: function(e) {
        if (isMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {
            return
        }
        domUtils.clearSelection()
    },
    end: function(e) {
        this._toggleGestureCover(false);
        if (this._stage === STARTED) {
            this._end(e)
        } else {
            if (this._stage === INITED) {
                this._stop(e)
            }
        }
        this._stage = SLEEP
    },
    dispose: function() {
        clearTimeout(this._immediateTimer);
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false)
    },
    _init: commonUtils.noop,
    _start: commonUtils.noop,
    _move: commonUtils.noop,
    _stop: commonUtils.noop,
    _end: commonUtils.noop
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
    if (commonUtils.isDefined(newBoundary)) {
        TOUCH_BOUNDARY = newBoundary;
        return
    }
    return TOUCH_BOUNDARY
};
module.exports = GestureEmitter;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/ui.keyboard_processor.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    inArray = __webpack_require__(7).inArray,
    eventUtils = __webpack_require__(3);
var KeyboardProcessor = Class.inherit({
    _keydown: eventUtils.addNamespace("keydown", "KeyboardProcessor"),
    codes: {
        8: "backspace",
        9: "tab",
        13: "enter",
        27: "escape",
        33: "pageUp",
        34: "pageDown",
        35: "end",
        36: "home",
        37: "leftArrow",
        38: "upArrow",
        39: "rightArrow",
        40: "downArrow",
        46: "del",
        32: "space",
        70: "F",
        65: "A",
        106: "asterisk",
        109: "minus"
    },
    ctor: function(options) {
        var _this = this;
        options = options || {};
        if (options.element) {
            this._element = $(options.element)
        }
        if (options.focusTarget) {
            this._focusTarget = options.focusTarget
        }
        this._handler = options.handler;
        this._context = options.context;
        this._childProcessors = [];
        if (this._element) {
            this._processFunction = function(e) {
                _this.process(e)
            };
            this._element.on(this._keydown, this._processFunction)
        }
    },
    dispose: function() {
        if (this._element) {
            this._element.off(this._keydown, this._processFunction)
        }
        this._element = void 0;
        this._handler = void 0;
        this._context = void 0;
        this._childProcessors = void 0
    },
    clearChildren: function() {
        this._childProcessors = []
    },
    push: function(child) {
        if (!this._childProcessors) {
            this.clearChildren()
        }
        this._childProcessors.push(child);
        return child
    },
    attachChildProcessor: function() {
        var childProcessor = new KeyboardProcessor;
        this._childProcessors.push(childProcessor);
        return childProcessor
    },
    reinitialize: function(childHandler, childContext) {
        this._context = childContext;
        this._handler = childHandler;
        return this
    },
    process: function(e) {
        if (this._focusTarget && this._focusTarget !== e.target && inArray(e.target, this._focusTarget) < 0) {
            return false
        }
        var args = {
            key: this.codes[e.which] || e.which,
            ctrl: e.ctrlKey,
            shift: e.shiftKey,
            alt: e.altKey,
            originalEvent: e
        };
        var handlerResult = this._handler && this._handler.call(this._context, args);
        if (handlerResult && this._childProcessors) {
            $.each(this._childProcessors, function(index, childProcessor) {
                childProcessor.process(e)
            })
        }
    }
});
module.exports = KeyboardProcessor;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/hover.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    devices = __webpack_require__(6),
    registerEvent = __webpack_require__(47),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17);
var HOVERSTART_NAMESPACE = "dxHoverStart",
    HOVERSTART = "dxhoverstart",
    POINTERENTER_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, HOVERSTART_NAMESPACE),
    HOVEREND_NAMESPACE = "dxHoverEnd",
    HOVEREND = "dxhoverend",
    POINTERLEAVE_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, HOVEREND_NAMESPACE);
var Hover = Class.inherit({
    noBubble: true,
    ctor: function() {
        this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore"
    },
    setup: function(element) {
        $.data(element, this._handlerArrayKeyPath, {})
    },
    add: function(element, handleObj) {
        var that = this,
            $element = $(element),
            handler = function(e) {
                that._handler(e)
            };
        $element.on(this._originalEventName, handleObj.selector, handler);
        $.data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler
    },
    _handler: function(e) {
        if (eventUtils.isTouchEvent(e) || devices.isSimulator()) {
            return
        }
        eventUtils.fireEvent({
            type: this._eventName,
            originalEvent: e,
            delegateTarget: e.delegateTarget
        })
    },
    remove: function(element, handleObj) {
        var handler = $.data(element, this._handlerArrayKeyPath)[handleObj.guid];
        $(element).off(this._originalEventName, handleObj.selector, handler)
    },
    teardown: function(element) {
        $.removeData(element, this._handlerArrayKeyPath)
    }
});
var HoverStart = Hover.inherit({
    ctor: function() {
        this._eventNamespace = HOVERSTART_NAMESPACE;
        this._eventName = HOVERSTART;
        this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
        this.callBase()
    },
    _handler: function(e) {
        var pointers = e.pointers || [];
        if (!pointers.length) {
            this.callBase(e)
        }
    }
});
var HoverEnd = Hover.inherit({
    ctor: function() {
        this._eventNamespace = HOVEREND_NAMESPACE;
        this._eventName = HOVEREND;
        this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
        this.callBase()
    }
});
registerEvent(HOVERSTART, new HoverStart);
registerEvent(HOVEREND, new HoverEnd);
exports.start = HOVERSTART;
exports.end = HOVEREND;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validation/validation_mixin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ValidationMixin = {
    _findGroup: function() {
        var $dxGroup, group = this.option("validationGroup");
        if (!group) {
            $dxGroup = this.element().parents(".dx-validationgroup").first();
            if ($dxGroup.length) {
                group = $dxGroup.dxValidationGroup("instance")
            } else {
                group = this._modelByElement(this.element())
            }
        }
        return group
    }
};
module.exports = ValidationMixin;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/router.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    typeUtils = __webpack_require__(9),
    inArray = __webpack_require__(7).inArray,
    Class = __webpack_require__(5);
var JSON_URI_PREFIX = encodeURIComponent("json:");
var Route = Class.inherit({
    _trimSeparators: function(str) {
        return str.replace(/^[\/.]+|\/+$/g, "")
    },
    _escapeRe: function(str) {
        return str.replace(/[^-\w]/g, "\\$1")
    },
    _checkConstraint: function(param, constraint) {
        param = String(param);
        if ("string" === typeof constraint) {
            constraint = new RegExp(constraint)
        }
        var match = constraint.exec(param);
        if (!match || match[0] !== param) {
            return false
        }
        return true
    },
    _ensureReady: function() {
        var that = this;
        if (this._patternRe) {
            return false
        }
        this._pattern = this._trimSeparators(this._pattern);
        this._patternRe = "";
        this._params = [];
        this._segments = [];
        this._separators = [];
        this._pattern.replace(/[^\/]+/g, function(segment, index) {
            that._segments.push(segment);
            if (index) {
                that._separators.push(that._pattern.substr(index - 1, 1))
            }
        });
        $.each(this._segments, function(index) {
            var segment = this,
                separator = index ? that._separators[index - 1] : "";
            if (":" === segment.charAt(0)) {
                segment = segment.substr(1);
                that._params.push(segment);
                that._patternRe += "(?:" + separator + "([^/]*))";
                if (segment in that._defaults) {
                    that._patternRe += "?"
                }
            } else {
                that._patternRe += separator + that._escapeRe(segment)
            }
        });
        this._patternRe = new RegExp("^" + this._patternRe + "$")
    },
    ctor: function(pattern, defaults, constraints) {
        this._pattern = pattern || "";
        this._defaults = defaults || {};
        this._constraints = constraints || {}
    },
    parse: function(uri) {
        var that = this;
        this._ensureReady();
        var matches = this._patternRe.exec(uri);
        if (!matches) {
            return false
        }
        var result = extend({}, this._defaults);
        $.each(this._params, function(i) {
            var index = i + 1;
            if (matches.length >= index && matches[index]) {
                result[this] = that.parseSegment(matches[index])
            }
        });
        $.each(this._constraints, function(key) {
            if (!that._checkConstraint(result[key], that._constraints[key])) {
                result = false;
                return false
            }
        });
        return result
    },
    format: function(routeValues) {
        var that = this,
            query = "";
        this._ensureReady();
        var mergeValues = extend({}, this._defaults),
            useStatic = 0,
            result = [],
            dels = [],
            unusedRouteValues = {};
        $.each(routeValues, function(paramName, paramValue) {
            routeValues[paramName] = that.formatSegment(paramValue);
            if (!(paramName in mergeValues)) {
                unusedRouteValues[paramName] = true
            }
        });
        $.each(this._segments, function(index, segment) {
            result[index] = index ? that._separators[index - 1] : "";
            if (":" === segment.charAt(0)) {
                var paramName = segment.substr(1);
                if (!(paramName in routeValues) && !(paramName in that._defaults)) {
                    result = null;
                    return false
                }
                if (paramName in that._constraints && !that._checkConstraint(routeValues[paramName], that._constraints[paramName])) {
                    result = null;
                    return false
                }
                if (paramName in routeValues) {
                    if (void 0 !== routeValues[paramName]) {
                        mergeValues[paramName] = routeValues[paramName];
                        result[index] += routeValues[paramName];
                        useStatic = index
                    }
                    delete unusedRouteValues[paramName]
                } else {
                    if (paramName in mergeValues) {
                        result[index] += mergeValues[paramName];
                        dels.push(index)
                    }
                }
            } else {
                result[index] += segment;
                useStatic = index
            }
        });
        $.each(mergeValues, function(key, value) {
            if (!!value && inArray(":" + key, that._segments) === -1 && routeValues[key] !== value) {
                result = null;
                return false
            }
        });
        var unusedCount = 0;
        if (!typeUtils.isEmptyObject(unusedRouteValues)) {
            query = "?";
            $.each(unusedRouteValues, function(key) {
                query += key + "=" + routeValues[key] + "&";
                unusedCount++
            });
            query = query.substr(0, query.length - 1)
        }
        if (null === result) {
            return false
        }
        if (dels.length) {
            $.map(dels, function(i) {
                if (i >= useStatic) {
                    result[i] = ""
                }
            })
        }
        var path = result.join("");
        path = path.replace(/\/+$/, "");
        return {
            uri: path + query,
            unusedCount: unusedCount
        }
    },
    formatSegment: function(value) {
        if (Array.isArray(value) || typeUtils.isPlainObject(value)) {
            return JSON_URI_PREFIX + encodeURIComponent(JSON.stringify(value))
        }
        return encodeURIComponent(value)
    },
    parseSegment: function(value) {
        if (value.substr(0, JSON_URI_PREFIX.length) === JSON_URI_PREFIX) {
            try {
                return JSON.parse(decodeURIComponent(value.substr(JSON_URI_PREFIX.length)))
            } catch (x) {}
        }
        return decodeURIComponent(value)
    }
});
var Router = Class.inherit({
    ctor: function() {
        this._registry = []
    },
    _trimSeparators: function(str) {
        return str.replace(/^[\/.]+|\/+$/g, "")
    },
    _createRoute: function(pattern, defaults, constraints) {
        return new Route(pattern, defaults, constraints)
    },
    register: function(pattern, defaults, constraints) {
        this._registry.push(this._createRoute(pattern, defaults, constraints))
    },
    _parseQuery: function(query) {
        var result = {},
            values = query.split("&");
        $.each(values, function(index, value) {
            var keyValuePair = value.split("=");
            result[keyValuePair[0]] = decodeURIComponent(keyValuePair[1])
        });
        return result
    },
    parse: function(uri) {
        var result, that = this;
        uri = this._trimSeparators(uri);
        var parts = uri.split("?", 2),
            path = parts[0],
            query = parts[1];
        $.each(this._registry, function() {
            var parseResult = this.parse(path);
            if (false !== parseResult) {
                result = parseResult;
                if (query) {
                    result = extend(result, that._parseQuery(query))
                }
                return false
            }
        });
        return result ? result : false
    },
    format: function(obj) {
        var result = false,
            minUnusedCount = 99999;
        obj = obj || {};
        $.each(this._registry, function() {
            var toFormat = extend(true, {}, obj);
            var formatResult = this.format(toFormat);
            if (false !== formatResult) {
                if (minUnusedCount > formatResult.unusedCount) {
                    minUnusedCount = formatResult.unusedCount;
                    result = formatResult.uri
                }
            }
        });
        return result
    }
});
module.exports = Router;
module.exports.Route = Route;
module.exports.default = module.exports;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/navigation_devices.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    browserAdapters = __webpack_require__(178),
    SessionStorage = __webpack_require__(107).sessionStorage,
    devices = __webpack_require__(6);
var SESSION_KEY = "dxPhoneJSApplication";
var HistoryBasedNavigationDevice = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this._browserAdapter = options.browserAdapter || this._createBrowserAdapter(options);
        this.uriChanged = $.Callbacks();
        this._browserAdapter.popState.add(this._onPopState.bind(this))
    },
    init: noop,
    getUri: function() {
        return this._browserAdapter.getHash()
    },
    setUri: function(uri, replaceCurrent) {
        if (replaceCurrent) {
            return this._browserAdapter.replaceState(uri)
        } else {
            if (uri !== this.getUri()) {
                return this._browserAdapter.pushState(uri)
            } else {
                return $.Deferred().resolve().promise()
            }
        }
    },
    back: function() {
        return this._browserAdapter.back()
    },
    _onPopState: function() {
        this.uriChanged.fire(this.getUri())
    },
    _isBuggyAndroid2: function() {
        var realDevice = devices.real();
        var version = realDevice.version;
        return "android" === realDevice.platform && version.length > 1 && (2 === version[0] && version[1] < 4 || version[0] < 2)
    },
    _isBuggyAndroid4: function() {
        var realDevice = devices.real();
        var version = realDevice.version;
        return "android" === realDevice.platform && version.length > 1 && 4 === version[0] && 0 === version[1]
    },
    _isWindowsPhone8: function() {
        var realDevice = devices.real();
        return "win" === realDevice.platform && realDevice.phone
    },
    _createBrowserAdapter: function(options) {
        var result, sourceWindow = options.window || window,
            supportPushReplace = sourceWindow.history.replaceState && sourceWindow.history.pushState;
        if (this._isWindowsPhone8()) {
            result = new browserAdapters.BuggyCordovaWP81BrowserAdapter(options)
        } else {
            if (sourceWindow !== sourceWindow.top) {
                result = new browserAdapters.HistorylessBrowserAdapter(options)
            } else {
                if (this._isBuggyAndroid4()) {
                    result = new browserAdapters.BuggyAndroidBrowserAdapter(options)
                } else {
                    if (this._isBuggyAndroid2() || !supportPushReplace) {
                        result = new browserAdapters.OldBrowserAdapter(options)
                    } else {
                        result = new browserAdapters.DefaultBrowserAdapter(options)
                    }
                }
            }
        }
        return result
    }
});
var StackBasedNavigationDevice = HistoryBasedNavigationDevice.inherit({
    ctor: function(options) {
        this.callBase(options);
        this.backInitiated = $.Callbacks();
        this._rootStateHandler = null;
        $(window).on("unload", this._saveBrowserState)
    },
    init: function() {
        var that = this;
        if (that._browserAdapter.canWorkInPureBrowser) {
            return that._initRootPage().done(function() {
                if (that._browserAdapter.isRootPage()) {
                    that._browserAdapter.pushState("")
                }
            })
        } else {
            return $.Deferred().resolve().promise()
        }
    },
    setUri: function(uri) {
        return this.callBase(uri, !this._browserAdapter.isRootPage())
    },
    _saveBrowserState: function() {
        var sessionStorage = SessionStorage();
        if (sessionStorage) {
            sessionStorage.setItem(SESSION_KEY, true)
        }
    },
    _initRootPage: function() {
        var hash = this.getUri(),
            sessionStorage = SessionStorage();
        if (!sessionStorage || sessionStorage.getItem(SESSION_KEY)) {
            return $.Deferred().resolve().promise()
        }
        sessionStorage.removeItem(SESSION_KEY);
        this._browserAdapter.createRootPage();
        return this._browserAdapter.pushState(hash)
    },
    _onPopState: function() {
        if (this._browserAdapter.isRootPage()) {
            if (this._rootStateHandler) {
                this._rootStateHandler()
            } else {
                this.backInitiated.fire()
            }
        } else {
            if (!this._rootStateHandler) {
                this._createRootStateHandler()
            }
            this.back()
        }
    },
    _createRootStateHandler: function() {
        var uri = this.getUri();
        this._rootStateHandler = function() {
            this.uriChanged.fire(uri);
            this._rootStateHandler = null
        }
    }
});
exports.HistoryBasedNavigationDevice = HistoryBasedNavigationDevice;
exports.StackBasedNavigationDevice = StackBasedNavigationDevice;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/presets.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.layoutSets = {};
exports.animationSets = {
    "native": {
        "view-content-change": [{
            animation: "slide"
        }, {
            animation: "ios7-slide",
            device: {
                platform: "ios"
            }
        }, {
            animation: "none",
            device: {
                deviceType: "desktop",
                platform: "generic"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-header-toolbar": [{
            animation: "ios7-toolbar"
        }, {
            animation: "slide",
            device: {
                grade: "B"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }]
    },
    "default": {
        "layout-change": [{
            animation: "none"
        }, {
            animation: "ios7-slide",
            device: {
                platform: "ios"
            }
        }, {
            animation: "pop",
            device: {
                platform: "android"
            }
        }, {
            animation: "openDoor",
            device: {
                deviceType: "phone",
                platform: "win",
                version: [8]
            }
        }, {
            animation: "win-pop",
            device: {
                deviceType: "phone",
                platform: "win"
            }
        }],
        "view-content-change": [{
            animation: "slide"
        }, {
            animation: "ios7-slide",
            device: {
                platform: "ios"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop",
                platform: "generic"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-content-rendered": [{
            animation: "fade"
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-header-toolbar": [{
            animation: "ios7-toolbar"
        }, {
            animation: "slide",
            device: {
                grade: "B"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "command-rendered-top": [{
            animation: "stagger-fade-drop"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }, {
            animation: "none",
            device: {
                platform: "win",
                version: [10]
            }
        }],
        "command-rendered-bottom": [{
            animation: "stagger-fade-rise"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }, {
            animation: "none",
            device: {
                platform: "win",
                version: [10]
            }
        }],
        "list-item-rendered": [{
            animation: "stagger-3d-drop",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "detail-item-rendered": [{
            animation: "stagger-3d-drop",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "edit-item-rendered": [{
            animation: "stagger-3d-drop",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }]
    },
    slide: {
        "view-content-change": [{
            animation: "slide"
        }, {
            animation: "ios7-slide",
            device: {
                platform: "ios"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop",
                platform: "generic"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-content-rendered": [{
            animation: "fade"
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-header-toolbar": [{
            animation: "ios7-toolbar"
        }, {
            animation: "slide",
            device: {
                grade: "B"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "command-rendered-top": [{
            animation: "stagger-fade-drop"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "command-rendered-bottom": [{
            animation: "stagger-fade-rise"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "list-item-rendered": [{
            animation: "stagger-fade-slide",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "detail-item-rendered": [{
            animation: "stagger-fade-slide",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "edit-item-rendered": [{
            animation: "stagger-fade-slide",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }]
    },
    zoom: {
        "view-content-change": [{
            animation: "slide"
        }, {
            animation: "ios7-slide",
            device: {
                platform: "ios"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop",
                platform: "generic"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-content-rendered": [{
            animation: "fade"
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "view-header-toolbar": [{
            animation: "ios7-toolbar"
        }, {
            animation: "slide",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "command-rendered-top": [{
            animation: "stagger-fade-zoom"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "command-rendered-bottom": [{
            animation: "stagger-fade-zoom"
        }, {
            animation: "fade",
            device: {
                grade: "B"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "list-item-rendered": [{
            animation: "stagger-fade-zoom",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "detail-item-rendered": [{
            animation: "stagger-fade-zoom",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }],
        "edit-item-rendered": [{
            animation: "stagger-fade-zoom",
            device: {
                grade: "A"
            }
        }, {
            animation: "fade",
            device: {
                deviceType: "desktop"
            }
        }, {
            animation: "none",
            device: {
                grade: "C"
            }
        }]
    }
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/swipe.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var eventUtils = __webpack_require__(3),
    GestureEmitter = __webpack_require__(111),
    registerEmitter = __webpack_require__(63);
var SWIPE_START_EVENT = "dxswipestart",
    SWIPE_EVENT = "dxswipe",
    SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
    defaultItemSizeFunc: function() {
        return this.getElement().width()
    },
    getBounds: function() {
        return [this._maxLeftOffset, this._maxRightOffset]
    },
    calcOffsetRatio: function(e) {
        var endEventData = eventUtils.eventData(e);
        return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
    },
    isFastSwipe: function(e) {
        var endEventData = eventUtils.eventData(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
    }
};
var VerticalStrategy = {
    defaultItemSizeFunc: function() {
        return this.getElement().height()
    },
    getBounds: function() {
        return [this._maxTopOffset, this._maxBottomOffset]
    },
    calcOffsetRatio: function(e) {
        var endEventData = eventUtils.eventData(e);
        return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
    },
    isFastSwipe: function(e) {
        var endEventData = eventUtils.eventData(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
    }
};
var STRATEGIES = {
    horizontal: HorizontalStrategy,
    vertical: VerticalStrategy
};
var SwipeEmitter = GestureEmitter.inherit({
    TICK_INTERVAL: 300,
    FAST_SWIPE_SPEED_LIMIT: 10,
    ctor: function(element) {
        this.callBase(element);
        this.direction = "horizontal";
        this.elastic = true
    },
    _getStrategy: function() {
        return STRATEGIES[this.direction]
    },
    _defaultItemSizeFunc: function() {
        return this._getStrategy().defaultItemSizeFunc.call(this)
    },
    _itemSizeFunc: function() {
        return this.itemSizeFunc || this._defaultItemSizeFunc
    },
    _init: function(e) {
        this._tickData = eventUtils.eventData(e)
    },
    _start: function(e) {
        this._savedEventData = eventUtils.eventData(e);
        e = this._fireEvent(SWIPE_START_EVENT, e);
        if (!e.cancel) {
            this._maxLeftOffset = e.maxLeftOffset;
            this._maxRightOffset = e.maxRightOffset;
            this._maxTopOffset = e.maxTopOffset;
            this._maxBottomOffset = e.maxBottomOffset
        }
    },
    _move: function(e) {
        var strategy = this._getStrategy(),
            moveEventData = eventUtils.eventData(e),
            offset = strategy.calcOffsetRatio.call(this, e);
        offset = this._fitOffset(offset, this.elastic);
        if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
            this._tickData = moveEventData
        }
        this._fireEvent(SWIPE_EVENT, e, {
            offset: offset
        });
        e.preventDefault()
    },
    _end: function(e) {
        var strategy = this._getStrategy(),
            offsetRatio = strategy.calcOffsetRatio.call(this, e),
            isFast = strategy.isFastSwipe.call(this, e),
            startOffset = offsetRatio,
            targetOffset = this._calcTargetOffset(offsetRatio, isFast);
        startOffset = this._fitOffset(startOffset, this.elastic);
        targetOffset = this._fitOffset(targetOffset, false);
        this._fireEvent(SWIPE_END_EVENT, e, {
            offset: startOffset,
            targetOffset: targetOffset
        })
    },
    _fitOffset: function(offset, elastic) {
        var strategy = this._getStrategy(),
            bounds = strategy.getBounds.call(this);
        if (offset < -bounds[0]) {
            return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0]
        }
        if (offset > bounds[1]) {
            return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1]
        }
        return offset
    },
    _calcTargetOffset: function(offsetRatio, isFast) {
        var result;
        if (isFast) {
            result = Math.ceil(Math.abs(offsetRatio));
            if (offsetRatio < 0) {
                result = -result
            }
        } else {
            result = Math.round(offsetRatio)
        }
        return result
    }
});
registerEmitter({
    emitter: SwipeEmitter,
    events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});
exports.swipe = SWIPE_EVENT;
exports.start = SWIPE_START_EVENT;
exports.end = SWIPE_END_EVENT;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/array_query.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    compileGetter = __webpack_require__(14).compileGetter,
    toComparable = __webpack_require__(14).toComparable,
    errorsModule = __webpack_require__(29),
    dataUtils = __webpack_require__(28);
var Iterator = Class.inherit({
    toArray: function() {
        var result = [];
        this.reset();
        while (this.next()) {
            result.push(this.current())
        }
        return result
    },
    countable: function() {
        return false
    }
});
var ArrayIterator = Iterator.inherit({
    ctor: function(array) {
        this.array = array;
        this.index = -1
    },
    next: function() {
        if (this.index + 1 < this.array.length) {
            this.index++;
            return true
        }
        return false
    },
    current: function() {
        return this.array[this.index]
    },
    reset: function() {
        this.index = -1
    },
    toArray: function() {
        return this.array.slice(0)
    },
    countable: function() {
        return true
    },
    count: function() {
        return this.array.length
    }
});
var WrappedIterator = Iterator.inherit({
    ctor: function(iter) {
        this.iter = iter
    },
    next: function() {
        return this.iter.next()
    },
    current: function() {
        return this.iter.current()
    },
    reset: function() {
        return this.iter.reset()
    }
});
var MapIterator = WrappedIterator.inherit({
    ctor: function(iter, mapper) {
        this.callBase(iter);
        this.index = -1;
        this.mapper = mapper
    },
    current: function() {
        return this.mapper(this.callBase(), this.index)
    },
    next: function() {
        var hasNext = this.callBase();
        if (hasNext) {
            this.index++
        }
        return hasNext
    }
});
var defaultCompare = function(xValue, yValue) {
    xValue = toComparable(xValue);
    yValue = toComparable(yValue);
    if (null === xValue && null !== yValue) {
        return -1
    }
    if (null !== xValue && null === yValue) {
        return 1
    }
    if (void 0 === xValue && void 0 !== yValue) {
        return 1
    }
    if (void 0 !== xValue && void 0 === yValue) {
        return -1
    }
    if (xValue < yValue) {
        return -1
    }
    if (xValue > yValue) {
        return 1
    }
    return 0
};
var SortIterator = Iterator.inherit({
    ctor: function(iter, getter, desc, compare) {
        if (!(iter instanceof MapIterator)) {
            iter = new MapIterator(iter, this._wrap)
        }
        this.iter = iter;
        this.rules = [{
            getter: getter,
            desc: desc,
            compare: compare
        }]
    },
    thenBy: function(getter, desc, compare) {
        var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);
        if (!this.sortedIter) {
            result.rules = this.rules.concat(result.rules)
        }
        return result
    },
    next: function() {
        this._ensureSorted();
        return this.sortedIter.next()
    },
    current: function() {
        this._ensureSorted();
        return this.sortedIter.current()
    },
    reset: function() {
        delete this.sortedIter
    },
    countable: function() {
        return this.sortedIter || this.iter.countable()
    },
    count: function() {
        if (this.sortedIter) {
            return this.sortedIter.count()
        }
        return this.iter.count()
    },
    _ensureSorted: function() {
        var that = this;
        if (that.sortedIter) {
            return
        }
        $.each(that.rules, function() {
            this.getter = compileGetter(this.getter)
        });
        that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
            return that._compare(x, y)
        })), that._unwrap)
    },
    _wrap: function(record, index) {
        return {
            index: index,
            value: record
        }
    },
    _unwrap: function(wrappedItem) {
        return wrappedItem.value
    },
    _compare: function(x, y) {
        var xIndex = x.index,
            yIndex = y.index;
        x = x.value;
        y = y.value;
        if (x === y) {
            return xIndex - yIndex
        }
        for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
            var rule = this.rules[i],
                xValue = rule.getter(x),
                yValue = rule.getter(y),
                compare = rule.compare || defaultCompare,
                compareResult = compare(xValue, yValue);
            if (compareResult) {
                return rule.desc ? -compareResult : compareResult
            }
        }
        return xIndex - yIndex
    }
});
var compileCriteria = function() {
    var compileGroup = function(crit) {
        var groupOperator, nextGroupOperator, idx = 0,
            bag = [],
            ops = [];
        $.each(crit, function() {
            if (Array.isArray(this) || commonUtils.isFunction(this)) {
                if (bag.length > 1 && groupOperator !== nextGroupOperator) {
                    throw new errorsModule.errors.Error("E4019")
                }
                ops.push(compileCriteria(this));
                bag.push("op[" + idx + "](d)");
                idx++;
                groupOperator = nextGroupOperator;
                nextGroupOperator = "&&"
            } else {
                nextGroupOperator = dataUtils.isConjunctiveOperator(this) ? "&&" : "||"
            }
        });
        return new Function("op", "return function(d) { return " + bag.join(" " + groupOperator + " ") + " }")(ops)
    };
    var toString = function(value) {
        return commonUtils.isDefined(value) ? value.toString() : ""
    };
    var compileBinary = function(crit) {
        crit = dataUtils.normalizeBinaryCriterion(crit);
        var getter = compileGetter(crit[0]),
            op = crit[1],
            value = crit[2];
        value = toComparable(value);
        switch (op.toLowerCase()) {
            case "=":
                return compileEquals(getter, value);
            case "<>":
                return compileEquals(getter, value, true);
            case ">":
                return function(obj) {
                    return toComparable(getter(obj)) > value
                };
            case "<":
                return function(obj) {
                    return toComparable(getter(obj)) < value
                };
            case ">=":
                return function(obj) {
                    return toComparable(getter(obj)) >= value
                };
            case "<=":
                return function(obj) {
                    return toComparable(getter(obj)) <= value
                };
            case "startswith":
                return function(obj) {
                    return 0 === toComparable(toString(getter(obj))).indexOf(value)
                };
            case "endswith":
                return function(obj) {
                    var getterValue = toComparable(toString(getter(obj))),
                        searchValue = toString(value);
                    if (getterValue.length < searchValue.length) {
                        return false
                    }
                    return getterValue.lastIndexOf(value) === getterValue.length - value.length
                };
            case "contains":
                return function(obj) {
                    return toComparable(toString(getter(obj))).indexOf(value) > -1
                };
            case "notcontains":
                return function(obj) {
                    return toComparable(toString(getter(obj))).indexOf(value) === -1
                }
        }
        throw errorsModule.errors.Error("E4003", op)
    };

    function compileEquals(getter, value, negate) {
        return function(obj) {
            obj = toComparable(getter(obj));
            var result = useStrictComparison(value) ? obj === value : obj == value;
            if (negate) {
                result = !result
            }
            return result
        }
    }

    function useStrictComparison(value) {
        return "" === value || 0 === value || false === value
    }

    function compileUnary(crit) {
        var op = crit[0],
            criteria = compileCriteria(crit[1]);
        if ("!" === op) {
            return function(obj) {
                return !criteria(obj)
            }
        }
        throw errorsModule.errors.Error("E4003", op)
    }
    return function(crit) {
        if (commonUtils.isFunction(crit)) {
            return crit
        }
        if (Array.isArray(crit[0])) {
            return compileGroup(crit)
        }
        if (dataUtils.isUnaryOperation(crit)) {
            return compileUnary(crit)
        }
        return compileBinary(crit)
    }
}();
var FilterIterator = WrappedIterator.inherit({
    ctor: function(iter, criteria) {
        this.callBase(iter);
        this.criteria = compileCriteria(criteria)
    },
    next: function() {
        while (this.iter.next()) {
            if (this.criteria(this.current())) {
                return true
            }
        }
        return false
    }
});
var GroupIterator = Iterator.inherit({
    ctor: function(iter, getter) {
        this.iter = iter;
        this.getter = getter
    },
    next: function() {
        this._ensureGrouped();
        return this.groupedIter.next()
    },
    current: function() {
        this._ensureGrouped();
        return this.groupedIter.current()
    },
    reset: function() {
        delete this.groupedIter
    },
    countable: function() {
        return !!this.groupedIter
    },
    count: function() {
        return this.groupedIter.count()
    },
    _ensureGrouped: function() {
        if (this.groupedIter) {
            return
        }
        var hash = {},
            keys = [],
            iter = this.iter,
            getter = compileGetter(this.getter);
        iter.reset();
        while (iter.next()) {
            var current = iter.current(),
                key = getter(current);
            if (key in hash) {
                hash[key].push(current)
            } else {
                hash[key] = [current];
                keys.push(key)
            }
        }
        this.groupedIter = new ArrayIterator($.map(keys, function(key) {
            return {
                key: key,
                items: hash[key]
            }
        }))
    }
});
var SelectIterator = WrappedIterator.inherit({
    ctor: function(iter, getter) {
        this.callBase(iter);
        this.getter = compileGetter(getter)
    },
    current: function() {
        return this.getter(this.callBase())
    },
    countable: function() {
        return this.iter.countable()
    },
    count: function() {
        return this.iter.count()
    }
});
var SliceIterator = WrappedIterator.inherit({
    ctor: function(iter, skip, take) {
        this.callBase(iter);
        this.skip = Math.max(0, skip);
        this.take = Math.max(0, take);
        this.pos = 0
    },
    next: function() {
        if (this.pos >= this.skip + this.take) {
            return false
        }
        while (this.pos < this.skip && this.iter.next()) {
            this.pos++
        }
        this.pos++;
        return this.iter.next()
    },
    reset: function() {
        this.callBase();
        this.pos = 0
    },
    countable: function() {
        return this.iter.countable()
    },
    count: function() {
        return Math.min(this.iter.count() - this.skip, this.take)
    }
});
var arrayQueryImpl = function(iter, queryOptions) {
    queryOptions = queryOptions || {};
    if (!(iter instanceof Iterator)) {
        iter = new ArrayIterator(iter)
    }
    var handleError = function(error) {
        var handler = queryOptions.errorHandler;
        if (handler) {
            handler(error)
        }
        errorsModule._errorHandler(error)
    };
    var aggregateCore = function(aggregator) {
        var seed, d = $.Deferred().fail(handleError),
            step = aggregator.step,
            finalize = aggregator.finalize;
        try {
            iter.reset();
            if ("seed" in aggregator) {
                seed = aggregator.seed
            } else {
                seed = iter.next() ? iter.current() : NaN
            }
            var accumulator = seed;
            while (iter.next()) {
                accumulator = step(accumulator, iter.current())
            }
            d.resolve(finalize ? finalize(accumulator) : accumulator)
        } catch (x) {
            d.reject(x)
        }
        return d.promise()
    };
    var aggregate = function(seed, step, finalize) {
        if (arguments.length < 2) {
            return aggregateCore({
                step: arguments[0]
            })
        }
        return aggregateCore({
            seed: seed,
            step: step,
            finalize: finalize
        })
    };
    var standardAggregate = function(name) {
        return aggregateCore(dataUtils.aggregators[name])
    };
    var select = function(getter) {
        if (!commonUtils.isFunction(getter) && !Array.isArray(getter)) {
            getter = $.makeArray(arguments)
        }
        return chainQuery(new SelectIterator(iter, getter))
    };
    var selectProp = function(name) {
        return select(compileGetter(name))
    };
    var chainQuery = function(iter) {
        return arrayQueryImpl(iter, queryOptions)
    };
    return {
        toArray: function() {
            return iter.toArray()
        },
        enumerate: function() {
            var d = $.Deferred().fail(handleError);
            try {
                d.resolve(iter.toArray())
            } catch (x) {
                d.reject(x)
            }
            return d.promise()
        },
        sortBy: function(getter, desc, compare) {
            return chainQuery(new SortIterator(iter, getter, desc, compare))
        },
        thenBy: function(getter, desc, compare) {
            if (iter instanceof SortIterator) {
                return chainQuery(iter.thenBy(getter, desc, compare))
            }
            throw errorsModule.errors.Error("E4004")
        },
        filter: function(criteria) {
            if (!Array.isArray(criteria)) {
                criteria = $.makeArray(arguments)
            }
            return chainQuery(new FilterIterator(iter, criteria))
        },
        slice: function(skip, take) {
            if (void 0 === take) {
                take = Number.MAX_VALUE
            }
            return chainQuery(new SliceIterator(iter, skip, take))
        },
        select: select,
        groupBy: function(getter) {
            return chainQuery(new GroupIterator(iter, getter))
        },
        aggregate: aggregate,
        count: function() {
            if (iter.countable()) {
                var d = $.Deferred().fail(handleError);
                try {
                    d.resolve(iter.count())
                } catch (x) {
                    d.reject(x)
                }
                return d.promise()
            }
            return standardAggregate("count")
        },
        sum: function(getter) {
            if (getter) {
                return selectProp(getter).sum()
            }
            return standardAggregate("sum")
        },
        min: function(getter) {
            if (getter) {
                return selectProp(getter).min()
            }
            return standardAggregate("min")
        },
        max: function(getter) {
            if (getter) {
                return selectProp(getter).max()
            }
            return standardAggregate("max")
        },
        avg: function(getter) {
            if (getter) {
                return selectProp(getter).avg()
            }
            return standardAggregate("avg")
        }
    }
};
module.exports = arrayQueryImpl;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/odata/query_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    queryAdapters = __webpack_require__(147),
    odataUtils = __webpack_require__(78),
    serializePropName = odataUtils.serializePropName,
    errors = __webpack_require__(29).errors,
    dataUtils = __webpack_require__(28),
    isFunction = commonUtils.isFunction,
    isPlainObject = typeUtils.isPlainObject,
    grep = commonUtils.grep;
var DEFAULT_PROTOCOL_VERSION = 2;
var compileCriteria = function() {
    var protocolVersion, fieldTypes;
    var createBinaryOperationFormatter = function(op) {
        return function(prop, val) {
            return prop + " " + op + " " + val
        }
    };
    var createStringFuncFormatter = function(op, reverse) {
        return function(prop, val) {
            var bag = [op, "("];
            if (reverse) {
                bag.push(val, ",", prop)
            } else {
                bag.push(prop, ",", val)
            }
            bag.push(")");
            return bag.join("")
        }
    };
    var formatters = {
        "=": createBinaryOperationFormatter("eq"),
        "<>": createBinaryOperationFormatter("ne"),
        ">": createBinaryOperationFormatter("gt"),
        ">=": createBinaryOperationFormatter("ge"),
        "<": createBinaryOperationFormatter("lt"),
        "<=": createBinaryOperationFormatter("le"),
        startswith: createStringFuncFormatter("startswith"),
        endswith: createStringFuncFormatter("endswith")
    };
    var formattersV2 = extend({}, formatters, {
        contains: createStringFuncFormatter("substringof", true),
        notcontains: createStringFuncFormatter("not substringof", true)
    });
    var formattersV4 = extend({}, formatters, {
        contains: createStringFuncFormatter("contains"),
        notcontains: createStringFuncFormatter("not contains")
    });
    var compileBinary = function(criteria) {
        criteria = dataUtils.normalizeBinaryCriterion(criteria);
        var op = criteria[1],
            formatters = 4 === protocolVersion ? formattersV4 : formattersV2,
            formatter = formatters[op.toLowerCase()];
        if (!formatter) {
            throw errors.Error("E4003", op)
        }
        var fieldName = criteria[0],
            value = criteria[2];
        if (fieldTypes && fieldTypes[fieldName]) {
            value = odataUtils.convertPrimitiveValue(fieldTypes[fieldName], value)
        }
        return formatter(serializePropName(fieldName), odataUtils.serializeValue(value, protocolVersion))
    };
    var compileUnary = function(criteria) {
        var op = criteria[0],
            crit = compileCore(criteria[1]);
        if ("!" === op) {
            return "not (" + crit + ")"
        }
        throw errors.Error("E4003", op)
    };
    var compileGroup = function(criteria) {
        var groupOperator, nextGroupOperator, bag = [];
        $.each(criteria, function(index, criterion) {
            if (Array.isArray(criterion)) {
                if (bag.length > 1 && groupOperator !== nextGroupOperator) {
                    throw new errors.Error("E4019")
                }
                bag.push("(" + compileCore(criterion) + ")");
                groupOperator = nextGroupOperator;
                nextGroupOperator = "and"
            } else {
                nextGroupOperator = dataUtils.isConjunctiveOperator(this) ? "and" : "or"
            }
        });
        return bag.join(" " + groupOperator + " ")
    };
    var compileCore = function(criteria) {
        if (Array.isArray(criteria[0])) {
            return compileGroup(criteria)
        }
        if (dataUtils.isUnaryOperation(criteria)) {
            return compileUnary(criteria)
        }
        return compileBinary(criteria)
    };
    return function(criteria, version, types) {
        fieldTypes = types;
        protocolVersion = version;
        return compileCore(criteria)
    }
}();
var createODataQueryAdapter = function(queryOptions) {
    var _select, _skip, _take, _countQuery, _sorting = [],
        _criteria = [],
        _expand = queryOptions.expand,
        _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
    var hasSlice = function() {
        return _skip || void 0 !== _take
    };
    var hasFunction = function(criterion) {
        for (var i = 0; i < criterion.length; i++) {
            if (isFunction(criterion[i])) {
                return true
            }
            if (Array.isArray(criterion[i]) && hasFunction(criterion[i])) {
                return true
            }
        }
        return false
    };
    var generateSelectExpand = function() {
        var hasDot = function(x) {
            return /\./.test(x)
        };
        var generateSelect = function() {
            if (!_select) {
                return
            }
            if (_oDataVersion < 4) {
                return serializePropName(_select.join())
            }
            return grep(_select, hasDot, true).join()
        };
        var generateExpand = function() {
            var generatorV2 = function() {
                var hash = {};
                if (_expand) {
                    $.each($.makeArray(_expand), function() {
                        hash[serializePropName(this)] = 1
                    })
                }
                if (_select) {
                    $.each($.makeArray(_select), function() {
                        var path = this.split(".");
                        if (path.length < 2) {
                            return
                        }
                        path.pop();
                        hash[serializePropName(path.join("."))] = 1
                    })
                }
                return $.map(hash, function(k, v) {
                    return v
                }).join()
            };
            var generatorV4 = function() {
                var format = function(hash) {
                    var formatCore = function(hash) {
                        var result = "",
                            select = [],
                            expand = [];
                        $.each(hash, function(key, value) {
                            if (Array.isArray(value)) {
                                [].push.apply(select, value)
                            }
                            if (isPlainObject(value)) {
                                expand.push(key + formatCore(value))
                            }
                        });
                        if (select.length || expand.length) {
                            result += "(";
                            if (select.length) {
                                result += "$select=" + $.map(select, serializePropName).join()
                            }
                            if (expand.length) {
                                if (select.length) {
                                    result += ";"
                                }
                                result += "$expand=" + $.map(expand, serializePropName).join()
                            }
                            result += ")"
                        }
                        return result
                    };
                    var result = [];
                    $.each(hash, function(key, value) {
                        result.push(key + formatCore(value))
                    });
                    return result.join()
                };
                var parseTree = function(exprs, root, stepper) {
                    var parseCore = function(exprParts, root, stepper) {
                        var result = stepper(root, exprParts.shift(), exprParts);
                        if (false === result) {
                            return
                        }
                        parseCore(exprParts, result, stepper)
                    };
                    $.each(exprs, function(_, x) {
                        parseCore(x.split("."), root, stepper)
                    })
                };
                var hash = {};
                if (_expand || _select) {
                    if (_expand) {
                        parseTree($.makeArray(_expand), hash, function(node, key, path) {
                            node[key] = node[key] || {};
                            if (!path.length) {
                                return false
                            }
                            return node[key]
                        })
                    }
                    if (_select) {
                        parseTree(grep($.makeArray(_select), hasDot), hash, function(node, key, path) {
                            if (!path.length) {
                                node[key] = node[key] || [];
                                node[key].push(key);
                                return false
                            }
                            return node[key] = node[key] || {}
                        })
                    }
                    return format(hash)
                }
            };
            if (_oDataVersion < 4) {
                return generatorV2()
            }
            return generatorV4()
        };
        var tuple = {
            $select: generateSelect() || void 0,
            $expand: generateExpand() || void 0
        };
        return tuple
    };
    var requestData = function() {
        var result = {};
        if (!_countQuery) {
            if (_sorting.length) {
                result.$orderby = _sorting.join(",")
            }
            if (_skip) {
                result.$skip = _skip
            }
            if (void 0 !== _take) {
                result.$top = _take
            }
            var tuple = generateSelectExpand();
            result.$select = tuple.$select;
            result.$expand = tuple.$expand
        }
        if (_criteria.length) {
            var criteria = _criteria.length < 2 ? _criteria[0] : _criteria,
                fieldTypes = queryOptions && queryOptions.fieldTypes;
            result.$filter = compileCriteria(criteria, _oDataVersion, fieldTypes)
        }
        if (_countQuery) {
            result.$top = 0
        }
        if (queryOptions.requireTotalCount || _countQuery) {
            if (4 !== _oDataVersion) {
                result.$inlinecount = "allpages"
            } else {
                result.$count = "true"
            }
        }
        return result
    };
    return {
        exec: function(url) {
            return odataUtils.sendRequest(_oDataVersion, {
                url: url,
                params: extend(requestData(), queryOptions && queryOptions.params)
            }, {
                beforeSend: queryOptions.beforeSend,
                jsonp: queryOptions.jsonp,
                withCredentials: queryOptions.withCredentials,
                countOnly: _countQuery,
                deserializeDates: queryOptions.deserializeDates,
                fieldTypes: queryOptions.fieldTypes
            })
        },
        multiSort: function(args) {
            var rules;
            if (hasSlice()) {
                return false
            }
            for (var i = 0; i < args.length; i++) {
                var rule, getter = args[i][0],
                    desc = !!args[i][1];
                if ("string" !== typeof getter) {
                    return false
                }
                rule = serializePropName(getter);
                if (desc) {
                    rule += " desc"
                }
                rules = rules || [];
                rules.push(rule)
            }
            _sorting = rules
        },
        slice: function(skipCount, takeCount) {
            if (hasSlice()) {
                return false
            }
            _skip = skipCount;
            _take = takeCount
        },
        filter: function(criterion) {
            if (hasSlice()) {
                return false
            }
            if (!Array.isArray(criterion)) {
                criterion = $.makeArray(arguments)
            }
            if (hasFunction(criterion)) {
                return false
            }
            if (_criteria.length) {
                _criteria.push("and")
            }
            _criteria.push(criterion)
        },
        select: function(expr) {
            if (_select || isFunction(expr)) {
                return false
            }
            if (!Array.isArray(expr)) {
                expr = $.makeArray(arguments)
            }
            _select = expr
        },
        count: function() {
            _countQuery = true
        }
    }
};
queryAdapters.odata = createODataQueryAdapter;
exports.odata = createODataQueryAdapter;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data_helper.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DataSource = __webpack_require__(51).DataSource,
    extend = __webpack_require__(1).extend,
    normalizeDataSourceOptions = __webpack_require__(51).normalizeDataSourceOptions;
var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
    DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler",
    DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler",
    DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler",
    DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = "_dataSourceFromUrlLoadMode",
    SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var DataHelperMixin = {
    postCtor: function() {
        this.on("disposing", function() {
            this._disposeDataSource()
        }.bind(this))
    },
    _refreshDataSource: function() {
        this._initDataSource();
        this._loadDataSource()
    },
    _initDataSource: function() {
        var widgetDataSourceOptions, dataSourceType, dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
        this._disposeDataSource();
        if (dataSourceOptions) {
            if (dataSourceOptions instanceof DataSource) {
                this._isSharedDataSource = true;
                this._dataSource = dataSourceOptions
            } else {
                widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
                dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
                    fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
                });
                this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions))
            }
            this._addDataSourceHandlers()
        }
    },
    _addDataSourceHandlers: function() {
        if (DATA_SOURCE_CHANGED_METHOD in this) {
            this._addDataSourceChangeHandler()
        }
        if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
            this._addDataSourceLoadErrorHandler()
        }
        if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
            this._addDataSourceLoadingChangedHandler()
        }
        this._addReadyWatcher()
    },
    _addReadyWatcher: function() {
        this._dataSource.on("loadingChanged", function(isLoading) {
            this._ready && this._ready(!isLoading)
        }.bind(this))
    },
    _addDataSourceChangeHandler: function() {
        var dataSource = this._dataSource;
        this._proxiedDataSourceChangedHandler = function() {
            this[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
        }.bind(this);
        dataSource.on("changed", this._proxiedDataSourceChangedHandler)
    },
    _addDataSourceLoadErrorHandler: function() {
        this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
        this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
    },
    _addDataSourceLoadingChangedHandler: function() {
        this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
        this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
    },
    _loadDataSource: function() {
        if (this._dataSource) {
            var dataSource = this._dataSource;
            if (dataSource.isLoaded()) {
                this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler()
            } else {
                dataSource.load()
            }
        }
    },
    _loadSingle: function(key, value) {
        key = "this" === key ? this._dataSource.key() || "this" : key;
        return this._dataSource.loadSingle(key, value)
    },
    _isLastPage: function() {
        return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
    },
    _isDataSourceLoading: function() {
        return this._dataSource && this._dataSource.isLoading()
    },
    _disposeDataSource: function() {
        if (this._dataSource) {
            if (this._isSharedDataSource) {
                delete this._isSharedDataSource;
                this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
            } else {
                this._dataSource.dispose()
            }
            delete this._dataSource;
            delete this._proxiedDataSourceChangedHandler;
            delete this._proxiedDataSourceLoadErrorHandler;
            delete this._proxiedDataSourceLoadingChangedHandler
        }
    },
    getDataSource: function() {
        return this._dataSource || null
    }
};
module.exports = DataHelperMixin;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/collection/item.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    publicComponentUtils = __webpack_require__(73);
var INVISIBLE_STATE_CLASS = "dx-state-invisible",
    DISABLED_STATE_CLASS = "dx-state-disabled",
    ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
var forcibleWatcher = function(watchMethod, fn, callback) {
    var filteredCallback = function() {
        var oldValue;
        return function(value) {
            if (oldValue !== value) {
                callback(value, oldValue);
                oldValue = value
            }
        }
    }();
    return {
        dispose: watchMethod(fn, filteredCallback),
        force: function() {
            filteredCallback(fn())
        }
    }
};
var CollectionItem = Class.inherit({
    ctor: function($element, options, rawData) {
        this._$element = $element;
        this._options = options;
        this._rawData = rawData;
        publicComponentUtils.attachInstanceToElement($element, this, this._dispose);
        this._render()
    },
    _render: function() {
        var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
        this._$element.append($placeholder);
        this._watchers = [];
        this._renderWatchers()
    },
    _renderWatchers: function() {
        this._startWatcher("disabled", this._renderDisabled.bind(this));
        this._startWatcher("visible", this._renderVisible.bind(this))
    },
    _startWatcher: function(field, render) {
        var rawData = this._rawData,
            exprGetter = this._options.fieldGetter(field);
        var watcher = forcibleWatcher(this._options.watchMethod(), function() {
            return exprGetter(rawData)
        }, function(value, oldValue) {
            this._dirty = true;
            render(value, oldValue)
        }.bind(this));
        this._watchers.push(watcher)
    },
    setDataField: function() {
        this._dirty = false;
        $.each(this._watchers, function(_, watcher) {
            watcher.force()
        });
        if (this._dirty) {
            return true
        }
    },
    _renderDisabled: function(value, oldValue) {
        this._$element.toggleClass(DISABLED_STATE_CLASS, !!value)
    },
    _renderVisible: function(value, oldValue) {
        this._$element.toggleClass(INVISIBLE_STATE_CLASS, void 0 !== value && !value)
    },
    _dispose: function() {
        $.each(this._watchers, function(_, watcher) {
            watcher.dispose()
        })
    }
});
CollectionItem.getInstance = function($element) {
    return publicComponentUtils.getInstanceByElement($element, this)
};
module.exports = CollectionItem;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/drop_down_editor/ui.drop_down_editor.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    isDefined = commonUtils.isDefined,
    extend = __webpack_require__(1).extend,
    errors = __webpack_require__(16),
    positionUtils = __webpack_require__(46),
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    messageLocalization = __webpack_require__(8),
    Button = __webpack_require__(25),
    eventUtils = __webpack_require__(3),
    TextBox = __webpack_require__(69),
    clickEvent = __webpack_require__(11),
    FunctionTemplate = __webpack_require__(91),
    Popup = __webpack_require__(68);
var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor",
    DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS = "dx-dropdowneditor-input-wrapper",
    DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button",
    DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon",
    DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay",
    DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped",
    DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active",
    DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible",
    DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DropDownEditor = TextBox.inherit({
    _supportedKeys: function() {
        return extend({}, this.callBase(), {
            tab: function(e) {
                if (!this.option("opened")) {
                    return
                }
                if ("instantly" === this.option("applyValueMode")) {
                    this.close();
                    return
                }
                var $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
                $focusableElement && $focusableElement.focus();
                e.preventDefault()
            },
            escape: function(e) {
                if (this.option("opened")) {
                    e.preventDefault()
                }
                this.close()
            },
            upArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.altKey) {
                    this.close();
                    return false
                }
                return true
            },
            downArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.altKey) {
                    this._validatedOpening();
                    return false
                }
                return true
            },
            enter: function(e) {
                if (this.option("opened")) {
                    e.preventDefault();
                    this._valueChangeEventHandler(e)
                }
                return true
            }
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            fieldEditEnabled: {
                since: "16.1",
                alias: "acceptCustomValue"
            },
            showDropButton: {
                since: "17.1",
                alias: "showDropDownButton"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: null,
            onOpened: null,
            onClosed: null,
            opened: false,
            acceptCustomValue: true,
            applyValueMode: "instantly",
            deferRendering: true,
            activeStateEnabled: true,
            dropDownButtonTemplate: "dropDownButton",
            fieldTemplate: null,
            contentTemplate: null,
            openOnFieldClick: false,
            showDropDownButton: true,
            popupPosition: this._getDefaultPopupPosition(),
            onPopupInitialized: null,
            applyButtonText: messageLocalization.format("OK"),
            cancelButtonText: messageLocalization.format("Cancel"),
            buttonsLocation: "default",
            showPopupTitle: false
        })
    },
    _getDefaultPopupPosition: function() {
        var position = getDefaultAlignment(this.option("rtlEnabled"));
        return {
            offset: {
                h: 0,
                v: -1
            },
            my: position + " top",
            at: position + " bottom",
            collision: "flip flip"
        }
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                var isGeneric = "generic" === device.platform,
                    isWin10 = "win" === device.platform && device.version && 10 === device.version[0];
                return isGeneric || isWin10
            },
            options: {
                popupPosition: {
                    offset: {
                        v: 0
                    }
                }
            }
        }])
    },
    _inputWrapper: function() {
        return this.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS)
    },
    _init: function() {
        this.callBase();
        this._initVisibilityActions();
        this._initPopupInitializedAction()
    },
    _initVisibilityActions: function() {
        this._openAction = this._createActionByOption("onOpened", {
            excludeValidators: ["disabled", "readOnly"]
        });
        this._closeAction = this._createActionByOption("onClosed", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initPopupInitializedAction: function() {
        this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
            excludeValidators: ["disabled", "readOnly", "designMode"]
        })
    },
    _render: function() {
        this.callBase();
        this._renderOpenHandler();
        this.element().addClass(DROP_DOWN_EDITOR_CLASS);
        this._renderOpenedState();
        this.setAria("role", "combobox")
    },
    _renderContentImpl: function() {
        if (!this.option("deferRendering")) {
            this._createPopup()
        }
    },
    _renderInput: function() {
        this.callBase();
        this.element().wrapInner($("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS));
        this._$container = this.element().children().eq(0);
        this.setAria({
            haspopup: "true",
            autocomplete: "list"
        })
    },
    _readOnlyPropValue: function() {
        return !this.option("acceptCustomValue") || this.callBase()
    },
    _cleanFocusState: function() {
        this.callBase();
        if (this.option("fieldTemplate")) {
            this._input().off("focusin focusout beforeactivate")
        }
    },
    _renderField: function() {
        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
        if (!(fieldTemplate && this.option("fieldTemplate"))) {
            return
        }
        this._renderTemplatedField(fieldTemplate, this._fieldRenderData())
    },
    _renderTemplatedField: function(fieldTemplate, data) {
        var isFocused = this._input().is(":focus");
        this._resetFocus(isFocused);
        var $container = this._$container;
        $container.empty();
        this._$dropDownButton = null;
        this._$clearButton = null;
        fieldTemplate.render({
            model: data,
            container: $container
        });
        if (!this._input().length) {
            throw errors.Error("E1010")
        }
        this._refreshEvents();
        this._refreshValueChangeEvent();
        isFocused && this._input().focus();
        this._renderFocusState()
    },
    _resetFocus: function(isFocused) {
        this._cleanFocusState();
        isFocused && this._input().focusout()
    },
    _fieldRenderData: function() {
        return this.option("value")
    },
    _renderInputAddons: function() {
        this._renderField();
        this.callBase();
        this._renderDropDownButton()
    },
    _renderDropDownButton: function() {
        if (this._$dropDownButton) {
            this._$dropDownButton.remove();
            this._$dropDownButton = null
        }
        var showDropDownButton = this.option("showDropDownButton");
        this.element().toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, showDropDownButton);
        if (!showDropDownButton) {
            return
        }
        this._$dropDownButton = this._createDropDownButton();
        this._attachDropDownButtonClickHandler()
    },
    _attachDropDownButtonClickHandler: function() {
        if (this.option("showDropDownButton") && !this.option("openOnFieldClick")) {
            this._$dropDownButton.dxButton("option", "onClick", this._openHandler.bind(this))
        }
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.dropDownButton = new FunctionTemplate(function(options) {
            var $icon = $("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
            options.container.append($icon)
        }, this)
    },
    _createDropDownButton: function() {
        var $button = $("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_CLASS).prependTo(this._buttonsContainer());
        this._createComponent($button, Button, {
            focusStateEnabled: false,
            hoverStateEnabled: false,
            activeStateEnabled: false,
            disabled: this.option("readOnly"),
            useInkRipple: false,
            template: this._getTemplateByOption("dropDownButtonTemplate")
        });
        $button.removeClass("dx-button");
        $button.on("mousedown", function(e) {
            e.preventDefault()
        });
        return $button
    },
    _renderOpenHandler: function() {
        var that = this,
            $inputWrapper = that.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS),
            eventName = eventUtils.addNamespace(clickEvent.name, that.NAME),
            openOnFieldClick = that.option("openOnFieldClick");
        $inputWrapper.off(eventName).on(eventName, that._getInputClickHandler(openOnFieldClick));
        that.element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
        if (openOnFieldClick) {
            that._openOnFieldClickAction = that._createAction(that._openHandler.bind(that))
        }
    },
    _getInputClickHandler: function(openOnFieldClick) {
        var that = this;
        return openOnFieldClick ? function(e) {
            that._executeOpenAction(e)
        } : function(e) {
            that._focusInput()
        }
    },
    _openHandler: function() {
        this._toggleOpenState()
    },
    _executeOpenAction: function(e) {
        this._openOnFieldClickAction({
            jQueryEvent: e
        })
    },
    _keyboardEventBindingTarget: function() {
        return this._input()
    },
    _focusInput: function() {
        if (this.option("disabled")) {
            return false
        }
        this._input().focus();
        return true
    },
    _toggleOpenState: function(isVisible) {
        if (!this._focusInput()) {
            return
        }
        if (!this.option("readOnly")) {
            isVisible = arguments.length ? isVisible : !this.option("opened");
            this.option("opened", isVisible)
        }
    },
    _renderOpenedState: function() {
        var opened = this.option("opened");
        if (opened) {
            this._createPopup()
        }
        this.element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
        this._setPopupOption("visible", opened);
        this.setAria({
            expanded: opened,
            owns: (opened || void 0) && this._popupContentId
        })
    },
    _createPopup: function() {
        if (this._$popup) {
            return
        }
        this._$popup = $("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).addClass(this.option("customOverlayCssClass")).appendTo(this.element());
        this._renderPopup();
        this._renderPopupContent()
    },
    _renderPopup: function() {
        this._popup = this._createComponent(this._$popup, Popup, this._popupConfig());
        this._popup.on({
            showing: this._popupShowingHandler.bind(this),
            shown: this._popupShownHandler.bind(this),
            hiding: this._popupHidingHandler.bind(this),
            hidden: this._popupHiddenHandler.bind(this)
        });
        this._popup.option("onContentReady", this._contentReadyHandler.bind(this));
        this._contentReadyHandler();
        this._popupContentId = "dx-" + new Guid;
        this.setAria("id", this._popupContentId, this._popup.content())
    },
    _contentReadyHandler: commonUtils.noop,
    _popupConfig: function() {
        return {
            onInitialized: this._popupInitializedHandler(),
            position: extend(this.option("popupPosition"), { of: this.element()
            }),
            showTitle: this.option("showPopupTitle"),
            width: "auto",
            height: "auto",
            shading: false,
            closeOnTargetScroll: true,
            closeOnOutsideClick: this._closeOutsideDropDownHandler.bind(this),
            animation: {
                show: {
                    type: "fade",
                    duration: 0,
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    duration: 400,
                    from: 1,
                    to: 0
                }
            },
            deferRendering: false,
            focusStateEnabled: false,
            showCloseButton: false,
            toolbarItems: this._getPopupToolbarItems(),
            onPositioned: this._popupPositionedHandler.bind(this),
            fullScreen: false
        }
    },
    _popupInitializedHandler: function() {
        if (!this.option("onPopupInitialized")) {
            return
        }
        return function(e) {
            this._popupInitializedAction({
                popup: e.component
            })
        }.bind(this)
    },
    _popupPositionedHandler: function(e) {
        this._popup.overlayContent().toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, e.position.v.flip)
    },
    _popupShowingHandler: commonUtils.noop,
    _popupHidingHandler: function() {
        this.option("opened", false)
    },
    _popupShownHandler: function() {
        this._openAction();
        if (this._$validationMessage) {
            this._$validationMessage.dxOverlay("option", "position", this._getValidationMessagePosition())
        }
    },
    _popupHiddenHandler: function() {
        this._closeAction();
        if (this._$validationMessage) {
            this._$validationMessage.dxOverlay("option", "position", this._getValidationMessagePosition())
        }
    },
    _getValidationMessagePosition: function() {
        var positionRequest = "below";
        if (this._popup && this._popup.option("visible")) {
            var myTop = positionUtils.setup(this.element()).top,
                popupTop = positionUtils.setup(this._popup.content()).top;
            positionRequest = myTop + this.option("popupPosition").offset.v > popupTop ? "below" : "above"
        }
        return this.callBase(positionRequest)
    },
    _renderPopupContent: function() {
        var contentTemplate = this._getTemplateByOption("contentTemplate");
        if (!(contentTemplate && this.option("contentTemplate"))) {
            return
        }
        var $popupContent = this._popup.content(),
            templateData = {
                value: this._fieldRenderData(),
                component: this
            };
        $popupContent.empty();
        contentTemplate.render({
            container: $popupContent,
            model: templateData
        })
    },
    _closeOutsideDropDownHandler: function(e) {
        var $target = $(e.target);
        var isInputClicked = !!$target.closest(this.element()).length;
        var isDropDownButtonClicked = !!$target.closest(this._$dropDownButton).length;
        var isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
        return isOutsideClick
    },
    _clean: function() {
        delete this._$dropDownButton;
        delete this._openOnFieldClickAction;
        if (this._$popup) {
            this._$popup.remove();
            delete this._$popup;
            delete this._popup
        }
        this.callBase()
    },
    _setPopupOption: function(optionName, value) {
        this._setWidgetOption("_popup", arguments)
    },
    _validatedOpening: function() {
        if (!this.option("readOnly")) {
            this._toggleOpenState(true)
        }
    },
    _getPopupToolbarItems: function() {
        return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : []
    },
    _getFirstPopupElement: function() {
        return this._popup._wrapper().find(".dx-popup-done.dx-button")
    },
    _getLastPopupElement: function() {
        return this._popup._wrapper().find(".dx-popup-cancel.dx-button")
    },
    _popupElementTabHandler: function(e) {
        var $element = $(e.currentTarget);
        if (e.shiftKey && $element.is(this._getFirstPopupElement()) || !e.shiftKey && $element.is(this._getLastPopupElement())) {
            this._input().focus();
            e.preventDefault()
        }
    },
    _popupElementEscHandler: function() {
        this._input().focus();
        this.close()
    },
    _popupButtonInitializedHandler: function(e) {
        e.component.registerKeyHandler("tab", this._popupElementTabHandler.bind(this));
        e.component.registerKeyHandler("escape", this._popupElementEscHandler.bind(this))
    },
    _popupToolbarItemsConfig: function() {
        var buttonsConfig = [{
            shortcut: "done",
            options: {
                onClick: this._applyButtonHandler.bind(this),
                text: this.option("applyButtonText"),
                onInitialized: this._popupButtonInitializedHandler.bind(this)
            }
        }, {
            shortcut: "cancel",
            options: {
                onClick: this._cancelButtonHandler.bind(this),
                text: this.option("cancelButtonText"),
                onInitialized: this._popupButtonInitializedHandler.bind(this)
            }
        }];
        return this._applyButtonsLocation(buttonsConfig)
    },
    _applyButtonsLocation: function(buttonsConfig) {
        var buttonsLocation = this.option("buttonsLocation"),
            resultConfig = buttonsConfig;
        if ("default" !== buttonsLocation) {
            var position = commonUtils.splitPair(buttonsLocation);
            $.each(resultConfig, function(_, element) {
                extend(element, {
                    toolbar: position[0],
                    location: position[1]
                })
            })
        }
        return resultConfig
    },
    _applyButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus()
    },
    _cancelButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus()
    },
    _toggleReadOnlyState: function() {
        this.callBase();
        this._$dropDownButton && this._$dropDownButton.dxButton("option", "disabled", this.option("readOnly"))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "opened":
                this._renderOpenedState();
                break;
            case "onOpened":
            case "onClosed":
                this._initVisibilityActions();
                break;
            case "onPopupInitialized":
                this._initPopupInitializedAction();
                break;
            case "fieldTemplate":
                if (isDefined(args.value)) {
                    this._renderInputAddons()
                } else {
                    this._invalidate()
                }
                break;
            case "showDropDownButton":
            case "contentTemplate":
            case "acceptCustomValue":
            case "openOnFieldClick":
                this._invalidate();
                break;
            case "dropDownButtonTemplate":
                this._renderDropDownButton();
                break;
            case "popupPosition":
            case "deferRendering":
                break;
            case "applyValueMode":
            case "applyButtonText":
            case "cancelButtonText":
            case "buttonsLocation":
                this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
                break;
            case "showPopupTitle":
                this._setPopupOption("showTitle", args.value);
                break;
            default:
                this.callBase(args)
        }
    },
    open: function() {
        this.option("opened", true)
    },
    close: function() {
        this.option("opened", false)
    },
    reset: function() {
        this.option("value", null);
        this._input().val("")
    },
    field: function() {
        return this._input()
    },
    content: function() {
        return this._popup ? this._popup.content() : null
    }
});
registerComponent("dxDropDownEditor", DropDownEditor);
module.exports = DropDownEditor;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    compileGetter = __webpack_require__(14).compileGetter,
    extend = __webpack_require__(1).extend,
    clickEvent = __webpack_require__(11),
    swipeEvents = __webpack_require__(118),
    support = __webpack_require__(24),
    messageLocalization = __webpack_require__(8),
    inkRipple = __webpack_require__(43),
    devices = __webpack_require__(6),
    ListItem = __webpack_require__(294),
    Button = __webpack_require__(25),
    eventUtils = __webpack_require__(3),
    themes = __webpack_require__(20),
    ScrollView = __webpack_require__(197),
    deviceDependentOptions = __webpack_require__(70).deviceDependentOptions,
    CollectionWidget = __webpack_require__(40),
    BindableTemplate = __webpack_require__(52);
var LIST_CLASS = "dx-list",
    LIST_ITEM_CLASS = "dx-list-item",
    LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS,
    LIST_GROUP_CLASS = "dx-list-group",
    LIST_GROUP_HEADER_CLASS = "dx-list-group-header",
    LIST_GROUP_BODY_CLASS = "dx-list-group-body",
    LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups",
    LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed",
    LIST_HAS_NEXT_CLASS = "dx-has-next",
    LIST_NEXT_BUTTON_CLASS = "dx-list-next-button",
    SELECT_ALL_SELECTOR = ".dx-list-select-all",
    LIST_ITEM_DATA_KEY = "dxListItemData",
    LIST_FEEDBACK_SHOW_TIMEOUT = 70;
var groupItemsGetter = compileGetter("items");
var ListBase = CollectionWidget.inherit({
    _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_SELECTOR].join(","),
    _supportedKeys: function() {
        var that = this;
        var moveFocusPerPage = function(direction) {
            var $item = getEdgeVisibleItem(direction),
                isFocusedItem = $item.is(that.option("focusedElement"));
            if (isFocusedItem) {
                scrollListTo($item, direction);
                $item = getEdgeVisibleItem(direction)
            }
            that.option("focusedElement", $item);
            that.scrollToItem($item)
        };
        var getEdgeVisibleItem = function(direction) {
            var scrollTop = that.scrollTop(),
                containerHeight = that.element().height();
            var $item = that.option("focusedElement"),
                isItemVisible = true;
            if (!$item) {
                return $()
            }
            while (isItemVisible) {
                var $nextItem = $item[direction]();
                if (!$nextItem.length) {
                    break
                }
                var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
                isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
                if (isItemVisible) {
                    $item = $nextItem
                }
            }
            return $item
        };
        var scrollListTo = function($item, direction) {
            var resultPosition = $item.position().top;
            if ("prev" === direction) {
                resultPosition = $item.position().top - that.element().height() + $item.outerHeight()
            }
            that.scrollTo(resultPosition)
        };
        return extend(this.callBase(), {
            leftArrow: commonUtils.noop,
            rightArrow: commonUtils.noop,
            pageUp: function() {
                moveFocusPerPage("prev");
                return false
            },
            pageDown: function() {
                moveFocusPerPage("next");
                return false
            }
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            autoPagingEnabled: {
                since: "15.1",
                message: "Use the 'pageLoadMode' option instead"
            },
            showNextButton: {
                since: "15.1",
                message: "Use the 'pageLoadMode' option instead"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            pullRefreshEnabled: false,
            scrollingEnabled: true,
            showScrollbar: "onScroll",
            useNativeScrolling: true,
            bounceEnabled: true,
            scrollByContent: true,
            scrollByThumb: false,
            pullingDownText: messageLocalization.format("dxList-pullingDownText"),
            pulledDownText: messageLocalization.format("dxList-pulledDownText"),
            refreshingText: messageLocalization.format("dxList-refreshingText"),
            pageLoadingText: messageLocalization.format("dxList-pageLoadingText"),
            onScroll: null,
            onPullRefresh: null,
            onPageLoading: null,
            pageLoadMode: "scrollBottom",
            nextButtonText: messageLocalization.format("dxList-nextButtonText"),
            onItemSwipe: null,
            grouped: false,
            onGroupRendered: null,
            collapsibleGroups: false,
            groupTemplate: "group",
            indicateLoading: true,
            activeStateEnabled: true,
            _itemAttributes: {
                role: "option"
            },
            useInkRipple: false,
            showChevronExpr: function(data) {
                return data ? data.showChevron : void 0
            },
            badgeExpr: function(data) {
                return data ? data.badge : void 0
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat(deviceDependentOptions(), [{
            device: function() {
                return !support.nativeScrolling
            },
            options: {
                useNativeScrolling: false
            }
        }, {
            device: function(device) {
                return !support.nativeScrolling && !devices.isSimulator() && "generic" === devices.real().platform && "generic" === device.platform
            },
            options: {
                showScrollbar: "onHover",
                pageLoadMode: "nextButton"
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }, {
            device: function() {
                return "win" === devices.current().platform && devices.isSimulator()
            },
            options: {
                bounceEnabled: false
            }
        }])
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateLoadingState(true)
        }
    },
    _itemClass: function() {
        return LIST_ITEM_CLASS
    },
    _itemDataKey: function() {
        return LIST_ITEM_DATA_KEY
    },
    _itemContainer: function() {
        return this._$container
    },
    _refreshItemElements: function() {
        if (!this.option("grouped")) {
            this._itemElementsCache = this._itemContainer().children(this._itemSelector())
        } else {
            this._itemElementsCache = this._itemContainer().children("." + LIST_GROUP_CLASS).children("." + LIST_GROUP_BODY_CLASS).children(this._itemSelector())
        }
    },
    reorderItem: function(itemElement, toItemElement) {
        this.callBase(itemElement, toItemElement);
        this._refreshItemElements()
    },
    _deleteItem: function(itemElement) {
        this.callBase(itemElement);
        this._refreshItemElements()
    },
    _itemElements: function() {
        return this._itemElementsCache
    },
    _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
            return
        }
        this.callBase(e)
    },
    _allowDynamicItemsAppend: function() {
        return true
    },
    _init: function() {
        this.callBase();
        this._$container = this.element();
        this._initScrollView();
        this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
        this._createGroupRenderAction();
        this.setAria("role", "listbox")
    },
    _dataSourceOptions: function() {
        this._suppressDeprecatedWarnings();
        var pagingEnabled = this.option("autoPagingEnabled");
        pagingEnabled = commonUtils.isDefined(this.option("showNextButton")) ? pagingEnabled || this.option("showNextButton") : pagingEnabled;
        this._resumeDeprecatedWarnings();
        return extend(this.callBase(), {
            paginate: commonUtils.isDefined(pagingEnabled) ? pagingEnabled : true
        })
    },
    _dataSourceFromUrlLoadMode: function() {
        return "raw"
    },
    _initScrollView: function() {
        this._suppressDeprecatedWarnings();
        var scrollingEnabled = this.option("scrollingEnabled"),
            pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled"),
            autoPagingEnabled = scrollingEnabled && commonUtils.ensureDefined(this.option("autoPagingEnabled"), "scrollBottom" === this.option("pageLoadMode")) && !!this._dataSource;
        this._resumeDeprecatedWarnings();
        this._scrollView = this._createComponent(this.element(), ScrollView, {
            disabled: this.option("disabled") || !scrollingEnabled,
            onScroll: this._scrollHandler.bind(this),
            onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
            onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
            showScrollbar: this.option("showScrollbar"),
            useNative: this.option("useNativeScrolling"),
            bounceEnabled: this.option("bounceEnabled"),
            scrollByContent: this.option("scrollByContent"),
            scrollByThumb: this.option("scrollByThumb"),
            pullingDownText: this.option("pullingDownText"),
            pulledDownText: this.option("pulledDownText"),
            refreshingText: this.option("refreshingText"),
            reachBottomText: this.option("pageLoadingText"),
            useKeyboard: false
        });
        this._$container = this._scrollView.content();
        this._createScrollViewActions()
    },
    _createScrollViewActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._pullRefreshAction = this._createActionByOption("onPullRefresh");
        this._pageLoadingAction = this._createActionByOption("onPageLoading")
    },
    _scrollHandler: function(e) {
        this._scrollAction && this._scrollAction(e)
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.group = new BindableTemplate(function($container, data) {
            if (typeUtils.isPlainObject(data)) {
                if (data.key) {
                    $container.text(data.key)
                }
            } else {
                $container.html(String(data))
            }
        }, ["key"], this.option("integrationOptions.watchMethod"))
    },
    _updateLoadingState: function(tryLoadMore) {
        this._suppressDeprecatedWarnings();
        var isDataLoaded = !tryLoadMore || this._isLastPage(),
            autoPagingEnabled = commonUtils.ensureDefined(this.option("autoPagingEnabled"), "scrollBottom" === this.option("pageLoadMode")),
            stopLoading = isDataLoaded || !autoPagingEnabled,
            hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
        this._resumeDeprecatedWarnings();
        if (stopLoading || this._scrollViewIsFull()) {
            this._scrollView.release(hideLoadIndicator);
            this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
            this._loadIndicationSuppressed(false)
        } else {
            this._infiniteDataLoading()
        }
    },
    _shouldRenderNextButton: function() {
        this._suppressDeprecatedWarnings();
        var result = commonUtils.ensureDefined(this.option("showNextButton"), "nextButton" === this.option("pageLoadMode")) && this._dataSource && this._dataSource.isLoaded();
        this._resumeDeprecatedWarnings();
        return result
    },
    _dataSourceLoadingChangedHandler: function(isLoading) {
        if (this._loadIndicationSuppressed()) {
            return
        }
        if (isLoading && this.option("indicateLoading")) {
            this._showLoadingIndicatorTimer = setTimeout(function() {
                var isEmpty = !this._itemElements().length;
                if (this._scrollView && !isEmpty) {
                    this._scrollView.startLoading()
                }
            }.bind(this))
        } else {
            clearTimeout(this._showLoadingIndicatorTimer);
            this._scrollView && this._scrollView.finishLoading()
        }
    },
    _dataSourceChangedHandler: function(newItems) {
        if (!this._shouldAppendItems()) {
            this._scrollView && this._scrollView.scrollTo(0)
        }
        this.callBase(newItems)
    },
    _hideLoadingIfLoadIndicationOff: function() {
        if (!this.option("indicateLoading")) {
            this._dataSourceLoadingChangedHandler(false)
        }
    },
    _loadIndicationSuppressed: function(value) {
        if (!arguments.length) {
            return this._isLoadIndicationSuppressed
        }
        this._isLoadIndicationSuppressed = value
    },
    _scrollViewIsFull: function() {
        return !this._scrollView || this._scrollView.isFull()
    },
    _pullDownHandler: function(e) {
        this._pullRefreshAction(e);
        if (this._dataSource && !this._isDataSourceLoading()) {
            this._clearSelectedItems();
            this._dataSource.pageIndex(0);
            this._dataSource.reload()
        } else {
            this._updateLoadingState()
        }
    },
    _infiniteDataLoading: function() {
        var isElementVisible = this.element().is(":visible");
        if (isElementVisible && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
            clearTimeout(this._loadNextPageTimer);
            this._loadNextPageTimer = setTimeout(this._loadNextPage.bind(this))
        }
    },
    _scrollBottomHandler: function(e) {
        this._pageLoadingAction(e);
        if (!this._isDataSourceLoading() && !this._isLastPage()) {
            this._loadNextPage()
        } else {
            this._updateLoadingState()
        }
    },
    _renderItems: function(items) {
        if (this.option("grouped")) {
            $.each(items, this._renderGroup.bind(this));
            this._attachGroupCollapseEvent();
            this._renderEmptyMessage()
        } else {
            this.callBase.apply(this, arguments)
        }
        this._refreshItemElements();
        this._updateLoadingState(true)
    },
    _attachGroupCollapseEvent: function() {
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
            selector = "." + LIST_GROUP_HEADER_CLASS,
            $element = this.element(),
            collapsibleGroups = this.option("collapsibleGroups");
        $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
        $element.off(eventName, selector);
        if (collapsibleGroups) {
            $element.on(eventName, selector, function(e) {
                this._createAction(function(e) {
                    var $group = $(e.jQueryEvent.currentTarget).parent();
                    this._collapseGroupHandler($group);
                    if (this.option("focusStateEnabled")) {
                        this.option("focusedElement", $group.find("." + LIST_ITEM_CLASS).eq(0))
                    }
                }.bind(this), {
                    validatingTargetName: "element"
                })({
                    jQueryEvent: e
                })
            }.bind(this))
        }
    },
    _collapseGroupHandler: function($group, toggle) {
        var deferred = $.Deferred(),
            $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
        $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
        var slideMethod = "slideToggle";
        if (true === toggle) {
            slideMethod = "slideUp"
        }
        if (false === toggle) {
            slideMethod = "slideDown"
        }
        $groupBody[slideMethod]({
            duration: 200,
            complete: function() {
                this.updateDimensions();
                this._updateLoadingState();
                deferred.resolve()
            }.bind(this)
        });
        return deferred.promise()
    },
    _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        if (this._initialized) {
            this._renderEmptyMessage();
            this._updateLoadingState()
        }
    },
    _render: function() {
        this._itemElementsCache = $();
        this.element().addClass(LIST_CLASS);
        this.callBase();
        this.option("useInkRipple") && this._renderInkRipple()
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _postprocessRenderItem: function(args) {
        this._refreshItemElements();
        this.callBase.apply(this, arguments);
        if (this.option("onItemSwipe")) {
            this._attachSwipeEvent($(args.itemElement))
        }
    },
    _attachSwipeEvent: function($itemElement) {
        var endEventName = eventUtils.addNamespace(swipeEvents.end, this.NAME);
        $itemElement.on(endEventName, this._itemSwipeEndHandler.bind(this))
    },
    _itemSwipeEndHandler: function(e) {
        this._itemJQueryEventHandler(e, "onItemSwipe", {
            direction: e.offset < 0 ? "left" : "right"
        })
    },
    _nextButtonHandler: function() {
        var source = this._dataSource;
        if (source && !source.isLoading()) {
            this._scrollView.toggleLoading(true);
            this._$nextButton.detach();
            this._loadIndicationSuppressed(true);
            this._loadNextPage()
        }
    },
    _renderGroup: function(index, group) {
        var $groupElement = $("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
        var $groupHeaderElement = $("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
        var groupTemplateName = this.option("groupTemplate"),
            groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index, $groupHeaderElement),
            renderArgs = {
                index: index,
                itemData: group,
                container: $groupHeaderElement
            };
        this._createItemByTemplate(groupTemplate, renderArgs);
        this._renderingGroupIndex = index;
        var $groupBody = $("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
        $.each(groupItemsGetter(group) || [], function(index, item) {
            this._renderItem(index, item, $groupBody)
        }.bind(this));
        this._groupRenderAction({
            groupElement: $groupElement,
            groupIndex: index,
            groupData: group
        })
    },
    _createGroupRenderAction: function() {
        this._groupRenderAction = this._createActionByOption("onGroupRendered")
    },
    _clean: function() {
        if (this._$nextButton) {
            this._$nextButton.remove();
            this._$nextButton = null
        }
        this.callBase.apply(this, arguments)
    },
    _dispose: function() {
        clearTimeout(this._holdTimer);
        clearTimeout(this._loadNextPageTimer);
        clearTimeout(this._showLoadingIndicatorTimer);
        this.callBase()
    },
    _toggleDisabledState: function(value) {
        this.callBase(value);
        this._scrollView.option("disabled", value || !this.option("scrollingEnabled"))
    },
    _toggleNextButton: function(value) {
        var dataSource = this._dataSource,
            $nextButton = this._getNextButton();
        this.element().toggleClass(LIST_HAS_NEXT_CLASS, value);
        if (value && dataSource && dataSource.isLoaded()) {
            $nextButton.appendTo(this._itemContainer())
        }
        if (!value) {
            $nextButton.detach()
        }
    },
    _getNextButton: function() {
        if (!this._$nextButton) {
            this._$nextButton = this._createNextButton()
        }
        return this._$nextButton
    },
    _createNextButton: function() {
        var $result = $("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
        var $button = $("<div>").appendTo($result);
        this._createComponent($button, Button, {
            text: this.option("nextButtonText"),
            onClick: this._nextButtonHandler.bind(this),
            integrationOptions: {}
        });
        return $result
    },
    _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this.scrollToItem(this.option("focusedElement"))
    },
    _refresh: function() {
        var scrollTop = this._scrollView.scrollTop();
        this.callBase();
        scrollTop && this._scrollView.scrollTo(scrollTop)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "pageLoadMode":
                this._toggleNextButton(args.value);
                this._initScrollView();
                break;
            case "showNextButton":
                this._toggleNextButton(args.value);
                break;
            case "dataSource":
                this.callBase(args);
                this._initScrollView();
                break;
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "pageLoadingText":
            case "useNative":
            case "showScrollbar":
            case "bounceEnabled":
            case "scrollByContent":
            case "scrollByThumb":
            case "scrollingEnabled":
            case "pullRefreshEnabled":
            case "autoPagingEnabled":
                this._initScrollView();
                this._updateLoadingState();
                break;
            case "nextButtonText":
            case "onItemSwipe":
            case "useInkRipple":
                this._invalidate();
                break;
            case "onScroll":
            case "onPullRefresh":
            case "onPageLoading":
                this._createScrollViewActions();
                this._invalidate();
                break;
            case "grouped":
            case "collapsibleGroups":
            case "groupTemplate":
                this._invalidate();
                break;
            case "onGroupRendered":
                this._createGroupRenderAction();
                break;
            case "width":
            case "height":
                this.callBase(args);
                this._scrollView.update();
                break;
            case "indicateLoading":
                this._hideLoadingIfLoadIndicationOff();
                break;
            case "visible":
                this.callBase(args);
                this._scrollView.update();
                break;
            case "rtlEnabled":
                this._initScrollView();
                this.callBase(args);
                break;
            case "showChevronExpr":
            case "badgeExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _extendActionArgs: function($itemElement) {
        if (!this.option("grouped")) {
            return this.callBase($itemElement)
        }
        var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
        var $item = $group.find("." + LIST_ITEM_CLASS);
        return extend(this.callBase($itemElement), {
            itemIndex: {
                group: $group.index(),
                item: $item.index($itemElement)
            }
        })
    },
    expandGroup: function(groupIndex) {
        var deferred = $.Deferred(),
            $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
        this._collapseGroupHandler($group, false).done(function() {
            deferred.resolveWith(this)
        }.bind(this));
        return deferred.promise()
    },
    collapseGroup: function(groupIndex) {
        var deferred = $.Deferred(),
            $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
        this._collapseGroupHandler($group, true).done(function() {
            deferred.resolveWith(this)
        }.bind(this));
        return deferred
    },
    updateDimensions: function() {
        var that = this,
            deferred = $.Deferred();
        if (that._scrollView) {
            that._scrollView.update().done(function() {
                !that._scrollViewIsFull() && that._updateLoadingState(true);
                deferred.resolveWith(that)
            })
        } else {
            deferred.resolveWith(that)
        }
        return deferred.promise()
    },
    reload: function() {
        this.scrollTo(0);
        this._pullDownHandler()
    },
    repaint: function() {
        this.scrollTo(0);
        this.callBase()
    },
    scrollTop: function() {
        return this._scrollView.scrollOffset().top
    },
    clientHeight: function() {
        return this._scrollView.clientHeight()
    },
    scrollHeight: function() {
        return this._scrollView.scrollHeight()
    },
    scrollBy: function(distance) {
        this._scrollView.scrollBy(distance)
    },
    scrollTo: function(location) {
        this._scrollView.scrollTo(location)
    },
    scrollToItem: function(itemElement) {
        var $item = this._editStrategy.getItemElement(itemElement);
        this._scrollView.scrollToElement($item)
    }
});
ListBase.ItemClass = ListItem;
module.exports = ListBase;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scrollable.native.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    devices = __webpack_require__(6),
    Class = __webpack_require__(5),
    Scrollbar = __webpack_require__(198);
var SCROLLABLE_NATIVE = "dxNativeScrollable",
    SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native",
    SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated",
    SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal",
    HIDE_SCROLLBAR_TIMEOUT = 500;
var NativeStrategy = Class.inherit({
    ctor: function(scrollable) {
        this._init(scrollable)
    },
    _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.element();
        this._$container = scrollable._$container;
        this._$content = scrollable._$content;
        this._direction = scrollable.option("direction");
        this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
        this._showScrollbar = scrollable.option("showScrollbar");
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable)
    },
    render: function() {
        this._renderPushBackOffset();
        var device = devices.real(),
            deviceType = device.platform;
        this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
        if (this._showScrollbar && this._useSimulatedScrollbar) {
            this._renderScrollbars()
        }
    },
    updateBounds: noop,
    _renderPushBackOffset: function() {
        var pushBackValue = this.option("pushBackValue");
        if (!pushBackValue && !this._component._lastPushBackValue) {
            return
        }
        this._$content.css({
            paddingTop: pushBackValue,
            paddingBottom: pushBackValue
        });
        this._component._lastPushBackValue = pushBackValue
    },
    _renderScrollbars: function() {
        this._scrollbars = {};
        this._hideScrollbarTimeout = 0;
        this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
        this._renderScrollbar(VERTICAL);
        this._renderScrollbar(HORIZONTAL)
    },
    _renderScrollbar: function(direction) {
        if (!this._isDirection(direction)) {
            return
        }
        this._scrollbars[direction] = new Scrollbar($("<div>").appendTo(this._$element), {
            direction: direction,
            expandable: this._component.option("scrollByThumb")
        })
    },
    handleInit: noop,
    handleStart: function() {
        this._disablePushBack = true
    },
    handleMove: function(e) {
        if (this._isLocked()) {
            e.cancel = true;
            return
        }
        if (this._allowedDirection()) {
            e.originalEvent.isScrollingEvent = true
        }
    },
    handleEnd: function() {
        this._disablePushBack = false
    },
    handleCancel: noop,
    handleStop: noop,
    _eachScrollbar: function(callback) {
        callback = callback.bind(this);
        $.each(this._scrollbars || {}, function(direction, scrollbar) {
            callback(scrollbar, direction)
        })
    },
    createActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._updateAction = this._createActionByOption("onUpdated")
    },
    _createActionArgs: function() {
        var location = this.location();
        return {
            jQueryEvent: this._eventForUserAction,
            scrollOffset: {
                top: -location.top,
                left: -location.left
            },
            reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : void 0,
            reachedRight: this._isDirection(HORIZONTAL) ? location.left <= this._containerSize.width - this._componentContentSize.width : void 0,
            reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : void 0,
            reachedBottom: this._isDirection(VERTICAL) ? location.top <= this._containerSize.height - this._componentContentSize.height : void 0
        }
    },
    handleScroll: function(e) {
        if (!this._isScrollLocationChanged()) {
            e.stopImmediatePropagation();
            return
        }
        this._eventForUserAction = e;
        this._moveScrollbars();
        this._scrollAction(this._createActionArgs());
        this._lastLocation = this.location();
        this._pushBackFromBoundary()
    },
    _pushBackFromBoundary: function() {
        var pushBackValue = this.option("pushBackValue");
        if (!pushBackValue || this._disablePushBack) {
            return
        }
        var scrollOffset = this._containerSize.height - this._contentSize.height,
            scrollTopPos = this._$container.scrollTop(),
            scrollBottomPos = scrollOffset + scrollTopPos - 2 * pushBackValue;
        if (!scrollTopPos) {
            this._$container.scrollTop(pushBackValue)
        } else {
            if (!scrollBottomPos) {
                this._$container.scrollTop(pushBackValue - scrollOffset)
            }
        }
    },
    _isScrollLocationChanged: function() {
        var currentLocation = this.location(),
            lastLocation = this._lastLocation || {},
            isTopChanged = lastLocation.top !== currentLocation.top,
            isLeftChanged = lastLocation.left !== currentLocation.left;
        return isTopChanged || isLeftChanged
    },
    _moveScrollbars: function() {
        this._eachScrollbar(function(scrollbar) {
            scrollbar.moveTo(this.location());
            scrollbar.option("visible", true)
        });
        this._hideScrollbars()
    },
    _hideScrollbars: function() {
        clearTimeout(this._hideScrollbarTimeout);
        this._hideScrollbarTimeout = setTimeout(function() {
            this._eachScrollbar(function(scrollbar) {
                scrollbar.option("visible", false)
            })
        }.bind(this), HIDE_SCROLLBAR_TIMEOUT)
    },
    location: function() {
        return {
            left: -this._$container.scrollLeft(),
            top: this.option("pushBackValue") - this._$container.scrollTop()
        }
    },
    disabledChanged: noop,
    update: function() {
        this._update();
        this._updateAction(this._createActionArgs())
    },
    _update: function() {
        this._updateDimensions();
        this._updateScrollbars()
    },
    _updateDimensions: function() {
        this._containerSize = {
            height: this._$container.height(),
            width: this._$container.width()
        };
        this._componentContentSize = {
            height: this._component.content().height(),
            width: this._component.content().width()
        };
        this._contentSize = {
            height: this._$content.height(),
            width: this._$content.width()
        };
        this._pushBackFromBoundary()
    },
    _updateScrollbars: function() {
        this._eachScrollbar(function(scrollbar, direction) {
            var dimension = direction === VERTICAL ? "height" : "width";
            scrollbar.option({
                containerSize: this._containerSize[dimension],
                contentSize: this._componentContentSize[dimension]
            });
            scrollbar.update()
        })
    },
    _allowedDirections: function() {
        return {
            vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
            horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
        }
    },
    dispose: function() {
        var className = this._$element.get(0).className;
        var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
        if (scrollableNativeRegexp.test(className)) {
            this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "))
        }
        this._$element.off("." + SCROLLABLE_NATIVE);
        this._$container.off("." + SCROLLABLE_NATIVE);
        this._removeScrollbars();
        clearTimeout(this._gestureEndTimer);
        clearTimeout(this._hideScrollbarTimeout)
    },
    _removeScrollbars: function() {
        this._eachScrollbar(function(scrollbar) {
            scrollbar.element().remove()
        })
    },
    scrollBy: function(distance) {
        var location = this.location();
        this._$container.scrollTop(-location.top - distance.top + this.option("pushBackValue"));
        this._$container.scrollLeft(-location.left - distance.left)
    },
    validate: function() {
        return !this.option("disabled") && this._allowedDirection()
    },
    getDirection: function() {
        return this._allowedDirection()
    },
    verticalOffset: function() {
        return this.option("pushBackValue")
    }
});
module.exports = NativeStrategy;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/gesture/swipeable.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    swipeEvents = __webpack_require__(118),
    DOMComponent = __webpack_require__(45),
    eventUtils = __webpack_require__(3),
    extend = __webpack_require__(1).extend,
    publicComponentUtils = __webpack_require__(73);
var DX_SWIPEABLE = "dxSwipeable",
    SWIPEABLE_CLASS = "dx-swipeable",
    ACTION_TO_EVENT_MAP = {
        onStart: swipeEvents.start,
        onUpdated: swipeEvents.swipe,
        onEnd: swipeEvents.end,
        onCancel: "dxswipecancel"
    };
var Swipeable = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            elastic: true,
            immediate: false,
            direction: "horizontal",
            itemSizeFunc: null,
            onStart: null,
            onUpdated: null,
            onEnd: null,
            onCancel: null
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass(SWIPEABLE_CLASS);
        this._attachEventHandlers()
    },
    _attachEventHandlers: function() {
        this._detachEventHandlers();
        if (this.option("disabled")) {
            return
        }
        var NAME = this.NAME;
        this._createEventData();
        $.each(ACTION_TO_EVENT_MAP, function(actionName, eventName) {
            var action = this._createActionByOption(actionName, {
                context: this
            });
            eventName = eventUtils.addNamespace(eventName, NAME);
            this.element().on(eventName, this._eventData, function(e) {
                return action({
                    jQueryEvent: e
                })
            })
        }.bind(this))
    },
    _createEventData: function() {
        this._eventData = {
            elastic: this.option("elastic"),
            itemSizeFunc: this.option("itemSizeFunc"),
            direction: this.option("direction"),
            immediate: this.option("immediate")
        }
    },
    _detachEventHandlers: function() {
        this.element().off("." + DX_SWIPEABLE)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "disabled":
            case "onStart":
            case "onUpdated":
            case "onEnd":
            case "onCancel":
            case "elastic":
            case "immediate":
            case "itemSizeFunc":
            case "direction":
                this._detachEventHandlers();
                this._attachEventHandlers();
                break;
            case "rtlEnabled":
                break;
            default:
                this.callBase(args)
        }
    }
});
publicComponentUtils.name(Swipeable, DX_SWIPEABLE);
module.exports = Swipeable;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    dateLocalization = __webpack_require__(32);
var abstract = Class.abstract;
var DateBoxStrategy = Class.inherit({
    ctor: function(dateBox) {
        this.dateBox = dateBox
    },
    widgetOption: function() {
        return this._widget && this._widget.option.apply(this._widget, arguments)
    },
    _renderWidget: function(element) {
        element = element || $("<div>");
        this._widget = this._createWidget(element);
        this._widget.element().appendTo(this._getWidgetContainer())
    },
    _createWidget: function(element) {
        var widgetName = this._getWidgetName();
        var widgetOptions = this._getWidgetOptions();
        return this.dateBox._createComponent(element, widgetName, widgetOptions)
    },
    _getWidgetOptions: abstract,
    _getWidgetName: abstract,
    getDefaultOptions: function() {
        return {
            mode: "text"
        }
    },
    getDisplayFormat: abstract,
    supportedKeys: noop,
    attachKeyboardEvents: function(keyboardProcessor) {
        this._widgetKeyboardProcessor = keyboardProcessor.attachChildProcessor()
    },
    getParsedText: function(text, format) {
        return dateLocalization.parse(text, format)
    },
    renderInputMinMax: noop,
    renderOpenedState: function() {
        if (this.dateBox.option("opened")) {
            this._updateValue()
        }
    },
    popupConfig: abstract,
    renderPopupContent: function() {
        var popup = this._getPopup();
        this._renderWidget();
        popup.content().parent().off("mousedown").on("mousedown", this._preventFocusOnPopup.bind(this))
    },
    getFirstPopupElement: noop,
    getLastPopupElement: noop,
    _preventFocusOnPopup: function(e) {
        e.preventDefault()
    },
    _getWidgetContainer: function() {
        return this._getPopup().content()
    },
    _getPopup: function() {
        return this.dateBox._popup
    },
    popupShowingHandler: noop,
    popupHiddenHandler: noop,
    _updateValue: function() {
        this._widget && this._widget.option("value", this.dateBoxValue())
    },
    _valueChangedHandler: function(args) {
        if (this.dateBox.option("opened") && "instantly" === this.dateBox.option("applyValueMode")) {
            this.dateBoxValue(args.value)
        }
    },
    useCurrentDateByDefault: noop,
    textChangedHandler: noop,
    renderValue: function() {
        if (this.dateBox.option("opened")) {
            this._updateValue()
        }
    },
    getValue: function() {
        return this._widget.option("value")
    },
    isAdaptivityChanged: function() {
        return false
    },
    dispose: function() {
        var popup = this._getPopup();
        if (popup) {
            popup.content().empty()
        }
    },
    dateBoxValue: function() {
        if (arguments.length) {
            return this.dateBox.dateValue.apply(this.dateBox, arguments)
        } else {
            return this.dateBox.dateOption.apply(this.dateBox, ["value"])
        }
    }
});
module.exports = DateBoxStrategy;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/select_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(13),
    inkRipple = __webpack_require__(43),
    messageLocalization = __webpack_require__(8),
    registerComponent = __webpack_require__(4),
    eventUtils = __webpack_require__(3),
    dataQuery = __webpack_require__(35),
    DropDownList = __webpack_require__(150),
    themes = __webpack_require__(20),
    clickEvent = __webpack_require__(11);
var DISABLED_STATE_SELECTOR = ".dx-state-disabled",
    SELECTBOX_CLASS = "dx-selectbox",
    SELECTBOX_POPUP_CLASS = "dx-selectbox-popup",
    SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container",
    SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper";
var SelectBox = DropDownList.inherit({
    _supportedKeys: function() {
        var that = this,
            parent = this.callBase(),
            clearSelectBox = function(e) {
                var isEditable = this._isEditable();
                if (!isEditable) {
                    if (this.option("showClearButton")) {
                        e.preventDefault();
                        this.reset()
                    }
                } else {
                    if (this._valueSubstituted()) {
                        this._preventFiltering = true
                    }
                }
                this._preventSubstitution = true
            };
        var searchIfNeeded = function() {
            if (that.option("searchEnabled") && that._valueSubstituted()) {
                that._searchHandler()
            }
        };
        return extend({}, parent, {
            tab: function() {
                if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
                    this._cleanInputSelection()
                }
                parent.tab.apply(this, arguments)
            },
            upArrow: function() {
                if (parent.upArrow.apply(this, arguments)) {
                    if (!this.option("opened")) {
                        this._setNextValue(-1)
                    }
                    return true
                }
            },
            downArrow: function() {
                if (parent.downArrow.apply(this, arguments)) {
                    if (!this.option("opened")) {
                        this._setNextValue(1)
                    }
                    return true
                }
            },
            leftArrow: function() {
                searchIfNeeded();
                parent.leftArrow.apply(this, arguments)
            },
            rightArrow: function() {
                searchIfNeeded();
                parent.rightArrow.apply(this, arguments)
            },
            home: function() {
                searchIfNeeded();
                parent.home.apply(this, arguments)
            },
            end: function() {
                searchIfNeeded();
                parent.end.apply(this, arguments)
            },
            escape: function() {
                parent.escape.apply(this, arguments);
                if (!this._isEditable()) {
                    this._focusListElement(null);
                    this._updateField(this.option("selectedItem"))
                }
            },
            enter: function(e) {
                if ("" === this._input().val() && this.option("value") && this.option("allowClearing")) {
                    this.option({
                        selectedItem: null,
                        value: null
                    });
                    this.close()
                } else {
                    if (this.option("acceptCustomValue")) {
                        e.preventDefault()
                    }
                    if (parent.enter.apply(this, arguments)) {
                        return this.option("opened")
                    }
                }
            },
            backspace: clearSelectBox,
            del: clearSelectBox
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            placeholder: messageLocalization.format("Select"),
            fieldTemplate: null,
            valueChangeEvent: "change",
            acceptCustomValue: false,
            onCustomItemCreating: function(e) {
                return e.text
            },
            showSelectionControls: false,
            autocompletionEnabled: true,
            allowClearing: true,
            tooltipEnabled: false,
            openOnFieldClick: true,
            showDropDownButton: true,
            displayCustomValue: false,
            _isAdaptablePopupPosition: false,
            useInkRipple: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return /win8/.test(themes.current())
            },
            options: {
                _isAdaptablePopupPosition: true,
                popupPosition: {
                    at: "left top",
                    offset: {
                        h: 0,
                        v: 0
                    }
                }
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                _isAdaptablePopupPosition: true,
                popupPosition: {
                    offset: {
                        h: -16,
                        v: -8
                    }
                },
                useInkRipple: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initCustomItemCreatingAction()
    },
    _render: function() {
        this._renderSubmitElement();
        this.callBase();
        this.element().addClass(SELECTBOX_CLASS);
        this.option("useInkRipple") && this._renderInkRipple();
        this._renderTooltip();
        this._$container.addClass(SELECTBOX_CONTAINER_CLASS)
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple || this._isEditable()) {
            return
        }
        var config = {
            element: this._inputWrapper(),
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _createPopup: function() {
        this.callBase();
        this._popup.element().addClass(SELECTBOX_POPUP_CLASS)
    },
    _popupWrapperClass: function() {
        return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS
    },
    _renderOpenedState: function() {
        this.callBase();
        if (this.option("opened")) {
            this._scrollToSelectedItem();
            this._focusSelectedElement()
        }
    },
    _focusSelectedElement: function() {
        var searchValue = this._searchValue();
        if (!searchValue) {
            this._focusListElement(null);
            return
        }
        var $listItems = this._list._itemElements(),
            index = inArray(this.option("selectedItem"), this.option("items")),
            focusedElement = index >= 0 && !this._isCustomItemSelected() ? $listItems.eq(index) : null;
        this._focusListElement(focusedElement)
    },
    _renderFocusedElement: function() {
        if (!this._list) {
            return
        }
        var searchValue = this._searchValue();
        if (!searchValue || this.option("acceptCustomValue")) {
            this._focusListElement(null);
            return
        }
        var $listItems = this._list._itemElements(),
            focusedElement = $listItems.not(DISABLED_STATE_SELECTOR).eq(0);
        this._focusListElement(focusedElement)
    },
    _focusListElement: function(element) {
        this._preventInputValueRender = true;
        this._list.option("focusedElement", element);
        delete this._preventInputValueRender
    },
    _scrollToSelectedItem: function() {
        this._list.scrollToItem(this._list.option("selectedItem"))
    },
    _listContentReadyHandler: function() {
        this.callBase();
        var isPaginate = this._dataSource && this._dataSource.paginate();
        if (isPaginate && this._needPopupRepaint()) {
            return
        }
        this._scrollToSelectedItem()
    },
    _renderValue: function() {
        this._renderInputValue();
        this._setSubmitValue()
    },
    _setSubmitValue: function() {
        var value = this.option("value"),
            submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value) : value;
        this._$submitElement.val(submitValue)
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _renderInputValue: function() {
        return this.callBase().always(function() {
            this._renderInputValueAsync()
        }.bind(this))
    },
    _renderInputValueAsync: function() {
        this._renderTooltip();
        this._renderInputValueImpl();
        this._refreshSelected()
    },
    _renderInputValueImpl: function() {
        this._renderInputAddons()
    },
    _fitIntoRange: function(value, start, end) {
        if (value > end) {
            return start
        }
        if (value < start) {
            return end
        }
        return value
    },
    _setNextValue: function(step) {
        var dataSourceIsLoaded = this._dataSource.isLoaded() ? $.Deferred().resolve() : this._dataSource.load();
        dataSourceIsLoaded.done(function() {
            var item = this._calcNextItem(step),
                value = this._valueGetter(item);
            this._setValue(value)
        }.bind(this))
    },
    _calcNextItem: function(step) {
        var items = this._items();
        var nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
        return items[nextIndex]
    },
    _items: function() {
        var items = this._list ? this.option("items") : this._dataSource.items();
        var availableItems = new dataQuery(items).filter("disabled", "<>", true).toArray();
        return availableItems
    },
    _getSelectedIndex: function() {
        var items = this._items();
        var selectedItem = this.option("selectedItem");
        var result = -1;
        $.each(items, function(index, item) {
            if (this._isValueEquals(item, selectedItem)) {
                result = index;
                return false
            }
        }.bind(this));
        return result
    },
    _setSelectedItem: function(item) {
        var isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
        this.callBase(isUnknownItem ? null : item)
    },
    _isCustomValueAllowed: function() {
        return this.option("acceptCustomValue") || this.callBase()
    },
    _displayValue: function(item) {
        item = !commonUtils.isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
        return this.callBase(item)
    },
    _listConfig: function() {
        var result = extend(this.callBase(), {
            pageLoadMode: "scrollBottom",
            onSelectionChanged: this._getSelectionChangeHandler(),
            selectedItem: this.option("selectedItem"),
            onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this)
        });
        if (this.option("showSelectionControls")) {
            extend(result, {
                showSelectionControls: true,
                selectionByClick: true
            })
        }
        return result
    },
    _listFocusedItemChangeHandler: function(e) {
        if (this._preventInputValueRender) {
            return
        }
        var list = e.component,
            focusedElement = list.option("focusedElement"),
            focusedItem = list._getItemData(focusedElement);
        this._updateField(focusedItem)
    },
    _updateField: function(item) {
        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
        if (!(fieldTemplate && this.option("fieldTemplate"))) {
            this._renderDisplayText(this._displayGetter(item));
            return
        }
        this._renderInputAddons()
    },
    _getSelectionChangeHandler: function() {
        return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : commonUtils.noop
    },
    _selectionChangeHandler: function(e) {
        $.each(e.addedItems || [], function(_, addedItem) {
            this._setValue(this._valueGetter(addedItem))
        }.bind(this))
    },
    _toggleOpenState: function(isVisible) {
        if (this.option("disabled")) {
            return
        }
        isVisible = arguments.length ? isVisible : !this.option("opened");
        if (!isVisible) {
            this._restoreInputText()
        }
        if (this._wasSearch() && isVisible) {
            this._wasSearch(false);
            if (this.option("showDataBeforeSearch") || 0 === this.option("minSearchLength")) {
                if (this._searchTimer) {
                    return
                }
                var searchValue = this._dataSource.searchValue();
                searchValue && this._wasSearch(true);
                this._filterDataSource(searchValue || null)
            } else {
                this._setListOption("items", [])
            }
        }
        this.callBase(isVisible)
    },
    _renderTooltip: function() {
        if (this.option("tooltipEnabled")) {
            this.element().attr("title", this.option("displayValue"))
        }
    },
    _renderDimensions: function() {
        this.callBase();
        this._setPopupOption("width")
    },
    _restoreInputText: function() {
        if (this.option("acceptCustomValue")) {
            return
        }
        if (!this._searchValue() && this.option("allowClearing")) {
            this._clearTextValue();
            return
        }
        var oldSelectedItem = this.option("selectedItem");
        this._renderInputValue().always(function(selectedItem) {
            var newSelectedItem = commonUtils.ensureDefined(selectedItem, oldSelectedItem);
            this._setSelectedItem(newSelectedItem);
            this._updateField(newSelectedItem);
            this._clearFilter()
        }.bind(this))
    },
    _focusOutHandler: function(e) {
        this.callBase(e);
        this._restoreInputText()
    },
    _clearTextValue: function() {
        this.option("value", null)
    },
    _renderValueChangeEvent: function() {
        if (this._isEditable()) {
            this.callBase()
        }
    },
    _isEditable: function() {
        return this.option("acceptCustomValue") || this.option("searchEnabled")
    },
    _fieldRenderData: function() {
        var $listFocused = this._list && this._list.option("focusedElement");
        if ($listFocused) {
            return this._list._getItemData($listFocused)
        }
        return this.option("selectedItem")
    },
    _readOnlyPropValue: function() {
        return !this._isEditable() || this.option("readOnly")
    },
    _isSelectedValue: function(value) {
        return this._isValueEquals(value, this.option("value"))
    },
    _shouldCloseOnItemClick: function() {
        return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"))
    },
    _listItemClickHandler: function(e) {
        var previousValue = this._getCurrentValue();
        this._saveValueChangeEvent(e.jQueryEvent);
        this._completeSelection(this._valueGetter(e.itemData));
        if (this._shouldCloseOnItemClick()) {
            this.option("opened", false)
        }
        if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
            this._updateField(e.itemData)
        }
    },
    _completeSelection: function(value) {
        if (this._wasSearch()) {
            this._clearFilter()
        }
        this._setValue(value)
    },
    _clearValueHandler: function() {
        this.reset()
    },
    _loadItem: function(value) {
        var that = this,
            deferred = $.Deferred();
        this.callBase(value).done(function(item) {
            deferred.resolve(item)
        }).fail(function() {
            var selectedItem = that.option("selectedItem");
            if (that.option("acceptCustomValue") && value === that._valueGetter(selectedItem)) {
                deferred.resolve(selectedItem)
            } else {
                deferred.reject()
            }
        });
        return deferred.promise()
    },
    _isCustomItemSelected: function() {
        var selectedItem = this.option("selectedItem"),
            searchValue = this._searchValue(),
            selectedItemText = this._displayGetter(selectedItem);
        return !selectedItemText || searchValue !== selectedItemText.toString()
    },
    _valueChangeEventHandler: function() {
        if (this.option("acceptCustomValue") && this._isCustomItemSelected()) {
            this._customItemAddedHandler()
        }
    },
    _initCustomItemCreatingAction: function() {
        this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating")
    },
    _customItemAddedHandler: function() {
        var searchValue = this._searchValue(),
            item = this._customItemCreatingAction({
                text: searchValue
            }),
            isDeferred = item && item.promise && item.done && item.fail;
        if (void 0 === item) {
            this._renderValue();
            throw errors.Error("E0121")
        }
        if (isDeferred) {
            item.done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null))
        } else {
            this._setCustomItem(item)
        }
    },
    _setCustomItem: function(item) {
        if (this._disposed) {
            return
        }
        item = item || null;
        this.option("selectedItem", item);
        this._setValue(this._valueGetter(item));
        this._renderDisplayText(this._displayGetter(item));
        if (null === item && this._wasSearch()) {
            this._filterDataSource(null)
        }
    },
    _createClearButton: function() {
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        return this.callBase().on(eventName, function() {
            return false
        })
    },
    _wasSearch: function(value) {
        if (!arguments.length) {
            return this._wasSearchValue
        }
        this._wasSearchValue = value
    },
    _searchHandler: function(e) {
        if (e && this._isControlKey(e.key) || this._preventFiltering) {
            delete this._preventFiltering;
            return
        }
        if (this._needPassDataSourceToList()) {
            this._wasSearch(true)
        }
        this.callBase(e)
    },
    _dataSourceFiltered: function(searchValue) {
        this.callBase();
        if (null !== searchValue) {
            this._renderInputSubstitution();
            this._renderFocusedElement()
        }
    },
    _valueSubstituted: function() {
        var input = this._input().get(0),
            isAllSelected = 0 === input.selectionStart && input.selectionEnd === this._searchValue().length,
            inputHasSelection = input.selectionStart !== input.selectionEnd;
        return this._wasSearch() && inputHasSelection && !isAllSelected
    },
    _shouldSubstitutionBeRendered: function() {
        return this.option("autocompletionEnabled") && !this._preventSubstitution && this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode")
    },
    _renderInputSubstitution: function() {
        if (!this._shouldSubstitutionBeRendered()) {
            delete this._preventSubstitution;
            return
        }
        var item = this._list && this._getPlainItems(this._list.option("items"))[0];
        if (!item) {
            return
        }
        var $input = this._input(),
            valueLength = $input.val().length;
        if (0 === valueLength) {
            return
        }
        var inputElement = $input.get(0),
            displayValue = this._displayGetter(item);
        inputElement.value = displayValue;
        inputElement.selectionStart = valueLength;
        inputElement.selectionEnd = displayValue.length
    },
    _cleanInputSelection: function() {
        var inputElement = this._input().get(0),
            endPosition = inputElement.value.length;
        inputElement.selectionStart = endPosition;
        inputElement.selectionEnd = endPosition
    },
    _dispose: function() {
        this._renderInputValueAsync = commonUtils.noop;
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "_isAdaptablePopupPosition":
            case "autocompletionEnabled":
                break;
            case "onCustomItemCreating":
                this._initCustomItemCreatingAction();
                break;
            case "tooltipEnabled":
                this._renderTooltip();
                break;
            case "displayCustomValue":
            case "acceptCustomValue":
            case "showSelectionControls":
            case "useInkRipple":
                this._invalidate();
                break;
            case "selectedItem":
                if (args.previousValue !== args.value) {
                    this.callBase(args)
                }
                break;
            case "allowClearing":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxSelectBox", SelectBox);
module.exports = SelectBox;
module.exports.default = module.exports;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    DOMComponent = __webpack_require__(45),
    extend = __webpack_require__(1).extend,
    ValidationMixin = __webpack_require__(114),
    ValidationEngine = __webpack_require__(58),
    DefaultAdapter = __webpack_require__(340),
    registerComponent = __webpack_require__(4);
var VALIDATOR_CLASS = "dx-validator";
var Validator = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            validationRules: []
        })
    },
    _init: function() {
        this.callBase();
        this._initGroupRegistration();
        this.focused = $.Callbacks();
        this._initAdapter()
    },
    _initGroupRegistration: function() {
        var group = this._findGroup();
        if (!this._groupWasInit) {
            this.on("disposing", function(args) {
                ValidationEngine.removeRegisteredValidator(args.component._validationGroup, args.component)
            })
        }
        if (!this._groupWasInit || this._validationGroup !== group) {
            ValidationEngine.removeRegisteredValidator(this._validationGroup, this);
            this._groupWasInit = true;
            this._validationGroup = group;
            ValidationEngine.registerValidatorInGroup(group, this)
        }
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            validationGroup: true
        })
    },
    _initAdapter: function() {
        var that = this,
            element = that.element()[0],
            dxStandardEditor = $.data(element, "dx-validation-target"),
            adapter = that.option("adapter");
        if (!adapter) {
            if (dxStandardEditor) {
                adapter = new DefaultAdapter(dxStandardEditor, this);
                adapter.validationRequestsCallbacks.add(function() {
                    that.validate()
                });
                this.option("adapter", adapter);
                return
            }
            throw errors.Error("E0120")
        }
        if (adapter.validationRequestsCallbacks) {
            adapter.validationRequestsCallbacks.add(function() {
                that.validate()
            })
        }
    },
    _render: function() {
        this.element().addClass(VALIDATOR_CLASS);
        this.callBase()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._initGroupRegistration()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "validationGroup":
                this._initGroupRegistration();
                return;
            case "validationRules":
                void 0 !== this.option("isValid") && this.validate();
                return;
            case "adapter":
                this._initAdapter();
                break;
            default:
                this.callBase(args)
        }
    },
    validate: function() {
        var result, that = this,
            adapter = that.option("adapter"),
            name = that.option("name"),
            bypass = adapter.bypass && adapter.bypass(),
            value = adapter.getValue(),
            currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError(),
            rules = $.map(that.option("validationRules"), function(rule) {
                rule.validator = that;
                return rule
            });
        if (bypass) {
            result = {
                isValid: true
            }
        } else {
            if (currentError && currentError.editorSpecific) {
                currentError.validator = this;
                result = {
                    isValid: false,
                    brokenRule: currentError
                }
            } else {
                result = ValidationEngine.validate(value, rules, name)
            }
        }
        this._applyValidationResult(result, adapter);
        return result
    },
    reset: function() {
        var that = this,
            adapter = that.option("adapter"),
            result = {
                isValid: true,
                brokenRule: null
            };
        adapter.reset();
        this._applyValidationResult(result, adapter)
    },
    _applyValidationResult: function(result, adapter) {
        var validatedAction = this._createActionByOption("onValidated");
        result.validator = this;
        adapter.applyValidationResults && adapter.applyValidationResults(result);
        this.option({
            isValid: result.isValid
        });
        validatedAction(result)
    },
    focus: function() {
        var adapter = this.option("adapter");
        adapter && adapter.focus && adapter.focus()
    }
}).include(ValidationMixin);
registerComponent("dxValidator", Validator);
module.exports = Validator;
module.exports.default = module.exports;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/context_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(342);
module.exports.default = module.exports;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.data_source_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DataSourceAdapter = __webpack_require__(216);
module.exports = {
    extend: function(extender) {
        DataSourceAdapter = DataSourceAdapter.inherit(extender)
    },
    create: function(component) {
        return new DataSourceAdapter(component)
    }
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    messageLocalization = __webpack_require__(8),
    clickEvent = __webpack_require__(11),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    registerComponent = __webpack_require__(4),
    CheckBox = __webpack_require__(99),
    HierarchicalCollectionWidget = __webpack_require__(213),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    dblclickEvent = __webpack_require__(182),
    fx = __webpack_require__(22),
    Scrollable = __webpack_require__(70),
    LoadIndicator = __webpack_require__(53),
    deferredUtils = __webpack_require__(10);
var WIDGET_CLASS = "dx-treeview",
    NODE_CONTAINER_CLASS = "dx-treeview-node-container",
    OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
    NODE_CLASS = "dx-treeview-node",
    ITEM_CLASS = "dx-treeview-item",
    ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
    ITEM_DATA_KEY = "dx-treeview-item-data",
    IS_LEAF = "dx-treeview-node-is-leaf",
    EXPAND_EVENT_NAMESPACE = "dxTreeView_expand",
    TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
    LOAD_INDICATOR_CLASS = "dx-treeview-loadindicator",
    LOAD_INDICATOR_WRAPPER_CLASS = "dx-treeview-loadindicator-wrapper",
    NODE_LOAD_INDICATOR_CLASS = "dx-treeview-node-loadindicator",
    TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
    SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
    DISABLED_STATE_CLASS = "dx-state-disabled",
    SELECTED_ITEM_CLASS = "dx-state-selected",
    DATA_ITEM_ID = "data-item-id";
var TreeView = HierarchicalCollectionWidget.inherit({
    _supportedKeys: function(e) {
        var click = function(e) {
            var $itemElement = this.option("focusedElement");
            if (!$itemElement) {
                return
            }
            e.target = $itemElement;
            e.currentTarget = $itemElement;
            this._itemClickHandler(e, $itemElement.children("." + ITEM_CLASS))
        };
        var select = function(e) {
            e.preventDefault();
            this._changeCheckBoxState(this.option("focusedElement"))
        };
        var toggleExpandedNestedItems = function(state, e) {
            if (!this.option("expandAllEnabled")) {
                return
            }
            e.preventDefault();
            var $rootElement = this.option("focusedElement");
            if (!$rootElement) {
                return
            }
            var rootItem = this._getItemData($rootElement.find("." + ITEM_CLASS));
            this._toggleExpandedNestedItems([rootItem], state)
        };
        return extend(this.callBase(), {
            enter: this._showCheckboxes() ? select : click,
            space: this._showCheckboxes() ? select : click,
            asterisk: toggleExpandedNestedItems.bind(this, true),
            minus: toggleExpandedNestedItems.bind(this, false)
        })
    },
    _changeCheckBoxState: function($element) {
        var checkboxInstance = this._getCheckBoxInstance($element),
            currentState = checkboxInstance.option("value");
        if (!checkboxInstance.option("disabled")) {
            this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
        }
    },
    _toggleExpandedNestedItems: function(items, state) {
        if (!items) {
            return
        }
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i],
                node = this._dataAdapter.getNodeByItem(item);
            this._toggleExpandedState(node, state);
            this._toggleExpandedNestedItems(item.items, state)
        }
    },
    _getNodeElement: function(node) {
        return this.element().find("[" + DATA_ITEM_ID + "='" + commonUtils.normalizeKey(node.internalFields.key) + "']")
    },
    _activeStateUnit: "." + ITEM_CLASS,
    _widgetClass: function() {
        return WIDGET_CLASS
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            animationEnabled: true,
            dataStructure: "tree",
            expandAllEnabled: false,
            hasItemsExpr: "hasItems",
            selectNodesRecursive: true,
            expandNodesRecursive: true,
            showCheckBoxesMode: "none",
            selectAllText: messageLocalization.format("dxList-selectAll"),
            onItemSelectionChanged: null,
            onItemExpanded: null,
            onItemCollapsed: null,
            scrollDirection: "vertical",
            virtualModeEnabled: false,
            rootValue: 0,
            searchValue: "",
            focusStateEnabled: false,
            selectionMode: "multiple",
            expandEvent: "dblclick",
            selectByClick: false,
            createChildren: null
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            showCheckBoxes: {
                since: "15.2",
                message: "use 'showCheckBoxesMode' option instead"
            },
            selectAllEnabled: {
                since: "15.2",
                message: "use 'showCheckBoxesMode' option instead"
            },
            onItemSelected: {
                since: "16.1",
                alias: "onItemSelectionChanged"
            }
        })
    },
    _initSelectedItems: commonUtils.noop,
    _syncSelectionOptions: commonUtils.noop,
    _fireSelectionChanged: function() {
        var selectionChangePromise = this._selectionChangePromise;
        deferredUtils.when(selectionChangePromise).done(function() {
            this._createActionByOption("onSelectionChanged", {
                excludeValidators: ["disabled", "readOnly"]
            })()
        }.bind(this))
    },
    _checkBoxModeChange: function(value, previousValue) {
        if ("none" === previousValue || "none" === value) {
            this.repaint();
            return
        }
        var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
        switch (value) {
            case "selectAll":
                !selectAllExists && this._renderSelectAllItem();
                break;
            case "normal":
                if (selectAllExists) {
                    this._$selectAllItem.remove();
                    delete this._$selectAllItem
                }
        }
    },
    _removeSelection: function() {
        var that = this;
        $.each(this._dataAdapter.getFullData(), function(_, node) {
            if (!that._hasChildren(node)) {
                return
            }
            that._dataAdapter.toggleSelection(node.internalFields.key, false, true)
        })
    },
    _optionChanged: function(args) {
        var name = args.name,
            value = args.value,
            previousValue = args.previousValue;
        switch (name) {
            case "showCheckBoxes":
                this.option("showCheckBoxesMode", value ? "normal" : "none");
                break;
            case "selectAllEnabled":
                this.option("showCheckBoxesMode", value ? "selectAll" : "normal");
                break;
            case "selectAllText":
                if (this._$selectAllItem) {
                    this._$selectAllItem.dxCheckBox("instance").option("text", value)
                }
                break;
            case "showCheckBoxesMode":
                this._checkBoxModeChange(value, previousValue);
                break;
            case "scrollDirection":
                this._scrollableContainer.option("direction", value);
                break;
            case "items":
                delete this._$selectAllItem;
                this.callBase(args);
                break;
            case "dataSource":
                this.callBase(args);
                this._initDataAdapter();
                this._filter = {};
                break;
            case "hasItemsExpr":
                this._initAccessors();
                this.repaint();
                break;
            case "expandEvent":
                this._initExpandEvent();
                break;
            case "dataStructure":
            case "rootValue":
            case "searchValue":
                if ((!value.length || value < previousValue) && "none" !== this.option("showCheckBoxesMode")) {
                    this._removeSelection()
                }
                this._initDataAdapter();
                this.repaint();
                break;
            case "createChildren":
            case "expandNodesRecursive":
            case "onItemSelectionChanged":
            case "onItemExpanded":
            case "onItemCollapsed":
            case "expandAllEnabled":
            case "animationEnabled":
            case "virtualModeEnabled":
            case "selectByClick":
                break;
            case "selectNodesRecursive":
                this._dataAdapter.setOption("recursiveSelection", args.value);
                this.repaint();
                break;
            default:
                this.callBase(args)
        }
    },
    _initDataSource: function() {
        if (this._useCustomChildrenLoader()) {
            this._loadChildrenByCustomLoader(null).done(function(newItems) {
                if (newItems && newItems.length) {
                    this.option("items", newItems)
                }
            }.bind(this))
        } else {
            this.callBase();
            this._isVirtualMode() && this._initVirtualMode()
        }
    },
    _initVirtualMode: function() {
        var that = this,
            filter = that._filter;
        if (!filter.custom) {
            filter.custom = that._dataSource.filter()
        }
        if (!filter.internal) {
            filter.internal = [that.option("parentIdExpr"), that.option("rootValue")]
        }
    },
    _useCustomChildrenLoader: function() {
        return commonUtils.isFunction(this.option("createChildren")) && this._isDataStructurePlain()
    },
    _loadChildrenByCustomLoader: function(parentNode) {
        var invocationResult = this.option("createChildren").call(this, parentNode);
        if (Array.isArray(invocationResult)) {
            return $.Deferred().resolve(invocationResult).promise()
        }
        if (invocationResult && commonUtils.isFunction(invocationResult.then)) {
            return deferredUtils.fromPromise(invocationResult)
        }
        return $.Deferred().resolve([]).promise()
    },
    _combineFilter: function() {
        if (!this._filter.custom || !this._filter.custom.length) {
            return this._filter.internal
        }
        return [this._filter.custom, this._filter.internal]
    },
    _dataSourceLoadErrorHandler: function() {
        this._renderEmptyMessage()
    },
    _init: function() {
        this._filter = {};
        this.callBase();
        this._initStoreChangeHandlers();
        this._initCheckBoxesMode()
    },
    _dataSourceChangedHandler: function(newItems) {
        if (this._initialized && this._isVirtualMode() && this.option("items").length) {
            return
        }
        this.option("items", newItems)
    },
    _removeTreeViewLoadIndicator: function() {
        if (!this._treeViewLoadIndicator) {
            return
        }
        this._treeViewLoadIndicator.remove();
        this._treeViewLoadIndicator = null
    },
    _createTreeViewLoadIndicator: function() {
        this._treeViewLoadIndicator = $("<div>", {
            "class": LOAD_INDICATOR_CLASS
        });
        this._createComponent(this._treeViewLoadIndicator, LoadIndicator, {});
        return this._treeViewLoadIndicator
    },
    _dataSourceLoadingChangedHandler: function(isLoading) {
        var resultFilter;
        if (this._isVirtualMode()) {
            resultFilter = this._combineFilter();
            this._dataSource.filter(resultFilter)
        }
        if (isLoading && !this._dataSource.isLoaded()) {
            this.option("items", []);
            var $wrapper = $("<div>", {
                "class": LOAD_INDICATOR_WRAPPER_CLASS
            });
            this._createTreeViewLoadIndicator().appendTo($wrapper);
            this.itemsContainer().append($wrapper);
            if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
                this._dataSource.filter([])
            }
        } else {
            this._removeTreeViewLoadIndicator()
        }
    },
    _initStoreChangeHandlers: function() {
        if ("plain" !== this.option("dataStructure")) {
            return
        }
        var that = this;
        this._dataSource && this._dataSource.store().on("inserted", function(newItem) {
            that.option().items = that.option("items").concat(newItem);
            that._dataAdapter.addItem(newItem);
            if (!that._isFiltered(newItem)) {
                return
            }
            that._updateLevel(that._parentIdGetter(newItem))
        }).on("removed", function(removedKey) {
            var node = that._dataAdapter.getNodeByKey(removedKey);
            that.option("items")[that._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
            that._markChildrenItemsToRemove(node);
            that._removeItems();
            that._dataAdapter.removeItem(removedKey);
            that._updateLevel(that._parentIdGetter(node))
        })
    },
    _markChildrenItemsToRemove: function(node) {
        var that = this,
            keys = node.internalFields.childrenKeys;
        $.each(keys, function(_, key) {
            that.option("items")[that._dataAdapter.getIndexByKey(key)] = 0;
            that._markChildrenItemsToRemove(that._dataAdapter.getNodeByKey(key))
        })
    },
    _removeItems: function() {
        var that = this,
            counter = 0,
            items = extend(true, [], this.option("items"));
        $.each(items, function(index, item) {
            if (!item) {
                that.option("items").splice(index - counter, 1);
                counter++
            }
        })
    },
    _isFiltered: function(item) {
        var value = this.option("searchValue"),
            reg = new RegExp(value, "i");
        return reg.test(this._displayGetter(item))
    },
    _updateLevel: function(parentId) {
        var $container = this._getContainerByParentKey(parentId);
        this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId))
    },
    _getOldContainer: function($itemElement) {
        if ($itemElement.length) {
            return $itemElement.children("." + NODE_CONTAINER_CLASS)
        }
        if (this._scrollableContainer) {
            return this._scrollableContainer.content().children()
        }
        return $()
    },
    _getContainerByParentKey: function(parentId) {
        var $container, node = this._dataAdapter.getNodeByKey(parentId),
            $itemElement = node ? this._getNodeElement(node) : [];
        this._getOldContainer($itemElement).remove();
        $container = this._renderNodeContainer($itemElement);
        if (this._isRootLevel(parentId)) {
            if (!this._scrollableContainer) {
                this._renderScrollableContainer()
            }
            this._scrollableContainer.content().append($container)
        }
        return $container
    },
    _isRootLevel: function(parentId) {
        return parentId === this.option("rootValue")
    },
    _getAccessors: function() {
        return ["key", "display", "selected", "expanded", "items", "parentId", "disabled", "hasItems"]
    },
    _getDataAdapterOptions: function() {
        return {
            rootValue: this.option("rootValue"),
            multipleSelection: !this._isSingleSelection(),
            recursiveSelection: this._isRecursiveSelection(),
            recursiveExpansion: this.option("expandNodesRecursive"),
            searchValue: this.option("searchValue"),
            dataType: this.option("dataStructure")
        }
    },
    _render: function() {
        this.callBase();
        this.setAria("role", "tree")
    },
    _renderContentImpl: function() {
        if (!this.option("items") || !this.option("items").length) {
            return
        }
        var $nodeContainer = this._renderNodeContainer();
        this._renderScrollableContainer();
        this._scrollableContainer.content().append($nodeContainer);
        this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
        this._initExpandEvent();
        if (this._selectAllEnabled()) {
            this._renderSelectAllItem($nodeContainer)
        }
    },
    _isVirtualMode: function() {
        return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource")
    },
    _isDataStructurePlain: function() {
        return "plain" === this.option("dataStructure")
    },
    _fireContentReadyAction: function() {
        this.callBase();
        if (this._scrollableContainer) {
            this._scrollableContainer.update()
        }
    },
    _renderScrollableContainer: function() {
        this._scrollableContainer = this._createComponent($("<div>").appendTo(this.element()), Scrollable, {
            direction: this.option("scrollDirection"),
            useKeyboard: false
        })
    },
    _renderNodeContainer: function($parent) {
        var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS);
        this.setAria("role", "group", $container);
        if ($parent && $parent.length) {
            var itemData = this._getItemData($parent.children("." + ITEM_CLASS));
            if (this._expandedGetter(itemData)) {
                $container.addClass(OPENED_NODE_CONTAINER_CLASS)
            }
            $container.appendTo($parent)
        }
        return $container
    },
    _createDOMElement: function($nodeContainer, node) {
        var $node = $("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, commonUtils.normalizeKey(node.internalFields.key)).prependTo($nodeContainer);
        this.setAria({
            role: "treeitem",
            label: this._displayGetter(node.internalFields.item) || "",
            expanded: node.internalFields.expanded || false,
            level: this._getLevel($nodeContainer)
        }, $node);
        return $node
    },
    _getLevel: function($nodeContainer) {
        var parent = $nodeContainer.parent();
        return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1
    },
    _showCheckboxes: function() {
        return "none" !== this.option("showCheckBoxesMode")
    },
    _selectAllEnabled: function() {
        return "selectAll" === this.option("showCheckBoxesMode")
    },
    _initCheckBoxesMode: function() {
        if (this._showCheckboxes()) {
            return
        }
        this._suppressDeprecatedWarnings();
        var showCheckboxes = this.option("showCheckBoxes"),
            selectAllEnabled = this.option("selectAllEnabled");
        this._resumeDeprecatedWarnings();
        this.option("showCheckBoxesMode", showCheckboxes ? selectAllEnabled ? "selectAll" : "normal" : "none")
    },
    _renderItems: function($nodeContainer, nodes) {
        var length = nodes.length - 1;
        for (var i = length; i >= 0; i--) {
            this._renderItem(nodes[i], $nodeContainer)
        }
        this._renderFocusTarget()
    },
    _renderItem: function(node, $nodeContainer) {
        var $node = this._createDOMElement($nodeContainer, node),
            nodeData = node.internalFields;
        this._showCheckboxes() && this._renderCheckBox($node, node);
        this.setAria("selected", nodeData.selected, $node);
        this._toggleSelectedClass($node, nodeData.selected);
        this.callBase(nodeData.key, nodeData.item, $node);
        if (false !== nodeData.item.visible) {
            this._renderChildren($node, node)
        }
    },
    _renderChildren: function($node, node) {
        if (!this._hasChildren(node)) {
            this._addLeafClass($node);
            return
        }
        this._renderToggleItemVisibilityIcon($node, node);
        if (!node.internalFields.expanded) {
            return
        }
        var that = this;
        that._loadSublevel(node).done(function(childNodes) {
            that._renderSublevel($node, that._getActualNode(node), childNodes)
        })
    },
    _getActualNode: function(cachedNode) {
        return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key)
    },
    _hasChildren: function(node) {
        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
            return false !== this._hasItemsGetter(node.internalFields.item)
        }
        return this.callBase(node)
    },
    _loadSublevel: function(node) {
        var deferred = $.Deferred(),
            that = this,
            childrenNodes = that._getChildNodes(node);
        if (childrenNodes.length) {
            deferred.resolve(childrenNodes)
        } else {
            that._loadNestedItems(node).done(function(items) {
                deferred.resolve(that._dataAdapter.getNodesByItems(items))
            })
        }
        return deferred.promise()
    },
    _renderSublevel: function($node, node, childNodes) {
        var $nestedNodeContainer = this._renderNodeContainer($node, node);
        this._renderItems($nestedNodeContainer, childNodes);
        if (childNodes.length && !node.internalFields.selected) {
            var firstChild = childNodes[0];
            this._updateParentsState(firstChild, this._getNodeElement(firstChild))
        }
        this._normalizeIconState($node, childNodes.length);
        $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
    },
    _executeItemRenderAction: function(key, itemData, itemElement) {
        var node = this._dataAdapter.getNodeByKey(key);
        this._getItemRenderAction()({
            itemElement: itemElement,
            itemIndex: key,
            itemData: itemData,
            node: node
        })
    },
    _addLeafClass: function($node) {
        $node.addClass(IS_LEAF)
    },
    _initExpandEvent: function() {
        var that = this,
            expandedEventName = this._getEventNameByOption(this.option("expandEvent")),
            $itemsContainer = this._itemContainer(),
            itemSelector = this._itemSelector();
        $itemsContainer.off("." + EXPAND_EVENT_NAMESPACE, itemSelector).on(expandedEventName, itemSelector, function(e) {
            var $nodeElement = $(e.currentTarget.parentNode);
            if (!$nodeElement.hasClass(IS_LEAF)) {
                that._toggleExpandedState(e.currentTarget, void 0, e)
            }
        })
    },
    _getEventNameByOption: function(name) {
        var event = "click" === name ? clickEvent : dblclickEvent;
        return eventUtils.addNamespace(event.name, EXPAND_EVENT_NAMESPACE)
    },
    _getNode: function(identifier) {
        if (!commonUtils.isDefined(identifier)) {
            return null
        }
        if (identifier.internalFields) {
            return identifier
        }
        if (commonUtils.isPrimitive(identifier)) {
            return this._dataAdapter.getNodeByKey(identifier)
        }
        var itemElement = $(identifier).get(0);
        if (!itemElement) {
            return null
        }
        if (commonUtils.isDomNode(itemElement)) {
            return this._getNodeByElement(itemElement)
        }
        return this._dataAdapter.getNodeByItem(itemElement)
    },
    _getNodeByElement: function(itemElement) {
        var $node = $(itemElement).closest("." + NODE_CLASS),
            key = commonUtils.denormalizeKey($node.attr(DATA_ITEM_ID));
        return this._dataAdapter.getNodeByKey(key)
    },
    _toggleExpandedState: function(itemElement, state, e) {
        var node = this._getNode(itemElement),
            currentState = node.internalFields.expanded;
        if (node.internalFields.disabled || currentState === state) {
            return
        }
        if (!commonUtils.isDefined(state)) {
            state = !currentState
        }
        this._dataAdapter.toggleExpansion(node.internalFields.key, state);
        node.internalFields.expanded = state;
        if (this._hasChildren(node)) {
            var $node = this._getNodeElement(node);
            this._createLoadIndicator($node)
        }
        this._updateExpandedItemsUI(node, state, e)
    },
    _createLoadIndicator: function($node) {
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS),
            $nodeContainer = $node.children("." + NODE_CONTAINER_CLASS);
        if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length) {
            return
        }
        this._createComponent($("<div>", {
            "class": NODE_LOAD_INDICATOR_CLASS
        }), LoadIndicator, {}).element().appendTo($node);
        $icon.hide()
    },
    _renderToggleItemVisibilityIcon: function($node, node) {
        var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
        if (node.internalFields.expanded) {
            $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
            $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
        }
        if (node.internalFields.disabled) {
            $icon.addClass(DISABLED_STATE_CLASS)
        }
        this._renderToggleItemVisibilityIconClick($icon, node)
    },
    _renderToggleItemVisibilityIconClick: function($icon, node) {
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME),
            that = this;
        $icon.off(eventName).on(eventName, function(e) {
            that._toggleExpandedState(node, void 0, e)
        })
    },
    _updateExpandedItemsUI: function(node, state, e) {
        var $node = this._getNodeElement(node);
        if (!$node.length && this.option("expandNodesRecursive")) {
            this._updateExpandedItemsUI(this._getNode(node.internalFields.parentKey), state, e)
        }
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
        var $nodeContainer = $node.children("." + NODE_CONTAINER_CLASS);
        $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
        var nodeContainerExists = $nodeContainer.length > 0;
        if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
            this._updateExpandedItem(node, state, e);
            return
        }
        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
            this._loadNestedItemsWithUpdate(node, state, e);
            return
        }
        this._renderSublevel($node, node, this._getChildNodes(node));
        this._fireContentReadyAction();
        this._updateExpandedItem(node, state, e)
    },
    _loadNestedItemsWithUpdate: function(node, state, e) {
        var that = this,
            $node = this._getNodeElement(node);
        that._loadNestedItems(node).done(function(items) {
            var actualNodeData = that._getActualNode(node);
            that._renderSublevel($node, actualNodeData, that._dataAdapter.getNodesByItems(items));
            if (!items || !items.length) {
                return
            }
            that._fireContentReadyAction();
            that._updateExpandedItem(actualNodeData, state, e)
        })
    },
    _loadNestedItems: function(node) {
        var that = this;
        if (that._useCustomChildrenLoader()) {
            var publicNode = this._dataAdapter.getPublicNode(node);
            return that._loadChildrenByCustomLoader(publicNode).done(function(newItems) {
                that._appendItems(newItems)
            })
        }
        if (!that._isVirtualMode()) {
            return $.Deferred().resolve([]).promise()
        }
        that._filter.internal = [that.option("parentIdExpr"), node.internalFields.key];
        that._dataSource.filter(that._combineFilter());
        return that._dataSource.load().done(function(newItems) {
            var areItemsAlreadyPresent = inArray(newItems[0], that.option("items")) + 1;
            !areItemsAlreadyPresent && that._appendItems(newItems)
        })
    },
    _appendItems: function(newItems) {
        this.option().items = this.option("items").concat(newItems);
        this._initDataAdapter()
    },
    _updateExpandedItem: function(node, state, e) {
        this._animateNodeContainer(node, state, e)
    },
    _animateNodeContainer: function(node, state, e) {
        var $node = this._getNodeElement(node),
            $nodeContainer = $node.children("." + NODE_CONTAINER_CLASS),
            nodeHeight = $nodeContainer.height();
        fx.stop($nodeContainer, true);
        fx.animate($nodeContainer, {
            type: "custom",
            duration: this.option("animationEnabled") ? 400 : 0,
            from: {
                "max-height": state ? 0 : nodeHeight
            },
            to: {
                "max-height": state ? nodeHeight : 0
            },
            start: function() {
                $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
            },
            complete: function() {
                $nodeContainer.css("max-height", "none");
                $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
                this.setAria("expanded", state, $node);
                this._scrollableContainer.update();
                this._fireExpandedStateUpdatedEvent(state, node, e)
            }.bind(this)
        })
    },
    _fireExpandedStateUpdatedEvent: function(isExpanded, node, e) {
        var target, optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
        if (!this._hasChildren(node)) {
            return
        }
        if (commonUtils.isDefined(e)) {
            this._itemJQueryEventHandler(e, optionName, {
                node: this._dataAdapter.getPublicNode(node)
            })
        } else {
            target = this._getNodeElement(node);
            this._itemEventHandler(target, optionName, {
                jQueryEvent: e,
                node: this._dataAdapter.getPublicNode(node)
            })
        }
    },
    _normalizeIconState: function($node, hasNewItems) {
        var $icon, $loadIndicator = $node.find(".dx-loadindicator");
        $loadIndicator.length && LoadIndicator.getInstance($loadIndicator).option("visible", false);
        if (hasNewItems) {
            $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
            $icon.show();
            return
        }
        $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
        $node.addClass(IS_LEAF)
    },
    _renderContent: function() {
        this._renderEmptyMessage();
        var items = this.option("items");
        if (items && items.length) {
            this._contentAlreadyRendered = true
        }
        this.callBase()
    },
    _renderSelectAllItem: function($container) {
        $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
        this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
        var value = this._dataAdapter.isAllSelected();
        this._createComponent(this._$selectAllItem, CheckBox, {
            value: value,
            text: this.option("selectAllText"),
            onValueChanged: this._toggleSelectAll.bind(this)
        });
        this._toggleSelectedClass(this._$selectAllItem, value);
        $container.before(this._$selectAllItem)
    },
    _toggleSelectAll: function(args) {
        this._dataAdapter.toggleSelectAll(args.value);
        this._updateItemsUI();
        this._fireSelectionChanged()
    },
    _renderCheckBox: function($node, node) {
        $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
        var $checkbox = $("<div>").appendTo($node);
        this._createComponent($checkbox, CheckBox, {
            value: node.internalFields.selected,
            onValueChanged: this._changeCheckboxValue.bind(this),
            focusStateEnabled: false,
            disabled: this._disabledGetter(node)
        })
    },
    _toggleSelectedClass: function($node, value) {
        $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
    },
    _toggleNodeDisabledState: function(node, state) {
        var $node = this._getNodeElement(node),
            $item = $node.find("." + ITEM_CLASS).eq(0);
        this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
        $item.toggleClass(DISABLED_STATE_CLASS, !!state);
        if (this._showCheckboxes()) {
            var checkbox = this._getCheckBoxInstance($node);
            checkbox.option("disabled", !!state)
        }
    },
    _itemOptionChanged: function(item, property, value) {
        var node = this._dataAdapter.getNodeByItem(item);
        switch (property) {
            case this.option("disabledExpr"):
                this._toggleNodeDisabledState(node, value)
        }
    },
    _changeCheckboxValue: function(e) {
        var $node = e.element.parent("." + NODE_CLASS),
            $item = $node.children("." + ITEM_CLASS),
            item = this._getItemData($item),
            node = this._getNodeByElement($item),
            value = e.value;
        if (node.internalFields.selected === value) {
            return
        }
        this._updateItemSelection(value, item, e.jQueryEvent)
    },
    _isSingleSelection: function() {
        return "single" === this.option("selectionMode")
    },
    _isRecursiveSelection: function() {
        return this.option("selectNodesRecursive") && "single" !== this.option("selectionMode")
    },
    _updateItemSelection: function(value, itemElement, jQueryEvent) {
        var node = this._getNode(itemElement);
        if (!node || node.internalFields.selected === value) {
            return
        }
        if (this._isSingleSelection()) {
            this._toggleSelectAll({
                value: false
            })
        }
        this._dataAdapter.toggleSelection(node.internalFields.key, value);
        this._updateItemsUI();
        var initiator = jQueryEvent || this._findItemElementByItem(node.internalFields.item),
            handler = jQueryEvent ? this._itemJQueryEventHandler : this._itemEventHandler;
        handler.call(this, initiator, "onItemSelectionChanged", {
            node: this._dataAdapter.getPublicNode(node),
            itemData: node.internalFields.item
        });
        this._fireSelectionChanged()
    },
    _getCheckBoxInstance: function($node) {
        return $node.children(".dx-checkbox").dxCheckBox("instance")
    },
    _updateItemsUI: function() {
        var that = this;
        $.each(this._dataAdapter.getData(), function(_, node) {
            var $node = that._getNodeElement(node),
                nodeSelection = node.internalFields.selected;
            if (!$node.length) {
                return
            }
            that._toggleSelectedClass($node, nodeSelection);
            that.setAria("selected", nodeSelection, $node);
            if (that._showCheckboxes()) {
                var checkbox = that._getCheckBoxInstance($node);
                checkbox.option("value", nodeSelection)
            }
        });
        if (this._selectAllEnabled()) {
            this._$selectAllItem.dxCheckBox("instance").option("value", this._dataAdapter.isAllSelected())
        }
    },
    _updateParentsState: function(node, $node) {
        var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
        if (!$node) {
            return
        }
        var $parentNode = $($node.parents("." + NODE_CLASS)[0]);
        if (this._showCheckboxes()) {
            var parentValue = parentNode.internalFields.selected;
            this._getCheckBoxInstance($parentNode).option("value", parentValue);
            this._toggleSelectedClass($parentNode, parentValue)
        }
        if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
            this._updateParentsState(parentNode, $parentNode)
        }
    },
    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = $(initiator).closest("." + NODE_CLASS).children("." + ITEM_CLASS);
        return action(extend(this._extendActionArgs($itemElement), actionArgs))
    },
    _itemContextMenuHandler: function(e) {
        this._createEventHandler("onItemContextMenu", e)
    },
    _itemHoldHandler: function(e) {
        this._createEventHandler("onItemHold", e)
    },
    _createEventHandler: function(eventName, e) {
        var node = this._getNodeByElement(e.currentTarget);
        this._itemJQueryEventHandler(e, eventName, {
            node: this._dataAdapter.getPublicNode(node)
        })
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _attachClickEvent: function() {
        var that = this,
            clickSelector = "." + this._itemClass(),
            pointerDownSelector = "." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS,
            eventName = eventUtils.addNamespace(clickEvent.name, that.NAME),
            pointerDownEvent = eventUtils.addNamespace(pointerEvents.down, this.NAME);
        that._itemContainer().off(eventName, clickSelector).off(pointerDownEvent, pointerDownSelector).on(eventName, clickSelector, function(e) {
            that._itemClickHandler(e, $(this))
        }).on(pointerDownEvent, pointerDownSelector, function(e) {
            that._itemPointerDownHandler(e)
        })
    },
    _itemClickHandler: function(e, $item) {
        var itemData = this._getItemData($item),
            node = this._getNodeByElement($item);
        this._itemJQueryEventHandler(e, "onItemClick", {
            node: this._dataAdapter.getPublicNode(node)
        });
        if (this.option("selectByClick")) {
            this._updateItemSelection(!node.internalFields.selected, itemData, e)
        }
    },
    _updateSelectionToFirstItem: function($items, startIndex) {
        var itemIndex = startIndex;
        while (itemIndex >= 0) {
            var $item = $($items[itemIndex]);
            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
            itemIndex--
        }
    },
    _updateSelectionToLastItem: function($items, startIndex) {
        var itemIndex = startIndex,
            length = $items.length;
        while (itemIndex < length) {
            var $item = $($items[itemIndex]);
            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
            itemIndex++
        }
    },
    _focusInHandler: function(e) {
        var that = this,
            currentTarget = e.currentTarget,
            focusTargets = that._focusTarget();
        if (inArray(currentTarget, focusTargets) !== -1) {
            that._toggleFocusClass(true, currentTarget)
        }
        if (that.option("focusedElement")) {
            clearTimeout(that._setFocusedItemTimeout);
            that._setFocusedItemTimeout = setTimeout(function() {
                that._setFocusedItem(that.option("focusedElement"))
            });
            return
        }
        var $activeItem = that._getActiveItem();
        that.option("focusedElement", $activeItem.closest("." + NODE_CLASS))
    },
    _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
            return
        }
        if (!$target.children().hasClass(DISABLED_STATE_CLASS)) {
            this.callBase($target)
        }
        this._scrollableContainer.scrollToElement($target.find("." + ITEM_CLASS).first())
    },
    _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        var $target = $(e.target).closest("." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS);
        if (!$target.length) {
            return
        }
        var itemElement = $target.hasClass(DISABLED_STATE_CLASS) ? null : $target;
        this.option("focusedElement", itemElement)
    },
    _findNonDisabledNodes: function($nodes) {
        return $nodes.not(function() {
            return $(this).children("." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
        })
    },
    _moveFocus: function(location, e) {
        var FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_FIRST = "first",
            FOCUS_LAST = "last",
            FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
            FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
        this.element().find("." + NODE_CONTAINER_CLASS).each(function() {
            fx.stop(this, true)
        });
        var $items = this._findNonDisabledNodes(this._nodeElements());
        if (!$items || !$items.length) {
            return
        }
        switch (location) {
            case FOCUS_UP:
                var $prevItem = this._prevItem($items);
                this.option("focusedElement", $prevItem);
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateItemSelection(true, $prevItem.find("." + ITEM_CLASS).get(0))
                }
                break;
            case FOCUS_DOWN:
                var $nextItem = this._nextItem($items);
                this.option("focusedElement", $nextItem);
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateItemSelection(true, $nextItem.find("." + ITEM_CLASS).get(0))
                }
                break;
            case FOCUS_FIRST:
                var $firstItem = $items.first();
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)))
                }
                this.option("focusedElement", $firstItem);
                break;
            case FOCUS_LAST:
                var $lastItem = $items.last();
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)))
                }
                this.option("focusedElement", $lastItem);
                break;
            case FOCUS_RIGHT:
                this._expandFocusedContainer();
                break;
            case FOCUS_LEFT:
                this._collapseFocusedContainer();
                break;
            default:
                this.callBase.apply(this, arguments);
                return
        }
    },
    _nodeElements: function() {
        return this.element().find("." + NODE_CLASS).not(":hidden")
    },
    _expandFocusedContainer: function() {
        var $focusedNode = this.option("focusedElement");
        if (!$focusedNode || $focusedNode.hasClass(IS_LEAF)) {
            return
        }
        var $node = $focusedNode.find("." + NODE_CONTAINER_CLASS).eq(0);
        if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
            this.option("focusedElement", this._nextItem(this._findNonDisabledNodes(this._nodeElements())));
            return
        }
        var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS));
        this._toggleExpandedState(node, true)
    },
    _getClosestNonDisabledNode: function($node) {
        do {
            $node = $node.parent().closest("." + NODE_CLASS)
        } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
        return $node
    },
    _collapseFocusedContainer: function() {
        var $focusedNode = this.option("focusedElement");
        if (!$focusedNode) {
            return
        }
        var nodeElement = $focusedNode.find("." + NODE_CONTAINER_CLASS).eq(0);
        if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
            var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS));
            this._toggleExpandedState(node, false)
        } else {
            var collapsedNode = this._getClosestNonDisabledNode($focusedNode);
            collapsedNode.length && this.option("focusedElement", collapsedNode)
        }
    },
    updateDimensions: function() {
        var that = this,
            deferred = $.Deferred();
        if (that._scrollableContainer) {
            that._scrollableContainer.update().done(function() {
                deferred.resolveWith(that)
            })
        } else {
            deferred.resolveWith(that)
        }
        return deferred.promise()
    },
    selectItem: function(itemElement) {
        this._updateItemSelection(true, itemElement);
    },
    unselectItem: function(itemElement) {
        this._updateItemSelection(false, itemElement)
    },
    expandItem: function(itemElement) {
        this._toggleExpandedState(itemElement, true)
    },
    collapseItem: function(itemElement) {
        this._toggleExpandedState(itemElement, false)
    },
    getNodes: function() {
        return this._dataAdapter.getTreeNodes()
    },
    getSelectedNodesKeys: function() {
        return this._dataAdapter.getSelectedNodesKeys()
    },
    selectAll: function() {
        if (this._selectAllEnabled()) {
            this._$selectAllItem.dxCheckBox("instance").option("value", true)
        } else {
            this._toggleSelectAll({
                value: true
            })
        }
    },
    unselectAll: function() {
        if (this._selectAllEnabled()) {
            this._$selectAllItem.dxCheckBox("instance").option("value", false)
        } else {
            this._toggleSelectAll({
                value: false
            })
        }
    },
    collapseAll: function() {
        var that = this;
        $.each(this._dataAdapter.getExpandedNodesKeys(), function(_, key) {
            that._toggleExpandedState(key, false)
        })
    }
});
registerComponent("dxTreeView", TreeView);
module.exports = TreeView;
module.exports.default = module.exports;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var fileSaver = __webpack_require__(161).fileSaver,
    _isFunction = __webpack_require__(2).isFunction;
exports.export = function(data, options, getData) {
    if (!data) {
        return
    }
    var exportingAction = options.exportingAction,
        exportedAction = options.exportedAction,
        fileSavingAction = options.fileSavingAction,
        eventArgs = {
            fileName: options.fileName,
            format: options.format,
            cancel: false
        };
    _isFunction(exportingAction) && exportingAction(eventArgs);
    if (!eventArgs.cancel) {
        getData(data, options, function(blob) {
            _isFunction(exportedAction) && exportedAction();
            if (_isFunction(fileSavingAction)) {
                eventArgs.data = blob;
                fileSavingAction(eventArgs)
            }
            if (!eventArgs.cancel) {
                fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl)
            }
        })
    }
};
exports.fileSaver = fileSaver;
exports.excel = {
    creator: __webpack_require__(162).ExcelCreator,
    getData: __webpack_require__(162).getData,
    formatConverter: __webpack_require__(163)
};
exports.image = {
    creator: __webpack_require__(134).imageCreator,
    getData: __webpack_require__(134).getData
};
exports.pdf = {
    getData: __webpack_require__(246).getData
};
exports.svg = {
    creator: __webpack_require__(164).svgCreator,
    getData: __webpack_require__(164).getData
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/image_creator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Color = __webpack_require__(85),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    camelize = __webpack_require__(36).camelize,
    when = __webpack_require__(10).when,
    _math = Math,
    PI = _math.PI,
    _min = _math.min,
    _abs = _math.abs,
    _sqrt = _math.sqrt,
    _pow = _math.pow,
    _atan2 = _math.atan2,
    _cos = _math.cos,
    _sin = _math.sin,
    _each = $.each,
    _extend = extend,
    _number = Number,
    IMAGE_QUALITY = 1,
    TEXT_DECORATION_LINE_WIDTH_COEFF = .05,
    DEFAULT_MARGIN_SIZE = {
        x: 30,
        y: 20
    },
    DEFAULT_FONT_SIZE = "10px",
    DEFAULT_FONT_FAMILY = "sans-serif",
    DEFAULT_TEXT_COLOR = "#000",
    clipPaths, imageDeferreds, patterns, filters;

function createCanvas(width, height, withoutMargins) {
    var canvas = $("<canvas>")[0];
    canvas.width = width + (withoutMargins ? 0 : 2 * DEFAULT_MARGIN_SIZE.x);
    canvas.height = height + (withoutMargins ? 0 : 2 * DEFAULT_MARGIN_SIZE.y);
    return canvas
}

function getStringFromCanvas(canvas, mimeType) {
    var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY),
        imageData = atob(dataURL.substring(("data:" + mimeType + ";base64,").length));
    return imageData
}

function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
    var opSide, adjSide, centerX, centerY, startAngle, endAngle, cBx = (x1 + x2) / 2,
        cBy = (y1 + y2) / 2,
        aB = _atan2(y1 - y2, x1 - x2),
        k = largeArcFlag ? 1 : -1;
    aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
    opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
    adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
    centerX = cBx + k * (adjSide * _cos(aB));
    centerY = cBy + k * (adjSide * _sin(aB));
    startAngle = _atan2(y1 - centerY, x1 - centerX);
    endAngle = _atan2(y2 - centerY, x2 - centerX);
    context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise)
}

function getElementOptions(element) {
    var coords, attr = parseAttributes(element.attributes || {}),
        style = element.style || {},
        options = _extend({}, attr, {
            text: element.textContent.replace(/\s+/g, " "),
            textAlign: "middle" === attr["text-anchor"] ? "center" : attr["text-anchor"]
        }),
        transform = attr.transform;
    if (transform) {
        coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
        if (coords) {
            coords = coords[0].match(/-*\d+([.]\d+)*/g);
            options.translateX = _number(coords[0]);
            options.translateY = coords[1] ? _number(coords[1]) : 0
        }
        coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
        if (coords) {
            coords = coords[0].match(/-*\d+([.]\d+)*/g);
            options.rotationAngle = _number(coords[0]);
            options.rotationX = coords[1] && _number(coords[1]);
            options.rotationY = coords[2] && _number(coords[2])
        }
    }
    parseStyles(style, options);
    return options
}

function drawRect(context, options) {
    var x = options.x,
        y = options.y,
        width = options.width,
        height = options.height,
        cornerRadius = options.rx;
    if (!cornerRadius) {
        context.rect(options.x, options.y, options.width, options.height)
    } else {
        cornerRadius = _min(cornerRadius, width / 2, height / 2);
        context.save();
        context.translate(x, y);
        context.moveTo(width / 2, 0);
        context.arcTo(width, 0, width, height, cornerRadius);
        context.arcTo(width, height, 0, height, cornerRadius);
        context.arcTo(0, height, 0, 0, cornerRadius);
        context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
        context.lineTo(width / 2, 0);
        context.restore()
    }
}

function drawImage(context, options) {
    var d = $.Deferred(),
        image = new Image;
    image.onload = function() {
        context.save();
        context.globalAlpha = options.globalAlpha;
        transformElement(context, options);
        clipElement(context, options);
        context.drawImage(image, options.x, options.y, options.width, options.height);
        context.restore();
        d.resolve()
    };
    image.onerror = function() {
        d.resolve()
    };
    imageDeferreds.push(d);
    image.setAttribute("crossOrigin", "anonymous");
    image.src = options["xlink:href"]
}

function drawPath(context, dAttr) {
    var param1, param2, dArray = dAttr.split(" "),
        i = 0;
    do {
        param1 = _number(dArray[i + 1]);
        param2 = _number(dArray[i + 2]);
        switch (dArray[i]) {
            case "M":
                context.moveTo(param1, param2);
                i += 3;
                break;
            case "L":
                context.lineTo(param1, param2);
                i += 3;
                break;
            case "C":
                context.bezierCurveTo(param1, param2, _number(dArray[i + 3]), _number(dArray[i + 4]), _number(dArray[i + 5]), _number(dArray[i + 6]));
                i += 7;
                break;
            case "A":
                arcTo(_number(dArray[i - 2]), _number(dArray[i - 1]), _number(dArray[i + 6]), _number(dArray[i + 7]), param1, _number(dArray[i + 4]), _number(dArray[i + 5]), context);
                i += 8;
                break;
            case "Z":
                context.closePath();
                i += 1
        }
    } while (i < dArray.length)
}

function parseStyles(style, options) {
    _each(style, function(_, field) {
        if ("" !== style[field]) {
            options[camelize(field)] = style[field]
        }
    });
    options.textDecoration = options.textDecoration || options.textDecorationLine;
    options.globalAlpha = options.opacity || options.globalAlpha
}

function parseUrl(urlString) {
    var matches = urlString && urlString.match(/url\(.*\#(.*?)["']?\)/i);
    return matches && matches[1]
}

function setFontStyle(context, options) {
    var fontParams = [];
    options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
    options.fontFamily || DEFAULT_FONT_FAMILY;
    options.fill = options.fill || DEFAULT_TEXT_COLOR;
    options.fontStyle && fontParams.push(options.fontStyle);
    options.fontWeight && fontParams.push(options.fontWeight);
    fontParams.push(options.fontSize);
    fontParams.push(options.fontFamily);
    context.font = fontParams.join(" ");
    context.textAlign = options.textAlign;
    context.fillStyle = options.fill;
    context.globalAlpha = options.globalAlpha
}

function drawText(context, options) {
    setFontStyle(context, options);
    options.text && context.fillText(options.text, options.x || 0, options.y || 0);
    strokeElement(context, options, true);
    drawTextDecoration(context, options)
}

function drawTextDecoration(context, options) {
    if (!options.textDecoration || "none" === options.textDecoration) {
        return
    }
    var x = options.x,
        textWidth = context.measureText(options.text).width,
        textHeight = parseInt(options.fontSize, 10),
        lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF,
        y = options.y;
    switch (options.textDecoration) {
        case "line-through":
            y -= textHeight / 3 + lineHeight / 2;
            break;
        case "overline":
            y -= textHeight - lineHeight;
            break;
        case "underline":
            y += lineHeight
    }
    context.rect(x, y, textWidth, lineHeight);
    fillElement(context, options);
    strokeElement(context, options)
}

function createClipPath(element) {
    clipPaths[element.attributes.id.textContent] = element.childNodes[0]
}

function createPattern(element) {
    patterns[element.attributes.id.textContent] = element
}

function aggregateOpacity(options) {
    options.strokeOpacity = void 0 !== options["stroke-opacity"] ? options["stroke-opacity"] : 1;
    options.fillOpacity = void 0 !== options["fill-opacity"] ? options["fill-opacity"] : 1;
    if (void 0 !== options.opacity) {
        options.strokeOpacity *= options.opacity;
        options.fillOpacity *= options.opacity
    }
}

function hasTspan(element) {
    var nodes = element.childNodes;
    for (var i = 0; i < nodes.length; i++) {
        if ("tspan" === nodes[i].tagName) {
            return true
        }
    }
    return false
}

function drawTextElement(childNodes, context, options) {
    var line, lines = [],
        offset = 0;
    for (var i = 0; i < childNodes.length; i++) {
        var element = childNodes[i];
        if (void 0 === element.tagName) {
            drawElement(element, context, options)
        } else {
            if ("tspan" === element.tagName || "text" === element.tagName) {
                var elementOptions = getElementOptions(element),
                    mergedOptions = _extend({}, options, elementOptions);
                if ("tspan" === element.tagName && hasTspan(element)) {
                    drawTextElement(element.childNodes, context, mergedOptions);
                    continue
                }
                mergedOptions.textAlign = "start";
                if (!line || void 0 !== elementOptions.x) {
                    line = {
                        elements: [],
                        options: [],
                        widths: [],
                        offsets: []
                    };
                    lines.push(line)
                }
                if (void 0 !== elementOptions.dy) {
                    offset += Number(elementOptions.dy)
                }
                line.elements.push(element);
                line.options.push(mergedOptions);
                line.offsets.push(offset);
                setFontStyle(context, mergedOptions);
                line.widths.push(context.measureText(mergedOptions.text).width)
            }
        }
    }
    lines.forEach(function(line) {
        var commonWidth = line.widths.reduce(function(commonWidth, width) {
                return commonWidth + width
            }, 0),
            xDiff = 0,
            currentOffset = 0;
        if ("center" === options.textAlign) {
            xDiff = commonWidth / 2
        }
        if ("end" === options.textAlign) {
            xDiff = commonWidth
        }
        line.options.forEach(function(o, index) {
            var width = line.widths[index];
            o.x = o.x - xDiff + currentOffset;
            o.y += line.offsets[index];
            currentOffset += width
        });
        line.elements.forEach(function(element, index) {
            drawTextElement(element.childNodes, context, line.options[index])
        })
    })
}

function drawElement(element, context, parentOptions) {
    var tagName = element.tagName,
        isText = "text" === tagName || "tspan" === tagName || void 0 === tagName,
        isImage = "image" === tagName,
        options = _extend({}, parentOptions, getElementOptions(element));
    if ("hidden" === options.visibility) {
        return
    }
    context.save();
    !isImage && transformElement(context, options);
    clipElement(context, options);
    aggregateOpacity(options);
    context.beginPath();
    switch (element.tagName) {
        case void 0:
            drawText(context, options);
            break;
        case "text":
        case "tspan":
            drawTextElement(element.childNodes, context, options);
            break;
        case "image":
            drawImage(context, options);
            break;
        case "path":
            drawPath(context, options.d);
            break;
        case "rect":
            drawRect(context, options);
            context.closePath();
            break;
        case "circle":
            context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1)
    }
    applyFilter(context, options);
    if (!isText) {
        fillElement(context, options);
        strokeElement(context, options)
    }
    context.restore()
}

function applyFilter(context, options) {
    var filterOptions, id = parseUrl(options.filter);
    if (id) {
        filterOptions = filters && filters[id];
        if (!filterOptions) {
            filterOptions = {
                offsetX: 0,
                offsetY: 0,
                blur: 0,
                color: "#000"
            }
        }
        context.shadowOffsetX = filterOptions.offsetX;
        context.shadowOffsetY = filterOptions.offsetY;
        context.shadowColor = filterOptions.color;
        context.shadowBlur = filterOptions.blur
    }
}

function transformElement(context, options) {
    context.translate(options.translateX || 0, options.translateY || 0);
    delete options.translateX;
    delete options.translateY;
    if (options.rotationAngle) {
        context.translate(options.rotationX || 0, options.rotationY || 0);
        context.rotate(options.rotationAngle * PI / 180);
        context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
        delete options.rotationAngle;
        delete options.rotationX;
        delete options.rotationY
    }
}

function clipElement(context, options) {
    if (options["clip-path"]) {
        drawElement(clipPaths[parseUrl(options["clip-path"])], context, {});
        context.clip();
        delete options["clip-path"]
    }
}

function hex2rgba(hexColor, alpha) {
    var color = new Color(hexColor);
    return "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")"
}

function createFilter(element) {
    var color, opacity, filterOptions = {};
    _each(element.childNodes, function(_, node) {
        var attr = node.attributes;
        if (!attr.result) {
            return
        }
        switch (attr.result.value) {
            case "gaussianBlurResult":
                if (attr.stdDeviation) {
                    filterOptions.blur = _number(attr.stdDeviation.value)
                }
                break;
            case "offsetResult":
                filterOptions.offsetX = _number(attr.dx.value);
                filterOptions.offsetY = _number(attr.dy.value);
                break;
            case "floodResult":
                color = attr["flood-color"] ? attr["flood-color"].value : "#000";
                opacity = attr["flood-opacity"] ? attr["flood-opacity"].value : 1;
                filterOptions.color = hex2rgba(color, opacity)
        }
    });
    filters[element.id] = filterOptions
}

function drawCanvasElements(elements, context, parentOptions) {
    var options;
    _each(elements, function(_, element) {
        switch (element.tagName && element.tagName.toLowerCase()) {
            case "g":
                options = _extend({}, parentOptions, getElementOptions(element));
                context.save();
                transformElement(context, options);
                clipElement(context, options);
                drawCanvasElements(element.childNodes, context, options);
                context.restore();
                break;
            case "defs":
                clipPaths = {};
                patterns = {};
                filters = {};
                drawCanvasElements(element.childNodes, context);
                break;
            case "clippath":
                createClipPath(element);
                break;
            case "pattern":
                createPattern(element);
                break;
            case "filter":
                createFilter(element);
                break;
            default:
                drawElement(element, context, parentOptions)
        }
    })
}

function setLineDash(context, options) {
    var matches = options["stroke-dasharray"] && options["stroke-dasharray"].match(/(\d+)/g);
    if (matches && matches.length && context.setLineDash) {
        matches = $.map(matches, function(item) {
            return _number(item)
        });
        context.setLineDash(matches)
    }
}

function strokeElement(context, options, isText) {
    var stroke = options.stroke;
    if (stroke && "none" !== stroke && 0 !== options["stroke-width"]) {
        setLineDash(context, options);
        context.lineJoin = options["stroke-linejoin"];
        context.lineWidth = options["stroke-width"];
        context.globalAlpha = options.strokeOpacity;
        context.strokeStyle = stroke;
        isText ? context.strokeText(options.text, options.x, options.y) : context.stroke()
    }
}

function getPattern(context, fill) {
    var pattern = patterns[parseUrl(fill)],
        options = getElementOptions(pattern),
        patternCanvas = createCanvas(options.width, options.height, true),
        patternContext = patternCanvas.getContext("2d");
    drawCanvasElements(pattern.childNodes, patternContext, options);
    return context.createPattern(patternCanvas, "repeat")
}

function fillElement(context, options) {
    var fill = options.fill;
    if (fill && "none" !== fill) {
        context.fillStyle = fill.search(/url/) === -1 ? fill : getPattern(context, fill);
        context.globalAlpha = options.fillOpacity;
        context.fill()
    }
}
var parseAttributes = function(attributes) {
    var attr, newAttributes = {};
    $.each(attributes, function(index, item) {
        attr = item.textContent;
        if (isFinite(attr)) {
            attr = _number(attr)
        }
        newAttributes[item.name.toLowerCase()] = attr
    });
    return newAttributes
};

function drawBackground(context, width, height, backgroundColor) {
    context.fillStyle = backgroundColor || "#ffffff";
    context.fillRect(-DEFAULT_MARGIN_SIZE.x, -DEFAULT_MARGIN_SIZE.y, width + 2 * DEFAULT_MARGIN_SIZE.x, height + 2 * DEFAULT_MARGIN_SIZE.y)
}

function getCanvasFromSvg(markup, width, height, backgroundColor) {
    var canvas = createCanvas(width, height),
        context = canvas.getContext("2d"),
        parser = new DOMParser,
        elem = parser.parseFromString(markup, "image/svg+xml"),
        svgElem = elem.childNodes[0];
    context.translate(DEFAULT_MARGIN_SIZE.x, DEFAULT_MARGIN_SIZE.y);
    imageDeferreds = [];
    document.body.appendChild(canvas);
    if (svgElem.attributes.direction) {
        canvas.dir = svgElem.attributes.direction.textContent
    }
    drawBackground(context, width, height, backgroundColor);
    drawCanvasElements(svgElem.childNodes, context, {});
    document.body.removeChild(canvas);
    return canvas
}

function resolveString(string, canvas, mimeType) {
    when.apply($, imageDeferreds).done(function() {
        var resultString = getStringFromCanvas(canvas, mimeType);
        string.resolve(resultString)
    })
}
exports.imageCreator = {
    getImageData: function(markup, options) {
        var mimeType = "image/" + options.format,
            string = $.Deferred(),
            width = options.width,
            height = options.height,
            backgroundColor = options.backgroundColor;
        if (commonUtils.isFunction(options.__parseAttributesFn)) {
            parseAttributes = options.__parseAttributesFn
        }
        resolveString(string, getCanvasFromSvg(markup, width, height, backgroundColor), mimeType);
        return string
    },
    getData: function(markup, options) {
        var that = this,
            imageData = exports.imageCreator.getImageData(markup, options),
            mimeType = "image/" + options.format,
            data = $.Deferred();
        when(imageData).done(function(binaryData) {
            imageData = commonUtils.isFunction(window.Blob) ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
            data.resolve(imageData)
        });
        return data
    },
    _getBlob: function(binaryData, mimeType) {
        var i, dataArray = new Uint8Array(binaryData.length);
        for (i = 0; i < binaryData.length; i++) {
            dataArray[i] = binaryData.charCodeAt(i)
        }
        return new Blob([dataArray.buffer], {
            type: mimeType
        })
    },
    _getBase64: function(binaryData) {
        return window.btoa(binaryData)
    }
};
exports.getData = function(data, options, callback) {
    exports.imageCreator.getData(data, options).done(callback)
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/ready.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = function(callback) {
    if ("complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll) {
        callback();
        return
    }
    var loadedCallback = function() {
        callback();
        document.removeEventListener("DOMContentLoaded", loadedCallback)
    };
    document.addEventListener("DOMContentLoaded", loadedCallback)
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/queue.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errors = __webpack_require__(13),
    when = __webpack_require__(10).when;

function createQueue(discardPendingTasks) {
    var _tasks = [],
        _busy = false;

    function exec() {
        while (_tasks.length) {
            _busy = true;
            var task = _tasks.shift(),
                result = task();
            if (void 0 === result) {
                continue
            }
            if (result.then) {
                when(result).always(exec);
                return
            }
            throw errors.Error("E0015")
        }
        _busy = false
    }

    function add(task, removeTaskCallback) {
        if (!discardPendingTasks) {
            _tasks.push(task)
        } else {
            if (_tasks[0] && removeTaskCallback) {
                removeTaskCallback(_tasks[0])
            }
            _tasks = [task]
        }
        if (!_busy) {
            exec()
        }
    }

    function busy() {
        return _busy
    }
    return {
        add: add,
        busy: busy
    }
}
exports.create = createQueue;
exports.enqueue = createQueue().add;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/wheel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerEvent = __webpack_require__(47),
    eventUtils = __webpack_require__(3);
var EVENT_NAME = "dxmousewheel",
    EVENT_NAMESPACE = "dxWheel";
var wheelEvent = void 0 !== document.onwheel ? "wheel" : "mousewheel";
var wheel = {
    setup: function(element) {
        var $element = $(element);
        $element.on(eventUtils.addNamespace(wheelEvent, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel))
    },
    teardown: function(element) {
        var $element = $(element);
        $element.off("." + EVENT_NAMESPACE)
    },
    _wheelHandler: function(e) {
        var delta = this._getWheelDelta(e.originalEvent);
        eventUtils.fireEvent({
            type: EVENT_NAME,
            originalEvent: e,
            delta: delta,
            pointerType: "mouse"
        });
        e.stopPropagation()
    },
    _getWheelDelta: function(event) {
        return event.wheelDelta ? event.wheelDelta : 30 * -event.deltaY
    }
};
registerEvent(EVENT_NAME, wheel);
exports.name = EVENT_NAME;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/empty_template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    TemplateBase = __webpack_require__(64);
var EmptyTemplate = TemplateBase.inherit({
    _renderCore: function() {
        return $()
    }
});
module.exports = EmptyTemplate;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/command.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(48),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    registerComponent = __webpack_require__(4),
    DOMComponent = __webpack_require__(45),
    isFunction = commonUtils.isFunction,
    isPlainObject = typeUtils.isPlainObject,
    noop = commonUtils.noop;
__webpack_require__(90);
var Command = DOMComponent.inherit({
    ctor: function(element, options) {
        if (isPlainObject(element)) {
            options = element;
            element = $("<div />")
        }
        this.callBase(element, options)
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            iconSrc: {
                since: "15.1",
                alias: "icon"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            onExecute: null,
            id: null,
            title: "",
            icon: "",
            visible: true,
            disabled: false,
            renderStage: "onViewShown"
        })
    },
    execute: function() {
        var isDisabled = this._options.disabled;
        if (isFunction(isDisabled)) {
            isDisabled = !!isDisabled.apply(this, arguments)
        }
        if (isDisabled) {
            throw errors.Error("E3004", this._options.id)
        }
        this.fireEvent("beforeExecute", arguments);
        this._createActionByOption("onExecute").apply(this, arguments);
        this.fireEvent("afterExecute", arguments)
    },
    _render: function() {
        this.callBase();
        this.element().addClass("dx-command")
    },
    _renderDisabledState: noop,
    _dispose: function() {
        this.callBase();
        this.element().removeData(this.NAME)
    }
});
registerComponent("dxCommand", Command);
module.exports = Command;
module.exports.default = module.exports;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/state_manager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Class = __webpack_require__(5),
    inArray = __webpack_require__(7).inArray,
    $ = __webpack_require__(0);
var MemoryKeyValueStorage = Class.inherit({
    ctor: function() {
        this.storage = {}
    },
    getItem: function(key) {
        return this.storage[key]
    },
    setItem: function(key, value) {
        this.storage[key] = value
    },
    removeItem: function(key) {
        delete this.storage[key]
    }
});
var StateManager = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this.storage = options.storage || new MemoryKeyValueStorage;
        this.stateSources = options.stateSources || []
    },
    addStateSource: function(stateSource) {
        this.stateSources.push(stateSource)
    },
    removeStateSource: function(stateSource) {
        var index = inArray(stateSource, this.stateSources);
        if (index > -1) {
            this.stateSources.splice(index, 1);
            stateSource.removeState(this.storage)
        }
    },
    saveState: function() {
        var that = this;
        $.each(this.stateSources, function(index, stateSource) {
            stateSource.saveState(that.storage)
        })
    },
    restoreState: function() {
        var that = this;
        $.each(this.stateSources, function(index, stateSource) {
            stateSource.restoreState(that.storage)
        })
    },
    clearState: function() {
        var that = this;
        $.each(this.stateSources, function(index, stateSource) {
            stateSource.removeState(that.storage)
        })
    }
});
module.exports = StateManager;
module.exports.MemoryKeyValueStorage = MemoryKeyValueStorage;
module.exports.default = module.exports;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/command_container.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    MarkupComponent = __webpack_require__(142).MarkupComponent,
    isPlainObject = __webpack_require__(9).isPlainObject,
    registerComponent = __webpack_require__(4);
__webpack_require__(90);
var CommandContainer = MarkupComponent.inherit({
    ctor: function(element, options) {
        if (isPlainObject(element)) {
            options = element;
            element = $("<div />")
        }
        this.callBase(element, options)
    },
    _setDefaultOptions: function() {
        this.callBase();
        this.option({
            id: null
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass("dx-command-container")
    }
});
registerComponent("dxCommandContainer", CommandContainer);
module.exports = CommandContainer;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/markup_component.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    noop = __webpack_require__(2).noop,
    publicComponentUtils = __webpack_require__(73);
var MarkupComponent = Class.inherit({
    ctor: function(element, options) {
        this.NAME = publicComponentUtils.name(this.constructor);
        options = options || {};
        this._$element = $(element);
        publicComponentUtils.attachInstanceToElement(this._$element, this, this._dispose);
        if (options.fromCache) {
            this._options = options
        } else {
            this._options = {};
            this._setDefaultOptions();
            if (options) {
                this.option(options)
            }
            this._render()
        }
    },
    _setDefaultOptions: noop,
    _render: noop,
    _dispose: noop,
    element: function() {
        return this._$element
    },
    option: function(name, value) {
        if (0 === arguments.length) {
            return this._options
        } else {
            if (1 === arguments.length) {
                if ("string" === typeof name) {
                    return this._options[name]
                } else {
                    value = name;
                    extend(this._options, value)
                }
            } else {
                this._options[name] = value
            }
        }
    },
    instance: function() {
        return this
    }
});
MarkupComponent.getInstance = function($element) {
    return publicComponentUtils.getInstanceByElement($($element), this)
};
exports.MarkupComponent = MarkupComponent;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/command_mapping.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    grep = __webpack_require__(2).grep,
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(48);
var CommandMapping = Class.inherit({
    ctor: function() {
        this._commandMappings = {};
        this._containerDefaults = {}
    },
    setDefaults: function(containerId, defaults) {
        this._containerDefaults[containerId] = defaults;
        return this
    },
    mapCommands: function(containerId, commandMappings) {
        var that = this;
        $.each(commandMappings, function(index, commandMapping) {
            if ("string" === typeof commandMapping) {
                commandMapping = {
                    id: commandMapping
                }
            }
            var commandId = commandMapping.id;
            var mappings = that._commandMappings[containerId] || {};
            mappings[commandId] = extend({
                showIcon: true,
                showText: true
            }, that._containerDefaults[containerId] || {}, commandMapping);
            that._commandMappings[containerId] = mappings
        });
        this._initExistingCommands();
        return this
    },
    unmapCommands: function(containerId, commandIds) {
        var that = this;
        $.each(commandIds, function(index, commandId) {
            var mappings = that._commandMappings[containerId] || {};
            if (mappings) {
                delete mappings[commandId]
            }
        });
        this._initExistingCommands()
    },
    getCommandMappingForContainer: function(commandId, containerId) {
        return (this._commandMappings[containerId] || {})[commandId]
    },
    checkCommandsExist: function(commands) {
        var that = this,
            result = grep(commands, function(commandName, index) {
                return inArray(commandName, that._existingCommands) < 0 && inArray(commandName, commands) === index
            });
        if (0 !== result.length) {
            throw errors.Error("E3005", result.join("', '"), 1 === result.length ? " is" : "s are")
        }
    },
    load: function(config) {
        if (!config) {
            return
        }
        var that = this;
        $.each(config, function(name, container) {
            that.setDefaults(name, container.defaults);
            that.mapCommands(name, container.commands)
        });
        return this
    },
    _initExistingCommands: function() {
        var that = this;
        this._existingCommands = [];
        $.each(that._commandMappings, function(name, _commands) {
            $.each(_commands, function(index, command) {
                if (inArray(command.id, that._existingCommands) < 0) {
                    that._existingCommands.push(command.id)
                }
            })
        })
    }
});
CommandMapping.defaultMapping = {
    "global-navigation": {
        defaults: {
            showIcon: true,
            showText: true
        },
        commands: []
    },
    "ios-header-toolbar": {
        defaults: {
            showIcon: false,
            showText: true,
            location: "after"
        },
        commands: ["edit", "save", {
            id: "back",
            location: "before"
        }, {
            id: "cancel",
            location: "before"
        }, {
            id: "create",
            showIcon: true,
            showText: false
        }]
    },
    "ios-action-sheet": {
        defaults: {
            showIcon: false,
            showText: true
        },
        commands: []
    },
    "ios-view-footer": {
        defaults: {
            showIcon: false,
            showText: true
        },
        commands: [{
            id: "delete",
            type: "danger"
        }]
    },
    "android-header-toolbar": {
        defaults: {
            showIcon: true,
            showText: false,
            location: "after"
        },
        commands: [{
            id: "back",
            showIcon: false,
            location: "before"
        }, "create", {
            id: "save",
            showText: true,
            showIcon: false,
            location: "after"
        }, {
            id: "edit",
            showText: false,
            location: "after"
        }, {
            id: "cancel",
            showText: false,
            location: "before"
        }, {
            id: "delete",
            showText: false,
            location: "after"
        }]
    },
    "android-simple-toolbar": {
        defaults: {
            showIcon: true,
            showText: false,
            location: "after"
        },
        commands: [{
            id: "back",
            showIcon: false,
            location: "before"
        }, {
            id: "create"
        }, {
            id: "save",
            showText: true,
            showIcon: false,
            location: "after"
        }, {
            id: "edit",
            showText: false,
            location: "after"
        }, {
            id: "cancel",
            showText: false,
            location: "before"
        }, {
            id: "delete",
            showText: false,
            location: "after"
        }]
    },
    "android-footer-toolbar": {
        defaults: {
            location: "after"
        },
        commands: [{
            id: "create",
            showText: false,
            location: "center"
        }, {
            id: "edit",
            showText: false,
            location: "before"
        }, {
            id: "delete",
            locateInMenu: "always"
        }, {
            id: "save",
            showIcon: false,
            location: "before"
        }]
    },
    "generic-header-toolbar": {
        defaults: {
            showIcon: false,
            showText: true,
            location: "after"
        },
        commands: ["edit", "save", {
            id: "back",
            location: "before"
        }, {
            id: "cancel",
            location: "before"
        }, {
            id: "create",
            showIcon: true,
            showText: false
        }]
    },
    "generic-view-footer": {
        defaults: {
            showIcon: false,
            showText: true
        },
        commands: [{
            id: "delete",
            type: "danger"
        }]
    },
    "win8-appbar": {
        defaults: {
            location: "after"
        },
        commands: ["edit", "cancel", "save", "delete", {
            id: "create",
            location: "before"
        }, {
            id: "refresh",
            location: "before"
        }]
    },
    "win8-toolbar": {
        defaults: {
            showText: false,
            location: "before"
        },
        commands: [{
            id: "previousPage"
        }]
    },
    "win8-phone-appbar": {
        defaults: {
            location: "center"
        },
        commands: ["create", "edit", "cancel", "save", "refresh", {
            id: "delete",
            locateInMenu: "always"
        }]
    },
    "win8-split-toolbar": {
        defaults: {
            showIcon: true,
            showText: false,
            location: "after"
        },
        commands: [{
            id: "back",
            showIcon: false,
            location: "before"
        }, {
            id: "create"
        }, {
            id: "save",
            showText: true,
            location: "before"
        }, {
            id: "edit",
            showText: true,
            locateInMenu: "always"
        }, {
            id: "cancel",
            showText: true,
            locateInMenu: "always"
        }, {
            id: "delete",
            showText: true,
            locateInMenu: "always"
        }]
    },
    "win8-master-detail-toolbar": {
        defaults: {
            showText: false,
            location: "before"
        },
        commands: ["back"]
    },
    "win10-appbar": {
        defaults: {
            showText: false,
            location: "after"
        },
        commands: [{
            id: "back",
            location: "before"
        }, "edit", "cancel", "save", "delete", "create", "refresh"]
    },
    "win10-phone-appbar": {
        defaults: {
            location: "after"
        },
        commands: ["create", "edit", "cancel", "save", "refresh", {
            id: "delete",
            locateInMenu: "always"
        }]
    },
    "desktop-toolbar": {
        defaults: {
            showIcon: false,
            showText: true,
            location: "after"
        },
        commands: ["cancel", "create", "edit", "save", {
            id: "delete",
            type: "danger"
        }]
    }
};
module.exports = CommandMapping;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/layout_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    frameworkUtils = __webpack_require__(93),
    layoutSets = __webpack_require__(117).layoutSets,
    EventsMixin = __webpack_require__(38),
    errors = __webpack_require__(48),
    domUtils = __webpack_require__(15),
    when = __webpack_require__(10).when,
    HIDDEN_BAG_ID = "__hidden-bag",
    TRANSITION_SELECTOR = ".dx-transition",
    CONTENT_SELECTOR = ".dx-content",
    DEFAULT_COMMAND_RENDER_STAGE = "onViewShown",
    CONTENT_RENDERED_EVENT_NAME = "dxcontentrendered.layoutController",
    PENDING_RENDERING_SELECTOR = ".dx-pending-rendering",
    PENDING_RENDERING_MANUAL_SELECTOR = ".dx-pending-rendering-manual",
    TransitionExecutorModule = __webpack_require__(88);
__webpack_require__(141);
__webpack_require__(49);
var transitionSelector = function(transitionName) {
    return ".dx-transition-" + transitionName
};
var DefaultLayoutController = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this.name = options.name || "";
        this._layoutModel = options.layoutModel || {};
        this._defaultPaneName = options.defaultPaneName || "content";
        this._transitionDuration = void 0 === options.transitionDuration ? 400 : options.transitionDuration;
        this._showViewFired = false
    },
    init: function(options) {
        options = options || {};
        this._visibleViews = {};
        this._$viewPort = options.$viewPort || $("body");
        this._commandManager = options.commandManager;
        this._viewEngine = options.viewEngine;
        this.transitionExecutor = new TransitionExecutorModule.TransitionExecutor;
        this._prepareTemplates();
        this._$viewPort.append(this.element());
        this._hideElements(this.element());
        if (options.templateContext) {
            this._templateContext = options.templateContext;
            this._proxiedTemplateContextChangedHandler = this._templateContextChangedHandler.bind(this)
        }
    },
    ensureActive: function(targetNode) {
        if (this._disabledState) {
            return this.enable()
        } else {
            return this.activate(targetNode)
        }
    },
    activate: function() {
        this._showViewFired = false;
        var $rootElement = this.element();
        this._showElements($rootElement);
        this._attachRefreshViewRequiredHandler();
        return $.Deferred().resolve().promise()
    },
    deactivate: function() {
        this._disabledState = false;
        this._showViewFired = false;
        this._releaseVisibleViews();
        this._hideElements(this.element());
        this._detachRefreshViewRequiredHandler();
        return $.Deferred().resolve().promise()
    },
    enable: function() {
        this._disabledState = false;
        if (!this._showViewFired) {
            this._notifyShowing()
        }
        this._showViewFired = false;
        return $.Deferred().resolve().promise()
    },
    disable: function() {
        this._disabledState = true;
        this._showViewFired = false;
        this._notifyHidden()
    },
    activeViewInfo: function() {
        return this._visibleViews[this._defaultPaneName]
    },
    _fireViewEvents: function(eventName, views) {
        var that = this;
        views = views || this._visibleViews;
        $.each(views, function(index, viewInfo) {
            that.fireEvent(eventName, [viewInfo])
        })
    },
    _notifyShowing: function(views) {
        this._fireViewEvents("viewShowing", views)
    },
    _notifyShown: function(views) {
        this._fireViewEvents("viewShown", views)
    },
    _notifyHidden: function(views) {
        this._fireViewEvents("viewHidden", views)
    },
    _applyTemplate: function($elements, model) {
        $elements.each(function(i, element) {
            frameworkUtils.templateProvider.applyTemplate(element, model)
        })
    },
    _releaseVisibleViews: function() {
        var that = this;
        $.each(this._visibleViews, function(index, viewInfo) {
            that._hideView(viewInfo);
            that._releaseView(viewInfo)
        });
        this._visibleViews = {}
    },
    _templateContextChangedHandler: function() {
        var that = this,
            viewsToShow = [];
        $.each(that._visibleViews, function(index, viewInfo) {
            if (viewInfo.currentViewTemplateId !== that._getViewTemplateId(viewInfo)) {
                viewsToShow.push(viewInfo)
            }
        });
        when.apply($, $.map(viewsToShow, function(viewInfo) {
            return that.showView(viewInfo)
        })).done(function() {
            that._notifyShown(viewsToShow)
        })
    },
    _attachRefreshViewRequiredHandler: function() {
        if (this._templateContext) {
            this._templateContext.on("optionChanged", this._proxiedTemplateContextChangedHandler)
        }
    },
    _detachRefreshViewRequiredHandler: function() {
        if (this._templateContextChanged) {
            this._templateContext.off("optionChanged", this._proxiedTemplateContextChangedHandler)
        }
    },
    _getPreviousViewInfo: function(viewInfo) {
        return this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)]
    },
    _prepareTemplates: function() {
        var that = this;
        var $layoutTemplate = that._viewEngine.getLayoutTemplate(this._getLayoutTemplateName());
        that._$layoutTemplate = $layoutTemplate;
        that._$mainLayout = that._createEmptyLayout();
        that._showElements(that._$mainLayout);
        that._applyTemplate(that._$mainLayout, that._layoutModel);
        that._$navigationWidget = that._createNavigationWidget()
    },
    renderNavigation: function(navigationCommands) {
        this._clearNavigationWidget();
        this._renderNavigationImpl(navigationCommands)
    },
    _renderNavigationImpl: function(navigationCommands) {
        this._renderCommands(this._$mainLayout, navigationCommands)
    },
    _createNavigationWidget: function() {
        var result, containers = this._findCommandContainers(this._$mainLayout);
        $.each(containers, function(k, container) {
            if ("global-navigation" === container.option("id")) {
                result = container.element();
                return false
            }
        });
        return result
    },
    _clearNavigationWidget: function() {
        if (this._$navigationWidget) {
            this._commandManager.clearContainer(this._$navigationWidget.dxCommandContainer("instance"))
        }
    },
    element: function() {
        return this._$mainLayout
    },
    _getViewFrame: function(viewInfo) {
        return this._$mainLayout
    },
    _getLayoutTemplateName: function() {
        return this.name
    },
    _applyModelToTransitionElements: function($markup, model) {
        var that = this;
        this._getTransitionElements($markup).each(function(i, item) {
            that._applyTemplate($(item).children(), model)
        })
    },
    _createViewLayoutTemplate: function() {
        var that = this;
        var $viewLayoutTemplate = that._$layoutTemplate.clone();
        this._hideElements($viewLayoutTemplate);
        return $viewLayoutTemplate
    },
    _createEmptyLayout: function() {
        var that = this;
        var $result = that._$layoutTemplate.clone();
        this._hideElements($result);
        this._getTransitionElements($result).empty();
        $result.children(CONTENT_SELECTOR).remove();
        return $result
    },
    _getTransitionElements: function($markup) {
        var $items = $markup.find(TRANSITION_SELECTOR).add($markup.filter(TRANSITION_SELECTOR)),
            result = [];
        for (var i = 0; i < $items.length; i++) {
            var $item = $items.eq(i);
            if (0 === $item.parents(TRANSITION_SELECTOR).length) {
                result.push($item.get(0))
            }
        }
        return $(result)
    },
    showView: function(viewInfo, direction) {
        direction = direction || "forward";
        var result, that = this,
            previousViewInfo = that._getPreviousViewInfo(viewInfo),
            previousViewTemplateId = previousViewInfo === viewInfo ? previousViewInfo.currentViewTemplateId : void 0;
        this._showViewFired = true;
        this._updateCurrentViewTemplateId(viewInfo);
        if (previousViewTemplateId && previousViewTemplateId === viewInfo.currentViewTemplateId && viewInfo === previousViewInfo) {
            that.fireEvent("viewShowing", [viewInfo, direction]);
            result = $.Deferred().resolve().promise()
        } else {
            that._ensureViewRendered(viewInfo);
            that.fireEvent("viewShowing", [viewInfo, direction]);
            result = this._showViewImpl(viewInfo, direction, previousViewTemplateId).done(function() {
                that._onViewShown(viewInfo)
            })
        }
        return result
    },
    disposeView: function(viewInfo) {
        this._clearRenderResult(viewInfo)
    },
    _clearRenderResult: function(viewInfo) {
        if (viewInfo.renderResult) {
            viewInfo.renderResult.$markup.remove();
            viewInfo.renderResult.$viewItems.remove();
            delete viewInfo.renderResult
        }
    },
    _renderViewImpl: function($viewTemplate, viewInfo) {
        var $viewItems, that = this,
            allowedChildrenSelector = ".dx-command,.dx-content,script",
            $layout = this._createViewLayoutTemplate(),
            isSimplifiedMarkup = true,
            outOfContentItems = $();
        if (0 === $viewTemplate.children(allowedChildrenSelector).length) {
            this._viewEngine._wrapViewDefaultContent($viewTemplate)
        }
        $viewItems = $viewTemplate.children();
        this._applyModelToTransitionElements($layout, viewInfo.model);
        this._viewEngine.applyLayout($viewTemplate, $layout);
        $viewItems.each(function(i, item) {
            var $item = $(item);
            that._applyTemplate($item, viewInfo.model);
            if ($item.is(allowedChildrenSelector)) {
                isSimplifiedMarkup = false
            } else {
                outOfContentItems = outOfContentItems.add($item)
            }
        });
        if (outOfContentItems.length && !isSimplifiedMarkup) {
            throw errors.Error("E3014", outOfContentItems[0].outerHTML)
        }
        viewInfo.renderResult = viewInfo.renderResult || {};
        viewInfo.renderResult.$viewItems = $viewItems;
        viewInfo.renderResult.$markup = $layout
    },
    _renderCommands: function($markup, commands) {
        var commandContainers = this._findCommandContainers($markup);
        return this._commandManager.renderCommandsToContainers(commands, commandContainers)
    },
    _prepareViewCommands: function(viewInfo) {
        var $viewItems = viewInfo.renderResult.$viewItems,
            viewCommands = this._commandManager.findCommands($viewItems),
            commandsToRenderMap = {};
        viewInfo.commands = frameworkUtils.utils.mergeCommands(viewInfo.commands || [], viewCommands);
        viewInfo.commandsToRenderMap = commandsToRenderMap;
        $.each(viewInfo.commands, function(index, command) {
            var renderStage = command.option("renderStage") || DEFAULT_COMMAND_RENDER_STAGE,
                targetArray = commandsToRenderMap[renderStage] = commandsToRenderMap[renderStage] || [];
            targetArray.push(command)
        })
    },
    _applyViewCommands: function(viewInfo, renderStage) {
        renderStage = renderStage || DEFAULT_COMMAND_RENDER_STAGE;
        var result, commandsToRender = viewInfo.commandsToRenderMap[renderStage],
            $markup = viewInfo.renderResult.$markup;
        if (commandsToRender) {
            result = this._renderCommands($markup, commandsToRender);
            delete viewInfo.commandsToRenderMap[renderStage]
        } else {
            result = $.Deferred().resolve().promise()
        }
        return result
    },
    _findCommandContainers: function($markup) {
        return domUtils.createComponents($markup, ["dxCommandContainer"])
    },
    _getViewTemplateId: function(viewInfo) {
        var viewTemplateInstance = viewInfo.$viewTemplate ? viewInfo.$viewTemplate.dxView("instance") : this._viewEngine.getViewTemplateInfo(viewInfo.viewName);
        return viewTemplateInstance.getId()
    },
    _updateCurrentViewTemplateId: function(viewInfo) {
        viewInfo.currentViewTemplateId = this._getViewTemplateId(viewInfo)
    },
    _ensureViewRendered: function(viewInfo) {
        var $cachedMarkup = viewInfo.renderResult && viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId];
        if ($cachedMarkup) {
            viewInfo.renderResult.$markup = $cachedMarkup
        } else {
            this._renderView(viewInfo);
            viewInfo.renderResult.markupCache = viewInfo.renderResult.markupCache || {};
            viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId] = viewInfo.renderResult.$markup
        }
    },
    _renderView: function(viewInfo) {
        var $viewTemplate = viewInfo.$viewTemplate || this._viewEngine.getViewTemplate(viewInfo.viewName);
        this._renderViewImpl($viewTemplate, viewInfo);
        this._prepareViewCommands(viewInfo);
        this._applyViewCommands(viewInfo, "onViewRendering");
        this._appendViewToLayout(viewInfo);
        $viewTemplate.remove();
        this._onRenderComplete(viewInfo);
        this.fireEvent("viewRendered", [viewInfo])
    },
    _prepareTransition: function($element, targetPlaceholderName) {
        if (0 === $element.children(".dx-content").length) {
            $element.wrapInner("<div>");
            $element.children().dxContent({
                targetPlaceholder: targetPlaceholderName
            })
        }
    },
    _appendViewToLayout: function(viewInfo) {
        var that = this,
            $viewFrame = that._getViewFrame(viewInfo),
            $markup = viewInfo.renderResult.$markup,
            $transitionContentElements = $(),
            animationItems = [];
        $.each($markup.find(".dx-content-placeholder"), function(index, el) {
            that._prepareTransition($(el), $(el).attr("data-dx-content-placeholder-name"))
        });
        $.each(that._getTransitionElements($viewFrame), function(index, transitionElement) {
            var $transition = $(transitionElement),
                $viewElement = $markup.find(transitionSelector($transition.attr("data-dx-transition-name"))).children(),
                animationItem = {
                    $element: $viewElement,
                    animation: $transition.attr("data-dx-transition-type")
                };
            animationItems.push(animationItem);
            $transition.append($viewElement);
            that._showViewElements($viewElement);
            domUtils.triggerShownEvent($viewElement);
            $transitionContentElements = $transitionContentElements.add($viewElement)
        });
        that._$mainLayout.append(viewInfo.renderResult.$viewItems.filter(".dx-command"));
        $markup.remove();
        viewInfo.renderResult.$markup = $transitionContentElements;
        viewInfo.renderResult.animationItems = animationItems
    },
    _onRenderComplete: function(viewInfo) {},
    _onViewShown: function(viewInfo) {
        $(document).trigger("dx.viewchanged")
    },
    _enter: function(animationItems, animationModifier) {
        var transitionExecutor = this.transitionExecutor;
        $.each(animationItems, function(index, item) {
            transitionExecutor.enter(item.$element, item.animation, animationModifier)
        })
    },
    _leave: function(animationItems, animationModifier) {
        var transitionExecutor = this.transitionExecutor;
        $.each(animationItems, function(index, item) {
            transitionExecutor.leave(item.$element, item.animation, animationModifier)
        })
    },
    _doTransition: function(oldViewInfo, newViewInfo, animationModifier) {
        if (oldViewInfo) {
            this._leave(oldViewInfo.renderResult.animationItems, animationModifier)
        }
        this._enter(newViewInfo.renderResult.animationItems, animationModifier);
        this._showView(newViewInfo);
        return this.transitionExecutor.start()
    },
    _showViewImpl: function(viewInfo, direction, previousViewTemplateId) {
        var that = this,
            previousViewInfo = this._getPreviousViewInfo(viewInfo),
            animationModifier = {
                direction: direction
            };
        if (previousViewInfo === viewInfo) {
            previousViewInfo = void 0
        }
        if (!previousViewInfo) {
            animationModifier.duration = 0;
            animationModifier.delay = 0
        }
        var d = $.Deferred();
        that._doTransition(previousViewInfo, viewInfo, animationModifier).done(function() {
            that._changeView(viewInfo, previousViewTemplateId).done(function(result) {
                d.resolve(result)
            })
        });
        return d.promise()
    },
    _releaseView: function(viewInfo) {
        this.fireEvent("viewReleased", [viewInfo])
    },
    _getReadyForRenderDeferredItems: function(viewInfo) {
        return $.Deferred().resolve().promise()
    },
    _changeView: function(viewInfo, previousViewTemplateId) {
        var that = this;
        if (previousViewTemplateId) {
            that._hideView(viewInfo, previousViewTemplateId)
        } else {
            var previousViewInfo = that._getPreviousViewInfo(viewInfo);
            if (previousViewInfo && previousViewInfo !== viewInfo) {
                that._hideView(previousViewInfo);
                that._releaseView(previousViewInfo)
            }
            this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)] = viewInfo
        }
        this._subscribeToDeferredItems(viewInfo);
        var d = $.Deferred();
        this._getReadyForRenderDeferredItems(viewInfo).done(function() {
            that._applyViewCommands(viewInfo).done(function() {
                that._renderDeferredItems(viewInfo.renderResult.$markup).done(function() {
                    d.resolve()
                })
            })
        });
        return d.promise()
    },
    _subscribeToDeferredItems: function(viewInfo) {
        var that = this,
            $markup = viewInfo.renderResult.$markup;
        $markup.find(PENDING_RENDERING_SELECTOR).add($markup.filter(PENDING_RENDERING_SELECTOR)).each(function() {
            var eventData = {
                viewInfo: viewInfo,
                context: that
            };
            $(this).on(CONTENT_RENDERED_EVENT_NAME, eventData, that._onDeferredContentRendered)
        })
    },
    _onDeferredContentRendered: function(event) {
        var $element = $(event.target),
            viewInfo = event.data.viewInfo,
            that = event.data.context;
        $element.off(CONTENT_RENDERED_EVENT_NAME, that._onDeferredContentRendered);
        that._renderCommands($element, viewInfo.commands)
    },
    _renderDeferredItems: function($items) {
        var that = this,
            result = $.Deferred();
        var $pendingItem = $items.find(PENDING_RENDERING_MANUAL_SELECTOR).add($items.filter(PENDING_RENDERING_MANUAL_SELECTOR)).first();
        if ($pendingItem.length) {
            var render = $pendingItem.data("dx-render-delegate");
            commonUtils.executeAsync(function() {
                render().done(function() {
                    that._renderDeferredItems($items).done(function() {
                        result.resolve()
                    })
                })
            })
        } else {
            result.resolve()
        }
        return result.promise()
    },
    _getViewPaneName: function(viewTemplateInfo) {
        return this._defaultPaneName
    },
    _hideElements: function($elements) {
        $elements.addClass("dx-fast-hidden")
    },
    _showElements: function($elements) {
        $elements.removeClass("dx-fast-hidden")
    },
    _hideViewElements: function($elements) {
        this._patchIds($elements);
        this._disableInputs($elements);
        $elements.removeClass("dx-active-view").addClass("dx-inactive-view")
    },
    _hideView: function(viewInfo, templateId) {
        if (viewInfo.renderResult) {
            var $markupToHide = void 0 === templateId ? viewInfo.renderResult.$markup : viewInfo.renderResult.markupCache[templateId];
            this._hideViewElements($markupToHide);
            this.fireEvent("viewHidden", [viewInfo])
        }
    },
    _showViewElements: function($elements) {
        this._unPatchIds($elements);
        this._enableInputs($elements);
        $elements.removeClass("dx-inactive-view").addClass("dx-active-view");
        this._skipAnimation($elements)
    },
    _showView: function(viewInfo) {
        if (viewInfo.renderResult) {
            this._showViewElements(viewInfo.renderResult.$markup)
        }
    },
    _skipAnimation: function($elements) {
        $elements.addClass("dx-skip-animation");
        for (var i = 0; i < $elements.length; i++) {
            $elements.eq(i).css("transform")
        }
        $elements.removeClass("dx-skip-animation")
    },
    _patchIds: function($markup) {
        this._processIds($markup, function(id) {
            var result = id;
            if (id.indexOf(HIDDEN_BAG_ID) === -1) {
                result = HIDDEN_BAG_ID + "-" + id
            }
            return result
        })
    },
    _unPatchIds: function($markup) {
        this._processIds($markup, function(id) {
            var result = id;
            if (0 === id.indexOf(HIDDEN_BAG_ID)) {
                result = id.substr(HIDDEN_BAG_ID.length + 1)
            }
            return result
        })
    },
    _processIds: function($markup, process) {
        var elementsWithIds = $markup.find("[id]");
        $.each(elementsWithIds, function(index, element) {
            var $el = $(element),
                id = $el.attr("id");
            $el.attr("id", process(id))
        })
    },
    _enableInputs: function($markup) {
        var $inputs = this._getInputs($markup).filter("[data-disabled='true']");
        $.each($inputs, function(index, input) {
            $(input).removeAttr("disabled").removeAttr("data-disabled")
        })
    },
    _disableInputs: function($markup) {
        var $inputs = this._getInputs($markup);
        $inputs = $inputs.filter(":not([disabled])").add($inputs.filter("[disabled=true]"));
        $.each($inputs, function(index, input) {
            $(input).attr({
                disabled: true,
                "data-disabled": true
            })
        })
    },
    _getInputs: function($markup) {
        return $markup.find("input, button, select, textarea")
    }
}).include(EventsMixin);
layoutSets.default = layoutSets.default || [];
layoutSets.default.push({
    controller: new DefaultLayoutController
});
exports.DefaultLayoutController = DefaultLayoutController;
exports.layoutSets = layoutSets;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/globalize/number.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(95);
var Globalize = __webpack_require__(50),
    numberLocalization = __webpack_require__(44),
    errors = __webpack_require__(13);
__webpack_require__(50);
if (Globalize && Globalize.formatNumber) {
    var enNumbers = {
        main: {
            en: {
                identity: {
                    version: {
                        _cldrVersion: "28",
                        _number: "$Revision: 11972 $"
                    },
                    language: "en"
                },
                numbers: {
                    defaultNumberingSystem: "latn",
                    otherNumberingSystems: {
                        "native": "latn"
                    },
                    minimumGroupingDigits: "1",
                    "symbols-numberSystem-latn": {
                        decimal: ".",
                        group: ",",
                        list: ";",
                        percentSign: "%",
                        plusSign: "+",
                        minusSign: "-",
                        exponential: "E",
                        superscriptingExponent: "",
                        perMille: "",
                        infinity: "",
                        nan: "NaN",
                        timeSeparator: ":"
                    },
                    "decimalFormats-numberSystem-latn": {
                        standard: "#,##0.###",
                        "long": {
                            decimalFormat: {
                                "1000-count-one": "0 thousand",
                                "1000-count-other": "0 thousand",
                                "10000-count-one": "00 thousand",
                                "10000-count-other": "00 thousand",
                                "100000-count-one": "000 thousand",
                                "100000-count-other": "000 thousand",
                                "1000000-count-one": "0 million",
                                "1000000-count-other": "0 million",
                                "10000000-count-one": "00 million",
                                "10000000-count-other": "00 million",
                                "100000000-count-one": "000 million",
                                "100000000-count-other": "000 million",
                                "1000000000-count-one": "0 billion",
                                "1000000000-count-other": "0 billion",
                                "10000000000-count-one": "00 billion",
                                "10000000000-count-other": "00 billion",
                                "100000000000-count-one": "000 billion",
                                "100000000000-count-other": "000 billion",
                                "1000000000000-count-one": "0 trillion",
                                "1000000000000-count-other": "0 trillion",
                                "10000000000000-count-one": "00 trillion",
                                "10000000000000-count-other": "00 trillion",
                                "100000000000000-count-one": "000 trillion",
                                "100000000000000-count-other": "000 trillion"
                            }
                        },
                        "short": {
                            decimalFormat: {
                                "1000-count-one": "0K",
                                "1000-count-other": "0K",
                                "10000-count-one": "00K",
                                "10000-count-other": "00K",
                                "100000-count-one": "000K",
                                "100000-count-other": "000K",
                                "1000000-count-one": "0M",
                                "1000000-count-other": "0M",
                                "10000000-count-one": "00M",
                                "10000000-count-other": "00M",
                                "100000000-count-one": "000M",
                                "100000000-count-other": "000M",
                                "1000000000-count-one": "0B",
                                "1000000000-count-other": "0B",
                                "10000000000-count-one": "00B",
                                "10000000000-count-other": "00B",
                                "100000000000-count-one": "000B",
                                "100000000000-count-other": "000B",
                                "1000000000000-count-one": "0T",
                                "1000000000000-count-other": "0T",
                                "10000000000000-count-one": "00T",
                                "10000000000000-count-other": "00T",
                                "100000000000000-count-one": "000T",
                                "100000000000000-count-other": "000T"
                            }
                        }
                    },
                    "scientificFormats-numberSystem-latn": {
                        standard: "#E0"
                    },
                    "percentFormats-numberSystem-latn": {
                        standard: "#,##0%"
                    },
                    "currencyFormats-numberSystem-latn": {
                        currencySpacing: {
                            beforeCurrency: {
                                currencyMatch: "[:^S:]",
                                surroundingMatch: "[:digit:]",
                                insertBetween: ""
                            },
                            afterCurrency: {
                                currencyMatch: "[:^S:]",
                                surroundingMatch: "[:digit:]",
                                insertBetween: ""
                            }
                        },
                        standard: "#,##0.00",
                        accounting: "#,##0.00;(#,##0.00)",
                        "short": {
                            standard: {
                                "1000-count-one": "0K",
                                "1000-count-other": "0K",
                                "10000-count-one": "00K",
                                "10000-count-other": "00K",
                                "100000-count-one": "000K",
                                "100000-count-other": "000K",
                                "1000000-count-one": "0M",
                                "1000000-count-other": "0M",
                                "10000000-count-one": "00M",
                                "10000000-count-other": "00M",
                                "100000000-count-one": "000M",
                                "100000000-count-other": "000M",
                                "1000000000-count-one": "0B",
                                "1000000000-count-other": "0B",
                                "10000000000-count-one": "00B",
                                "10000000000-count-other": "00B",
                                "100000000000-count-one": "000B",
                                "100000000000-count-other": "000B",
                                "1000000000000-count-one": "0T",
                                "1000000000000-count-other": "0T",
                                "10000000000000-count-one": "00T",
                                "10000000000000-count-other": "00T",
                                "100000000000000-count-one": "000T",
                                "100000000000000-count-other": "000T"
                            }
                        },
                        "unitPattern-count-one": "{0} {1}",
                        "unitPattern-count-other": "{0} {1}"
                    },
                    "miscPatterns-numberSystem-latn": {
                        atLeast: "{0}+",
                        range: "{0}{1}"
                    }
                }
            }
        }
    };
    if ("en" === Globalize.locale().locale) {
        Globalize.load(enNumbers);
        Globalize.locale("en")
    }
    var formattersCache = {};
    var getFormatter = function(format) {
        var formatter, formatCacheKey;
        if ("object" === typeof format) {
            formatCacheKey = Globalize.locale().locale + ":" + JSON.stringify(format)
        } else {
            formatCacheKey = Globalize.locale().locale + ":" + format
        }
        formatter = formattersCache[formatCacheKey];
        if (!formatter) {
            formatter = formattersCache[formatCacheKey] = Globalize.numberFormatter(format)
        }
        return formatter
    };
    var globalizeNumberLocalization = {
        _formatNumberCore: function(value, format, formatConfig) {
            if ("exponential" === format) {
                return this.callBase.apply(this, arguments)
            }
            return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value)
        },
        _normalizeFormatConfig: function(format, formatConfig, value) {
            var config;
            if ("decimal" === format) {
                config = {
                    minimumIntegerDigits: formatConfig.precision || 1,
                    useGrouping: false,
                    maximumFractionDigits: 0,
                    round: value < 0 ? "ceil" : "floor"
                }
            } else {
                config = this._getPrecisionConfig(formatConfig.precision)
            }
            if ("percent" === format) {
                config.style = "percent"
            }
            return config
        },
        _getPrecisionConfig: function(precision) {
            var config;
            if (null === precision) {
                config = {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 20
                }
            } else {
                config = {
                    minimumFractionDigits: precision || 0,
                    maximumFractionDigits: precision || 0
                }
            }
            return config
        },
        format: function(value, format) {
            if ("number" !== typeof value) {
                return value
            }
            format = this._normalizeFormat(format);
            if (!format || "function" !== typeof format && !format.type && !format.formatter) {
                return getFormatter(format)(value)
            }
            return this.callBase.apply(this, arguments)
        },
        parse: function(text, format) {
            if (!text) {
                return
            }
            if (format && format.parser) {
                return format.parser(text)
            }
            if (format) {
                errors.log("W0011")
            }
            return Globalize.parseNumber(text)
        }
    };
    numberLocalization.inject(globalizeNumberLocalization)
}


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/contextmenu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    devices = __webpack_require__(6),
    Class = __webpack_require__(5),
    registerEvent = __webpack_require__(47),
    eventUtils = __webpack_require__(3),
    holdEvent = __webpack_require__(66);
var CONTEXTMENU_NAMESPACE = "dxContexMenu",
    CONTEXTMENU_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE),
    HOLD_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(holdEvent.name, CONTEXTMENU_NAMESPACE),
    CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
var ContextMenu = Class.inherit({
    setup: function(element) {
        var $element = $(element);
        $element.on(CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
        if (support.touch || devices.isSimulator()) {
            $element.on(HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this))
        }
    },
    _holdHandler: function(e) {
        if (eventUtils.isMouseEvent(e) && !devices.isSimulator()) {
            return
        }
        this._fireContextMenu(e)
    },
    _contextMenuHandler: function(e) {
        this._fireContextMenu(e)
    },
    _fireContextMenu: function(e) {
        return eventUtils.fireEvent({
            type: CONTEXTMENU_EVENT_NAME,
            originalEvent: e
        })
    },
    teardown: function(element) {
        $(element).off("." + CONTEXTMENU_NAMESPACE)
    }
});
registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu);
exports.name = CONTEXTMENU_EVENT_NAME;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/query_adapters.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = {};


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/custom_store.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    deferredUtils = __webpack_require__(10),
    dataUtils = __webpack_require__(28),
    isFunction = __webpack_require__(2).isFunction,
    errors = __webpack_require__(29).errors,
    Store = __webpack_require__(96),
    arrayQuery = __webpack_require__(119),
    queryByOptions = __webpack_require__(97).queryByOptions;
var TOTAL_COUNT = "totalCount",
    LOAD = "load",
    BY_KEY = "byKey",
    INSERT = "insert",
    UPDATE = "update",
    REMOVE = "remove";

function isPromise(obj) {
    return obj && isFunction(obj.then)
}

function trivialPromise(value) {
    return $.Deferred().resolve(value).promise()
}

function ensureRequiredFuncOption(name, obj) {
    if (!isFunction(obj)) {
        throw errors.Error("E4011", name)
    }
}

function throwInvalidUserFuncResult(name) {
    throw errors.Error("E4012", name)
}

function createUserFuncFailureHandler(pendingDeferred) {
    function errorMessageFromXhr(promiseArguments) {
        var xhr = promiseArguments[0],
            textStatus = promiseArguments[1];
        if (!xhr || !xhr.getResponseHeader) {
            return null
        }
        return dataUtils.errorMessageFromXhr(xhr, textStatus)
    }
    return function(arg) {
        var error;
        if (arg instanceof Error) {
            error = arg
        } else {
            error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error")
        }
        if (error.message !== dataUtils.XHR_ERROR_UNLOAD) {
            pendingDeferred.reject(error)
        }
    }
}

function invokeUserLoad(store, options) {
    var userResult, userFunc = store._loadFunc;
    ensureRequiredFuncOption(LOAD, userFunc);
    userResult = userFunc.apply(store, [options]);
    if (Array.isArray(userResult)) {
        userResult = trivialPromise(userResult)
    } else {
        if (null === userResult || void 0 === userResult) {
            userResult = trivialPromise([])
        } else {
            if (!isPromise(userResult)) {
                throwInvalidUserFuncResult(LOAD)
            }
        }
    }
    return deferredUtils.fromPromise(userResult)
}

function invokeUserTotalCountFunc(store, options) {
    var userResult, userFunc = store._totalCountFunc;
    if (!isFunction(userFunc)) {
        throw errors.Error("E4021")
    }
    userResult = userFunc.apply(store, [options]);
    if (!isPromise(userResult)) {
        userResult = Number(userResult);
        if (!isFinite(userResult)) {
            throwInvalidUserFuncResult(TOTAL_COUNT)
        }
        userResult = trivialPromise(userResult)
    }
    return deferredUtils.fromPromise(userResult)
}

function invokeUserByKeyFunc(store, key, extraOptions) {
    var userResult, userFunc = store._byKeyFunc;
    ensureRequiredFuncOption(BY_KEY, userFunc);
    userResult = userFunc.apply(store, [key, extraOptions]);
    if (!isPromise(userResult)) {
        userResult = trivialPromise(userResult)
    }
    return deferredUtils.fromPromise(userResult)
}

function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
    if (store.__rawData) {
        continuation(store.__rawData)
    } else {
        invokeUserLoad(store, userFuncOptions).done(function(rawData) {
            if (store._cacheRawData) {
                store.__rawData = rawData
            }
            continuation(rawData)
        }).fail(createUserFuncFailureHandler(pendingDeferred))
    }
}

function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
    options = options || {};
    var userFuncOptions = {};
    if ("userData" in options) {
        userFuncOptions.userData = options.userData
    }
    runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
        var itemsQuery, totalCountQuery, rawDataQuery = arrayQuery(rawData, {
                errorHandler: store._errorHandler
            }),
            waitList = [];
        var items, totalCount;
        if (!countOnly) {
            itemsQuery = queryByOptions(rawDataQuery, options);
            if (itemsQuery === rawDataQuery) {
                items = rawData.slice(0)
            } else {
                waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
                    items = asyncResult
                }))
            }
        }
        if (options.requireTotalCount || countOnly) {
            totalCountQuery = queryByOptions(rawDataQuery, options, true);
            if (totalCountQuery === rawDataQuery) {
                totalCount = rawData.length
            } else {
                waitList.push(totalCountQuery.count().done(function(asyncResult) {
                    totalCount = asyncResult
                }))
            }
        }
        $.when.apply($, waitList).done(function() {
            if (countOnly) {
                pendingDeferred.resolve(totalCount)
            } else {
                if (options.requireTotalCount) {
                    pendingDeferred.resolve(items, {
                        totalCount: totalCount
                    })
                } else {
                    pendingDeferred.resolve(items)
                }
            }
        }).fail(function(x) {
            pendingDeferred.reject(x)
        })
    })
}

function runRawLoadWithKey(pendingDeferred, store, key) {
    runRawLoad(pendingDeferred, store, {}, function(rawData) {
        var item, keyExpr = store.key();
        for (var i = 0, len = rawData.length; i < len; i++) {
            item = rawData[i];
            if (dataUtils.keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
                pendingDeferred.resolve(item);
                return
            }
        }
        pendingDeferred.reject(errors.Error("E4009"))
    })
}
var CustomStore = Store.inherit({
    ctor: function(options) {
        options = options || {};
        this.callBase(options);
        this._useDefaultSearch = !!options.useDefaultSearch || "raw" === options.loadMode;
        this._loadMode = options.loadMode;
        this._cacheRawData = false !== options.cacheRawData;
        this._loadFunc = options[LOAD];
        this._totalCountFunc = options[TOTAL_COUNT];
        this._byKeyFunc = options[BY_KEY];
        this._insertFunc = options[INSERT];
        this._updateFunc = options[UPDATE];
        this._removeFunc = options[REMOVE]
    },
    createQuery: function() {
        throw errors.Error("E4010")
    },
    clearRawDataCache: function() {
        delete this.__rawData
    },
    _totalCountImpl: function(options) {
        var d = $.Deferred();
        if ("raw" === this._loadMode && !this._totalCountFunc) {
            runRawLoadWithQuery(d, this, options, true)
        } else {
            invokeUserTotalCountFunc(this, options).done(function(count) {
                d.resolve(Number(count))
            }).fail(createUserFuncFailureHandler(d));
            d = this._addFailHandlers(d)
        }
        return d.promise()
    },
    _loadImpl: function(options) {
        var d = $.Deferred();
        if ("raw" === this._loadMode) {
            runRawLoadWithQuery(d, this, options, false)
        } else {
            invokeUserLoad(this, options).done(function(data, extra) {
                d.resolve(data, extra)
            }).fail(createUserFuncFailureHandler(d));
            d = this._addFailHandlers(d)
        }
        return d.promise()
    },
    _byKeyImpl: function(key, extraOptions) {
        var d = $.Deferred();
        if (this._byKeyViaLoad()) {
            this._requireKey();
            runRawLoadWithKey(d, this, key)
        } else {
            invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
                d.resolve(obj)
            }).fail(createUserFuncFailureHandler(d))
        }
        return d.promise()
    },
    _byKeyViaLoad: function() {
        return "raw" === this._loadMode && !this._byKeyFunc
    },
    _insertImpl: function(values) {
        var userResult, userFunc = this._insertFunc,
            d = $.Deferred();
        ensureRequiredFuncOption(INSERT, userFunc);
        userResult = userFunc.apply(this, [values]);
        if (!isPromise(userResult)) {
            userResult = trivialPromise(userResult)
        }
        deferredUtils.fromPromise(userResult).done(function(newKey) {
            d.resolve(values, newKey)
        }).fail(createUserFuncFailureHandler(d));
        return d.promise()
    },
    _updateImpl: function(key, values) {
        var userResult, userFunc = this._updateFunc,
            d = $.Deferred();
        ensureRequiredFuncOption(UPDATE, userFunc);
        userResult = userFunc.apply(this, [key, values]);
        if (!isPromise(userResult)) {
            userResult = trivialPromise()
        }
        deferredUtils.fromPromise(userResult).done(function() {
            d.resolve(key, values)
        }).fail(createUserFuncFailureHandler(d));
        return d.promise()
    },
    _removeImpl: function(key) {
        var userResult, userFunc = this._removeFunc,
            d = $.Deferred();
        ensureRequiredFuncOption(REMOVE, userFunc);
        userResult = userFunc.apply(this, [key]);
        if (!isPromise(userResult)) {
            userResult = trivialPromise()
        }
        deferredUtils.fromPromise(userResult).done(function() {
            d.resolve(key)
        }).fail(createUserFuncFailureHandler(d));
        return d.promise()
    }
});
module.exports = CustomStore;
module.exports.default = module.exports;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.plain.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var inArray = __webpack_require__(7).inArray,
    EditStrategy = __webpack_require__(277);
var PlainEditStrategy = EditStrategy.inherit({
    _getPlainItems: function() {
        return this._collectionWidget.option("items") || []
    },
    getIndexByItemData: function(itemData) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        if (keyOf) {
            return this.getIndexByKey(keyOf(itemData))
        } else {
            return inArray(itemData, this._getPlainItems())
        }
    },
    getItemDataByIndex: function(index) {
        return this._getPlainItems()[index]
    },
    deleteItemAtIndex: function(index) {
        this._getPlainItems().splice(index, 1)
    },
    itemsGetter: function() {
        return this._getPlainItems()
    },
    getKeysByItems: function(items) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        var result = items;
        if (keyOf) {
            result = [];
            for (var i = 0; i < items.length; i++) {
                result.push(keyOf(items[i]))
            }
        }
        return result
    },
    getIndexByKey: function(key) {
        var keys = this.getKeysByItems(this._getPlainItems());
        for (var i = 0, length = keys.length; i < length; i++) {
            if (this._equalKeys(key, keys[i])) {
                return i
            }
        }
        return -1
    },
    getItemsByKeys: function(keys, items) {
        return items || keys
    },
    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._getPlainItems(),
            movedItemData = items[movingIndex];
        items.splice(movingIndex, 1);
        items.splice(destinationIndex, 0, movedItemData)
    },
    _isItemIndex: function(index) {
        return "number" === typeof index && Math.round(index) === index
    },
    _getNormalizedItemIndex: function(itemElement) {
        return this._collectionWidget._itemElements().index(itemElement)
    },
    _normalizeItemIndex: function(index) {
        return index
    },
    _denormalizeItemIndex: function(index) {
        return index
    },
    _getItemByNormalizedIndex: function(index) {
        return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
    },
    _itemsFromSameParent: function() {
        return true
    }
});
module.exports = PlainEditStrategy;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/drop_down_editor/ui.drop_down_list.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    DropDownEditor = __webpack_require__(123),
    List = __webpack_require__(79),
    errors = __webpack_require__(16),
    eventUtils = __webpack_require__(3),
    devices = __webpack_require__(6),
    DataExpressionMixin = __webpack_require__(152),
    messageLocalization = __webpack_require__(8),
    themes = __webpack_require__(20),
    ChildDefaultTemplate = __webpack_require__(74);
var LIST_ITEM_SELECTOR = ".dx-list-item",
    LIST_ITEM_DATA_KEY = "dxListItemData",
    DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper",
    SKIP_GESTURE_EVENT_CLASS = "dx-skip-gesture-event",
    SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var DropDownList = DropDownEditor.inherit({
    _supportedKeys: function() {
        var parent = this.callBase();
        return extend({}, parent, {
            tab: function() {
                if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
                    var $focusedItem = this._list.option("focusedElement");
                    $focusedItem && this._setSelectedElement($focusedItem)
                } else {
                    this._focusTarget().focusout()
                }
                parent.tab.apply(this, arguments)
            },
            space: commonUtils.noop,
            home: commonUtils.noop,
            end: commonUtils.noop
        })
    },
    _setSelectedElement: function($element) {
        var value = this._valueGetter(this._list._getItemData($element));
        this._setValue(value)
    },
    _setValue: function(value) {
        this.option("value", value)
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            pagingEnabled: {
                since: "15.1",
                message: "Use the 'dataSource.paginate' option instead"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), extend(DataExpressionMixin._dataExpressionDefaultOptions(), {
            displayValue: void 0,
            searchEnabled: false,
            searchMode: "contains",
            searchTimeout: 500,
            minSearchLength: 0,
            searchExpr: null,
            valueChangeEvent: "input change keyup",
            selectedItem: null,
            pagingEnabled: void 0,
            noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
            onSelectionChanged: null,
            onItemClick: commonUtils.noop,
            showDataBeforeSearch: false,
            grouped: false,
            groupTemplate: "group",
            popupPosition: {
                my: "left top",
                at: "left bottom",
                offset: {
                    h: 0,
                    v: 0
                },
                collision: "flip"
            },
            popupWidthExtension: 0
        }))
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return "win" === device.platform && device.version && 8 === device.version[0]
            },
            options: {
                popupPosition: {
                    offset: {
                        v: -6
                    }
                }
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                popupWidthExtension: 32
            }
        }, {
            device: {
                platform: "ios"
            },
            options: {
                popupPosition: {
                    offset: {
                        v: -1
                    }
                }
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                buttonsLocation: "bottom center"
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            value: true,
            selectedItem: true,
            displayValue: true
        })
    },
    _init: function() {
        this.callBase();
        this._initDataExpressions();
        this._initActions();
        this._setListDataSource();
        this._validateSearchMode();
        this._clearSelectedItem()
    },
    _initActions: function() {
        this._initContentReadyAction();
        this._initSelectionChangedAction();
        this._initItemClickAction()
    },
    _initContentReadyAction: function() {
        this._contentReadyAction = this._createActionByOption("onContentReady", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initSelectionChangedAction: function() {
        this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick")
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.item = new ChildDefaultTemplate("item", this)
    },
    _renderField: function() {
        this.callBase();
        this._input().on("input", this._setFocusPolicy.bind(this))
    },
    _preventFocusOnPopup: function(e) {
        if (this._list && this._list.initialOption("focusStateEnabled")) {
            e.preventDefault()
        }
    },
    _createPopup: function() {
        this.callBase();
        this._popup._wrapper().addClass(this._popupWrapperClass());
        this._popup.content().off("mousedown").on("mousedown", this._preventFocusOnPopup.bind(this))
    },
    _popupWrapperClass: function() {
        return DROPDOWNLIST_POPUP_WRAPPER_CLASS
    },
    _renderInputValue: function() {
        var value = this._getCurrentValue();
        return this._loadInputValue(value, this._setSelectedItem.bind(this)).always(this.callBase.bind(this, value))
    },
    _loadInputValue: function(value, callback) {
        return this._loadItem(value).always(callback)
    },
    _loadItem: function(value) {
        var plainItems = this._getPlainItems(this.option("items")),
            selectedItem = commonUtils.grep(plainItems, function(item) {
                return this._isValueEquals(this._valueGetter(item), value)
            }.bind(this))[0];
        return void 0 !== selectedItem ? $.Deferred().resolve(selectedItem).promise() : this._loadValue(value)
    },
    _getPlainItems: function(items) {
        var plainItems = [];
        items = items || [];
        for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        return plainItems
    },
    _setSelectedItem: function(item) {
        var displayValue = this._displayValue(item);
        this.option("selectedItem", commonUtils.ensureDefined(item, null));
        this.option("displayValue", displayValue)
    },
    _displayValue: function(item) {
        return this._displayGetter(item)
    },
    _refreshSelected: function() {
        this._listItemElements().each(function(_, itemElement) {
            var $itemElement = $(itemElement);
            var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY));
            var isItemSelected = this._isSelectedValue(itemValue);
            if (isItemSelected) {
                this._list.selectItem($itemElement)
            } else {
                this._list.unselectItem($itemElement)
            }
        }.bind(this))
    },
    _popupShownHandler: function() {
        this.callBase();
        this._setFocusPolicy()
    },
    _setFocusPolicy: function() {
        if (!this.option("focusStateEnabled") || !this._list) {
            return
        }
        this._list.option("focusedElement", null)
    },
    _isSelectedValue: function(value) {
        return this._isValueEquals(value, this.option("value"))
    },
    _validateSearchMode: function() {
        var searchMode = this.option("searchMode"),
            normalizedSearchMode = searchMode.toLowerCase();
        if (inArray(normalizedSearchMode, SEARCH_MODES) < 0) {
            throw errors.Error("E1019", searchMode)
        }
    },
    _clearSelectedItem: function() {
        this.option("selectedItem", null)
    },
    _processDataSourceChanging: function() {
        this._setListDataSource();
        this._renderInputValue().fail(function() {
            if (this._isCustomValueAllowed()) {
                return
            }
            this._clearSelectedItem()
        }.bind(this))
    },
    _isCustomValueAllowed: function() {
        return this.option("displayCustomValue")
    },
    reset: function() {
        this.callBase();
        this._clearFilter();
        this._clearSelectedItem()
    },
    _listItemElements: function() {
        return this._$list ? this._$list.find(LIST_ITEM_SELECTOR) : $()
    },
    _popupConfig: function() {
        var that = this;
        return extend(this.callBase(), {
            templatesRenderAsynchronously: false,
            width: this.option("width"),
            onShowing: function() {
                that.element().addClass(SKIP_GESTURE_EVENT_CLASS)
            },
            onHidden: function() {
                that.element().removeClass(SKIP_GESTURE_EVENT_CLASS)
            },
            height: "auto",
            maxHeight: this._getMaxHeight.bind(this)
        })
    },
    _renderPopupContent: function() {
        this._renderList()
    },
    _attachChildKeyboardEvents: function() {
        this._childKeyboardProcessor = this._keyboardProcessor.attachChildProcessor();
        this._setListOption("_keyboardProcessor", this._childKeyboardProcessor)
    },
    _fireContentReadyAction: commonUtils.noop,
    _setAriaTargetForList: function() {
        this._list._getAriaTarget = this._getAriaTarget.bind(this);
        this._list.setAria("role", "combobox")
    },
    _renderList: function() {
        this._listId = "dx-" + (new Guid)._value;
        var $list = this._$list = $("<div>", {
            id: this._listId
        }).appendTo(this._popup.content());
        this._list = this._createComponent($list, List, this._listConfig());
        this._refreshList();
        this._setAriaTargetForList()
    },
    _renderOpenedState: function() {
        this.callBase();
        var opened = this.option("opened") || void 0;
        this.setAria({
            activedescendant: opened && this._list.getFocusedItemId(),
            owns: opened && this._listId
        })
    },
    _refreshList: function() {
        if (this._list && this._shouldRefreshDataSource()) {
            this._setListDataSource()
        }
    },
    _shouldRefreshDataSource: function() {
        var dataSourceProvided = !!this._list.option("dataSource");
        return dataSourceProvided !== this._needPassDataSourceToList()
    },
    _isDesktopDevice: function() {
        return "desktop" === devices.real().deviceType
    },
    _getListKeyExpr: function() {
        var valueExpr = this.option("valueExpr"),
            isValueExprField = commonUtils.isString(valueExpr) && "this" !== valueExpr;
        return isValueExprField ? valueExpr : null
    },
    _listConfig: function() {
        var options = {
            selectionMode: "single",
            _templates: this.option("_templates"),
            templateProvider: this.option("templateProvider"),
            noDataText: this.option("noDataText"),
            grouped: this.option("grouped"),
            onContentReady: this._listContentReadyHandler.bind(this),
            itemTemplate: this._getTemplateByOption("itemTemplate"),
            indicateLoading: false,
            keyExpr: this._getListKeyExpr(),
            groupTemplate: this.option("groupTemplate"),
            tabIndex: -1,
            onItemClick: this._listItemClickAction.bind(this),
            dataSource: this._getDataSource(),
            _keyboardProcessor: this._childKeyboardProcessor,
            hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
            focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false
        };
        return options
    },
    _getDataSource: function() {
        return this._needPassDataSourceToList() ? this._dataSource : null
    },
    _dataSourceOptions: function() {
        this._suppressDeprecatedWarnings();
        var pagingEnabled = this.option("pagingEnabled");
        this._resumeDeprecatedWarnings();
        return {
            paginate: commonUtils.ensureDefined(pagingEnabled, false)
        }
    },
    _dataSourceFromUrlLoadMode: function() {
        return "raw"
    },
    _listContentReadyHandler: function() {
        this._list = this._list || this._$list.dxList("instance");
        this._dimensionChanged();
        this._contentReadyAction()
    },
    _setListOption: function(optionName, value) {
        this._setWidgetOption("_list", arguments)
    },
    _listItemClickAction: function(e) {
        this._listItemClickHandler(e);
        this._itemClickAction(e)
    },
    _listItemClickHandler: commonUtils.noop,
    _setListDataSource: function() {
        if (!this._list) {
            return
        }
        this._setListOption("dataSource", this._getDataSource());
        if (!this._needPassDataSourceToList()) {
            this._setListOption("items", [])
        }
    },
    _needPassDataSourceToList: function() {
        return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded()
    },
    _isMinSearchLengthExceeded: function() {
        return this._searchValue().toString().length >= this.option("minSearchLength")
    },
    _searchValue: function() {
        return this._input().val() || ""
    },
    _getSearchEvent: function() {
        return eventUtils.addNamespace("keyup", this.NAME + "Search")
    },
    _renderEvents: function() {
        this.callBase();
        if (this._shouldRenderSearchEvent()) {
            this._input().on(this._getSearchEvent(), this._searchHandler.bind(this))
        }
    },
    _shouldRenderSearchEvent: function() {
        return this.option("searchEnabled")
    },
    _refreshEvents: function() {
        this._input().off(this._getSearchEvent());
        this.callBase()
    },
    _searchHandler: function() {
        if (!this._isMinSearchLengthExceeded()) {
            this._searchCanceled();
            return
        }
        var searchTimeout = this.option("searchTimeout");
        if (searchTimeout) {
            this._clearSearchTimer();
            this._searchTimer = setTimeout(this._searchDataSource.bind(this), searchTimeout)
        } else {
            this._searchDataSource()
        }
    },
    _searchCanceled: function() {
        this._clearSearchTimer();
        if (this._needPassDataSourceToList()) {
            this._filterDataSource(null)
        }
        this._refreshList()
    },
    _searchDataSource: function() {
        this._filterDataSource(this._searchValue())
    },
    _filterDataSource: function(searchValue) {
        this._clearSearchTimer();
        var dataSource = this._dataSource;
        dataSource.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
        dataSource.searchOperation(this.option("searchMode"));
        dataSource.searchValue(searchValue);
        return dataSource.load().done(this._dataSourceFiltered.bind(this, searchValue))
    },
    _clearFilter: function() {
        var dataSource = this._dataSource;
        dataSource && dataSource.searchValue() && dataSource.searchValue(null)
    },
    _dataSourceFiltered: function() {
        this._refreshList();
        this._refreshPopupVisibility()
    },
    _refreshPopupVisibility: function() {
        if (this.option("readOnly")) {
            return
        }
        this.option("opened", this._hasItemsToShow());
        if (this.option("opened")) {
            this._dimensionChanged()
        }
    },
    _dataSourceChangedHandler: function(newItems) {
        if (0 === this._dataSource.pageIndex()) {
            this.option().items = newItems
        } else {
            this.option().items = this.option().items.concat(newItems)
        }
    },
    _hasItemsToShow: function() {
        var resultItems = this._dataSource && this._dataSource.items() || [];
        var resultAmount = resultItems.length;
        var isMinSearchLengthExceeded = this._needPassDataSourceToList();
        return isMinSearchLengthExceeded && resultAmount && this._hasFocusClass()
    },
    _clearSearchTimer: function() {
        clearTimeout(this._searchTimer);
        delete this._searchTimer
    },
    _popupShowingHandler: function() {
        this._dimensionChanged()
    },
    _dimensionChanged: function() {
        this._popup && this._updatePopupDimensions()
    },
    _updatePopupDimensions: function() {
        this._updatePopupWidth();
        this._updatePopupHeight()
    },
    _updatePopupWidth: function() {
        this._setPopupOption("width", this.element().outerWidth() + this.option("popupWidthExtension"))
    },
    _needPopupRepaint: function() {
        if (!this._dataSource) {
            return false
        }
        var currentPageIndex = this._dataSource.pageIndex(),
            needRepaint = commonUtils.isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex;
        this._pageIndex = currentPageIndex;
        return needRepaint
    },
    _updatePopupHeight: function() {
        if (this._needPopupRepaint()) {
            this._popup.repaint()
        }
        this._list && this._list.updateDimensions()
    },
    _getMaxHeight: function() {
        var $element = this.element(),
            offset = $element.offset(),
            windowHeight = $(window).height(),
            maxHeight = Math.max(offset.top, windowHeight - offset.top - $element.outerHeight());
        return Math.min(.5 * windowHeight, maxHeight)
    },
    _clean: function() {
        if (this._list) {
            delete this._list
        }
        this.callBase()
    },
    _dispose: function() {
        this._clearSearchTimer();
        this.callBase()
    },
    _setCollectionWidgetOption: function() {
        this._setListOption.apply(this, arguments)
    },
    _optionChanged: function(args) {
        this._dataExpressionOptionChanged(args);
        switch (args.name) {
            case "hoverStateEnabled":
            case "focusStateEnabled":
                this._isDesktopDevice() && this._setListOption(args.name, args.value);
                this.callBase(args);
                break;
            case "items":
                if (!this.option("dataSource")) {
                    this._processDataSourceChanging()
                }
                break;
            case "dataSource":
                this._processDataSourceChanging();
                break;
            case "valueExpr":
                this._renderValue();
                this._setListOption("keyExpr", this._getListKeyExpr());
                break;
            case "displayExpr":
                this._renderValue();
                break;
            case "searchMode":
                this._validateSearchMode();
                break;
            case "minSearchLength":
                this._refreshList();
                break;
            case "searchEnabled":
            case "showDataBeforeSearch":
            case "searchExpr":
            case "pagingEnabled":
                this._invalidate();
                break;
            case "onContentReady":
                this._initContentReadyAction();
                break;
            case "onSelectionChanged":
                this._initSelectionChangedAction();
                break;
            case "onItemClick":
                this._initItemClickAction();
                break;
            case "grouped":
            case "groupTemplate":
            case "noDataText":
                this._setListOption(args.name);
                break;
            case "displayValue":
                this.option("text", args.value);
                break;
            case "itemTemplate":
            case "searchTimeout":
            case "popupWidthExtension":
                break;
            case "selectedItem":
                this._selectionChangedAction({
                    selectedItem: args.value
                });
                break;
            default:
                this.callBase(args)
        }
    }
}).include(DataExpressionMixin);
registerComponent("dxDropDownList", DropDownList);
module.exports = DropDownList;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/load_panel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    messageLocalization = __webpack_require__(8),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    LoadIndicator = __webpack_require__(53),
    Overlay = __webpack_require__(39);
var LOADPANEL_CLASS = "dx-loadpanel",
    LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper",
    LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator",
    LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message",
    LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content",
    LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper",
    LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
var LoadPanel = Overlay.inherit({
    _supportedKeys: function() {
        return extend(this.callBase(), {
            escape: noop
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            message: messageLocalization.format("Loading"),
            width: 222,
            height: 90,
            animation: null,
            showIndicator: true,
            indicatorSrc: "",
            showPane: true,
            delay: 0,
            closeOnBackButton: false,
            resizeEnabled: false,
            focusStateEnabled: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "generic"
            },
            options: {
                shadingColor: "transparent"
            }
        }])
    },
    _init: function() {
        this.callBase.apply(this, arguments)
    },
    _initOptions: function() {
        this.callBase.apply(this, arguments);
        this.option("templatesRenderAsynchronously", false)
    },
    _render: function() {
        this.callBase();
        this.element().addClass(LOADPANEL_CLASS);
        this._wrapper().addClass(LOADPANEL_WRAPPER_CLASS)
    },
    _renderContentImpl: function() {
        this.callBase();
        this.content().addClass(LOADPANEL_CONTENT_CLASS);
        this._$contentWrapper = $("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
        this._$contentWrapper.appendTo(this._$content);
        this._togglePaneVisible();
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage()
    },
    _show: function() {
        var delay = this.option("delay");
        if (!delay) {
            return this.callBase()
        }
        var deferred = $.Deferred();
        var callBase = this.callBase.bind(this);
        this._clearShowTimeout();
        this._showTimeout = setTimeout(function() {
            callBase().done(function() {
                deferred.resolve()
            })
        }, delay);
        return deferred.promise()
    },
    _hide: function() {
        this._clearShowTimeout();
        return this.callBase()
    },
    _clearShowTimeout: function() {
        clearTimeout(this._showTimeout)
    },
    _renderMessage: function() {
        if (!this._$contentWrapper) {
            return
        }
        var message = this.option("message");
        if (!message) {
            return
        }
        var $message = $("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
        this._$contentWrapper.append($message)
    },
    _renderLoadIndicator: function() {
        if (!this._$contentWrapper || !this.option("showIndicator")) {
            return
        }
        this._$indicator = $("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$contentWrapper);
        this._createComponent(this._$indicator, LoadIndicator, {
            indicatorSrc: this.option("indicatorSrc")
        })
    },
    _cleanPreviousContent: function() {
        this.content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
        this.content().find("." + LOADPANEL_INDICATOR_CLASS).remove()
    },
    _togglePaneVisible: function() {
        this.content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "delay":
                break;
            case "message":
            case "showIndicator":
                this._cleanPreviousContent();
                this._renderLoadIndicator();
                this._renderMessage();
                break;
            case "showPane":
                this._togglePaneVisible();
                break;
            case "indicatorSrc":
                if (this._$indicator) {
                    this._createComponent(this._$indicator, LoadIndicator, {
                        indicatorSrc: this.option("indicatorSrc")
                    })
                }
                break;
            default:
                this.callBase(args)
        }
    },
    _dispose: function() {
        this._clearShowTimeout();
        this.callBase()
    }
});
registerComponent("dxLoadPanel", LoadPanel);
module.exports = LoadPanel;
module.exports.default = module.exports;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/editor/ui.data_expression.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    variableWrapper = __webpack_require__(41),
    dataCoreUtils = __webpack_require__(14),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    FunctionTemplate = __webpack_require__(91),
    DataHelperMixin = __webpack_require__(121),
    DataSourceModule = __webpack_require__(51),
    ArrayStore = __webpack_require__(67);
var DataExpressionMixin = extend(DataHelperMixin, {
    _dataExpressionDefaultOptions: function() {
        return {
            items: [],
            dataSource: null,
            itemTemplate: "item",
            value: null,
            valueExpr: "this",
            displayExpr: void 0
        }
    },
    _initDataExpressions: function() {
        this._compileValueGetter();
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._initDataSource();
        this._itemsToDataSource()
    },
    _itemsToDataSource: function() {
        if (!this.option("dataSource")) {
            this._dataSource = new DataSourceModule.DataSource({
                store: new ArrayStore(this.option("items")),
                pageSize: 0
            })
        }
    },
    _compileDisplayGetter: function() {
        this._displayGetter = dataCoreUtils.compileGetter(this._displayGetterExpr())
    },
    _displayGetterExpr: function() {
        return this.option("displayExpr")
    },
    _compileValueGetter: function() {
        this._valueGetter = dataCoreUtils.compileGetter(this._valueGetterExpr())
    },
    _valueGetterExpr: function() {
        return this.option("valueExpr") || "this"
    },
    _loadValue: function(value) {
        var deferred = $.Deferred();
        value = this._unwrappedValue(value);
        if (!commonUtils.isDefined(value)) {
            return deferred.reject().promise()
        }
        this._loadSingle(this._valueGetterExpr(), value).done(function(item) {
            this._isValueEquals(this._valueGetter(item), value) ? deferred.resolve(item) : deferred.reject()
        }.bind(this)).fail(function() {
            deferred.reject()
        });
        return deferred.promise()
    },
    _getCurrentValue: function() {
        return this.option("value")
    },
    _unwrappedValue: function(value) {
        value = commonUtils.isDefined(value) ? value : this._getCurrentValue();
        if (value && this._dataSource && "this" === this._valueGetterExpr()) {
            value = this._getItemKey(value)
        }
        return variableWrapper.unwrap(value)
    },
    _getItemKey: function(value) {
        var key = this._dataSource.key();
        if (Array.isArray(key)) {
            var result = {};
            for (var i = 0, n = key.length; i < n; i++) {
                result[key[i]] = value[key[i]]
            }
            return result
        }
        if (key && "object" === typeof value) {
            value = value[key]
        }
        return value
    },
    _isValueEquals: function(value1, value2) {
        var dataSourceKey = this._dataSource && this._dataSource.key();
        var isDefined = commonUtils.isDefined;
        var result = this._compareValues(value1, value2);
        if (!result && dataSourceKey && isDefined(value1) && isDefined(value2)) {
            if (Array.isArray(dataSourceKey)) {
                result = this._compareByCompositeKey(value1, value2, dataSourceKey)
            } else {
                result = this._compareByKey(value1, value2, dataSourceKey)
            }
        }
        return result
    },
    _compareByCompositeKey: function(value1, value2, key) {
        var isObject = commonUtils.isObject;
        if (!isObject(value1) || !isObject(value2)) {
            return false
        }
        for (var i = 0, n = key.length; i < n; i++) {
            if (value1[key[i]] !== value2[key[i]]) {
                return false
            }
        }
        return true
    },
    _compareByKey: function(value1, value2, key) {
        var ensureDefined = commonUtils.ensureDefined;
        var unwrapObservable = variableWrapper.unwrap;
        var valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
        var valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
        return this._compareValues(valueKey1, valueKey2)
    },
    _compareValues: function(value1, value2) {
        return dataCoreUtils.toComparable(value1, true) === dataCoreUtils.toComparable(value2, true)
    },
    _initDynamicTemplates: function() {
        if (this._displayGetterExpr()) {
            this._originalItemTemplate = this._defaultTemplates.item;
            this._defaultTemplates.item = new FunctionTemplate(function(options) {
                return $("<div/>").text(this._displayGetter(options.model)).html()
            }.bind(this))
        } else {
            if (this._originalItemTemplate) {
                this._defaultTemplates.item = this._originalItemTemplate
            }
        }
    },
    _setCollectionWidgetItemTemplate: function() {
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("itemTemplate", this._getTemplateByOption("itemTemplate"))
    },
    _dataExpressionOptionChanged: function(args) {
        switch (args.name) {
            case "items":
                this._itemsToDataSource();
                this._setCollectionWidgetOption("items");
                break;
            case "dataSource":
                this._initDataSource();
                break;
            case "itemTemplate":
                this._setCollectionWidgetItemTemplate();
                break;
            case "valueExpr":
                this._compileValueGetter();
                break;
            case "displayExpr":
                this._compileDisplayGetter();
                this._setCollectionWidgetItemTemplate()
        }
    }
});
module.exports = DataExpressionMixin;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(310);
module.exports.default = module.exports;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    support = __webpack_require__(24),
    browser = __webpack_require__(21),
    CollectionWidgetItem = __webpack_require__(122),
    devices = __webpack_require__(6),
    CollectionWidget = __webpack_require__(40);
var BOX_CLASS = "dx-box",
    BOX_SELECTOR = ".dx-box",
    BOX_ITEM_CLASS = "dx-box-item",
    BOX_ITEM_DATA_KEY = "dxBoxItemData";
var flexGrowProp = support.styleProp("flexGrow");
var flexShrinkProp = support.styleProp("flexShrink");
var flexPropPrefix = support.stylePropPrefix("flexDirection");
var MINSIZE_MAP = {
    row: "minWidth",
    col: "minHeight"
};
var MAXSIZE_MAP = {
    row: "maxWidth",
    col: "maxHeight"
};
var SHRINK = 1;
var FLEX_JUSTIFY_CONTENT_MAP = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    "space-between": "space-between",
    "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
    row: "row",
    col: "column"
};
var BoxItem = CollectionWidgetItem.inherit({
    _renderVisible: function(value, oldValue) {
        this.callBase(value);
        if (commonUtils.isDefined(oldValue)) {
            this._options.fireItemStateChangedAction({
                name: "visible",
                state: value,
                oldState: oldValue
            })
        }
    }
});
var FlexLayoutStrategy = Class.inherit({
    ctor: function($element, option) {
        this._$element = $element;
        this._option = option
    },
    renderBox: function() {
        this._$element.css({
            display: support.stylePropPrefix("flexDirection") + "flex",
            flexDirection: FLEX_DIRECTION_MAP[this._option("direction")]
        })
    },
    renderAlign: function() {
        this._$element.css({
            justifyContent: this._normalizedAlign()
        })
    },
    _normalizedAlign: function() {
        var align = this._option("align");
        return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align
    },
    renderCrossAlign: function() {
        this._$element.css({
            alignItems: this._normalizedCrossAlign()
        })
    },
    _normalizedCrossAlign: function() {
        var crossAlign = this._option("crossAlign");
        return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign
    },
    renderItems: function($items) {
        var direction = this._option("direction");
        $.each($items, function() {
            var $item = $(this);
            var item = $item.data(BOX_ITEM_DATA_KEY);
            $item.css({
                display: flexPropPrefix + "flex",
                flexBasis: item.baseSize || 0
            }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
            var itemStyle = $item.get(0).style;
            itemStyle[flexGrowProp] = item.ratio;
            itemStyle[flexShrinkProp] = commonUtils.isDefined(item.shrink) ? item.shrink : SHRINK;
            $item.children().each(function(_, itemContent) {
                $(itemContent).css({
                    width: "auto",
                    height: "auto",
                    display: support.stylePropPrefix("flexDirection") + "flex",
                    flexDirection: $item.children().css("flexDirection") || "column",
                    flexBasis: 0
                });
                itemContent.style[flexGrowProp] = 1
            })
        })
    },
    initSize: commonUtils.noop,
    update: commonUtils.noop
});
var BOX_EVENTNAMESPACE = "dxBox",
    UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE,
    FALLBACK_BOX_ITEM = "dx-box-fallback-item";
var FALLBACK_WRAP_MAP = {
    row: "nowrap",
    col: "normal"
};
var FALLBACK_MAIN_SIZE_MAP = {
    row: "width",
    col: "height"
};
var FALLBACK_CROSS_SIZE_MAP = {
    row: "height",
    col: "width"
};
var FALLBACK_PRE_MARGIN_MAP = {
    row: "marginLeft",
    col: "marginTop"
};
var FALLBACK_POST_MARGIN_MAP = {
    row: "marginRight",
    col: "marginBottom"
};
var FALLBACK_CROSS_PRE_MARGIN_MAP = {
    row: "marginTop",
    col: "marginLeft"
};
var FALLBACK_CROSS_POST_MARGIN_MAP = {
    row: "marginBottom",
    col: "marginRight"
};
var MARGINS_RTL_FLIP_MAP = {
    marginLeft: "marginRight",
    marginRight: "marginLeft"
};
var FallbackLayoutStrategy = Class.inherit({
    ctor: function($element, option) {
        this._$element = $element;
        this._option = option
    },
    renderBox: function() {
        this._$element.css({
            fontSize: 0,
            whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
            verticalAlign: "top"
        });
        this._$element.off(UPDATE_EVENT).on(UPDATE_EVENT, this.update.bind(this))
    },
    renderAlign: function() {
        var $items = this._$items;
        if (!$items) {
            return
        }
        var align = this._option("align"),
            shift = 0,
            totalItemSize = this.totalItemSize,
            direction = this._option("direction"),
            boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]](),
            freeSpace = boxSize - totalItemSize;
        this._setItemsMargins($items, direction, 0);
        switch (align) {
            case "start":
                break;
            case "end":
                shift = freeSpace;
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                break;
            case "center":
                shift = .5 * freeSpace;
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
                break;
            case "space-between":
                shift = .5 * freeSpace / ($items.length - 1);
                this._setItemsMargins($items, direction, shift);
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);
                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);
                break;
            case "space-around":
                shift = .5 * freeSpace / $items.length;
                this._setItemsMargins($items, direction, shift)
        }
    },
    _setItemsMargins: function($items, direction, shift) {
        $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift)
    },
    renderCrossAlign: function() {
        var $items = this._$items;
        if (!$items) {
            return
        }
        var crossAlign = this._option("crossAlign"),
            direction = this._option("direction"),
            size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
        var that = this;
        switch (crossAlign) {
            case "start":
                break;
            case "end":
                $.each($items, function() {
                    var $item = $(this),
                        itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                        shift = size - itemSize;
                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift)
                });
                break;
            case "center":
                $.each($items, function() {
                    var $item = $(this),
                        itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                        shift = .5 * (size - itemSize);
                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift)
                });
                break;
            case "stretch":
                $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%")
        }
    },
    _chooseMarginSide: function(value) {
        if (!this._option("rtlEnabled")) {
            return value
        }
        return MARGINS_RTL_FLIP_MAP[value] || value
    },
    renderItems: function($items) {
        this._$items = $items;
        var direction = this._option("direction"),
            totalRatio = 0,
            totalWeightedShrink = 0,
            totalBaseSize = 0;
        $.each($items, function(_, item) {
            var $item = $(item);
            $item.css({
                display: "inline-block",
                verticalAlign: "top"
            });
            $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
            $item.removeClass(FALLBACK_BOX_ITEM);
            var itemData = $item.data(BOX_ITEM_DATA_KEY),
                ratio = itemData.ratio || 0,
                size = this._baseSize($item),
                shrink = commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK;
            totalRatio += ratio;
            totalWeightedShrink += shrink * size;
            totalBaseSize += size
        }.bind(this));
        var freeSpaceSize = this._boxSize() - totalBaseSize;
        var itemSize = function($item) {
            var itemData = $item.data(BOX_ITEM_DATA_KEY),
                size = this._baseSize($item),
                factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : (commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK) * size,
                totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink,
                shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
            return size + shift
        }.bind(this);
        var totalItemSize = 0;
        $.each($items, function(_, item) {
            var $item = $(item),
                itemData = $(item).data(BOX_ITEM_DATA_KEY),
                size = itemSize($item);
            totalItemSize += size;
            $item.css(MAXSIZE_MAP[direction], itemData.maxSize || "none").css(MINSIZE_MAP[direction], itemData.minSize || "0").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
            $item.addClass(FALLBACK_BOX_ITEM)
        });
        this.totalItemSize = totalItemSize
    },
    _baseSize: function(item) {
        var itemData = $(item).data(BOX_ITEM_DATA_KEY);
        return null == itemData.baseSize ? 0 : "auto" === itemData.baseSize ? this._contentSize(item) : this._parseSize(itemData.baseSize)
    },
    _contentSize: function(item) {
        return $(item)[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]()
    },
    _parseSize: function(size) {
        return String(size).match(/.+%$/) ? .01 * parseFloat(size) * this._boxSizeValue : size
    },
    _boxSize: function(value) {
        if (!arguments.length) {
            this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();
            return this._boxSizeValue
        }
        this._boxSizeValue = value
    },
    _totalBaseSize: function() {
        var result = 0;
        $.each(this._$items, function(_, item) {
            result += this._baseSize(item)
        }.bind(this));
        return result
    },
    initSize: function() {
        this._boxSize(this._$element[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]())
    },
    update: function() {
        if (!this._$items || this._$element.is(":hidden")) {
            return
        }
        this._$items.detach();
        this.initSize();
        this._$element.append(this._$items);
        this.renderItems(this._$items);
        this.renderAlign();
        this.renderCrossAlign();
        var element = this._$element.get(0);
        this._$items.find(BOX_SELECTOR).each(function() {
            if (element === $(this).parent().closest(BOX_SELECTOR).get(0)) {
                $(this).triggerHandler(UPDATE_EVENT)
            }
        })
    }
});
var Box = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            direction: "row",
            align: "start",
            crossAlign: "stretch",
            activeStateEnabled: false,
            focusStateEnabled: false,
            onItemStateChanged: void 0,
            _layoutStrategy: "flex",
            _queue: void 0
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var device = devices.real();
                var isOldAndroid = "android" === device.platform && (device.version[0] < 4 || 4 === device.version[0] && device.version[1] < 4),
                    isOldIos = "ios" === device.platform && device.version[0] < 7;
                return "win" === device.platform || browser.msie || isOldAndroid || isOldIos
            },
            options: {
                _layoutStrategy: "fallback"
            }
        }])
    },
    _itemClass: function() {
        return BOX_ITEM_CLASS
    },
    _itemDataKey: function() {
        return BOX_ITEM_DATA_KEY
    },
    _itemElements: function() {
        return this._itemContainer().children(this._itemSelector())
    },
    _init: function() {
        this.callBase();
        this.element().addClass(BOX_CLASS + "-" + this.option("_layoutStrategy"));
        this._initLayout();
        this._initBoxQueue()
    },
    _initLayout: function() {
        this._layout = "fallback" === this.option("_layoutStrategy") ? new FallbackLayoutStrategy(this.element(), this.option.bind(this)) : new FlexLayoutStrategy(this.element(), this.option.bind(this))
    },
    _initBoxQueue: function() {
        this._queue = this.option("_queue") || []
    },
    _queueIsNotEmpty: function() {
        return this.option("_queue") ? false : !!this._queue.length
    },
    _pushItemToQueue: function($item, config) {
        this._queue.push({
            $item: $item,
            config: config
        })
    },
    _shiftItemFromQueue: function() {
        return this._queue.shift()
    },
    _render: function() {
        this._renderActions();
        this.callBase();
        this.element().addClass(BOX_CLASS);
        this._renderBox()
    },
    _renderActions: function() {
        this._onItemStateChanged = this._createActionByOption("onItemStateChanged")
    },
    _renderBox: function() {
        this._layout.renderBox();
        this._layout.renderAlign();
        this._layout.renderCrossAlign()
    },
    _renderItems: function(items) {
        this._layout.initSize();
        this.callBase(items);
        while (this._queueIsNotEmpty()) {
            var item = this._shiftItemFromQueue();
            this._createComponent(item.$item, Box, extend({
                _layoutStrategy: this.option("_layoutStrategy"),
                itemTemplate: this.option("itemTemplate"),
                itemHoldTimeout: this.option("itemHoldTimeout"),
                onItemHold: this.option("onItemHold"),
                onItemClick: this.option("onItemClick"),
                onItemContextMenu: this.option("onItemContextMenu"),
                onItemRendered: this.option("onItemRendered"),
                _queue: this._queue
            }, item.config))
        }
        this._layout.renderItems(this._itemElements());
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout(function() {
            if (!this._isUpdated) {
                this._layout.update()
            }
            this._isUpdated = false;
            this._updateTimer = null
        }.bind(this))
    },
    _renderItemContent: function(args) {
        var $itemNode = args.itemData && args.itemData.node;
        if ($itemNode) {
            return this._renderItemContentByNode(args, $itemNode)
        }
        return this.callBase(args)
    },
    _postprocessRenderItem: function(args) {
        var boxConfig = args.itemData.box;
        if (!boxConfig) {
            return
        }
        this._pushItemToQueue(args.itemContent, boxConfig)
    },
    _createItemByTemplate: function(itemTemplate, args) {
        if (args.itemData.box) {
            return itemTemplate.source ? itemTemplate.source() : $()
        }
        return this.callBase(itemTemplate, args)
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _dimensionChanged: function() {
        if (this._updateTimer) {
            return
        }
        this._isUpdated = true;
        this._layout.update()
    },
    _dispose: function() {
        clearTimeout(this._updateTimer);
        this.callBase.apply(this, arguments)
    },
    _itemOptionChanged: function(item, property, value, oldValue) {
        if ("visible" === property) {
            this._onItemStateChanged({
                name: property,
                state: value,
                oldState: false !== oldValue
            })
        }
        this.callBase(item, property, value)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "_layoutStrategy":
            case "_queue":
            case "direction":
                this._invalidate();
                break;
            case "align":
                this._layout.renderAlign();
                break;
            case "crossAlign":
                this._layout.renderCrossAlign();
                break;
            default:
                this.callBase(args)
        }
    },
    _itemOptions: function() {
        var that = this,
            options = this.callBase();
        options.fireItemStateChangedAction = function(e) {
            that._onItemStateChanged(e)
        };
        return options
    },
    repaint: function() {
        this._dimensionChanged()
    }
});
Box.ItemClass = BoxItem;
registerComponent("dxBox", Box);
module.exports = Box;
module.exports.default = module.exports;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/drop_down_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    Widget = __webpack_require__(27),
    Button = __webpack_require__(25),
    Popover = __webpack_require__(98),
    DataHelperMixin = __webpack_require__(121),
    List = __webpack_require__(79),
    ChildDefaultTemplate = __webpack_require__(74);
var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu",
    DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup",
    DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = "dx-dropdownmenu-popup-wrapper",
    DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list",
    DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
var POPUP_OPTION_MAP = {
    popupWidth: "width",
    popupHeight: "height"
};
var BUTTON_OPTION_MAP = {
    buttonIcon: "icon",
    buttonText: "text",
    buttonWidth: "width",
    buttonHeight: "height",
    buttonTemplate: "template"
};
var DropDownMenu = Widget.inherit({
    _supportedKeys: function() {
        var extension = {};
        if (!this.option("opened") || !this._list.option("focusedElement")) {
            extension = this._button._supportedKeys()
        }
        return extend(this.callBase(), extension, {
            tab: function() {
                this._popup && this._popup.hide()
            }
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            buttonIconSrc: {
                since: "15.1",
                alias: "buttonIcon"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            items: [],
            onItemClick: null,
            dataSource: null,
            itemTemplate: "item",
            buttonText: "",
            buttonIcon: "overflow",
            buttonWidth: void 0,
            buttonHeight: void 0,
            buttonTemplate: "content",
            onButtonClick: null,
            usePopover: false,
            popupWidth: "auto",
            popupHeight: "auto",
            activeStateEnabled: true,
            hoverStateEnabled: true,
            opened: false,
            deferRendering: false,
            popupPosition: {
                my: "top center",
                at: "bottom center",
                collision: "fit flip",
                offset: {
                    v: 1
                }
            },
            popupAnimation: void 0,
            onItemRendered: null,
            menuWidget: List
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: [{
                platform: "ios"
            }],
            options: {
                usePopover: true
            }
        }, {
            device: [{
                platform: "generic"
            }],
            options: {
                popupPosition: {
                    offset: {
                        v: 4
                    }
                }
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: [{
                platform: "android"
            }],
            options: {
                popupPosition: {
                    my: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                    at: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                    collision: "flipfit"
                },
                popupAnimation: {
                    show: {
                        type: "pop",
                        duration: 200,
                        from: {
                            scale: 0
                        },
                        to: {
                            scale: 1
                        }
                    },
                    hide: {
                        type: "pop",
                        duration: 200,
                        from: {
                            scale: 1
                        },
                        to: {
                            scale: 0
                        }
                    }
                }
            }
        }])
    },
    _initOptions: function(options) {
        if ("android" === devices.current().platform) {
            if (!options.popupPosition) {
                options.popupPosition = {
                    at: (options.usePopover ? "bottom " : "top ") + (options.rtlEnabled ? "left" : "right")
                }
            }
        }
        this.callBase(options)
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _init: function() {
        this.callBase();
        this.element().addClass(DROP_DOWN_MENU_CLASS);
        this._initDataSource();
        this._initItemClickAction();
        this._initButtonClickAction()
    },
    _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick")
    },
    _initButtonClickAction: function() {
        this._buttonClickAction = this._createActionByOption("onButtonClick")
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.item = new ChildDefaultTemplate("item", this);
        this._defaultTemplates.content = new ChildDefaultTemplate("content", this)
    },
    _render: function() {
        this._renderButton();
        this.callBase();
        this.setAria({
            role: "menubar",
            haspopup: true,
            expanded: this.option("opened")
        })
    },
    _renderContentImpl: function() {
        if (this.option("opened")) {
            this._renderPopup()
        }
    },
    _clean: function() {
        this._cleanFocusState();
        if (this._popup) {
            this._popup.element().remove();
            delete this._$popup
        }
    },
    _renderButton: function() {
        var $button = this.element().addClass(DROP_DOWN_MENU_BUTTON_CLASS),
            config = this._buttonOptions();
        this._button = this._createComponent($button, Button, config)
    },
    _buttonOptions: function() {
        return {
            text: this.option("buttonText"),
            icon: this.option("buttonIcon"),
            width: this.option("buttonWidth"),
            height: this.option("buttonHeight"),
            template: this.option("buttonTemplate"),
            focusStateEnabled: false,
            onClick: function(e) {
                this.option("opened", !this.option("opened"));
                this._buttonClickAction(e)
            }.bind(this)
        }
    },
    _toggleMenuVisibility: function(opened) {
        var state = void 0 === opened ? !this._popup.option("visible") : opened;
        if (opened) {
            this._renderPopup()
        }
        this._popup.toggle(state);
        this.setAria("expanded", state)
    },
    _renderPopup: function() {
        if (this._$popup) {
            return
        }
        var $popup = this._$popup = $("<div>").appendTo(this.element()),
            config = this._popupOptions();
        this._popup = this._createComponent($popup, Popover, config)
    },
    _popupOptions: function() {
        var usePopup = !this.option("usePopover");
        return {
            onInitialized: function(args) {
                args.component._wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS).toggleClass(DROP_DOWN_MENU_POPUP_CLASS, usePopup)
            },
            visible: this.option("opened"),
            onContentReady: this._popupContentReadyHandler.bind(this),
            deferRendering: false,
            position: this.option("popupPosition"),
            animation: this.option("popupAnimation"),
            onOptionChanged: function(args) {
                if ("visible" === args.name) {
                    this.option("opened", args.value)
                }
            }.bind(this),
            target: this.element(),
            height: this.option("popupHeight"),
            width: this.option("popupWidth")
        }
    },
    _popupContentReadyHandler: function() {
        var popup = Popover.getInstance(this._$popup);
        this._renderList(popup)
    },
    _renderList: function(instance) {
        var $content = instance.content(),
            listConfig = this._listOptions();
        $content.addClass(DROP_DOWN_MENU_LIST_CLASS);
        this._list = this._createComponent($content, this.option("menuWidget"), listConfig);
        this._list._getAriaTarget = function() {
            return this.element()
        }.bind(this);
        this._setListDataSource();
        var listMaxHeight = .5 * $(window).height();
        if ($content.height() > listMaxHeight) {
            $content.height(listMaxHeight)
        }
    },
    _listOptions: function() {
        return {
            _keyboardProcessor: this._listProcessor,
            pageLoadMode: "scrollBottom",
            indicateLoading: false,
            noDataText: "",
            itemTemplate: this._getTemplateByOption("itemTemplate"),
            onItemClick: function(e) {
                this.option("opened", false);
                this._itemClickAction(e)
            }.bind(this),
            tabIndex: -1,
            focusStateEnabled: this.option("focusStateEnabled"),
            activeStateEnabled: this.option("activeStateEnabled"),
            onItemRendered: this.option("onItemRendered"),
            _itemAttributes: {
                role: "menuitem"
            }
        }
    },
    _setListDataSource: function() {
        if (this._list) {
            this._list.option("dataSource", this._dataSource || this.option("items"))
        }
        delete this._deferRendering
    },
    _attachKeyboardEvents: function() {
        this.callBase.apply(this, arguments);
        this._listProcessor = this._keyboardProcessor && this._keyboardProcessor.attachChildProcessor();
        if (this._list) {
            this._list.option("_keyboardProcessor", this._listProcessor)
        }
    },
    _cleanFocusState: function() {
        this.callBase.apply(this, arguments);
        delete this._listProcessor
    },
    _toggleVisibility: function(visible) {
        this.callBase(visible);
        this._button.option("visible", visible)
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        switch (name) {
            case "items":
            case "dataSource":
                if (this.option("deferRendering") && !this.option("opened")) {
                    this._deferRendering = true
                } else {
                    this._refreshDataSource();
                    this._setListDataSource()
                }
                break;
            case "itemTemplate":
                if (this._list) {
                    this._list.option(name, this._getTemplate(value))
                }
                break;
            case "onItemClick":
                this._initItemClickAction();
                break;
            case "onButtonClick":
                this._buttonClickAction();
                break;
            case "buttonIcon":
            case "buttonText":
            case "buttonWidth":
            case "buttonHeight":
            case "buttonTemplate":
                this._button.option(BUTTON_OPTION_MAP[name], value);
                this._renderPopup();
                break;
            case "popupWidth":
            case "popupHeight":
                this._popup.option(POPUP_OPTION_MAP[name], value);
                break;
            case "usePopover":
            case "menuWidget":
                this._invalidate();
                break;
            case "focusStateEnabled":
            case "activeStateEnabled":
                if (this._list) {
                    this._list.option(name, value)
                }
                this.callBase(args);
                break;
            case "onItemRendered":
                if (this._list) {
                    this._list.option(name, value)
                }
                break;
            case "opened":
                if (this._deferRendering) {
                    this._refreshDataSource();
                    this._setListDataSource()
                }
                this._toggleMenuVisibility(value);
                break;
            case "deferRendering":
            case "popupPosition":
                break;
            default:
                this.callBase(args)
        }
    },
    open: function() {
        this.option("opened", true)
    },
    close: function() {
        this.option("opened", false)
    }
}).include(DataHelperMixin);
registerComponent("dxDropDownMenu", DropDownMenu);
module.exports = DropDownMenu;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    errors = __webpack_require__(13),
    compileGetter = __webpack_require__(14).compileGetter,
    Class = __webpack_require__(5),
    Button = __webpack_require__(25),
    abstract = Class.abstract;
var TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container",
    TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button";
var ToolbarStrategy = Class.inherit({
    ctor: function(toolbar) {
        this._toolbar = toolbar
    },
    render: function() {
        this._renderMenuButton();
        this._renderWidget()
    },
    _widgetOptions: function() {
        var itemClickAction = this._toolbar._createActionByOption("onItemClick");
        return {
            itemTemplate: this._getMenuItemTemplate.bind(this),
            onItemClick: function(e) {
                this._toggleMenu(false, true);
                itemClickAction(e)
            }.bind(this)
        }
    },
    _getMenuItemTemplate: function() {
        return this._toolbar._getTemplateByOption("menuItemTemplate")
    },
    _renderWidget: function() {
        var $menu = $("<div>").appendTo(this._menuContainer());
        this._menu = this._toolbar._createComponent($menu, this._menuWidgetClass(), this._widgetOptions());
        this.renderMenuItems()
    },
    _menuContainer: abstract,
    _menuWidgetClass: abstract,
    _hasVisibleMenuItems: function(items) {
        var menuItems = items || this._toolbar.option("items"),
            result = false;
        var optionGetter = compileGetter("visible"),
            overflowGetter = compileGetter("locateInMenu");
        var menuLocation = false;
        $.each(menuItems, function(index, item) {
            var itemVisible = optionGetter(item, {
                    functionsAsIs: true
                }),
                itemOverflow = overflowGetter(item, {
                    functionsAsIs: true
                });
            if ("menu" === item.location) {
                menuLocation = true
            }
            if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow || "menu" === item.location)) {
                result = true
            }
        });
        if (menuLocation) {
            errors.log("W0001", "dxToolbar - 'location' item field", "menu", "16.1", "Use 'locateInMenu' item field instead.")
        }
        return result
    },
    _getMenuItems: function() {
        return this._toolbar._getMenuItems()
    },
    _renderMenuButton: function() {
        var buttonOptions = this._menuButtonOptions();
        this._renderMenuButtonContainer();
        this._$button = $("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS);
        this._toolbar._createComponent(this._$button, Button, buttonOptions)
    },
    _menuButtonOptions: function() {
        return {
            onClick: this._menuButtonClickHandler.bind(this)
        }
    },
    _menuButtonClickHandler: function() {
        this._toggleMenu(!this._menuShown, true)
    },
    _renderMenuButtonContainer: function() {
        var $afterSection = this._toolbar._$afterSection;
        this._$menuButtonContainer = $("<div>").appendTo($afterSection).addClass(this._toolbar._buttonClass()).addClass(TOOLBAR_MENU_CONTAINER_CLASS)
    },
    renderMenuItems: function() {
        this._menu && this._menu.option("items", this._getMenuItems())
    },
    toggleMenuVisibility: function(visible, animate) {
        this._menu && this._toggleMenu(visible, animate)
    },
    _toggleMenu: function(visible) {
        this._menuShown = visible
    },
    getMenuWidget: function() {
        return this._menu
    },
    widgetOption: function(name, value) {
        this._menu && this._menu.option(name, value)
    },
    handleToolbarVisibilityChange: noop
});
module.exports = ToolbarStrategy;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validation_summary.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    grep = __webpack_require__(2).grep,
    extend = __webpack_require__(1).extend,
    ValidationMixin = __webpack_require__(114),
    ValidationEngine = __webpack_require__(58),
    CollectionWidget = __webpack_require__(40);
var VALIDATION_SUMMARY_CLASS = "dx-validationsummary",
    ITEM_CLASS = VALIDATION_SUMMARY_CLASS + "-item",
    ITEM_DATA_KEY = VALIDATION_SUMMARY_CLASS + "-item-data";
var ValidationSummary = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            focusStateEnabled: false,
            noDataText: null
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            validationGroup: true
        })
    },
    _init: function() {
        this.callBase();
        this._initGroupRegistration()
    },
    _initGroupRegistration: function() {
        var group = this._findGroup(),
            groupConfig = ValidationEngine.addGroup(group);
        this._unsubscribeGroup();
        this._groupWasInit = true;
        this._validationGroup = group;
        this.groupSubscription = this._groupValidationHandler.bind(this);
        groupConfig.on("validated", this.groupSubscription)
    },
    _unsubscribeGroup: function() {
        var groupConfig = ValidationEngine.getGroupConfig(this._validationGroup);
        groupConfig && groupConfig.off("validated", this.groupSubscription)
    },
    _getOrderedItems: function(validators, items) {
        var orderedItems = [];
        $.each(validators, function(_, validator) {
            var firstItem = grep(items, function(item) {
                if (item.validator === validator) {
                    return true
                }
            })[0];
            if (firstItem) {
                orderedItems.push(firstItem)
            }
        });
        return orderedItems
    },
    _groupValidationHandler: function(params) {
        var that = this,
            items = that._getOrderedItems(params.validators, $.map(params.brokenRules, function(rule) {
                return {
                    text: rule.message,
                    validator: rule.validator
                }
            }));
        that.validators = params.validators;
        $.each(that.validators, function(_, validator) {
            if (validator._validationSummary !== this) {
                var handler = that._itemValidationHandler.bind(that),
                    disposingHandler = function() {
                        validator.off("validated", handler);
                        validator._validationSummary = null;
                        handler = null
                    };
                validator.on("validated", handler);
                validator.on("disposing", disposingHandler);
                validator._validationSummary = this
            }
        });
        that.option("items", items)
    },
    _itemValidationHandler: function(itemValidationResult) {
        var elementIndex, items = this.option("items"),
            isValid = itemValidationResult.isValid,
            replacementFound = false,
            newMessage = itemValidationResult.brokenRule && itemValidationResult.brokenRule.message,
            validator = itemValidationResult.validator;
        $.each(items, function(index, item) {
            if (item.validator === validator) {
                if (isValid) {
                    elementIndex = index
                } else {
                    item.text = newMessage
                }
                replacementFound = true;
                return false
            }
        });
        if (isValid ^ replacementFound) {
            return
        }
        if (isValid) {
            items.splice(elementIndex, 1)
        } else {
            items.push({
                text: newMessage,
                validator: validator
            })
        }
        items = this._getOrderedItems(this.validators, items);
        this.option("items", items)
    },
    _render: function() {
        this.element().addClass(VALIDATION_SUMMARY_CLASS);
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "validationGroup":
                this._initGroupRegistration();
                break;
            default:
                this.callBase(args)
        }
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _postprocessRenderItem: function(params) {
        params.itemElement.on("click", function() {
            params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus()
        })
    },
    _dispose: function() {
        this.callBase();
        this._unsubscribeGroup()
    }
}).include(ValidationMixin);
registerComponent("dxValidationSummary", ValidationSummary);
module.exports = ValidationSummary;
module.exports.default = module.exports;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (viz/themes.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    vizUtils = __webpack_require__(159),
    themes = {},
    themesMapping = {},
    themesSchemeMapping = {},
    _extend = extend,
    _each = $.each,
    _normalizeEnum = vizUtils.normalizeEnum,
    currentThemeName = null,
    nextCacheUid = 0,
    widgetsCache = {};

function findTheme(themeName) {
    var name = _normalizeEnum(themeName);
    return themes[name] || themes[themesMapping[name] || currentThemeName]
}

function findThemeNameByName(name, scheme) {
    return themesMapping[name + "." + scheme] || themesSchemeMapping[name + "." + scheme] || themesMapping[name]
}

function findThemeNameByPlatform(platform, version, scheme) {
    return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme)
}

function currentTheme(themeName, colorScheme) {
    if (!arguments.length) {
        return currentThemeName
    }
    var scheme = _normalizeEnum(colorScheme);
    currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform(_normalizeEnum(themeName.platform), themeName.version, scheme) : findThemeNameByName(_normalizeEnum(themeName), scheme)) || currentThemeName;
    return this
}

function getThemeInfo(themeName, splitter) {
    var k = themeName.indexOf(splitter);
    return k > 0 ? {
        name: themeName.substring(0, k),
        scheme: themeName.substring(k + 1)
    } : null
}

function registerThemeName(themeName, targetThemeName) {
    var themeInfo = getThemeInfo(themeName, ".") || getThemeInfo(themeName, "-") || {
            name: themeName
        },
        name = themeInfo.name,
        scheme = themeInfo.scheme;
    if (scheme) {
        themesMapping[name] = themesMapping[name] || targetThemeName;
        themesMapping[name + "." + scheme] = themesMapping[name + "-" + scheme] = targetThemeName
    } else {
        themesMapping[name] = targetThemeName
    }
}

function registerTheme(theme, baseThemeName) {
    var themeName = _normalizeEnum(theme && theme.name);
    if (themeName) {
        registerThemeName(themeName, themeName);
        themes[themeName] = _extend(true, {}, findTheme(baseThemeName), patchTheme(theme))
    }
}

function registerThemeAlias(alias, theme) {
    registerThemeName(_normalizeEnum(alias), _normalizeEnum(theme))
}

function registerThemeSchemeAlias(from, to) {
    themesSchemeMapping[from] = to
}

function mergeScalar(target, field, source, sourceValue) {
    var _value = source ? source[field] : sourceValue;
    if (void 0 !== _value && void 0 === target[field]) {
        target[field] = _value
    }
}

function mergeObject(target, field, source, sourceValue) {
    var _value = source ? source[field] : sourceValue;
    if (void 0 !== _value) {
        target[field] = _extend(true, {}, _value, target[field])
    }
}

function patchTheme(theme) {
    theme = _extend(true, {
        loadingIndicator: {
            font: {}
        },
        "export": {
            font: {}
        },
        legend: {
            font: {},
            border: {}
        },
        title: {
            font: {}
        },
        tooltip: {
            font: {}
        },
        "chart:common": {},
        "chart:common:axis": {
            grid: {},
            minorGrid: {},
            tick: {},
            minorTick: {},
            title: {
                font: {}
            },
            label: {
                font: {}
            }
        },
        chart: {
            commonSeriesSettings: {
                candlestick: {}
            }
        },
        pie: {},
        polar: {},
        gauge: {
            scale: {
                tick: {},
                minorTick: {},
                label: {
                    font: {}
                }
            }
        },
        barGauge: {},
        map: {
            background: {}
        },
        treeMap: {
            tile: {
                selectionStyle: {
                    border: {}
                }
            },
            group: {
                border: {},
                selectionStyle: {
                    border: {}
                },
                label: {
                    font: {}
                }
            }
        },
        rangeSelector: {
            scale: {
                tick: {},
                minorTick: {},
                label: {
                    font: {}
                }
            },
            chart: {}
        },
        sparkline: {},
        bullet: {}
    }, theme);
    mergeScalar(theme.loadingIndicator, "backgroundColor", theme);
    mergeScalar(theme.chart.commonSeriesSettings.candlestick, "innerColor", null, theme.backgroundColor);
    mergeScalar(theme.map.background, "color", null, theme.backgroundColor);
    mergeScalar(theme.title.font, "color", null, theme.primaryTitleColor);
    mergeObject(theme.title, "subtitle", null, theme.title);
    mergeScalar(theme.legend.font, "color", null, theme.secondaryTitleColor);
    mergeScalar(theme.legend.border, "color", null, theme.axisColor);
    patchAxes(theme);
    _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector", "sparkline", "bullet"], function(_, section) {
        mergeScalar(theme[section], "redrawOnResize", theme);
        mergeScalar(theme[section], "containerBackgroundColor", null, theme.backgroundColor);
        mergeObject(theme[section], "tooltip", theme)
    });
    _each(["chart", "pie", "polar", "gauge", "barGauge", "map", "treeMap", "rangeSelector"], function(_, section) {
        mergeObject(theme[section], "loadingIndicator", theme);
        mergeObject(theme[section], "export", theme);
        mergeObject(theme[section], "legend", theme);
        mergeObject(theme[section], "title", theme)
    });
    _each(["chart", "pie", "polar"], function(_, section) {
        mergeObject(theme, section, null, theme["chart:common"])
    });
    _each(["chart", "polar"], function(_, section) {
        theme[section] = theme[section] || {};
        mergeObject(theme[section], "commonAxisSettings", null, theme["chart:common:axis"])
    });
    mergeObject(theme.rangeSelector.chart, "commonSeriesSettings", theme.chart);
    mergeObject(theme.rangeSelector.chart, "dataPrepareSettings", theme.chart);
    mergeScalar(theme.treeMap.group.border, "color", null, theme.axisColor);
    mergeScalar(theme.treeMap.tile.selectionStyle.border, "color", null, theme.primaryTitleColor);
    mergeScalar(theme.treeMap.group.selectionStyle.border, "color", null, theme.primaryTitleColor);
    mergeScalar(theme.treeMap.group.label.font, "color", null, theme.secondaryTitleColor);
    mergeScalar(theme.map.legend, "backgroundColor", theme);
    patchMapLayers(theme);
    return theme
}

function patchAxes(theme) {
    var commonAxisSettings = theme["chart:common:axis"],
        colorFieldName = "color";
    _each([commonAxisSettings, commonAxisSettings.grid, commonAxisSettings.minorGrid, commonAxisSettings.tick, commonAxisSettings.minorTick], function(_, obj) {
        mergeScalar(obj, colorFieldName, null, theme.axisColor)
    });
    mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
    mergeScalar(commonAxisSettings.label.font, colorFieldName, null, theme.axisLabelColor);
    mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisLabelColor);
    mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
    mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
    mergeScalar(theme.rangeSelector.scale.tick, colorFieldName, null, theme.axisColor);
    mergeScalar(theme.rangeSelector.scale.minorTick, colorFieldName, null, theme.axisColor);
    mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisLabelColor)
}

function patchMapLayers(theme) {
    var map = theme.map;
    _each(["area", "line", "marker"], function(_, section) {
        mergeObject(map, "layer:" + section, null, map.layer)
    });
    _each(["dot", "bubble", "pie", "image"], function(_, section) {
        mergeObject(map, "layer:marker:" + section, null, map["layer:marker"])
    })
}

function addCacheItem(target) {
    var cacheUid = ++nextCacheUid;
    target._cache = cacheUid;
    widgetsCache[cacheUid] = target
}

function removeCacheItem(target) {
    delete widgetsCache[target._cache]
}

function refreshTheme() {
    _each(widgetsCache, function() {
        this.refresh()
    });
    return this
}
_extend(exports, {
    currentTheme: currentTheme,
    registerTheme: registerTheme,
    findTheme: findTheme,
    registerThemeAlias: registerThemeAlias,
    registerThemeSchemeAlias: registerThemeSchemeAlias,
    refreshTheme: refreshTheme,
    addCacheItem: addCacheItem,
    removeCacheItem: removeCacheItem
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (viz/core/utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    _isDefined = commonUtils.isDefined,
    _inArray = inArray,
    _each = $.each,
    _math = Math,
    _round = _math.round,
    _sqrt = Math.sqrt,
    _extend = extend;
var PI = Math.PI,
    MAX_PIXEL_COUNT = 1e10,
    PI_DIV_180 = PI / 180,
    LN10 = Math.LN10;
var cosFunc = Math.cos,
    sinFunc = Math.sin,
    abs = Math.abs,
    log = Math.log,
    floor = Math.floor,
    ceil = Math.ceil,
    max = Math.max,
    isNaN = window.isNaN,
    Number = window.Number,
    NaN = window.NaN;
var isNumber = commonUtils.isNumeric,
    isExponential = commonUtils.isExponential;
var getPrecision = function(value) {
    var stringFraction, startIndex, precision, stringValue = value.toString(),
        pointIndex = stringValue.indexOf(".");
    if (isExponential(value)) {
        precision = getDecimalOrder(value);
        if (precision < 0) {
            return Math.abs(precision)
        } else {
            return 0
        }
    }
    if (pointIndex !== -1) {
        startIndex = pointIndex + 1;
        stringFraction = stringValue.substring(startIndex, startIndex + 20);
        return stringFraction.length
    }
    return 0
};
var getLog = function(value, base) {
    if (!value) {
        return NaN
    }
    return Math.log(value) / Math.log(base)
};
var raiseTo = function(power, base) {
    return Math.pow(base, power)
};
var normalizeAngle = function(angle) {
    return (angle % 360 + 360) % 360
};
var convertAngleToRendererSpace = function(angle) {
    return 90 - angle
};
var degreesToRadians = function(value) {
    return PI * value / 180
};
var getCosAndSin = function(angle) {
    var angleInRadians = degreesToRadians(angle);
    return {
        cos: cosFunc(angleInRadians),
        sin: sinFunc(angleInRadians)
    }
};
var DECIMAL_ORDER_THRESHOLD = 1e-14;
var getDistance = function(x1, y1, x2, y2) {
    var diffX = x2 - x1,
        diffY = y2 - y1;
    return Math.sqrt(diffY * diffY + diffX * diffX)
};
var getDecimalOrder = function(number) {
    var cn, n = abs(number);
    if (!isNaN(n)) {
        if (n > 0) {
            n = log(n) / LN10;
            cn = ceil(n);
            return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
        }
        return 0
    }
    return NaN
};
var getAppropriateFormat = function(start, end, count) {
    var format, order = max(getDecimalOrder(start), getDecimalOrder(end)),
        precision = -getDecimalOrder(abs(end - start) / count);
    if (!isNaN(order) && !isNaN(precision)) {
        if (abs(order) <= 4) {
            format = "fixedPoint";
            precision < 0 && (precision = 0);
            precision > 4 && (precision = 4)
        } else {
            format = "exponential";
            precision += order - 1;
            precision > 3 && (precision = 3)
        }
        return {
            type: format,
            precision: precision
        }
    }
    return null
};
var getFraction = function(value) {
    var valueString, dotIndex;
    if (isNumber(value)) {
        valueString = value.toString();
        dotIndex = valueString.indexOf(".");
        if (dotIndex >= 0) {
            if (isExponential(value)) {
                return valueString.substr(dotIndex + 1, valueString.indexOf("e") - dotIndex - 1)
            } else {
                valueString = value.toFixed(20);
                return valueString.substr(dotIndex + 1, valueString.length - dotIndex + 1)
            }
        }
    }
    return ""
};
var getSignificantDigitPosition = function(value) {
    var i, fraction = getFraction(value);
    if (fraction) {
        for (i = 0; i < fraction.length; i++) {
            if ("0" !== fraction.charAt(i)) {
                return i + 1
            }
        }
    }
    return 0
};
var adjustValue = function(value) {
    var nextValue, i, fraction = getFraction(value);
    if (fraction) {
        for (i = 1; i <= fraction.length; i++) {
            nextValue = roundValue(value, i);
            if (0 !== nextValue && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1]) {
                return nextValue
            }
        }
    }
    return value
};
var roundValue = function(value, precision) {
    if (precision > 20) {
        precision = 20
    }
    if (isNumber(value)) {
        if (isExponential(value)) {
            return Number(value.toExponential(precision))
        } else {
            return Number(value.toFixed(precision))
        }
    }
};
var applyPrecisionByMinDelta = function(min, delta, value) {
    var minPrecision = getPrecision(min),
        deltaPrecision = getPrecision(delta);
    return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
};
var getPower = function(value) {
    return value.toExponential().split("e")[1]
};

function map(array, callback) {
    var value, i = 0,
        len = array.length,
        result = [];
    while (i < len) {
        value = callback(array[i], i);
        if (null !== value) {
            result.push(value)
        }
        i++
    }
    return result
}

function selectByKeys(object, keys) {
    return map(keys, function(key) {
        return object[key] ? object[key] : null
    })
}

function decreaseFields(object, keys, eachDecrease, decrease) {
    var dec = decrease;
    _each(keys, function(_, key) {
        if (object[key]) {
            object[key] -= eachDecrease;
            dec -= eachDecrease
        }
    });
    return dec
}

function normalizeEnum(value) {
    return String(value).toLowerCase()
}

function setCanvasValues(canvas) {
    if (canvas) {
        canvas.originalTop = canvas.top;
        canvas.originalBottom = canvas.bottom;
        canvas.originalLeft = canvas.left;
        canvas.originalRight = canvas.right
    }
}

function normalizeBBoxField(value) {
    return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0
}

function normalizeBBox(bBox) {
    var xl = normalizeBBoxField(floor(bBox.x)),
        yt = normalizeBBoxField(floor(bBox.y)),
        xr = normalizeBBoxField(ceil(bBox.width + bBox.x)),
        yb = normalizeBBoxField(ceil(bBox.height + bBox.y)),
        result = {
            x: xl,
            y: yt,
            width: xr - xl,
            height: yb - yt
        };
    result.isEmpty = !result.x && !result.y && !result.width && !result.height;
    return result
}

function rotateBBox(bBox, center, angle) {
    var cos = Number(cosFunc(angle * PI_DIV_180).toFixed(3)),
        sin = Number(sinFunc(angle * PI_DIV_180).toFixed(3)),
        w2 = bBox.width / 2,
        h2 = bBox.height / 2,
        centerX = bBox.x + w2,
        centerY = bBox.y + h2,
        w2_ = abs(w2 * cos) + abs(h2 * sin),
        h2_ = abs(w2 * sin) + abs(h2 * cos),
        centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin,
        centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
    return normalizeBBox({
        x: centerX_ - w2_,
        y: centerY_ - h2_,
        width: 2 * w2_,
        height: 2 * h2_
    })
}
extend(exports, {
    decreaseGaps: function(object, keys, decrease) {
        var arrayGaps;
        do {
            arrayGaps = selectByKeys(object, keys);
            arrayGaps.push(_math.ceil(decrease / arrayGaps.length));
            decrease = decreaseFields(object, keys, _math.min.apply(null, arrayGaps), decrease)
        } while (decrease > 0 && arrayGaps.length > 1);
        return decrease
    },
    normalizeEnum: normalizeEnum,
    parseScalar: function(value, defaultValue) {
        return void 0 !== value ? value : defaultValue
    },
    enumParser: function(values) {
        var i, ii, stored = {};
        for (i = 0, ii = values.length; i < ii; ++i) {
            stored[normalizeEnum(values[i])] = 1
        }
        return function(value, defaultValue) {
            var _value = normalizeEnum(value);
            return stored[_value] ? _value : defaultValue
        }
    },
    patchFontOptions: function(options) {
        var fontOptions = {};
        _each(options || {}, function(key, value) {
            if (/^(cursor|opacity)$/i.test(key)) {} else {
                if ("color" === key) {
                    key = "fill"
                } else {
                    key = "font-" + key
                }
            }
            fontOptions[key] = value
        });
        return fontOptions
    },
    convertPolarToXY: function(centerCoords, startAngle, angle, radius) {
        var cosSin, shiftAngle = 90;
        angle = _isDefined(angle) ? angle + startAngle - shiftAngle : 0;
        cosSin = getCosAndSin(angle);
        return {
            x: _round(centerCoords.x + radius * cosSin.cos),
            y: _round(centerCoords.y + radius * cosSin.sin)
        }
    },
    convertXYToPolar: function(centerCoords, x, y) {
        var radius = getDistance(centerCoords.x, centerCoords.y, x, y),
            angle = _math.atan2(y - centerCoords.y, x - centerCoords.x);
        return {
            phi: _round(normalizeAngle(180 * angle / _math.PI)),
            r: _round(radius)
        }
    },
    processSeriesTemplate: function(seriesTemplate, items) {
        var series, length, data, customizeSeries = commonUtils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : commonUtils.noop,
            nameField = seriesTemplate.nameField || "series",
            generatedSeries = {},
            seriesOrder = [],
            i = 0;
        items = items || [];
        for (length = items.length; i < length; i++) {
            data = items[i];
            if (nameField in data) {
                series = generatedSeries[data[nameField]];
                if (!series) {
                    series = generatedSeries[data[nameField]] = {
                        name: data[nameField],
                        data: []
                    };
                    seriesOrder.push(series.name)
                }
                series.data.push(data)
            }
        }
        return map(seriesOrder, function(orderedName) {
            var group = generatedSeries[orderedName];
            return extend(group, customizeSeries.call(null, group.name))
        })
    },
    getCategoriesInfo: function(categories, startValue, endValue) {
        if (!(categories && categories.length > 0)) {
            return {}
        }
        startValue = _isDefined(startValue) ? startValue : categories[0];
        endValue = _isDefined(endValue) ? endValue : categories[categories.length - 1];
        var visibleCategories, swapBuf, hasVisibleCategories, visibleCategoriesLen, categoriesValue = map(categories, function(category) {
                return _isDefined(category) ? category.valueOf() : null
            }),
            indexStartValue = _isDefined(startValue) ? _inArray(startValue.valueOf(), categoriesValue) : 0,
            indexEndValue = _isDefined(endValue) ? _inArray(endValue.valueOf(), categoriesValue) : categories.length - 1,
            inverted = false;
        indexStartValue < 0 && (indexStartValue = 0);
        indexEndValue < 0 && (indexEndValue = categories.length - 1);
        if (indexEndValue < indexStartValue) {
            swapBuf = indexEndValue;
            indexEndValue = indexStartValue;
            indexStartValue = swapBuf;
            inverted = true
        }
        visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
        visibleCategoriesLen = visibleCategories.length;
        hasVisibleCategories = visibleCategoriesLen > 0;
        return {
            categories: hasVisibleCategories ? visibleCategories : null,
            start: hasVisibleCategories ? visibleCategories[inverted ? visibleCategoriesLen - 1 : 0] : null,
            end: hasVisibleCategories ? visibleCategories[inverted ? 0 : visibleCategoriesLen - 1] : null,
            inverted: inverted
        }
    },
    setCanvasValues: setCanvasValues,
    updatePanesCanvases: function(panes, canvas, rotated) {
        var weightSum = 0;
        _each(panes, function(_, pane) {
            pane.weight = pane.weight || 1;
            weightSum += pane.weight
        });
        var distributedSpace = 0,
            padding = panes.padding || 10,
            paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom,
            oneWeight = (paneSpace - padding * (panes.length - 1)) / weightSum,
            startName = rotated ? "left" : "top",
            endName = rotated ? "right" : "bottom";
        _each(panes, function(_, pane) {
            var calcLength = _round(pane.weight * oneWeight);
            pane.canvas = pane.canvas || {};
            _extend(pane.canvas, canvas);
            pane.canvas[startName] = canvas[startName] + distributedSpace;
            pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
            distributedSpace = distributedSpace + calcLength + padding;
            setCanvasValues(pane.canvas)
        })
    },
    unique: function(array) {
        var values = {};
        return map(array, function(item) {
            var result = !values[item] ? item : null;
            values[item] = true;
            return result
        })
    },
    map: map,
    getVerticallyShiftedAngularCoords: function(bBox, dy, center) {
        var isPositive = bBox.x + bBox.width / 2 >= center.x,
            horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x,
            verticalOffset1 = bBox.y - center.y,
            verticalOffset2 = verticalOffset1 + dy,
            horizontalOffset2 = _round(_sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2)),
            dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
        return {
            x: center.x + (isPositive ? dx : dx - bBox.width),
            y: bBox.y + dy
        }
    }
});
exports.getPrecision = getPrecision;
exports.getLog = getLog;
exports.raiseTo = raiseTo;
exports.normalizeAngle = normalizeAngle;
exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
exports.degreesToRadians = degreesToRadians;
exports.getCosAndSin = getCosAndSin;
exports.getDecimalOrder = getDecimalOrder;
exports.getAppropriateFormat = getAppropriateFormat;
exports.getDistance = getDistance;
exports.getFraction = getFraction;
exports.adjustValue = adjustValue;
exports.roundValue = roundValue;
exports.applyPrecisionByMinDelta = applyPrecisionByMinDelta;
exports.getSignificantDigitPosition = getSignificantDigitPosition;
exports.getPower = getPower;
exports.rotateBBox = rotateBBox;
exports.normalizeBBox = normalizeBBox;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (viz/palette.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var vizUtils = __webpack_require__(159),
    _floor = Math.floor,
    _ceil = Math.ceil,
    _Color = __webpack_require__(85),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    _isArray = Array.isArray,
    _isString = commonUtils.isString,
    _extend = extend,
    _normalizeEnum = vizUtils.normalizeEnum,
    HIGHLIGHTING_STEP = 50,
    DEFAULT = "default",
    currentPaletteName = DEFAULT;
var palettes = {
    "default": {
        simpleSet: ["#5f8b95", "#ba4d51", "#af8a53", "#955f71", "#859666", "#7e688c"],
        indicatingSet: ["#a3b97c", "#e1b676", "#ec7f83"],
        gradientSet: ["#5f8b95", "#ba4d51"]
    },
    "harmony light": {
        simpleSet: ["#fcb65e", "#679ec5", "#ad79ce", "#7abd5c", "#e18e92", "#b6d623", "#b7abea", "#85dbd5"],
        indicatingSet: ["#b6d623", "#fcb65e", "#e18e92"],
        gradientSet: ["#7abd5c", "#fcb65e"]
    },
    "soft pastel": {
        simpleSet: ["#60a69f", "#78b6d9", "#6682bb", "#a37182", "#eeba69", "#90ba58", "#456c68", "#7565a4"],
        indicatingSet: ["#90ba58", "#eeba69", "#a37182"],
        gradientSet: ["#78b6d9", "#eeba69"]
    },
    pastel: {
        simpleSet: ["#bb7862", "#70b3a1", "#bb626a", "#057d85", "#ab394b", "#dac599", "#153459", "#b1d2c6"],
        indicatingSet: ["#70b3a1", "#dac599", "#bb626a"],
        gradientSet: ["#bb7862", "#70b3a1"]
    },
    bright: {
        simpleSet: ["#70c92f", "#f8ca00", "#bd1550", "#e97f02", "#9d419c", "#7e4452", "#9ab57e", "#36a3a6"],
        indicatingSet: ["#70c92f", "#f8ca00", "#bd1550"],
        gradientSet: ["#e97f02", "#f8ca00"]
    },
    soft: {
        simpleSet: ["#cbc87b", "#9ab57e", "#e55253", "#7e4452", "#e8c267", "#565077", "#6babac", "#ad6082"],
        indicatingSet: ["#9ab57e", "#e8c267", "#e55253"],
        gradientSet: ["#9ab57e", "#e8c267"]
    },
    ocean: {
        simpleSet: ["#75c099", "#acc371", "#378a8a", "#5fa26a", "#064970", "#38c5d2", "#00a7c6", "#6f84bb"],
        indicatingSet: ["#c8e394", "#7bc59d", "#397c8b"],
        gradientSet: ["#acc371", "#38c5d2"]
    },
    vintage: {
        simpleSet: ["#dea484", "#efc59c", "#cb715e", "#eb9692", "#a85c4c", "#f2c0b5", "#c96374", "#dd956c"],
        indicatingSet: ["#ffe5c6", "#f4bb9d", "#e57660"],
        gradientSet: ["#efc59c", "#cb715e"]
    },
    violet: {
        simpleSet: ["#d1a1d1", "#eeacc5", "#7b5685", "#7e7cad", "#a13d73", "#5b41ab", "#e287e2", "#689cc1"],
        indicatingSet: ["#d8e2f6", "#d0b2da", "#d56a8a"],
        gradientSet: ["#eeacc5", "#7b5685"]
    }
};

function currentPalette(name) {
    if (void 0 === name) {
        return currentPaletteName
    } else {
        name = _normalizeEnum(name);
        currentPaletteName = name in palettes ? name : DEFAULT
    }
}

function getPalette(palette, parameters) {
    var result, type = parameters && parameters.type;
    if (_isArray(palette)) {
        return palette.slice(0)
    } else {
        if (_isString(palette)) {
            result = palettes[_normalizeEnum(palette)]
        }
        if (!result) {
            result = palettes[currentPaletteName]
        }
    }
    result = result || null;
    return type ? result ? result[type].slice(0) : result : result
}

function registerPalette(name, palette) {
    var paletteName, item = {};
    if (_isArray(palette)) {
        item.simpleSet = palette.slice(0)
    } else {
        if (palette) {
            item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : void 0;
            item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : void 0;
            item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : void 0
        }
    }
    if (item.simpleSet || item.indicatingSet || item.gradientSet) {
        paletteName = _normalizeEnum(name);
        _extend(palettes[paletteName] = palettes[paletteName] || {}, item)
    }
}

function RingBuf(buf) {
    var ind = 0;
    this.next = function() {
        var res = buf[ind++];
        if (ind === buf.length) {
            this.reset()
        }
        return res
    };
    this.reset = function() {
        ind = 0
    }
}

function Palette(palette, parameters) {
    parameters = parameters || {};
    var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
    this._originalPalette = getPalette(palette, {
        type: parameters.type || "simpleSet"
    });
    this._paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
    this._resetPalette()
}
Palette.prototype = {
    constructor: Palette,
    dispose: function() {
        this._originalPalette = this._palette = this._paletteSteps = null
    },
    getNextColor: function() {
        var that = this;
        if (that._currentColor >= that._palette.length) {
            that._resetPalette()
        }
        return that._palette[that._currentColor++]
    },
    _resetPalette: function() {
        var that = this,
            step = that._paletteSteps.next();
        that._palette = step ? getAlteredPalette(that._originalPalette, step) : that._originalPalette.slice(0);
        that._currentColor = 0
    },
    reset: function() {
        this._paletteSteps.reset();
        this._resetPalette();
        return this
    }
};

function getAlteredPalette(originalPalette, step) {
    var i, palette = [],
        ii = originalPalette.length;
    for (i = 0; i < ii; ++i) {
        palette.push(getNewColor(originalPalette[i], step))
    }
    return palette
}

function getNewColor(currentColor, step) {
    var newColor = new _Color(currentColor).alter(step),
        lightness = getLightness(newColor);
    if (lightness > 200 || lightness < 55) {
        newColor = new _Color(currentColor).alter(-step / 2)
    }
    return newColor.toHex()
}

function getLightness(color) {
    return .3 * color.r + .59 * color.g + .11 * color.b
}

function DiscretePalette(source, size) {
    var palette = size > 0 ? createDiscreteColors(getPalette(source, {
        type: "gradientSet"
    }), size) : [];
    this.getColor = function(index) {
        return palette[index] || null
    }
}

function createDiscreteColors(source, count) {
    var i, colorCount = count - 1,
        sourceCount = source.length - 1,
        colors = [],
        gradient = [];

    function addColor(pos) {
        var k = sourceCount * pos,
            kl = _floor(k),
            kr = _ceil(k);
        gradient.push(colors[kl].blend(colors[kr], k - kl).toHex())
    }
    for (i = 0; i <= sourceCount; ++i) {
        colors.push(new _Color(source[i]))
    }
    if (colorCount > 0) {
        for (i = 0; i <= colorCount; ++i) {
            addColor(i / colorCount)
        }
    } else {
        addColor(.5)
    }
    return gradient
}

function GradientPalette(source) {
    var palette = getPalette(source, {
            type: "gradientSet"
        }),
        color1 = new _Color(palette[0]),
        color2 = new _Color(palette[1]);
    this.getColor = function(ratio) {
        return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null
    }
}
_extend(exports, {
    Palette: Palette,
    DiscretePalette: DiscretePalette,
    GradientPalette: GradientPalette,
    registerPalette: registerPalette,
    getPalette: getPalette,
    currentPalette: currentPalette
});


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/file_saver.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    browser = __webpack_require__(21),
    commonUtils = __webpack_require__(2),
    FILE_EXTESIONS = {
        EXCEL: "xlsx",
        CSS: "css",
        PNG: "png",
        JPEG: "jpeg",
        GIF: "gif",
        SVG: "svg",
        PDF: "pdf"
    };
var MIME_TYPES = exports.MIME_TYPES = {
    CSS: "text/css",
    EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    PNG: "image/png",
    JPEG: "image/jpeg",
    GIF: "image/gif",
    SVG: "image/svg+xml",
    PDF: "application/pdf"
};
exports.fileSaver = {
    _getDataUri: function(format, data) {
        return "data:" + MIME_TYPES[format] + ";base64," + data
    },
    _linkDownloader: function(fileName, href, callback) {
        var exportLinkElement = document.createElement("a"),
            attributes = {
                download: fileName,
                href: href
            };
        document.body.appendChild(exportLinkElement);
        $(exportLinkElement).css({
            display: "none"
        }).text("load").attr(attributes)[0].click();
        return exportLinkElement
    },
    _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
        var formAttributes = {
                method: "post",
                action: proxyUrl,
                enctype: "multipart/form-data"
            },
            exportForm = $("<form>").css({
                display: "none"
            }).attr(formAttributes);
        exportForm.append('<input type="hidden" name="fileName" value="' + fileName + '" />');
        exportForm.append('<input type="hidden" name="contentType" value="' + contentType + '" />');
        exportForm.append('<input type="hidden" name="data" value="' + data + '" />');
        exportForm.appendTo("body");
        exportForm.submit();
        if (exportForm.submit()) {
            exportForm.remove()
        }
    },
    _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
        return this._formDownloader(proxyUrl, fileName, MIME_TYPES[format], data, callback)
    },
    _winJSBlobSave: function(blob, fileName, format) {
        var savePicker = new Windows.Storage.Pickers.FileSavePicker;
        savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
        savePicker.fileTypeChoices.insert(MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
        savePicker.suggestedFileName = fileName;
        savePicker.pickSaveFileAsync().then(function(file) {
            if (file) {
                file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
                    var inputStream = blob.msDetachStream();
                    Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                        outputStream.flushAsync().done(function() {
                            inputStream.close();
                            outputStream.close()
                        })
                    })
                })
            }
        })
    },
    _saveBlobAs: function(fileName, format, data, linkClick) {
        this._blobSaved = false;
        if (commonUtils.isDefined(navigator.msSaveOrOpenBlob)) {
            navigator.msSaveOrOpenBlob(data, fileName);
            this._blobSaved = true
        } else {
            if (commonUtils.isDefined(window.WinJS)) {
                this._winJSBlobSave(data, fileName, format);
                this._blobSaved = true
            } else {
                var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                linkClick = commonUtils.isDefined(linkClick) ? linkClick : function() {
                    var link = $("#dxExportLink");
                    URL.revokeObjectURL(link.attr("href"));
                    link.remove()
                };
                if (commonUtils.isDefined(URL)) {
                    return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
                }
            }
        }
    },
    saveAs: function(fileName, format, data, proxyURL, linkClick) {
        fileName += "." + FILE_EXTESIONS[format];
        if (commonUtils.isFunction(window.Blob)) {
            this._saveBlobAs(fileName, format, data)
        } else {
            if (commonUtils.isDefined(proxyURL) && !commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
                this._saveByProxy(proxyURL, fileName, format, data)
            } else {
                if (!commonUtils.isDefined(navigator.userAgent.match(/iPad/i))) {
                    errors.log("E1034")
                }
                if (browser.msie && parseInt(browser.version) < 10) {
                    return
                }
                this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
            }
        }
    }
};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/excel_creator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(16),
    stringUtils = __webpack_require__(30),
    JSZip = __webpack_require__(244),
    fileSaver = __webpack_require__(161),
    excelFormatConverter = __webpack_require__(163),
    XML_TAG = '<?xml version="1.0" encoding="utf-8"?>',
    GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>',
    SINGLE_SHEET_PR_XML = "<sheetPr/>",
    BASE_STYLE_XML = '<fonts count="2"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font><font><b/><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="1"><fill><patternFill patternType="none"/></fill></fills><borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin"><color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/></bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>',
    OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
    RELATIONSHIP_PART_NAME = "rels",
    XL_FOLDER_NAME = "xl",
    WORKBOOK_FILE_NAME = "workbook.xml",
    CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
    SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
    STYLE_FILE_NAME = "styles.xml",
    WORKSHEETS_FOLDER = "worksheets",
    WORKSHEET_FILE_NAME = "sheet1.xml",
    VALID_TYPES = {
        "boolean": "b",
        date: "d",
        number: "n",
        string: "s"
    },
    EXCEL_START_TIME = Date.UTC(1899, 11, 30),
    DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
    BOLD_STYLES_COUNT = 4,
    MAX_DIGIT_WIDTH_IN_PIXELS = 7,
    CUSTOM_FORMAT_START_INDEX = 165;
exports.ExcelCreator = Class.inherit({
    _getXMLTag: function(tagName, attributes, content) {
        var i, attr, result = "<" + tagName,
            length = attributes.length;
        for (i = 0; i < length; i++) {
            attr = attributes[i];
            result = result + " " + attr.name + '="' + attr.value + '"'
        }
        return commonUtils.isDefined(content) ? result + ">" + content + "</" + tagName + ">" : result + " />"
    },
    _getCellIndex: function(rowIndex, cellIndex) {
        var charCode, sheetIndex = "",
            max = 26;
        if (this._maxIndex[0] < Number(rowIndex)) {
            this._maxIndex[0] = Number(rowIndex)
        }
        if (this._maxIndex[1] < Number(cellIndex)) {
            this._maxIndex[1] = Number(cellIndex)
        }
        while (true) {
            charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
            sheetIndex = String.fromCharCode(charCode) + sheetIndex;
            if (cellIndex >= max) {
                cellIndex = Math.floor(cellIndex / max) - 1
            } else {
                break
            }
        }
        return sheetIndex + rowIndex
    },
    _getDataType: function(dataType) {
        return VALID_TYPES[dataType] || "s"
    },
    _formatObjectConverter: function(format, precision, dataType) {
        var result = {
            format: format,
            precision: precision,
            dataType: dataType
        };
        if (commonUtils.isObject(format)) {
            return extend(result, format, {
                format: format.type,
                currency: format.currency
            })
        }
        return result
    },
    _appendFormat: function(format, precision, dataType) {
        var currency, newFormat = this._formatObjectConverter(format, precision, dataType);
        format = newFormat.format;
        precision = newFormat.precision;
        currency = newFormat.currency;
        dataType = newFormat.dataType;
        format = excelFormatConverter.convertFormat(format, precision, dataType, currency);
        if (format) {
            if (inArray(format, this._styleFormat) === -1) {
                this._styleFormat.push(format)
            }
            return inArray(format, this._styleFormat) + 1
        }
    },
    _appendString: function(value) {
        if (commonUtils.isDefined(value)) {
            value = String(value);
            if (value.length) {
                value = stringUtils.encodeHtml(value);
                if (void 0 === this._stringHash[value]) {
                    this._stringHash[value] = this._stringArray.length;
                    this._stringArray.push(value)
                }
                return this._stringHash[value]
            }
        }
    },
    _getExcelDateValue: function(date) {
        var days, totalTime;
        if (commonUtils.isDate(date)) {
            days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / 864e5);
            if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
                days--
            }
            totalTime = (3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()) / 86400;
            return days + totalTime
        }
    },
    _prepareValue: function(rowIndex, cellIndex) {
        var dataProvider = this._dataProvider,
            value = dataProvider.getCellValue(rowIndex, cellIndex),
            type = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex)),
            formatID = this._styleArray[this._dataProvider.getStyleId(rowIndex, cellIndex)].formatID,
            format = commonUtils.isNumeric(formatID) ? this._styleFormat[formatID - 1] : null;
        if ("d" === type && !commonUtils.isDate(value)) {
            type = "s"
        }
        switch (type) {
            case "s":
                value = this._appendString(value);
                break;
            case "d":
                value = this._getExcelDateValue(value, format);
                type = "n"
        }
        return {
            value: value,
            type: type
        }
    },
    _getDataArray: function() {
        var rowIndex, cellIndex, cellsArray, cellData, cellsLength, that = this,
            result = [],
            dataProvider = that._dataProvider,
            rowsLength = dataProvider.getRowsCount(),
            columns = dataProvider.getColumns();
        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
            cellsArray = [];
            cellsLength = columns.length;
            for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
                cellData = that._prepareValue(rowIndex, cellIndex);
                cellsArray.push({
                    style: dataProvider.getStyleId(rowIndex, cellIndex),
                    value: cellData.value,
                    type: cellData.type
                })
            }
            if (!that._needSheetPr && dataProvider.getGroupLevel(rowIndex) > 0) {
                that._needSheetPr = true
            }
            result.push(cellsArray)
        }
        return result
    },
    _getBoldStyleID: function(alignment) {
        for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++) {
            if (this._styleArray[i].alignment === alignment) {
                return i
            }
        }
    },
    _calculateWidth: function(pixelsWidth) {
        pixelsWidth = parseInt(pixelsWidth, 10);
        if (!pixelsWidth || pixelsWidth < 5) {
            pixelsWidth = 100
        }
        return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + .5) / 100)
    },
    _prepareStyleData: function() {
        var that = this,
            styles = that._dataProvider.getStyles();
        that._dataProvider.getColumns().forEach(function(column) {
            that._colsArray.push(that._calculateWidth(column.width))
        });
        styles.forEach(function(style) {
            that._styleArray.push({
                bold: !!style.bold,
                alignment: style.alignment || "left",
                formatID: that._appendFormat(style.format, style.precision, style.dataType),
                wrapText: style.wrapText
            })
        })
    },
    _prepareCellData: function() {
        this._cellsArray = this._getDataArray()
    },
    _createXMLRelationships: function(xmlRelationships) {
        return this._getXMLTag("Relationships", [{
            name: "xmlns",
            value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
        }], xmlRelationships)
    },
    _createXMLRelationship: function(id, type, target) {
        return this._getXMLTag("Relationship", [{
            name: "Id",
            value: "rId" + id
        }, {
            name: "Type",
            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type
        }, {
            name: "Target",
            value: target
        }])
    },
    _getWorkbookContent: function() {
        var content = '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/></bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames><definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName><definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>';
        return XML_TAG + this._getXMLTag("workbook", [{
            name: "xmlns:r",
            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
        }, {
            name: "xmlns",
            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
        }], content)
    },
    _getContentTypesContent: function() {
        return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>'
    },
    _generateStylesXML: function() {
        var formatIndex, that = this,
            folder = that._zip.folder(XL_FOLDER_NAME),
            xmlStyles = [],
            XML = "";
        for (formatIndex = 0; formatIndex < that._styleFormat.length; formatIndex++) {
            that._styleFormat[formatIndex] = that._getXMLTag("numFmt", [{
                name: "numFmtId",
                value: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX
            }, {
                name: "formatCode",
                value: that._styleFormat[formatIndex]
            }])
        }
        XML = XML + that._getXMLTag("numFmts", [{
            name: "count",
            value: that._styleFormat.length
        }], that._styleFormat.join("")) + BASE_STYLE_XML;
        this._styleArray.forEach(function(style) {
            xmlStyles.push(that._getXMLTag("xf", [{
                name: "xfId",
                value: 0
            }, {
                name: "applyAlignment",
                value: 1
            }, {
                name: "fontId",
                value: Number(!!style.bold)
            }, {
                name: "applyNumberFormat",
                value: commonUtils.isDefined(style.formatID) ? 1 : 0
            }, {
                name: "numFmtId",
                value: commonUtils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
            }], that._getXMLTag("alignment", [{
                name: "vertical",
                value: "top"
            }, {
                name: "wrapText",
                value: Number(!!style.wrapText)
            }, {
                name: "horizontal",
                value: style.alignment
            }])))
        });
        XML += that._getXMLTag("cellXfs", [{
            name: "count",
            value: xmlStyles.length
        }], xmlStyles.join(""));
        XML += that._getXMLTag("cellStyles", [{
            name: "count",
            value: 1
        }], that._getXMLTag("cellStyle", [{
            name: "name",
            value: "Normal"
        }, {
            name: "xfId",
            value: 0
        }, {
            name: "builtinId",
            value: 0
        }]));
        XML = XML_TAG + that._getXMLTag("styleSheet", [{
            name: "xmlns",
            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
        }], XML);
        folder.file(STYLE_FILE_NAME, XML);
        that._styleArray = []
    },
    _generateStringsXML: function() {
        var stringIndex, folder = this._zip.folder(XL_FOLDER_NAME),
            stringsLength = this._stringArray.length,
            sharedStringXml = XML_TAG;
        for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
            this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]))
        }
        sharedStringXml += this._getXMLTag("sst", [{
            name: "xmlns",
            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
        }, {
            name: "count",
            value: this._stringArray.length
        }, {
            name: "uniqueCount",
            value: this._stringArray.length
        }], this._stringArray.join(""));
        folder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
        this._stringArray = []
    },
    _getPaneXML: function() {
        var attributes = [{
                name: "activePane",
                value: "bottomLeft"
            }, {
                name: "state",
                value: "frozen"
            }],
            frozenArea = this._dataProvider.getFrozenArea();
        if (!(frozenArea.x || frozenArea.y)) {
            return ""
        }
        if (frozenArea.x) {
            attributes.push({
                name: "xSplit",
                value: frozenArea.x
            })
        }
        if (frozenArea.y) {
            attributes.push({
                name: "ySplit",
                value: frozenArea.y
            })
        }
        attributes.push({
            name: "topLeftCell",
            value: this._getCellIndex(frozenArea.y + 1, frozenArea.x)
        });
        return this._getXMLTag("pane", attributes)
    },
    _generateWorksheetXML: function() {
        var colIndex, rowIndex, cellData, xmlCells, maxCellIndex, cellsLength, counter = 0,
            xmlRows = [],
            rowsLength = this._cellsArray.length,
            colsLength = this._colsArray.length,
            rSpans = "1:" + colsLength,
            headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1,
            xmlResult = [
                ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">', this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, '<dimension ref="A1:', this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + '"/><sheetViews><sheetView ' + (this._rtlEnabled ? 'rightToLeft="1" ' : "") + 'tabSelected="1" workbookViewId="0">' + this._getPaneXML() + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" outlineLevelRow="', this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, '" x14ac:dyDescent="0.25"/>'].join("")
            ];
        for (colIndex = 0; colIndex < colsLength; colIndex++) {
            this._colsArray[colIndex] = this._getXMLTag("col", [{
                name: "width",
                value: this._colsArray[colIndex]
            }, {
                name: "min",
                value: Number(colIndex) + 1
            }, {
                name: "max",
                value: Number(colIndex) + 1
            }])
        }
        xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
            xmlCells = [];
            cellsLength = this._cellsArray[rowIndex].length;
            for (colIndex = 0; colIndex < cellsLength; colIndex++) {
                rowIndex = Number(rowIndex);
                cellData = this._cellsArray[rowIndex][colIndex];
                xmlCells.push(this._getXMLTag("c", [{
                    name: "r",
                    value: this._getCellIndex(rowIndex + 1, colIndex)
                }, {
                    name: "s",
                    value: cellData.style
                }, {
                    name: "t",
                    value: cellData.type
                }], commonUtils.isDefined(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null))
            }
            xmlRows.push(this._getXMLTag("row", [{
                name: "r",
                value: Number(rowIndex) + 1
            }, {
                name: "spans",
                value: rSpans
            }, {
                name: "outlineLevel",
                value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(rowIndex) : 0
            }, {
                name: "x14ac:dyDescent",
                value: "0.25"
            }], xmlCells.join("")));
            this._cellsArray[rowIndex] = null;
            if (counter++ > 1e4) {
                xmlResult.push(xmlRows.join(""));
                xmlRows = [];
                counter = 0
            }
        }
        xmlResult.push(xmlRows.join(""));
        xmlRows = [];
        maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
        xmlResult.push("</sheetData>" + (this._options.autoFilterEnabled ? '<autoFilter ref="A' + this._dataProvider.getHeaderRowCount() + ":" + maxCellIndex + '" />' : "") + this._generateMergingXML() + '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors></worksheet>');
        this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
        this._colsArray = [];
        this._cellsArray = [];
        xmlResult = []
    },
    _generateMergingXML: function() {
        var k, l, cellIndex, rowIndex, mergeArrayLength, mergeIndex, rowsLength = commonUtils.isDefined(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount(),
            columnsLength = this._dataProvider.getColumns().length,
            usedArea = [],
            mergeArray = [],
            mergeXML = "";
        for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
            for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
                if (!commonUtils.isDefined(usedArea[rowIndex]) || !commonUtils.isDefined(usedArea[rowIndex][cellIndex])) {
                    var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
                    if (cellMerge.colspan || cellMerge.rowspan) {
                        mergeArray.push({
                            start: this._getCellIndex(rowIndex + 1, cellIndex),
                            end: this._getCellIndex(rowIndex + 1 + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
                        });
                        for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
                            for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                                if (!commonUtils.isDefined(usedArea[k])) {
                                    usedArea[k] = []
                                }
                                usedArea[k][l] = true
                            }
                        }
                    }
                }
            }
        }
        mergeArrayLength = mergeArray.length;
        for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
            mergeXML += this._getXMLTag("mergeCell", [{
                name: "ref",
                value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
            }])
        }
        return mergeXML.length ? this._getXMLTag("mergeCells", [{
            name: "count",
            value: mergeArrayLength
        }], mergeXML) : ""
    },
    _generateCommonXML: function() {
        var xmlRelationships, relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
            folder = this._zip.folder(XL_FOLDER_NAME),
            relsXML = XML_TAG;
        this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
        xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
        relsXML += this._createXMLRelationships(xmlRelationships);
        folder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
        folder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
        this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
    },
    _generateContent: function() {
        this._prepareStyleData();
        this._prepareCellData();
        this._generateWorkXML();
        this._generateCommonXML()
    },
    _generateWorkXML: function() {
        this._generateStylesXML();
        this._generateStringsXML();
        this._generateWorksheetXML()
    },
    ctor: function(dataProvider, options) {
        this._rtlEnabled = options && !!options.rtlEnabled;
        this._options = options;
        this._maxIndex = [1, 2];
        this._stringArray = [];
        this._stringHash = {};
        this._styleArray = [];
        this._colsArray = [];
        this._cellsArray = [];
        this._styleFormat = [];
        this._needSheetPr = false;
        this._dataProvider = dataProvider;
        if (commonUtils.isDefined(JSZip)) {
            this._zip = new JSZip
        } else {
            this._zip = null
        }
    },
    _checkZipState: function() {
        if (!this._zip) {
            throw errors.Error("E1041")
        }
    },
    ready: function() {
        return this._dataProvider.ready()
    },
    getData: function(isBlob) {
        var options = {
            type: isBlob ? "blob" : "base64",
            compression: "DEFLATE",
            mimeType: fileSaver.MIME_TYPES.EXCEL
        };
        this._checkZipState();
        this._generateContent();
        return this._zip.generateAsync ? this._zip.generateAsync(options) : this._zip.generate(options)
    }
});
exports.getData = function(data, options, callback) {
    var excelCreator = new exports.ExcelCreator(data, options);
    excelCreator._checkZipState();
    excelCreator.ready().done(function() {
        if (excelCreator._zip.generateAsync) {
            excelCreator.getData(commonUtils.isFunction(window.Blob)).then(callback)
        } else {
            callback(excelCreator.getData(commonUtils.isFunction(window.Blob)))
        }
    })
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/excel_format_converter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var commonUtils = __webpack_require__(2),
    stringUtils = __webpack_require__(30),
    numberFormatter = __webpack_require__(44),
    dateLocalization = __webpack_require__(32),
    getLanguageID = __webpack_require__(245).getLanguageId,
    UNSUPPORTED_FORMAT_MAPPING = {
        quarter: "shortDate",
        quarterAndYear: "shortDate",
        minute: "longTime",
        millisecond: "longTime"
    },
    FORMAT_SEPARATORS = " .,:;/\\<>()-",
    ARABIC_ZERO_CODE = 1632,
    DEFINED_NUMBER_FORMTATS = {
        thousands: "#,##0{0},&quot;K&quot;",
        millions: "#,##0{0},,&quot;M&quot;",
        billions: "#,##0{0},,,&quot;B&quot;",
        trillions: "#,##0{0},,,,&quot;T&quot;",
        percent: "0{0}%",
        decimal: "#{0}",
        fixedpoint: "#,##0{0}",
        exponential: "0{0}E+00",
        currency: " "
    };
__webpack_require__(105);
var excelFormatConverter = module.exports = {
    _applyPrecision: function(format, precision) {
        var result, i;
        if (precision > 0) {
            result = "decimal" !== format ? "." : "";
            for (i = 0; i < precision; i++) {
                result += "0"
            }
            return result
        }
        return ""
    },
    _getCurrencyFormat: function(currency) {
        return numberFormatter.getOpenXmlCurrencyFormat(currency)
    },
    _isDigit: function(char) {
        var code = char && char.charCodeAt(0);
        return char >= "0" && char <= "9" || code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10
    },
    _getDifference: function(defaultPattern, patterns, processedIndexes) {
        var isDigit, i = 0,
            that = this,
            result = [];
        var patternsFilter = function(pattern) {
            return defaultPattern[i] !== pattern[i]
        };
        if (!Array.isArray(patterns)) {
            patterns = [patterns]
        }
        for (i = 0; i < defaultPattern.length; i++) {
            if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
                do {
                    isDigit = that._isDigit(defaultPattern[i]);
                    if (!result.length && !isDigit && that._isDigit(patterns[0][i])) {
                        break
                    }
                    result.push(i);
                    processedIndexes.unshift(i);
                    i++
                } while (defaultPattern[i] && FORMAT_SEPARATORS.indexOf(defaultPattern[i]) < 0 && isDigit === that._isDigit(defaultPattern[i]));
                break
            }
        }
        if (1 === result.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "" === defaultPattern[processedIndexes[0] - 1])) {
            processedIndexes.unshift(processedIndexes[0] - 1)
        }
        return result
    },
    _replaceCharsCore: function(pattern, indexes, char, patternPositions) {
        var baseCharIndex = indexes[0];
        var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
        indexes.forEach(function(_, index) {
            pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1)
        });
        if (1 === indexes.length) {
            pattern = pattern.replace("0" + char, char + char);
            pattern = pattern.replace("" + char, char + char)
        }
        return pattern
    },
    _replaceChars: function(pattern, indexes, char, patternPositions) {
        var i, index, patternIndex;
        if (!this._isDigit(pattern[indexes[0]] || "0")) {
            var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
            while (indexes.length > letterCount) {
                index = indexes.pop();
                patternIndex = patternPositions[index];
                patternPositions[index] = -1;
                for (i = index + 1; i < patternPositions.length; i++) {
                    patternPositions[i]--
                }
                pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1)
            }
            index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;
            while (indexes.length < letterCount) {
                indexes.push(indexes[indexes.length - 1] + 1);
                for (i = index; i < patternPositions.length; i++) {
                    patternPositions[i]++
                }
                pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex)
            }
        }
        pattern = this._replaceCharsCore(pattern, indexes, char, patternPositions);
        return pattern
    },
    _format: function(value, format) {
        if (Array.isArray(value)) {
            return value.map(function(value) {
                return (dateLocalization.format(value, format) || "").toString()
            })
        }
        return (dateLocalization.format(value, format) || "").toString()
    },
    _escapeChars: function(pattern, defaultPattern, processedIndexes, patternPositions) {
        var escapeIndexes = defaultPattern.split("").map(function(char, index) {
            if (processedIndexes.indexOf(index) < 0 && (FORMAT_SEPARATORS.indexOf(char) < 0 || "/" === char)) {
                return patternPositions[index]
            }
            return -1
        });
        pattern = pattern.split("").map(function(char, index) {
            if (escapeIndexes.indexOf(index) >= 0) {
                return "\\" + char
            }
            return char
        }).join("");
        pattern = pattern.replace("AM\\/PM", "AM/PM");
        return pattern
    },
    _hasArabicDigits: function(text) {
        var code;
        for (var i = 0; i < text.length; i++) {
            code = text.charCodeAt(i);
            if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
                return true
            }
        }
        return false
    },
    _convertDateFormat: function(format) {
        format = UNSUPPORTED_FORMAT_MAPPING[format && format.type || format] || format;
        var that = this,
            processedIndexes = [],
            defaultPattern = that._format(new Date(2009, 8, 8, 6, 5, 4), format),
            patternPositions = defaultPattern.split("").map(function(_, index) {
                return index
            }),
            result = defaultPattern,
            datePatterns = [{
                date: new Date(2009, 8, 8, 6, 5, 2),
                pattern: "s"
            }, {
                date: new Date(2009, 8, 8, 6, 2, 4),
                pattern: "m"
            }, {
                date: new Date(2009, 8, 8, 2, 5, 4),
                pattern: "H"
            }, {
                date: new Date(2009, 8, 8, 18, 5, 4),
                pattern: "AM/PM"
            }, {
                date: new Date(2009, 8, 1, 6, 5, 4),
                pattern: "d"
            }, {
                date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
                pattern: "d"
            }, {
                date: new Date(2009, 9, 6, 6, 5, 4),
                pattern: "M"
            }, {
                date: new Date(1998, 8, 8, 6, 5, 4),
                pattern: "y"
            }];
        if (!result) {
            return
        }
        datePatterns.forEach(function(test) {
            var diff = that._getDifference(defaultPattern, that._format(test.date, format), processedIndexes);
            result = that._replaceChars(result, diff, test.pattern, patternPositions)
        });
        result = that._escapeChars(result, defaultPattern, processedIndexes, patternPositions);
        result = that._getLanguageInfo(defaultPattern) + result;
        return result
    },
    _getLanguageInfo: function(defaultPattern) {
        var languageID = getLanguageID(),
            languageIDStr = languageID ? languageID.toString(16) : "",
            languageInfo = "";
        if (this._hasArabicDigits(defaultPattern)) {
            while (languageIDStr.length < 3) {
                languageIDStr = "0" + languageIDStr
            }
            languageInfo = "[$-2010" + languageIDStr + "]"
        } else {
            if (languageIDStr) {
                languageInfo = "[$-" + languageIDStr + "]"
            }
        }
        return languageInfo
    },
    _convertNumberFormat: function(format, precision, currency) {
        var result, excelFormat = "currency" === format ? this._getCurrencyFormat(currency) : DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
        if (excelFormat) {
            result = stringUtils.format(excelFormat, this._applyPrecision(format, precision))
        }
        return result
    },
    convertFormat: function(format, precision, type, currency) {
        if (commonUtils.isDefined(format)) {
            if ("date" === type) {
                return excelFormatConverter._convertDateFormat(format)
            } else {
                if (commonUtils.isString(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
                    return excelFormatConverter._convertNumberFormat(format, precision, currency)
                }
            }
        }
    }
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/svg_creator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    getSvgMarkup = __webpack_require__(247).getSvgMarkup,
    when = __webpack_require__(10).when;
exports.svgCreator = {
    _markup: "",
    _imageArray: {},
    _imageDeferreds: [],
    _getBinaryFile: function(src, callback) {
        var xhr = new XMLHttpRequest;
        xhr.onreadystatechange = function() {
            if (xhr.readyState === xhr.DONE) {
                if (200 === xhr.status && xhr.response) {
                    callback(xhr.response)
                } else {
                    callback(false)
                }
            }
        };
        xhr.open("GET", src, true);
        xhr.responseType = "arraybuffer";
        xhr.send()
    },
    _loadImages: function() {
        var that = this;
        $.each(that._imageArray, function(src) {
            var deferred = new $.Deferred;
            that._imageDeferreds.push(deferred);
            that._getBinaryFile(src, function(response) {
                if (!response) {
                    delete that._imageArray[src];
                    deferred.resolve();
                    return
                }
                var i, binary = "",
                    bytes = new Uint8Array(response),
                    length = bytes.byteLength;
                for (i = 0; i < length; i++) {
                    binary += String.fromCharCode(bytes[i])
                }
                that._imageArray[src] = "data:image/png;base64," + btoa(binary);
                deferred.resolve()
            })
        })
    },
    _parseImages: function(element) {
        var href, that = this;
        if ("image" === element.tagName) {
            href = $(element).attr("xlink:href");
            if (!that._imageArray[href]) {
                that._imageArray[href] = ""
            }
        }
        $.each(element.childNodes, function(_, element) {
            that._parseImages(element)
        })
    },
    _prepareImages: function(svgElem) {
        this._parseImages(svgElem);
        this._loadImages();
        return when.apply($, this._imageDeferreds)
    },
    getData: function(data, options) {
        var markup, that = this,
            xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>',
            blob = $.Deferred(),
            parser = new DOMParser,
            elem = parser.parseFromString(data, "image/svg+xml"),
            svgElem = elem.childNodes[0],
            $svgObject = $(svgElem);
        $svgObject.css("background-color", options.backgroundColor);
        markup = xmlVersion + getSvgMarkup($svgObject.get(0));
        that._prepareImages(svgElem).done(function() {
            $.each(that._imageArray, function(href, dataURI) {
                markup = markup.split(href).join(dataURI)
            });
            blob.resolve(commonUtils.isFunction(window.Blob) ? that._getBlob(markup) : that._getBase64(markup))
        });
        return blob
    },
    _getBlob: function(markup) {
        return new Blob([markup], {
            type: "image/svg+xml"
        })
    },
    _getBase64: function(markup) {
        return window.btoa(markup)
    }
};
exports.getData = function(data, options, callback) {
    exports.svgCreator.getData(data, options).done(callback)
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/memorized_callbacks.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var MemorizedCallbacks = function() {
    var memory = [];
    var callbacks = $.Callbacks();
    this.add = function(fn) {
        $.each(memory, function(_, item) {
            fn.apply(fn, item)
        });
        callbacks.add(fn)
    };
    this.remove = function(fn) {
        callbacks.remove(fn)
    };
    this.fire = function() {
        memory.push(arguments);
        callbacks.fire.apply(callbacks, arguments)
    }
};
module.exports = MemorizedCallbacks;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (mobile/init_mobile_viewport/init_mobile_viewport.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    resizeCallbacks = __webpack_require__(61).resizeCallbacks,
    support = __webpack_require__(24),
    devices = __webpack_require__(6);
var initMobileViewport = function(options) {
    options = extend({}, options);
    var realDevice = devices.real();
    var allowZoom = options.allowZoom;
    var allowPan = options.allowPan;
    var allowSelection = "allowSelection" in options ? options.allowSelection : "generic" === realDevice.platform;
    var metaSelector = "meta[name=viewport]";
    if (!$(metaSelector).length) {
        $("<meta />").attr("name", "viewport").appendTo("head")
    }
    var metaVerbs = ["width=device-width"],
        msTouchVerbs = [];
    if (allowZoom) {
        msTouchVerbs.push("pinch-zoom")
    } else {
        metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no")
    }
    if (allowPan) {
        msTouchVerbs.push("pan-x", "pan-y")
    }
    if (!allowPan && !allowZoom) {
        $("html, body").css({
            "-ms-content-zooming": "none",
            "-ms-user-select": "none",
            overflow: "hidden"
        })
    } else {
        $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar")
    }
    if (!allowSelection && support.supportProp("user-select")) {
        $(".dx-viewport").css(support.styleProp("user-select"), "none")
    }
    $(metaSelector).attr("content", metaVerbs.join());
    $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
    realDevice = devices.real();
    if (support.touch && !("win" === realDevice.platform && 10 === realDevice.version[0])) {
        $(document).off(".dxInitMobileViewport").on("dxpointermove.dxInitMobileViewport", function(e) {
            var count = e.pointers.length,
                isTouchEvent = "touch" === e.pointerType,
                zoomDisabled = !allowZoom && count > 1,
                panDisabled = !allowPan && 1 === count && !e.isScrollingEvent;
            if (isTouchEvent && (zoomDisabled || panDisabled)) {
                e.preventDefault()
            }
        })
    }
    if (realDevice.ios) {
        var isPhoneGap = "file:" === document.location.protocol;
        if (!isPhoneGap) {
            resizeCallbacks.add(function() {
                var windowWidth = $(window).width();
                $("body").width(windowWidth)
            })
        }
    }
    if (realDevice.android) {
        resizeCallbacks.add(function() {
            setTimeout(function() {
                document.activeElement.scrollIntoViewIfNeeded()
            })
        })
    }
};
exports.initMobileViewport = initMobileViewport;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (mobile/process_hardware_back_button.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    hardwareBack = $.Callbacks();
module.exports = function() {
    hardwareBack.fire()
};
module.exports.processCallback = hardwareBack;
module.exports.default = module.exports;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (format_helper.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    dateUtils = __webpack_require__(55),
    numberLocalization = __webpack_require__(44),
    dateLocalization = __webpack_require__(32),
    dependencyInjector = __webpack_require__(72),
    logger = __webpack_require__(83).logger;
__webpack_require__(105);
module.exports = dependencyInjector({
    format: function(value, format, precision) {
        var formatIsValid = commonUtils.isString(format) && "" !== format || typeUtils.isPlainObject(format) || commonUtils.isFunction(format),
            valueIsValid = commonUtils.isNumeric(value) || commonUtils.isDate(value);
        if (!formatIsValid || !valueIsValid) {
            return commonUtils.isDefined(value) ? value.toString() : ""
        }
        if (commonUtils.isFunction(format)) {
            return format(value)
        }
        if (void 0 !== precision) {
            logger.warn("Option 'precision' is deprecated. Use field 'precision' of a format object instead.")
        }
        if (commonUtils.isString(format)) {
            format = {
                type: format,
                precision: precision
            }
        }
        if (commonUtils.isNumeric(value)) {
            return numberLocalization.format(value, format)
        }
        if (commonUtils.isDate(value)) {
            return dateLocalization.format(value, format)
        }
    },
    getTimeFormat: function(showSecond) {
        return showSecond ? "longtime" : "shorttime"
    },
    _normalizeFormat: function(format) {
        if (!Array.isArray(format)) {
            return format
        }
        if (1 === format.length) {
            return format[0]
        }
        return function(date) {
            return format.map(function(formatPart) {
                return dateLocalization.format(date, formatPart)
            }).join(" ")
        }
    },
    getDateFormatByDifferences: function(dateDifferences) {
        var resultFormat = [];
        if (dateDifferences.millisecond) {
            resultFormat.push("millisecond")
        }
        if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second) {
            resultFormat.unshift(this.getTimeFormat(dateDifferences.second))
        }
        if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
            resultFormat.unshift("shortdate");
            return this._normalizeFormat(resultFormat)
        }
        if (dateDifferences.year && dateDifferences.month) {
            return "monthandyear"
        }
        if (dateDifferences.year && dateDifferences.quarter) {
            return "quarterandyear"
        }
        if (dateDifferences.year) {
            return "year"
        }
        if (dateDifferences.quarter) {
            return "quarter"
        }
        if (dateDifferences.month && dateDifferences.day) {
            resultFormat.unshift("monthandday");
            return this._normalizeFormat(resultFormat)
        }
        if (dateDifferences.month) {
            return "month"
        }
        if (dateDifferences.day) {
            var dayFormatter = function(date) {
                return dateLocalization.format(date, "dayofweek") + ", " + dateLocalization.format(date, "day")
            };
            resultFormat.unshift(dayFormatter);
            return this._normalizeFormat(resultFormat)
        }
        return this._normalizeFormat(resultFormat)
    },
    getDateFormatByTicks: function(ticks) {
        var resultFormat, maxDiff, currentDiff, i;
        if (ticks.length > 1) {
            maxDiff = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
            for (i = 1; i < ticks.length - 1; i++) {
                currentDiff = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
                if (maxDiff.count < currentDiff.count) {
                    maxDiff = currentDiff
                }
            }
        } else {
            maxDiff = {
                year: true,
                month: true,
                day: true,
                hour: ticks[0].getHours() > 0,
                minute: ticks[0].getMinutes() > 0,
                second: ticks[0].getSeconds() > 0,
                millisecond: ticks[0].getMilliseconds() > 0
            }
        }
        resultFormat = this.getDateFormatByDifferences(maxDiff);
        return resultFormat
    },
    getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
        var resultFormat, dateDifferences, dateUnitInterval, dateDifferencesConverter = {
                week: "day"
            },
            correctDateDifferences = function(dateDifferences, tickInterval, value) {
                switch (tickInterval) {
                    case "year":
                    case "quarter":
                        dateDifferences.month = value;
                    case "month":
                        dateDifferences.day = value;
                    case "week":
                    case "day":
                        dateDifferences.hour = value;
                    case "hour":
                        dateDifferences.minute = value;
                    case "minute":
                        dateDifferences.second = value;
                    case "second":
                        dateDifferences.millisecond = value
                }
            },
            correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                    if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                        differences.millisecond = true;
                        differences.second = false
                    }
                } else {
                    if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                            differences.second = true;
                            differences.minute = false
                        }
                    } else {
                        if (!maxDate.getMinutes() && maxDate.getHours()) {
                            if (maxDate.getHours() - minDate.getHours() === 1) {
                                differences.minute = true;
                                differences.hour = false
                            }
                        } else {
                            if (!maxDate.getHours() && maxDate.getDate() > 1) {
                                if (maxDate.getDate() - minDate.getDate() === 1) {
                                    differences.hour = true;
                                    differences.day = false
                                }
                            } else {
                                if (1 === maxDate.getDate() && maxDate.getMonth()) {
                                    if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                        differences.day = true;
                                        differences.month = false
                                    }
                                } else {
                                    if (!maxDate.getMonth() && maxDate.getFullYear()) {
                                        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                            differences.month = true;
                                            differences.year = false
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        tickInterval = commonUtils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
        dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
        if (startValue !== endValue) {
            correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue)
        }
        dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
        correctDateDifferences(dateDifferences, dateUnitInterval, true);
        dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || "second");
        correctDateDifferences(dateDifferences, dateUnitInterval, false);
        dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
        resultFormat = this.getDateFormatByDifferences(dateDifferences);
        return resultFormat
    }
});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/touch.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    BaseStrategy = __webpack_require__(110);
var eventMap = {
    dxpointerdown: "touchstart",
    dxpointermove: "touchmove",
    dxpointerup: "touchend",
    dxpointercancel: "touchcancel",
    dxpointerover: "",
    dxpointerout: "",
    dxpointerenter: "",
    dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
    var pointers = [];
    $.each(e.touches, function(_, touch) {
        pointers.push(extend({
            pointerId: touch.identifier
        }, touch))
    });
    return {
        pointers: pointers,
        pointerId: e.changedTouches[0].identifier
    }
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
    return "ios" === devices.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent)
};
var TouchStrategy = BaseStrategy.inherit({
    ctor: function() {
        this.callBase.apply(this, arguments);
        this._pointerId = 0
    },
    _handler: function(e) {
        if (skipTouchWithSameIdentifier(this._eventName)) {
            var touch = e.changedTouches[0];
            if (this._pointerId === touch.identifier && 0 !== this._pointerId) {
                return
            }
            this._pointerId = touch.identifier
        }
        return this.callBase.apply(this, arguments)
    },
    _fireEvent: function(args) {
        return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args))
    }
});
TouchStrategy.map = eventMap;
TouchStrategy.normalize = normalizeTouchEvent;
module.exports = TouchStrategy;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/observer.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0);
var addEventsListener = function(events, handler) {
    events.split(" ").forEach(function(event) {
        document.addEventListener(event, handler, true)
    })
};
var Observer = function(eventMap, pointerEquals, onPointerAdding) {
    onPointerAdding = onPointerAdding || function() {};
    var pointers = [];
    var getPointerIndex = function(e) {
        var index = -1;
        $.each(pointers, function(i, pointer) {
            if (!pointerEquals(e, pointer)) {
                return true
            }
            index = i;
            return false
        });
        return index
    };
    var addPointer = function(e) {
        if (getPointerIndex(e) === -1) {
            onPointerAdding(e);
            pointers.push(e)
        }
    };
    var removePointer = function(e) {
        var index = getPointerIndex(e);
        if (index > -1) {
            pointers.splice(index, 1)
        }
    };
    var updatePointer = function(e) {
        pointers[getPointerIndex(e)] = e
    };
    addEventsListener(eventMap.dxpointerdown, addPointer);
    addEventsListener(eventMap.dxpointermove, updatePointer);
    addEventsListener(eventMap.dxpointerup, removePointer);
    addEventsListener(eventMap.dxpointercancel, removePointer);
    this.pointers = function() {
        return pointers
    };
    this.reset = function() {
        pointers = []
    }
};
module.exports = Observer;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/mouse.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    BaseStrategy = __webpack_require__(110),
    Observer = __webpack_require__(170);
var eventMap = {
    dxpointerdown: "mousedown",
    dxpointermove: "mousemove",
    dxpointerup: "mouseup",
    dxpointercancel: "",
    dxpointerover: "mouseover",
    dxpointerout: "mouseout",
    dxpointerenter: "mouseenter",
    dxpointerleave: "mouseleave"
};
var normalizeMouseEvent = function(e) {
    e.pointerId = 1;
    return {
        pointers: observer.pointers(),
        pointerId: 1
    }
};
var observer;
var activated = false;
var activateStrategy = function() {
    if (activated) {
        return
    }
    observer = new Observer(eventMap, function() {
        return true
    });
    activated = true
};
var MouseStrategy = BaseStrategy.inherit({
    ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy()
    },
    _fireEvent: function(args) {
        return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args))
    }
});
MouseStrategy.map = eventMap;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function() {
    observer.reset()
};
module.exports = MouseStrategy;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/widget/jquery.template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(13),
    commonUtils = __webpack_require__(2),
    TemplateBase = __webpack_require__(64),
    domUtils = __webpack_require__(15);
var templateEngines = {};
var registerTemplateEngine = function(name, templateEngine) {
    templateEngines[name] = templateEngine
};
var outerHtml = function(element) {
    element = $(element);
    var templateTag = element.length && element[0].nodeName.toLowerCase();
    if ("script" === templateTag) {
        return element.html()
    } else {
        element = $("<div>").append(element);
        return element.html()
    }
};
registerTemplateEngine("default", {
    compile: function(element) {
        return domUtils.normalizeTemplateElement(element)
    },
    render: function(template) {
        return template.clone()
    }
});
registerTemplateEngine("jquery-tmpl", {
    compile: function(element) {
        return outerHtml(element)
    },
    render: function(template, data) {
        return $.tmpl(template, data)
    }
});
registerTemplateEngine("jsrender", {
    compile: function(element) {
        return $.templates(outerHtml(element))
    },
    render: function(template, data) {
        return template.render(data)
    }
});
registerTemplateEngine("mustache", {
    compile: function(element) {
        return outerHtml(element)
    },
    render: function(template, data) {
        return Mustache.render(template, data)
    }
});
registerTemplateEngine("hogan", {
    compile: function(element) {
        return Hogan.compile(outerHtml(element))
    },
    render: function(template, data) {
        return template.render(data)
    }
});
registerTemplateEngine("underscore", {
    compile: function(element) {
        return _.template(outerHtml(element))
    },
    render: function(template, data) {
        return template(data)
    }
});
registerTemplateEngine("handlebars", {
    compile: function(element) {
        return Handlebars.compile(outerHtml(element))
    },
    render: function(template, data) {
        return template(data)
    }
});
registerTemplateEngine("doT", {
    compile: function(element) {
        return doT.template(outerHtml(element))
    },
    render: function(template, data) {
        return template(data)
    }
});
var currentTemplateEngine;
var setTemplateEngine = function(templateEngine) {
    if (commonUtils.isString(templateEngine)) {
        currentTemplateEngine = templateEngines[templateEngine];
        if (!currentTemplateEngine) {
            throw errors.Error("E0020", templateEngine)
        }
    } else {
        currentTemplateEngine = templateEngine
    }
};
setTemplateEngine("default");
var Template = TemplateBase.inherit({
    ctor: function(element) {
        this._element = element;
        this._compiledTemplate = currentTemplateEngine.compile(element)
    },
    _renderCore: function(options) {
        return $("<div>").append(currentTemplateEngine.render(this._compiledTemplate, options.model, options.index)).contents()
    },
    source: function() {
        return $(this._element).clone()
    }
});
module.exports = Template;
module.exports.setTemplateEngine = setTemplateEngine;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/template.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ko = __webpack_require__(42),
    commonUtils = __webpack_require__(2),
    TemplateBase = __webpack_require__(64),
    domUtils = __webpack_require__(15);
var getParentContext = function() {
    var parentNode = $("<div>")[0];
    ko.applyBindingsToNode(parentNode);
    var parentContext = ko.contextFor(parentNode);
    getParentContext = function() {
        return parentContext
    };
    return parentContext
};
var KoTemplate = TemplateBase.inherit({
    ctor: function(element) {
        this._element = element;
        this._template = $("<div>").append(domUtils.normalizeTemplateElement(element));
        this._registerKoTemplate()
    },
    _registerKoTemplate: function() {
        var template = this._template.get(0);
        new ko.templateSources.anonymousTemplate(template).nodes(template)
    },
    _prepareDataForContainer: function(data, container) {
        if (container && container.length) {
            var containerElement = container.get(0);
            var containerContext = ko.contextFor(containerElement);
            data = void 0 !== data ? data : ko.dataFor(containerElement) || {};
            if (containerContext) {
                return data === containerContext.$data ? containerContext : containerContext.createChildContext(data)
            }
        }
        return getParentContext().createChildContext(data)
    },
    _renderCore: function(options) {
        var model = this._prepareDataForContainer(options.model, options.container);
        if (commonUtils.isDefined(options.index)) {
            model.$index = options.index
        }
        var $placeholder = $("<div>").appendTo(options.container);
        var $result;
        ko.renderTemplate(this._template.get(0), model, {
            afterRender: function(nodes) {
                $result = $(nodes)
            }
        }, $placeholder.get(0), "replaceNode");
        return $result
    },
    source: function() {
        return $(this._element).clone()
    },
    dispose: function() {
        this._template.remove()
    }
});
module.exports = KoTemplate;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/resizable.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    stringUtils = __webpack_require__(30),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    translator = __webpack_require__(19),
    fitIntoRange = __webpack_require__(56).fitIntoRange,
    DOMComponent = __webpack_require__(45),
    eventUtils = __webpack_require__(3),
    dragEvents = __webpack_require__(76),
    isPlainObject = typeUtils.isPlainObject,
    isFunction = commonUtils.isFunction;
var RESIZABLE = "dxResizable",
    RESIZABLE_CLASS = "dx-resizable",
    RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing",
    RESIZABLE_HANDLE_CLASS = "dx-resizable-handle",
    RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top",
    RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom",
    RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left",
    RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right",
    RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner",
    DRAGSTART_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, RESIZABLE),
    DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, RESIZABLE),
    DRAGSTART_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, RESIZABLE);
var Resizable = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            handles: "all",
            step: "1",
            stepPrecision: "simple",
            area: void 0,
            minWidth: 30,
            maxWidth: 1 / 0,
            minHeight: 30,
            maxHeight: 1 / 0,
            onResizeStart: null,
            onResize: null,
            onResizeEnd: null
        })
    },
    _init: function() {
        this.callBase();
        this.element().addClass(RESIZABLE_CLASS)
    },
    _render: function() {
        this.callBase();
        this._renderActions();
        this._renderHandles()
    },
    _renderActions: function() {
        this._resizeStartAction = this._createActionByOption("onResizeStart");
        this._resizeEndAction = this._createActionByOption("onResizeEnd");
        this._resizeAction = this._createActionByOption("onResize")
    },
    _renderHandles: function() {
        var handles = this.option("handles");
        if ("none" === handles) {
            return
        }
        var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
        $.each(directions, function(index, handleName) {
            this._renderHandle(handleName)
        }.bind(this));
        inArray("bottom", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-bottom-right");
        inArray("bottom", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-bottom-left");
        inArray("top", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-top-right");
        inArray("top", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-top-left")
    },
    _renderHandle: function(handleName) {
        var $element = this.element(),
            $handle = $("<div>");
        $handle.addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo($element);
        this._attachEventHandlers($handle)
    },
    _attachEventHandlers: function($handle) {
        if (this.option("disabled")) {
            return
        }
        var handlers = {};
        handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
        handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
        handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
        $handle.on(handlers, {
            direction: "both",
            immediate: true
        })
    },
    _dragStartHandler: function(e) {
        var $element = this.element();
        if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        this._toggleResizingClass(true);
        this._movingSides = this._getMovingSides(e);
        this._elementLocation = translator.locate($element);
        this._elementSize = {
            width: $element.outerWidth(),
            height: $element.outerHeight()
        };
        this._renderDragOffsets(e);
        this._resizeStartAction({
            jQueryEvent: e,
            width: this._elementSize.width,
            height: this._elementSize.height,
            handles: this._movingSides
        });
        e.targetElements = null
    },
    _toggleResizingClass: function(value) {
        this.element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
    },
    _renderDragOffsets: function(e) {
        var area = this._getArea();
        if (!area) {
            return
        }
        var $handle = $(e.target).closest("." + RESIZABLE_HANDLE_CLASS),
            handleWidth = $handle.outerWidth(),
            handleHeight = $handle.outerHeight(),
            handleOffset = $handle.offset(),
            areaOffset = area.offset;
        e.maxLeftOffset = handleOffset.left - areaOffset.left;
        e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth;
        e.maxTopOffset = handleOffset.top - areaOffset.top;
        e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight
    },
    _getBorderWidth: function($element, direction) {
        if (commonUtils.isWindow($element.get(0))) {
            return 0
        }
        var borderWidth = $element.css("border-" + direction + "-width");
        return parseInt(borderWidth) || 0
    },
    _dragHandler: function(e) {
        var $element = this.element(),
            sides = this._movingSides;
        var location = this._elementLocation,
            size = this._elementSize,
            offset = this._getOffset(e);
        var width = size.width + offset.x * (sides.left ? -1 : 1),
            height = size.height + offset.y * (sides.top ? -1 : 1);
        if (offset.x || "strict" === this.option("stepPrecision")) {
            this._renderWidth(width)
        }
        if (offset.y || "strict" === this.option("stepPrecision")) {
            this._renderHeight(height)
        }
        var offsetTop = offset.y - ((this.element().outerHeight() || height) - height),
            offsetLeft = offset.x - ((this.element().outerWidth() || width) - width);
        translator.move($element, {
            top: location.top + (sides.top ? offsetTop : 0),
            left: location.left + (sides.left ? offsetLeft : 0)
        });
        this._resizeAction({
            jQueryEvent: e,
            width: this.option("width") || width,
            height: this.option("height") || height,
            handles: this._movingSides
        })
    },
    _getOffset: function(e) {
        var offset = e.offset,
            steps = stringUtils.pairToObject(this.option("step")),
            sides = this._getMovingSides(e),
            strictPrecision = "strict" === this.option("stepPrecision");
        if (!sides.left && !sides.right) {
            offset.x = 0
        }
        if (!sides.top && !sides.bottom) {
            offset.y = 0
        }
        return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps)
    },
    _getSimpleOffset: function(offset, steps) {
        return {
            x: offset.x - offset.x % steps.h,
            y: offset.y - offset.y % steps.v
        }
    },
    _getStrictOffset: function(offset, steps, sides) {
        var location = this._elementLocation,
            size = this._elementSize,
            xPos = sides.left ? location.left : location.left + size.width,
            yPos = sides.top ? location.top : location.top + size.height,
            newXShift = (xPos + offset.x) % steps.h,
            newYShift = (yPos + offset.y) % steps.v,
            sign = Math.sign || function(x) {
                x = +x;
                if (0 === x || isNaN(x)) {
                    return x
                }
                return x > 0 ? 1 : -1
            },
            separatorOffset = function(steps, offset) {
                return (1 + .2 * sign(offset)) % 1 * steps
            },
            isSmallOffset = function(offset, steps) {
                return Math.abs(offset) < .2 * steps
            };
        var newOffsetX = offset.x - newXShift,
            newOffsetY = offset.y - newYShift;
        if (newXShift > separatorOffset(steps.h, offset.x)) {
            newOffsetX += steps.h
        }
        if (newYShift > separatorOffset(steps.v, offset.y)) {
            newOffsetY += steps.v
        }
        return {
            x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,
            y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0
        }
    },
    _getMovingSides: function(e) {
        var $target = $(e.target),
            hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left"),
            hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right"),
            hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left"),
            hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
        return {
            top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
            left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
            bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
            right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
        }
    },
    _getArea: function() {
        var area = this.option("area");
        if (isFunction(area)) {
            area = area.call(this)
        }
        if (isPlainObject(area)) {
            return this._getAreaFromObject(area)
        }
        return this._getAreaFromElement(area)
    },
    _getAreaFromObject: function(area) {
        var result = {
            width: area.right - area.left,
            height: area.bottom - area.top,
            offset: {
                left: area.left,
                top: area.top
            }
        };
        this._correctAreaGeometry(result);
        return result
    },
    _getAreaFromElement: function(area) {
        var result, $area = $(area);
        if ($area.length) {
            result = {
                width: $area.innerWidth(),
                height: $area.innerHeight(),
                offset: extend({
                    top: 0,
                    left: 0
                }, commonUtils.isWindow($area[0]) ? {} : $area.offset())
            };
            this._correctAreaGeometry(result, $area)
        }
        return result
    },
    _correctAreaGeometry: function(result, $area) {
        var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0,
            areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
        result.offset.left += areaBorderLeft + this._getBorderWidth(this.element(), "left");
        result.offset.top += areaBorderTop + this._getBorderWidth(this.element(), "top");
        result.width -= this.element().outerWidth() - this.element().innerWidth();
        result.height -= this.element().outerHeight() - this.element().innerHeight()
    },
    _dragEndHandler: function(e) {
        var $element = this.element();
        this._resizeEndAction({
            jQueryEvent: e,
            width: $element.outerWidth(),
            height: $element.outerHeight(),
            handles: this._movingSides
        });
        this._toggleResizingClass(false)
    },
    _renderWidth: function(width) {
        this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")))
    },
    _renderHeight: function(height) {
        this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "disabled":
            case "handles":
                this._invalidate();
                break;
            case "minWidth":
            case "maxWidth":
                this._renderWidth(this.element().outerWidth());
                break;
            case "minHeight":
            case "maxHeight":
                this._renderHeight(this.element().outerHeight());
                break;
            case "onResize":
            case "onResizeStart":
            case "onResizeEnd":
                this._renderActions();
                break;
            case "area":
            case "stepPrecision":
            case "step":
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        this.element().find("." + RESIZABLE_HANDLE_CLASS).remove()
    }
});
registerComponent(RESIZABLE, Resizable);
module.exports = Resizable;
module.exports.default = module.exports;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/html_application.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    Component = __webpack_require__(106),
    extendUtils = __webpack_require__(1),
    errors = __webpack_require__(48),
    Application = __webpack_require__(176).Application,
    ConditionalViewCacheDecorator = __webpack_require__(65).ConditionalViewCacheDecorator,
    html = __webpack_require__(117),
    CommandManager = __webpack_require__(179),
    ViewEngine = __webpack_require__(181).ViewEngine,
    messageLocalization = __webpack_require__(8),
    viewPort = __webpack_require__(54).value,
    initMobileViewportModule = __webpack_require__(166),
    devices = __webpack_require__(6),
    feedbackEvents = __webpack_require__(75),
    TransitionExecutorModule = __webpack_require__(88),
    animationPresetsModule = __webpack_require__(109),
    when = __webpack_require__(10).when;
__webpack_require__(144);
__webpack_require__(20);
var VIEW_PORT_CLASSNAME = "dx-viewport",
    LAYOUT_CHANGE_ANIMATION_NAME = "layout-change";
var HtmlApplication = Application.inherit({
    ctor: function(options) {
        options = options || {};
        this.callBase(options);
        this._$root = $(options.rootNode || document.body);
        this._initViewport(options.viewPort);
        if ("mobileApp" === this._applicationMode) {
            initMobileViewportModule.initMobileViewport(options.viewPort)
        }
        this.device = options.device || devices.current();
        this.commandManager = options.commandManager || new CommandManager({
            commandMapping: this.commandMapping
        });
        this._initTemplateContext();
        this.viewEngine = options.viewEngine || new ViewEngine({
            $root: this._$root,
            device: this.device,
            templateCacheStorage: options.templateCacheStorage || window.localStorage,
            templatesVersion: options.templatesVersion,
            templateContext: this._templateContext
        });
        this.components.push(this.viewEngine);
        this._initMarkupFilters(this.viewEngine);
        this._layoutSet = options.layoutSet || html.layoutSets.default;
        this._animationSet = options.animationSet || html.animationSets.default;
        this._availableLayoutControllers = [];
        this._activeLayoutControllersStack = [];
        this.transitionExecutor = new TransitionExecutorModule.TransitionExecutor;
        this._initAnimations(this._animationSet)
    },
    _initAnimations: function(animationSet) {
        if (!animationSet) {
            return
        }
        $.each(animationSet, function(name, configs) {
            $.each(configs, function(index, config) {
                animationPresetsModule.presets.registerPreset(name, config)
            })
        });
        animationPresetsModule.presets.applyChanges()
    },
    _localizeMarkup: function($markup) {
        messageLocalization.localizeNode($markup)
    },
    _notifyIfBadMarkup: function($markup) {
        $markup.each(function() {
            var html = $(this).html();
            if (/href="#/.test(html)) {
                errors.log("W3005", html)
            }
        })
    },
    _initMarkupFilters: function(viewEngine) {
        var filters = [];
        filters.push(this._localizeMarkup);
        if (viewEngine.markupLoaded) {
            viewEngine.markupLoaded.add(function(args) {
                $.each(filters, function(_, filter) {
                    filter(args.markup)
                })
            })
        }
    },
    _createViewCache: function(options) {
        var result = this.callBase(options);
        if (!options.viewCache) {
            result = new ConditionalViewCacheDecorator({
                filter: function(key, viewInfo) {
                    return !viewInfo.viewTemplateInfo.disableCache
                },
                viewCache: result
            })
        }
        return result
    },
    _initViewport: function() {
        this._$viewPort = this._getViewPort();
        viewPort(this._$viewPort)
    },
    _getViewPort: function() {
        var $viewPort = $("." + VIEW_PORT_CLASSNAME);
        if (!$viewPort.length) {
            $viewPort = $("<div>").addClass(VIEW_PORT_CLASSNAME).appendTo(this._$root)
        }
        return $viewPort
    },
    _initTemplateContext: function() {
        this._templateContext = new Component({
            orientation: devices.orientation()
        });
        devices.on("orientationChanged", function(args) {
            this._templateContext.option("orientation", args.orientation)
        }.bind(this))
    },
    _showViewImpl: function(viewInfo, direction) {
        var that = this,
            deferred = $.Deferred(),
            result = deferred.promise(),
            layoutController = viewInfo.layoutController;
        that._obtainViewLink(viewInfo);
        layoutController.showView(viewInfo, direction).done(function() {
            that._activateLayoutController(layoutController, that._getTargetNode(viewInfo), direction).done(function() {
                deferred.resolve()
            })
        });
        feedbackEvents.lock(result);
        return result
    },
    _resolveLayoutController: function(viewInfo) {
        var args = {
            viewInfo: viewInfo,
            layoutController: null,
            availableLayoutControllers: this._availableLayoutControllers
        };
        this._processEvent("resolveLayoutController", args, viewInfo.model);
        return args.layoutController || this._resolveLayoutControllerImpl(viewInfo)
    },
    _checkLayoutControllerIsInitialized: function(layoutController) {
        if (layoutController) {
            var isControllerInited = false;
            $.each(this._layoutSet, function(_, controllerInfo) {
                if (controllerInfo.controller === layoutController) {
                    isControllerInited = true;
                    return false
                }
            });
            if (!isControllerInited) {
                throw errors.Error("E3024")
            }
        }
    },
    _ensureOneLayoutControllerFound: function(target, matches) {
        var toJSONInterceptor = function(key, value) {
            if ("controller" === key) {
                return "[controller]: { name:" + value.name + " }"
            }
            return value
        };
        if (!matches.length) {
            errors.log("W3003", JSON.stringify(target, null, 4), JSON.stringify(this._availableLayoutControllers, toJSONInterceptor, 4));
            throw errors.Error("E3011")
        }
        if (matches.length > 1) {
            errors.log("W3004", JSON.stringify(target, null, 4), JSON.stringify(matches, toJSONInterceptor, 4));
            throw errors.Error("E3012")
        }
    },
    _resolveLayoutControllerImpl: function(viewInfo) {
        var templateInfo = viewInfo.viewTemplateInfo || {},
            navigateOptions = viewInfo.navigateOptions || {},
            target = extendUtils.extend({
                root: !viewInfo.canBack,
                customResolveRequired: false,
                pane: templateInfo.pane,
                modal: void 0 !== navigateOptions.modal ? navigateOptions.modal : templateInfo.modal || false
            }, devices.current());
        var matches = commonUtils.findBestMatches(target, this._availableLayoutControllers);
        this._ensureOneLayoutControllerFound(target, matches);
        return matches[0].controller
    },
    _onNavigatingBack: function(args) {
        this.callBase.apply(this, arguments);
        if (!args.cancel && !this.canBack() && this._activeLayoutControllersStack.length > 1) {
            var previousActiveLayoutController = this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 2],
                previousViewInfo = previousActiveLayoutController.activeViewInfo();
            args.cancel = true;
            this._activateLayoutController(previousActiveLayoutController, void 0, "backward");
            this.navigationManager.currentItem(previousViewInfo.key)
        }
    },
    _activeLayoutController: function() {
        return this._activeLayoutControllersStack.length ? this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 1] : void 0
    },
    _getTargetNode: function(viewInfo) {
        var jQueryEvent = (viewInfo.navigateOptions || {}).jQueryEvent;
        return jQueryEvent ? $(jQueryEvent.target) : void 0
    },
    _activateLayoutController: function(layoutController, targetNode, direction) {
        var that = this,
            previousLayoutController = that._activeLayoutController();
        if (previousLayoutController === layoutController) {
            return $.Deferred().resolve().promise()
        }
        var d = $.Deferred();
        layoutController.ensureActive(targetNode).done(function(result) {
            that._deactivatePreviousLayoutControllers(layoutController, direction, result).done(function() {
                that._activeLayoutControllersStack.push(layoutController);
                d.resolve()
            })
        });
        return d.promise()
    },
    _deactivatePreviousLayoutControllers: function(layoutController, direction) {
        var that = this,
            tasks = [],
            controllerToDeactivate = that._activeLayoutControllersStack.pop();
        if (!controllerToDeactivate) {
            return $.Deferred().resolve().promise()
        }
        if (layoutController.isOverlay) {
            that._activeLayoutControllersStack.push(controllerToDeactivate);
            tasks.push(controllerToDeactivate.disable())
        } else {
            var transitionDeferred = $.Deferred(),
                skipAnimation = false;
            var getControllerDeactivator = function(controllerToDeactivate, d) {
                return function() {
                    controllerToDeactivate.deactivate().done(function() {
                        d.resolve()
                    })
                }
            };
            while (controllerToDeactivate && controllerToDeactivate !== layoutController) {
                var d = $.Deferred();
                if (controllerToDeactivate.isOverlay) {
                    skipAnimation = true
                } else {
                    that.transitionExecutor.leave(controllerToDeactivate.element(), LAYOUT_CHANGE_ANIMATION_NAME, {
                        direction: direction
                    })
                }
                transitionDeferred.promise().done(getControllerDeactivator(controllerToDeactivate, d));
                tasks.push(d.promise());
                controllerToDeactivate = that._activeLayoutControllersStack.pop()
            }
            if (skipAnimation) {
                transitionDeferred.resolve()
            } else {
                that.transitionExecutor.enter(layoutController.element(), LAYOUT_CHANGE_ANIMATION_NAME, {
                    direction: direction
                });
                that.transitionExecutor.start().done(function() {
                    transitionDeferred.resolve()
                })
            }
        }
        return when.apply($, tasks)
    },
    init: function() {
        var that = this,
            result = this.callBase();
        result.done(function() {
            that._initLayoutControllers();
            that.renderNavigation()
        });
        return result
    },
    _disposeView: function(viewInfo) {
        if (viewInfo.layoutController.disposeView) {
            viewInfo.layoutController.disposeView(viewInfo)
        }
        this.callBase(viewInfo)
    },
    viewPort: function() {
        return this._$viewPort
    },
    _createViewInfo: function() {
        var viewInfo = this.callBase.apply(this, arguments),
            templateInfo = this.getViewTemplateInfo(viewInfo.viewName);
        if (!templateInfo) {
            throw errors.Error("E3013", "dxView", viewInfo.viewName)
        }
        viewInfo.viewTemplateInfo = templateInfo;
        viewInfo.layoutController = this._resolveLayoutController(viewInfo);
        return viewInfo
    },
    _createViewModel: function(viewInfo) {
        this.callBase(viewInfo);
        extendUtils.extendFromObject(viewInfo.model, viewInfo.viewTemplateInfo)
    },
    _initLayoutControllers: function() {
        var that = this;
        $.each(that._layoutSet, function(index, controllerInfo) {
            var controller = controllerInfo.controller,
                target = devices.current();
            if (commonUtils.findBestMatches(target, [controllerInfo]).length) {
                that._availableLayoutControllers.push(controllerInfo);
                if (controller.init) {
                    controller.init({
                        app: that,
                        $viewPort: that._$viewPort,
                        navigationManager: that.navigationManager,
                        viewEngine: that.viewEngine,
                        templateContext: that._templateContext,
                        commandManager: that.commandManager
                    })
                }
                if (controller.on) {
                    controller.on("viewReleased", function(viewInfo) {
                        that._onViewReleased(viewInfo)
                    });
                    controller.on("viewHidden", function(viewInfo) {
                        that._onViewHidden(viewInfo)
                    });
                    controller.on("viewRendered", function(viewInfo) {
                        that._processEvent("viewRendered", {
                            viewInfo: viewInfo
                        }, viewInfo.model)
                    });
                    controller.on("viewShowing", function(viewInfo, direction) {
                        that._processEvent("viewShowing", {
                            viewInfo: viewInfo,
                            direction: direction,
                            params: viewInfo.routeData
                        }, viewInfo.model)
                    });
                    controller.on("viewShown", function(viewInfo, direction) {
                        that._processEvent("viewShown", {
                            viewInfo: viewInfo,
                            direction: direction,
                            params: viewInfo.routeData
                        }, viewInfo.model)
                    })
                }
            }
        })
    },
    _onViewReleased: function(viewInfo) {
        this._releaseViewLink(viewInfo)
    },
    renderNavigation: function() {
        var that = this;
        $.each(that._availableLayoutControllers, function(index, controllerInfo) {
            var controller = controllerInfo.controller;
            if (controller.renderNavigation) {
                controller.renderNavigation(that.navigation)
            }
        })
    },
    getViewTemplate: function(viewName) {
        return this.viewEngine.getViewTemplate(viewName)
    },
    getViewTemplateInfo: function(viewName) {
        var viewComponent = this.viewEngine.getViewTemplateInfo(viewName);
        return viewComponent && viewComponent.option()
    },
    loadTemplates: function(source) {
        return this.viewEngine.loadTemplates(source)
    },
    templateContext: function() {
        return this._templateContext
    }
});
module.exports = HtmlApplication;
module.exports.default = module.exports;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/application.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    abstract = Class.abstract,
    Action = __webpack_require__(62),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    mergeCommands = __webpack_require__(93).utils.mergeCommands,
    createActionExecutors = __webpack_require__(177).createActionExecutors,
    Router = __webpack_require__(115),
    NavigationManager = __webpack_require__(94),
    StateManager = __webpack_require__(140),
    dxCommand = __webpack_require__(139),
    messageLocalization = __webpack_require__(8),
    CommandMapping = __webpack_require__(143),
    ViewCache = __webpack_require__(65),
    EventsMixin = __webpack_require__(38),
    sessionStorage = __webpack_require__(107).sessionStorage,
    dataUtils = __webpack_require__(28),
    errors = __webpack_require__(48),
    when = __webpack_require__(10).when,
    BACK_COMMAND_TITLE, INIT_IN_PROGRESS = "InProgress",
    INIT_COMPLETE = "Inited";
var Application = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this._options = options;
        this.namespace = options.namespace || window;
        this._applicationMode = options.mode ? options.mode : "mobileApp";
        this.components = [];
        BACK_COMMAND_TITLE = messageLocalization.localizeString("@Back");
        this.router = options.router || new Router;
        var navigationManagers = {
            mobileApp: NavigationManager.StackBasedNavigationManager,
            webSite: NavigationManager.HistoryBasedNavigationManager
        };
        this.navigationManager = options.navigationManager || new navigationManagers[this._applicationMode]({
            keepPositionInStack: "keepHistory" === options.navigateToRootViewMode
        });
        this.navigationManager.on("navigating", this._onNavigating.bind(this));
        this.navigationManager.on("navigatingBack", this._onNavigatingBack.bind(this));
        this.navigationManager.on("navigated", this._onNavigated.bind(this));
        this.navigationManager.on("navigationCanceled", this._onNavigationCanceled.bind(this));
        this.stateManager = options.stateManager || new StateManager({
            storage: options.stateStorage || sessionStorage()
        });
        this.stateManager.addStateSource(this.navigationManager);
        this.viewCache = this._createViewCache(options);
        this.commandMapping = this._createCommandMapping(options.commandMapping);
        this.createNavigation(options.navigation);
        this._isNavigating = false;
        this._viewLinksHash = {};
        Action.registerExecutor(createActionExecutors(this));
        this.components.push(this.router);
        this.components.push(this.navigationManager)
    },
    _createViewCache: function(options) {
        var result;
        if (options.viewCache) {
            result = options.viewCache
        } else {
            if (options.disableViewCache) {
                result = new ViewCache.NullViewCache
            } else {
                result = new ViewCache.CapacityViewCacheDecorator({
                    size: options.viewCacheSize,
                    viewCache: new ViewCache
                })
            }
        }
        result.on("viewRemoved", function(e) {
            this._releaseViewLink(e.viewInfo)
        }.bind(this));
        return result
    },
    _createCommandMapping: function(commandMapping) {
        var result = commandMapping;
        if (!(commandMapping instanceof CommandMapping)) {
            result = new CommandMapping;
            result.load(CommandMapping.defaultMapping || {}).load(commandMapping || {})
        }
        return result
    },
    createNavigation: function(navigationConfig) {
        this.navigation = this._createNavigationCommands(navigationConfig);
        this._mapNavigationCommands(this.navigation, this.commandMapping)
    },
    _createNavigationCommands: function(commandConfig) {
        if (!commandConfig) {
            return []
        }
        var generatedIdCount = 0;
        return $.map(commandConfig, function(item) {
            var command;
            if (item instanceof dxCommand) {
                command = item
            } else {
                command = new dxCommand(extend({
                    root: true
                }, item))
            }
            if (!command.option("id")) {
                command.option("id", "navigation_" + generatedIdCount++)
            }
            return command
        })
    },
    _mapNavigationCommands: function(navigationCommands, commandMapping) {
        var navigationCommandIds = $.map(navigationCommands, function(command) {
            return command.option("id")
        });
        commandMapping.mapCommands("global-navigation", navigationCommandIds)
    },
    _callComponentMethod: function(methodName, args) {
        var tasks = [];
        $.each(this.components, function(index, component) {
            if (component[methodName] && commonUtils.isFunction(component[methodName])) {
                var result = component[methodName](args);
                if (result && result.done) {
                    tasks.push(result)
                }
            }
        });
        return when.apply($, tasks)
    },
    init: function() {
        var that = this;
        that._initState = INIT_IN_PROGRESS;
        return that._callComponentMethod("init").done(function() {
            that._initState = INIT_COMPLETE;
            that._processEvent("initialized")
        }).fail(function(error) {
            throw error || errors.Error("E3022")
        })
    },
    _onNavigatingBack: function(args) {
        this._processEvent("navigatingBack", args)
    },
    _onNavigating: function(args) {
        var that = this;
        if (that._isNavigating) {
            that._pendingNavigationArgs = args;
            args.cancel = true;
            return
        } else {
            that._isNavigating = true;
            delete that._pendingNavigationArgs
        }
        var routeData = this.router.parse(args.uri);
        if (!routeData) {
            throw errors.Error("E3001", args.uri)
        }
        var uri = this.router.format(routeData);
        if (args.uri !== uri && uri) {
            args.cancel = true;
            args.cancelReason = "redirect";
            commonUtils.executeAsync(function() {
                that.navigate(uri, args.options)
            })
        } else {
            that._processEvent("navigating", args)
        }
    },
    _onNavigated: function(args) {
        var resultDeferred, that = this,
            direction = args.options.direction,
            viewInfo = that._acquireViewInfo(args.item, args.options);
        if (!viewInfo.model) {
            this._processEvent("beforeViewSetup", {
                viewInfo: viewInfo
            });
            that._createViewModel(viewInfo);
            that._createViewCommands(viewInfo);
            this._processEvent("afterViewSetup", {
                viewInfo: viewInfo
            })
        }
        that._highlightCurrentNavigationCommand(viewInfo);
        resultDeferred = that._showView(viewInfo, direction).always(function() {
            that._isNavigating = false;
            var pendingArgs = that._pendingNavigationArgs;
            if (pendingArgs) {
                commonUtils.executeAsync(function() {
                    that.navigate(pendingArgs.uri, pendingArgs.options)
                })
            }
        });
        return resultDeferred
    },
    _isViewReadyToShow: function(viewInfo) {
        return !!viewInfo.model
    },
    _onNavigationCanceled: function(args) {
        var that = this;
        if (!that._pendingNavigationArgs || that._pendingNavigationArgs.uri !== args.uri) {
            var currentItem = that.navigationManager.currentItem();
            if (currentItem) {
                commonUtils.executeAsync(function() {
                    var viewInfo = that._acquireViewInfo(currentItem, args.options);
                    that._highlightCurrentNavigationCommand(viewInfo, true)
                })
            }
            that._isNavigating = false
        }
    },
    _disposeRemovedViews: function() {
        var args, that = this;
        $.each(that._viewLinksHash, function(key, link) {
            if (!link.linkCount) {
                args = {
                    viewInfo: link.viewInfo
                };
                that._processEvent("viewDisposing", args, args.viewInfo.model);
                that._disposeView(link.viewInfo);
                that._processEvent("viewDisposed", args, args.viewInfo.model);
                delete that._viewLinksHash[key]
            }
        })
    },
    _onViewHidden: function(viewInfo) {
        var args = {
            viewInfo: viewInfo
        };
        this._processEvent("viewHidden", args, args.viewInfo.model)
    },
    _disposeView: function(viewInfo) {
        var commands = viewInfo.commands || [];
        $.each(commands, function(index, command) {
            command._dispose()
        })
    },
    _acquireViewInfo: function(navigationItem, navigateOptions) {
        var routeData = this.router.parse(navigationItem.uri),
            viewInfoKey = this._getViewInfoKey(navigationItem, routeData),
            viewInfo = this.viewCache.getView(viewInfoKey);
        if (!viewInfo) {
            viewInfo = this._createViewInfo(navigationItem, navigateOptions);
            this._obtainViewLink(viewInfo);
            this.viewCache.setView(viewInfoKey, viewInfo)
        } else {
            this._updateViewInfo(viewInfo, navigationItem, navigateOptions)
        }
        return viewInfo
    },
    _getViewInfoKey: function(navigationItem, routeData) {
        var args = {
            key: navigationItem.key,
            navigationItem: navigationItem,
            routeData: routeData
        };
        this._processEvent("resolveViewCacheKey", args);
        return args.key
    },
    _processEvent: function(eventName, args, model) {
        this._callComponentMethod(eventName, args);
        this.fireEvent(eventName, args && [args]);
        var modelMethod = (model || {})[eventName];
        if (modelMethod) {
            modelMethod.call(model, args)
        }
    },
    _updateViewInfo: function(viewInfo, navigationItem, navigateOptions) {
        var uri = navigationItem.uri,
            routeData = this.router.parse(uri);
        viewInfo.viewName = routeData.view;
        viewInfo.routeData = routeData;
        viewInfo.uri = uri;
        viewInfo.navigateOptions = navigateOptions;
        viewInfo.canBack = this.canBack(navigateOptions.stack);
        viewInfo.previousViewInfo = this._getPreviousViewInfo(navigateOptions)
    },
    _createViewInfo: function(navigationItem, navigateOptions) {
        var uri = navigationItem.uri,
            routeData = this.router.parse(uri),
            viewInfo = {
                key: this._getViewInfoKey(navigationItem, routeData)
            };
        this._updateViewInfo(viewInfo, navigationItem, navigateOptions);
        return viewInfo
    },
    _createViewModel: function(viewInfo) {
        viewInfo.model = viewInfo.model || this._callViewCodeBehind(viewInfo)
    },
    _createViewCommands: function(viewInfo) {
        viewInfo.commands = viewInfo.model.commands || [];
        if (viewInfo.canBack && "webSite" !== this._applicationMode) {
            this._appendBackCommand(viewInfo)
        }
    },
    _callViewCodeBehind: function(viewInfo) {
        var setupFunc = commonUtils.noop,
            routeData = viewInfo.routeData;
        if (routeData.view in this.namespace) {
            setupFunc = this.namespace[routeData.view]
        }
        return setupFunc.call(this.namespace, routeData, viewInfo) || {}
    },
    _appendBackCommand: function(viewInfo) {
        var commands = viewInfo.commands,
            that = this,
            backTitle = BACK_COMMAND_TITLE;
        if (that._options.useViewTitleAsBackText) {
            backTitle = ((viewInfo.previousViewInfo || {}).model || {}).title || backTitle
        }
        var toMergeTo = [new dxCommand({
            id: "back",
            title: backTitle,
            behavior: "back",
            onExecute: function() {
                that.back({
                    stack: viewInfo.navigateOptions.stack
                })
            },
            icon: "arrowleft",
            type: "back",
            renderStage: that._options.useViewTitleAsBackText ? "onViewRendering" : "onViewShown"
        })];
        var result = mergeCommands(toMergeTo, commands);
        commands.length = 0;
        commands.push.apply(commands, result)
    },
    _showView: function(viewInfo, direction) {
        var that = this;
        var eventArgs = {
            viewInfo: viewInfo,
            direction: direction,
            params: viewInfo.routeData
        };
        dataUtils.processRequestResultLock.obtain();
        return that._showViewImpl(eventArgs.viewInfo, eventArgs.direction).done(function() {
            commonUtils.executeAsync(function() {
                dataUtils.processRequestResultLock.release();
                that._processEvent("viewShown", eventArgs, viewInfo.model);
                that._disposeRemovedViews()
            })
        })
    },
    _highlightCurrentNavigationCommand: function(viewInfo, forceUpdate) {
        var selectedCommand, that = this,
            currentNavigationItemId = viewInfo.model && viewInfo.model.currentNavigationItemId;
        if (void 0 !== currentNavigationItemId) {
            $.each(this.navigation, function(index, command) {
                if (command.option("id") === currentNavigationItemId) {
                    selectedCommand = command;
                    return false
                }
            })
        }
        if (!selectedCommand) {
            $.each(this.navigation, function(index, command) {
                var commandUri = command.option("onExecute");
                if (commonUtils.isString(commandUri)) {
                    commandUri = commandUri.replace(/^#+/, "");
                    if (commandUri === that.navigationManager.rootUri()) {
                        selectedCommand = command;
                        return false
                    }
                }
            })
        }
        $.each(this.navigation, function(index, command) {
            if (forceUpdate && command === selectedCommand && command.option("highlighted")) {
                command.fireEvent("optionChanged", [{
                    name: "highlighted",
                    value: true,
                    previousValue: true
                }])
            }
            command.option("highlighted", command === selectedCommand)
        })
    },
    _showViewImpl: abstract,
    _obtainViewLink: function(viewInfo) {
        var key = viewInfo.key;
        if (!this._viewLinksHash[key]) {
            this._viewLinksHash[key] = {
                viewInfo: viewInfo,
                linkCount: 1
            }
        } else {
            this._viewLinksHash[key].linkCount++
        }
    },
    _releaseViewLink: function(viewInfo) {
        if (void 0 === this._viewLinksHash[viewInfo.key]) {
            errors.log("W3001", viewInfo.key)
        }
        if (0 === this._viewLinksHash[viewInfo.key].linkCount) {
            errors.log("W3002", viewInfo.key)
        }
        this._viewLinksHash[viewInfo.key].linkCount--
    },
    navigate: function(uri, options) {
        var that = this;
        if (typeUtils.isPlainObject(uri)) {
            uri = that.router.format(uri);
            if (false === uri) {
                throw errors.Error("E3002")
            }
        }
        if (!that._initState) {
            that.init().done(function() {
                that.restoreState();
                that.navigate(uri, options)
            })
        } else {
            if (that._initState === INIT_COMPLETE) {
                if (!that._isNavigating || uri) {
                    that.navigationManager.navigate(uri, options)
                }
            } else {
                throw errors.Error("E3003")
            }
        }
    },
    canBack: function(stackKey) {
        return this.navigationManager.canBack(stackKey)
    },
    _getPreviousViewInfo: function(navigateOptions) {
        var result, previousNavigationItem = this.navigationManager.previousItem(navigateOptions.stack);
        if (previousNavigationItem) {
            var routeData = this.router.parse(previousNavigationItem.uri);
            result = this.viewCache.getView(this._getViewInfoKey(previousNavigationItem, routeData))
        }
        return result
    },
    back: function(options) {
        this.navigationManager.back(options)
    },
    saveState: function() {
        this.stateManager.saveState()
    },
    restoreState: function() {
        this.stateManager.restoreState()
    },
    clearState: function() {
        this.stateManager.clearState()
    }
}).include(EventsMixin);
exports.Application = Application;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/action_executors.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    dataCoreUtils = __webpack_require__(14),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    Route = __webpack_require__(115).Route;

function prepareNavigateOptions(options, actionArguments) {
    if (actionArguments.args) {
        var sourceEventArguments = actionArguments.args[0];
        options.jQueryEvent = sourceEventArguments.jQueryEvent
    }
    if ("dxCommand" === (actionArguments.component || {}).NAME) {
        extend(options, actionArguments.component.option())
    }
}

function preventDefaultLinkBehavior(e) {
    if (!e) {
        return
    }
    var $targetElement = $(e.target);
    if ($targetElement.attr("href")) {
        e.preventDefault()
    }
}
var createActionExecutors = function(app) {
    return {
        routing: {
            execute: function(e) {
                var routeValues, uri, action = e.action,
                    options = {};
                if (isPlainObject(action)) {
                    routeValues = action.routeValues;
                    if (routeValues && isPlainObject(routeValues)) {
                        options = action.options
                    } else {
                        routeValues = action
                    }
                    uri = app.router.format(routeValues);
                    prepareNavigateOptions(options, e);
                    preventDefaultLinkBehavior(options.jQueryEvent);
                    app.navigate(uri, options);
                    e.handled = true
                }
            }
        },
        hash: {
            execute: function(e) {
                if ("string" !== typeof e.action || "#" !== e.action.charAt(0)) {
                    return
                }
                var uriTemplate = e.action.substr(1),
                    args = e.args[0],
                    uri = uriTemplate;
                var defaultEvaluate = function(expr) {
                    var getter = dataCoreUtils.compileGetter(expr),
                        model = e.args[0].model;
                    return getter(model)
                };
                var evaluate = args.evaluate || defaultEvaluate;
                uri = uriTemplate.replace(/\{([^}]+)\}/g, function(entry, expr) {
                    expr = $.trim(expr);
                    if (expr.indexOf(",") > -1) {
                        expr = $.map(expr.split(","), $.trim)
                    }
                    var value = evaluate(expr);
                    if (void 0 === value) {
                        value = ""
                    }
                    value = Route.prototype.formatSegment(value);
                    return value
                });
                var options = {};
                prepareNavigateOptions(options, e);
                preventDefaultLinkBehavior(options.jQueryEvent);
                app.navigate(uri, options);
                e.handled = true
            }
        },
        url: {
            execute: function(e) {
                if ("string" === typeof e.action && "#" !== e.action.charAt(0)) {
                    document.location = e.action
                }
            }
        }
    }
};
exports.createActionExecutors = createActionExecutors;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/browser_adapters.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    queue = __webpack_require__(136);
var ROOT_PAGE_URL = "__root__",
    BUGGY_ANDROID_BUFFER_PAGE_URL = "__buffer__";
var DefaultBrowserAdapter = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this._window = options.window || window;
        this.popState = $.Callbacks();
        $(this._window).on("hashchange", this._onHashChange.bind(this));
        this._tasks = queue.create();
        this.canWorkInPureBrowser = true
    },
    replaceState: function(uri) {
        var that = this;
        return this._addTask(function() {
            uri = that._normalizeUri(uri);
            that._window.history.replaceState(null, null, "#" + uri);
            that._currentTask.resolve()
        })
    },
    pushState: function(uri) {
        var that = this;
        return this._addTask(function() {
            uri = that._normalizeUri(uri);
            that._window.history.pushState(null, null, "#" + uri);
            that._currentTask.resolve()
        })
    },
    createRootPage: function() {
        return this.replaceState(ROOT_PAGE_URL)
    },
    _onHashChange: function() {
        if (this._currentTask) {
            this._currentTask.resolve()
        }
        this.popState.fire()
    },
    back: function() {
        var that = this;
        return this._addTask(function() {
            that._window.history.back()
        })
    },
    getHash: function() {
        return this._normalizeUri(this._window.location.hash)
    },
    isRootPage: function() {
        return this.getHash() === ROOT_PAGE_URL
    },
    _normalizeUri: function(uri) {
        return (uri || "").replace(/^#+/, "")
    },
    _addTask: function(task) {
        var that = this,
            d = $.Deferred();
        this._tasks.add(function() {
            that._currentTask = d;
            task();
            return d
        });
        return d.promise()
    }
});
var OldBrowserAdapter = DefaultBrowserAdapter.inherit({
    ctor: function() {
        this._innerEventCount = 0;
        this.callBase.apply(this, arguments);
        this._skipNextEvent = false
    },
    replaceState: function(uri) {
        var that = this;
        uri = that._normalizeUri(uri);
        if (that.getHash() !== uri) {
            that._addTask(function() {
                that._skipNextEvent = true;
                that._window.history.back()
            });
            return that._addTask(function() {
                that._skipNextEvent = true;
                that._window.location.hash = uri
            })
        }
        return $.Deferred().resolve().promise()
    },
    pushState: function(uri) {
        var that = this;
        uri = this._normalizeUri(uri);
        if (this.getHash() !== uri) {
            return that._addTask(function() {
                that._skipNextEvent = true;
                that._window.location.hash = uri
            })
        }
        return $.Deferred().resolve().promise()
    },
    createRootPage: function() {
        return this.pushState(ROOT_PAGE_URL)
    },
    _onHashChange: function() {
        var currentTask = this._currentTask;
        this._currentTask = null;
        if (this._skipNextEvent) {
            this._skipNextEvent = false
        } else {
            this.popState.fire()
        }
        if (currentTask) {
            currentTask.resolve()
        }
    }
});
var BuggyAndroidBrowserAdapter = OldBrowserAdapter.inherit({
    createRootPage: function() {
        this.pushState(BUGGY_ANDROID_BUFFER_PAGE_URL);
        return this.callBase()
    }
});
var HistorylessBrowserAdapter = DefaultBrowserAdapter.inherit({
    ctor: function(options) {
        options = options || {};
        this._window = options.window || window;
        this.popState = $.Callbacks();
        $(this._window).on("dxback", this._onHashChange.bind(this));
        this._currentHash = this._window.location.hash
    },
    replaceState: function(uri) {
        this._currentHash = this._normalizeUri(uri);
        return $.Deferred().resolve().promise()
    },
    pushState: function(uri) {
        return this.replaceState(uri)
    },
    createRootPage: function() {
        return this.replaceState(ROOT_PAGE_URL)
    },
    getHash: function() {
        return this._normalizeUri(this._currentHash)
    },
    back: function() {
        return this.replaceState(ROOT_PAGE_URL)
    },
    _onHashChange: function() {
        var promise = this.back();
        this.popState.fire();
        return promise
    }
});
var BuggyCordovaWP81BrowserAdapter = DefaultBrowserAdapter.inherit({
    ctor: function(options) {
        this.callBase(options);
        this.canWorkInPureBrowser = false
    }
});
exports.DefaultBrowserAdapter = DefaultBrowserAdapter;
exports.OldBrowserAdapter = OldBrowserAdapter;
exports.BuggyAndroidBrowserAdapter = BuggyAndroidBrowserAdapter;
exports.HistorylessBrowserAdapter = HistorylessBrowserAdapter;
exports.BuggyCordovaWP81BrowserAdapter = BuggyCordovaWP81BrowserAdapter;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/command_manager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    noop = __webpack_require__(2).noop,
    errors = __webpack_require__(48),
    CommandMapping = __webpack_require__(143),
    commandToDXWidgetAdapters = __webpack_require__(180),
    when = __webpack_require__(10).when;
__webpack_require__(139);
__webpack_require__(141);
var CommandManager = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this.defaultWidgetAdapter = options.defaultWidgetAdapter || this._getDefaultWidgetAdapter();
        this.commandMapping = options.commandMapping || new CommandMapping
    },
    _getDefaultWidgetAdapter: function() {
        return {
            addCommand: noop,
            clearContainer: noop
        }
    },
    _getContainerAdapter: function($container) {
        var componentNames = $container.data("dxComponents"),
            adapters = commandToDXWidgetAdapters;
        if (componentNames) {
            for (var index in componentNames) {
                var widgetName = componentNames[index];
                if (widgetName in adapters) {
                    return adapters[widgetName]
                }
            }
        }
        return this.defaultWidgetAdapter
    },
    findCommands: function($items) {
        var items = $items.find(".dx-command").add($items.filter(".dx-command"));
        var result = $.map(items, function(element) {
            return $(element).dxCommand("instance")
        });
        return result
    },
    findCommandContainers: function($markup) {
        var result = $.map($markup.find(".dx-command-container"), function(element) {
            return $(element).dxCommandContainer("instance")
        });
        return result
    },
    _checkCommandId: function(id, command) {
        if (null === id) {
            throw errors.Error("E3010", command.element().get(0).outerHTML)
        }
    },
    renderCommandsToContainers: function(commands, containers) {
        var that = this,
            commandHash = {},
            commandIds = [],
            deferreds = [];
        $.each(commands, function(i, command) {
            var id = command.option("id");
            that._checkCommandId(id, command);
            commandIds.push(id);
            commandHash[id] = command
        });
        that.commandMapping.checkCommandsExist(commandIds);
        $.each(containers, function(k, container) {
            var commandInfos = [];
            $.each(commandHash, function(id, command) {
                var commandId = id;
                var commandOptions = that.commandMapping.getCommandMappingForContainer(commandId, container.option("id"));
                if (commandOptions) {
                    commandInfos.push({
                        command: command,
                        options: commandOptions
                    })
                }
            });
            if (commandInfos.length) {
                var deferred = that._attachCommandsToContainer(container.element(), commandInfos);
                if (deferred) {
                    deferreds.push(deferred)
                }
            }
        });
        return when.apply($, deferreds)
    },
    clearContainer: function(container) {
        var $container = container.element(),
            adapter = this._getContainerAdapter($container);
        adapter.clearContainer($container)
    },
    _arrangeCommandsToContainers: function(commands, containers) {
        errors.log("W0002", "CommandManager", "_arrangeCommandsToContainers", "14.1", "Use the 'renderCommandsToContainers' method instead.");
        this.renderCommandsToContainers(commands, containers)
    },
    _attachCommandsToContainer: function($container, commandInfos) {
        var result, adapter = this._getContainerAdapter($container);
        if (adapter.beginUpdate) {
            adapter.beginUpdate($container)
        }
        $.each(commandInfos, function(index, commandInfo) {
            adapter.addCommand($container, commandInfo.command, commandInfo.options)
        });
        if (adapter.endUpdate) {
            result = adapter.endUpdate($container)
        }
        return result
    }
});
module.exports = CommandManager;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/widget_command_adapters.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    commandToContainer = __webpack_require__(93).utils.commandToContainer,
    fx = __webpack_require__(22),
    TransitionExecutorModule = __webpack_require__(88),
    DX_COMMAND_TO_WIDGET_ADAPTER = "dxCommandToWidgetAdapter";
var WidgetItemWrapperBase = Class.inherit({
    ctor: function(command, containerOptions) {
        this.command = command;
        this.widgetItem = this._createWidgetItem(command, containerOptions)
    },
    _createWidgetItem: function(command, containerOptions) {
        var result, itemOptions = extend({}, containerOptions, command.option()),
            executeCommandCallback = function(e) {
                command.execute(e)
            };
        itemOptions.text = commandToContainer.resolveTextValue(command, containerOptions);
        itemOptions.icon = commandToContainer.resolveIconValue(command, containerOptions);
        itemOptions.type = commandToContainer.resolvePropertyValue(command, containerOptions, "type");
        itemOptions.location = commandToContainer.resolvePropertyValue(command, containerOptions, "location");
        itemOptions.locateInMenu = commandToContainer.resolvePropertyValue(command, containerOptions, "locateInMenu");
        itemOptions.showText = commandToContainer.resolvePropertyValue(command, containerOptions, "showText");
        result = this._createWidgetItemCore(itemOptions, executeCommandCallback);
        result.command = command;
        return result
    },
    _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
        return itemOptions
    },
    dispose: function() {
        delete this.command;
        delete this.widgetItem
    }
});
var WidgetAdapterBase = Class.inherit({
    ctor: function($widgetElement) {
        this._commandToWidgetItemOptionNames = {};
        this.$widgetElement = $widgetElement;
        this.$widgetElement.data(DX_COMMAND_TO_WIDGET_ADAPTER, this);
        this.widget = this._getWidgetByElement($widgetElement);
        this._widgetWidgetContentReadyHandler = this._onWidgetContentReady.bind(this);
        this._widgetWidgetItemRenderedHandler = this._onWidgetItemRendered.bind(this);
        this._widgetDisposingHandler = this._onWidgetDisposing.bind(this);
        this.widget.on("itemRendered", this._widgetWidgetItemRenderedHandler);
        this.widget.on("contentReady", this._widgetWidgetContentReadyHandler);
        this.widget.on("disposing", this._widgetDisposingHandler);
        this.itemWrappers = [];
        this._transitionExecutor = new TransitionExecutorModule.TransitionExecutor
    },
    addCommand: function(command, containerOptions) {
        var itemWrapper = this._createItemWrapper(command, containerOptions);
        this.itemWrappers.push(itemWrapper);
        this._addItemToWidget(itemWrapper);
        this._commandChangedHandler = this._onCommandChanged.bind(this);
        itemWrapper.command.on("optionChanged", this._commandChangedHandler)
    },
    beginUpdate: function() {
        this.widget.beginUpdate()
    },
    endUpdate: function() {
        this.widget.endUpdate();
        return this.animationDeferred
    },
    _onWidgetItemRendered: function(e) {
        if (e.itemData.isJustAdded && e.itemData.command && e.itemData.command.option("visible") && this._commandRenderedAnimation) {
            this._transitionExecutor.enter(e.itemElement, this._commandRenderedAnimation);
            delete e.itemData.isJustAdded
        }
    },
    _onWidgetContentReady: function(e) {
        this.animationDeferred = this._transitionExecutor.start()
    },
    _onWidgetDisposing: function() {
        this.dispose(true)
    },
    _setWidgetItemOption: function(optionName, optionValue, itemCommand) {
        var items = this.widget.option("items"),
            itemIndex = inArray(itemCommand, $.map(items, function(item) {
                return item.command || {}
            }));
        if (itemIndex > -1) {
            var optionPath = "items[" + itemIndex + "].";
            if (!this._requireWidgetRefresh(optionName) && this.widget.option("items[" + itemIndex + "]").options) {
                optionPath += "options."
            }
            optionPath += this._commandToWidgetItemOptionNames[optionName] || optionName;
            this.widget.option(optionPath, optionValue)
        }
    },
    _requireWidgetRefresh: function(optionName) {
        return "visible" === optionName || "locateInMenu" === optionName || "location" === optionName
    },
    _onCommandChanged: function(args) {
        if ("highlighted" === args.name || args.component.isOptionDeprecated(args.name)) {
            return
        }
        this._setWidgetItemOption(args.name, args.value, args.component)
    },
    _addItemToWidget: function(itemWrapper) {
        var items = this.widget.option("items");
        items.push(itemWrapper.widgetItem);
        if (this.widget.element().is(":visible")) {
            itemWrapper.widgetItem.isJustAdded = true
        }
        this.widget.option("items", items)
    },
    refresh: function() {
        var items = this.widget.option("items");
        this.widget.option("items", items)
    },
    clear: function(widgetDisposing) {
        var that = this;
        $.each(that.itemWrappers, function(index, itemWrapper) {
            itemWrapper.command.off("optionChanged", that._commandChangedHandler);
            itemWrapper.dispose()
        });
        this.itemWrappers.length = 0;
        if (!widgetDisposing) {
            this._clearWidgetItems()
        }
    },
    _clearWidgetItems: function() {
        this.widget.option("items", [])
    },
    dispose: function(widgetDisposing) {
        this.clear(widgetDisposing);
        if (this.widget) {
            this.widget.off("itemRendered", this._widgetWidgetItemRenderedHandler);
            this.widget.off("contentReady", this._widgetContentReadyHandler);
            this.widget.off("disposing", this._widgetDisposingHandler);
            this.$widgetElement.removeData(DX_COMMAND_TO_WIDGET_ADAPTER);
            delete this.widget;
            delete this.$widgetElement
        }
    }
});
var CommandToWidgetAdapter = Class.inherit({
    ctor: function(createAdapter) {
        this.createAdapter = createAdapter
    },
    _getWidgetAdapter: function($container) {
        var widgetAdapter = $container.data(DX_COMMAND_TO_WIDGET_ADAPTER);
        if (!widgetAdapter) {
            widgetAdapter = this.createAdapter($container)
        }
        return widgetAdapter
    },
    addCommand: function($container, command, containerOptions) {
        var widgetAdapter = this._getWidgetAdapter($container);
        widgetAdapter.addCommand(command, containerOptions)
    },
    clearContainer: function($container) {
        var widgetAdapter = this._getWidgetAdapter($container);
        widgetAdapter.clear()
    },
    beginUpdate: function($container) {
        var widgetAdapter = this._getWidgetAdapter($container);
        widgetAdapter.beginUpdate()
    },
    endUpdate: function($container) {
        var widgetAdapter = this._getWidgetAdapter($container);
        return widgetAdapter.endUpdate()
    }
});
var dxToolbarItemWrapper = WidgetItemWrapperBase.inherit({
    _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
        var widgetItem;
        itemOptions.onClick = executeCommandCallback;
        if ("menu" === itemOptions.location || "always" === itemOptions.locateInMenu) {
            widgetItem = itemOptions;
            widgetItem.isAction = true
        } else {
            widgetItem = {
                locateInMenu: itemOptions.locateInMenu,
                location: itemOptions.location,
                visible: itemOptions.visible,
                options: itemOptions,
                widget: "dxButton"
            };
            if ("inMenu" === itemOptions.showText) {
                widgetItem.showText = itemOptions.showText
            }
            itemOptions.visible = true;
            delete itemOptions.location
        }
        return widgetItem
    }
});
var dxToolbarAdapter = WidgetAdapterBase.inherit({
    ctor: function($widgetElement) {
        this.callBase($widgetElement);
        this._commandToWidgetItemOptionNames = {
            title: "text"
        };
        if ("topToolbar" === this.widget.option("renderAs")) {
            this._commandRenderedAnimation = "command-rendered-top"
        } else {
            this._commandRenderedAnimation = "command-rendered-bottom"
        }
    },
    _getWidgetByElement: function($element) {
        return $element.dxToolbar("instance")
    },
    _createItemWrapper: function(command, containerOptions) {
        return new dxToolbarItemWrapper(command, containerOptions)
    },
    addCommand: function(command, containerOptions) {
        this.widget.option("visible", true);
        this.callBase(command, containerOptions)
    }
});
var dxListItemWrapper = WidgetItemWrapperBase.inherit({
    _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
        itemOptions.title = itemOptions.text;
        itemOptions.onClick = executeCommandCallback;
        return itemOptions
    }
});
var dxListAdapter = WidgetAdapterBase.inherit({
    _createItemWrapper: function(command, containerOptions) {
        return new dxListItemWrapper(command, containerOptions)
    },
    _getWidgetByElement: function($element) {
        return $element.dxList("instance")
    }
});
var dxNavBarItemWrapper = WidgetItemWrapperBase.inherit({});
var dxNavBarAdapter = WidgetAdapterBase.inherit({
    ctor: function($widgetElement) {
        this.callBase($widgetElement);
        this._commandToWidgetItemOptionNames = {
            title: "text"
        };
        this.widget.option("onItemClick", this._onNavBarItemClick.bind(this))
    },
    _onNavBarItemClick: function(e) {
        var items = this.widget.option("items");
        for (var i = items.length; --i;) {
            items[i].command.option("highlighted", false)
        }
        e.itemData.command.execute(e)
    },
    _getWidgetByElement: function($element) {
        return $element.dxNavBar("instance")
    },
    _createItemWrapper: function(command, containerOptions) {
        return new dxNavBarItemWrapper(command, containerOptions)
    },
    addCommand: function(command, containerOptions) {
        this.callBase(command, containerOptions);
        this._updateSelectedIndex()
    },
    _onCommandChanged: function(args) {
        var optionName = args.name,
            newValue = args.value;
        if ("highlighted" === optionName && newValue) {
            this._updateSelectedIndex()
        }
        this.callBase(args)
    },
    _updateSelectedIndex: function() {
        var items = this.widget.option("items");
        for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
            var command = items[i].command;
            if (command && command.option("highlighted")) {
                this.widget.option("selectedIndex", i);
                break
            }
        }
    }
});
var dxPivotItemWrapper = WidgetItemWrapperBase.inherit({
    _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
        itemOptions.title = itemOptions.text;
        return itemOptions
    }
});
var dxPivotAdapter = WidgetAdapterBase.inherit({
    ctor: function($widgetElement) {
        this.callBase($widgetElement);
        this.widget.option("onSelectionChanged", this._onPivotSelectionChange.bind(this))
    },
    _onPivotSelectionChange: function(e) {
        if (e.addedItems.length && e.removedItems.length && e.addedItems[0] && e.addedItems[0].command) {
            e.addedItems[0].command.execute(e)
        }
    },
    _getWidgetByElement: function($element) {
        return $element.dxPivot("instance")
    },
    _createItemWrapper: function(command, containerOptions) {
        return new dxPivotItemWrapper(command, containerOptions)
    },
    addCommand: function(command, containerOptions) {
        this.callBase(command, containerOptions);
        this._updateSelectedIndex()
    },
    _onCommandChanged: function(args) {
        var optionName = args.name,
            newValue = args.value;
        if ("visible" === optionName) {
            this._reRenderPivot()
        } else {
            if ("highlighted" === optionName && newValue) {
                this._updateSelectedIndex()
            }
        }
        this.callBase(args)
    },
    _addItemToWidget: function(itemWrapper) {
        if (itemWrapper.command.option("visible")) {
            this.callBase(itemWrapper)
        }
    },
    _updateSelectedIndex: function() {
        var pivot = this.widget,
            items = pivot.option("items") || [];
        fx.off = true;
        for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
            var command = items[i].command;
            if (command && command.option("highlighted")) {
                pivot.option("selectedIndex", i);
                break
            }
        }
        fx.off = false
    },
    _reRenderPivot: function() {
        var that = this;
        that.widget.option("items", []);
        $.each(that.itemWrappers, function(index, itemWrapper) {
            if (itemWrapper.command.option("visible")) {
                that._addItemToWidget(itemWrapper)
            }
        });
        that.refresh();
        that._updateSelectedIndex()
    }
});
var dxSlideOutItemWrapper = WidgetItemWrapperBase.inherit({});
var dxSlideOutAdapter = WidgetAdapterBase.inherit({
    ctor: function($widgetElement) {
        this.callBase($widgetElement);
        this._commandToWidgetItemOptionNames = {
            title: "text"
        };
        this.widget.option("onItemClick", this._onSlideOutItemClick.bind(this))
    },
    _onSlideOutItemClick: function(e) {
        e.itemData.command.execute(e)
    },
    _getWidgetByElement: function($element) {
        return $element.dxSlideOut("instance")
    },
    _createItemWrapper: function(command, containerOptions) {
        return new dxSlideOutItemWrapper(command, containerOptions)
    },
    _updateSelectedIndex: function() {
        var items = this.widget.option("items") || [];
        for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
            var command = items[i].command;
            if (command && command.option("highlighted")) {
                this.widget.option("selectedIndex", i);
                break
            }
        }
    },
    addCommand: function(command, containerOptions) {
        this.callBase(command, containerOptions);
        this._updateSelectedIndex()
    },
    _onCommandChanged: function(args) {
        var optionName = args.name,
            newValue = args.value;
        if ("highlighted" === optionName && newValue) {
            this._updateSelectedIndex()
        }
        this.callBase(args)
    }
});
exports.dxToolbar = new CommandToWidgetAdapter(function($widgetElement) {
    return new dxToolbarAdapter($widgetElement)
});
exports.dxList = new CommandToWidgetAdapter(function($widgetElement) {
    return new dxListAdapter($widgetElement)
});
exports.dxNavBar = new CommandToWidgetAdapter(function($widgetElement) {
    return new dxNavBarAdapter($widgetElement)
});
exports.dxPivot = new CommandToWidgetAdapter(function($widgetElement) {
    return new dxPivotAdapter($widgetElement)
});
exports.dxSlideOut = new CommandToWidgetAdapter(function($widgetElement) {
    return new dxSlideOutAdapter($widgetElement)
});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (framework/html/view_engine.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    version = __webpack_require__(104),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(48),
    domUtils = __webpack_require__(15),
    when = __webpack_require__(10).when,
    _VIEW_ROLE = "dxView",
    _LAYOUT_ROLE = "dxLayout",
    MARKUP_TEMPLATE_MARKER = "MarkupTemplate:";
__webpack_require__(49);
var ViewEngine = Class.inherit({
    ctor: function(options) {
        options = options || {};
        this.$root = options.$root;
        this.device = options.device || {};
        this.dataOptionsAttributeName = options.dataOptionsAttributeName || "data-options";
        this._templateMap = {};
        this._pendingViewContainer = null;
        this.markupLoaded = $.Callbacks();
        this._templateContext = options.templateContext;
        this._$skippedMarkup = $();
        if (void 0 !== options.templatesVersion && options.templateCacheStorage && this._isReleaseVersion()) {
            this._templateCacheEnabled = true;
            this._templatesVersion = "v_" + options.templatesVersion;
            this._templateCacheStorage = options.templateCacheStorage;
            this._templateCacheKey = "dxTemplateCache_" + version + "_" + JSON.stringify(this.device)
        }
    },
    _isReleaseVersion: function() {
        return !/http:\/\/localhost/.test(location.href)
    },
    _enumerateTemplates: function(processFn) {
        var that = this;
        $.each(that._templateMap, function(name, templatesByRoleMap) {
            $.each(templatesByRoleMap, function(role, templates) {
                $.each(templates, function(index, template) {
                    processFn(template)
                })
            })
        })
    },
    _findComponent: function(name, role) {
        var components = (this._templateMap[name] || {})[role] || [],
            filter = this._templateContext && this._templateContext.option() || {};
        components = this._filterTemplates(filter, components);
        this._checkMatchedTemplates(components);
        return components[0]
    },
    _findTemplate: function(name, role) {
        var component = this._findComponent(name, role);
        if (!component) {
            this._clearCache();
            throw errors.Error("E3013", role, name)
        }
        var $result, $template = component.element();
        if (!component._isStaticComponentsCreated) {
            domUtils.createComponents($template, ["dxContent", "dxContentPlaceholder", "dxTransition"]);
            component._isStaticComponentsCreated = true
        }
        $result = $template.clone().removeClass("dx-hidden");
        return $result
    },
    _clearCache: function() {
        if (this._templateCacheEnabled) {
            this._templateCacheStorage.removeItem(this._templateCacheKey)
        }
    },
    _loadTemplatesFromMarkupCore: function($markup) {
        var that = this;
        if ($markup.find("[data-dx-role]").length) {
            throw errors.Error("E3019")
        }
        that.markupLoaded.fire({
            markup: $markup
        });
        var components = domUtils.createComponents($markup, [_VIEW_ROLE, _LAYOUT_ROLE]);
        $.each(components, function(index, component) {
            var $element = component.element();
            $element.addClass("dx-hidden");
            that._registerTemplateComponent(component);
            component.element().detach()
        });
        var $skipped = $markup.filter("script");
        $skipped.appendTo(that.$root);
        that._$skippedMarkup = that._$skippedMarkup.add($skipped)
    },
    _registerTemplateComponent: function(component) {
        var role = component.NAME,
            options = component.option(),
            templateName = options.name,
            componentsByRoleMap = this._templateMap[templateName] || {};
        componentsByRoleMap[role] = componentsByRoleMap[role] || [];
        componentsByRoleMap[role].push(component);
        this._templateMap[templateName] = componentsByRoleMap
    },
    _applyPartialViews: function($render) {
        var that = this;
        domUtils.createComponents($render, ["dxViewPlaceholder"]);
        $.each($render.find(".dx-view-placeholder"), function() {
            var $partialPlaceholder = $(this);
            if ($partialPlaceholder.children().length) {
                return
            }
            var viewName = $partialPlaceholder.data("dxViewPlaceholder").option("viewName"),
                $view = that._findTemplate(viewName, _VIEW_ROLE);
            that._applyPartialViews($view);
            $partialPlaceholder.append($view);
            $view.removeClass("dx-hidden")
        })
    },
    _ajaxImpl: function() {
        return $.ajax.apply($, arguments)
    },
    _loadTemplatesFromURL: function(url) {
        var that = this,
            options = this._getLoadOptions(),
            deferred = $.Deferred();
        url = options.winPhonePrefix + url;
        this._ajaxImpl({
            url: url,
            isLocal: options.isLocal,
            dataType: "html"
        }).done(function(data) {
            that._loadTemplatesFromMarkupCore(domUtils.createMarkupFromString(data));
            deferred.resolve()
        }).fail(function(jqXHR, textStatus, errorThrown) {
            var error = errors.Error("E3021", url, errorThrown);
            deferred.reject(error)
        });
        return deferred.promise()
    },
    _getLoadOptions: function() {
        if (location.protocol.indexOf("wmapp") >= 0) {
            return {
                winPhonePrefix: location.protocol + "www/",
                isLocal: true
            }
        }
        return {
            winPhonePrefix: "",
            isLocal: void 0
        }
    },
    _loadExternalTemplates: function() {
        var tasks = [],
            that = this;
        $("head").find("link[rel='dx-template']").each(function(index, link) {
            var task = that._loadTemplatesFromURL($(link).attr("href"));
            tasks.push(task)
        });
        return when.apply($, tasks)
    },
    _processTemplates: function() {
        var that = this;
        $.each(that._templateMap, function(name, templatesByRoleMap) {
            $.each(templatesByRoleMap, function(role, templates) {
                that._filterTemplatesByDevice(templates)
            })
        });
        that._enumerateTemplates(function(template) {
            that._applyPartialViews(template.element())
        })
    },
    _filterTemplatesByDevice: function(components) {
        var filteredComponents = this._filterTemplates(this.device, components);
        $.each(components, function(index, component) {
            if (inArray(component, filteredComponents) < 0) {
                component.element().remove()
            }
        });
        components.length = 0;
        components.push.apply(components, filteredComponents)
    },
    _filterTemplates: function(filter, components) {
        return commonUtils.findBestMatches(filter, components, function(component) {
            return component.option()
        })
    },
    _checkMatchedTemplates: function(bestMatches) {
        if (bestMatches.length > 1) {
            var message = "";
            $.each(bestMatches, function(index, match) {
                message += match.element().attr("data-options") + "\r\n"
            });
            throw errors.Error("E3020", message, JSON.stringify(this.device))
        }
    },
    _wrapViewDefaultContent: function($viewTemplate) {
        $viewTemplate.wrapInner('<div class="dx-full-height"></div>');
        $viewTemplate.children().eq(0).dxContent({
            targetPlaceholder: "content"
        })
    },
    _initDefaultLayout: function() {
        this._$defaultLayoutTemplate = $('<div class="dx-full-height" data-options="dxLayout : { name: \'default\' } "> \n    <div class="dx-full-height" data-options="dxContentPlaceholder : { name: \'content\' } " ></div> \n</div>');
        domUtils.createComponents(this._$defaultLayoutTemplate)
    },
    _getDefaultLayoutTemplate: function() {
        return this._$defaultLayoutTemplate.clone()
    },
    applyLayout: function($view, $layout) {
        if (void 0 === $layout || 0 === $layout.length) {
            $layout = this._getDefaultLayoutTemplate()
        }
        if (0 === $view.children(".dx-content").length) {
            this._wrapViewDefaultContent($view)
        }
        var $toMerge = $().add($layout).add($view);
        var $placeholderContents = $toMerge.find(".dx-content");
        $.each($placeholderContents, function() {
            var $placeholderContent = $(this);
            var placeholderId = $placeholderContent.attr("data-dx-target-placeholder-id");
            var $placeholder = $toMerge.find(".dx-content-placeholder-" + placeholderId);
            $placeholder.empty();
            $placeholder.append($placeholderContent)
        });
        for (var i = $placeholderContents.length; i >= 0; i--) {
            var $item = $placeholderContents.eq(i);
            if (!$item.is(".dx-content-placeholder .dx-content")) {
                $item.remove()
            }
        }
        return $layout
    },
    _loadTemplatesFromCache: function() {
        if (!this._templateCacheEnabled) {
            return
        }
        var cache;
        var fromJSONInterceptor = function(key, value) {
            if ("string" === typeof value && 0 === value.indexOf(MARKUP_TEMPLATE_MARKER)) {
                var data = JSON.parse(value.substr(MARKUP_TEMPLATE_MARKER.length)),
                    type = data.type,
                    options = data.options,
                    $markup = domUtils.createMarkupFromString(data.markup);
                options.fromCache = true;
                return $markup[type](options)[type]("instance")
            } else {
                if ("skippedMarkup" === key) {
                    return $("<div>").append(domUtils.createMarkupFromString(value)).contents()
                }
            }
            return value
        };
        var toParse = this._templateCacheStorage.getItem(this._templateCacheKey);
        if (toParse) {
            try {
                var cacheContainer = JSON.parse(toParse, fromJSONInterceptor);
                cache = cacheContainer[this._templatesVersion]
            } catch (e) {
                this._clearCache()
            }
        }
        if (!cache) {
            return
        }
        this._templateMap = cache.templates;
        this.$root.append(cache.skippedMarkup);
        return true
    },
    _putTemplatesToCache: function() {
        if (!this._templateCacheEnabled) {
            return
        }
        var toJSONInterceptor = function(key, value) {
            if (value && value.element) {
                return MARKUP_TEMPLATE_MARKER + JSON.stringify({
                    markup: value.element().prop("outerHTML"),
                    options: value.option(),
                    type: value.NAME
                })
            } else {
                if ("skippedMarkup" === key) {
                    return $("<div>").append(value.clone()).html()
                }
            }
            return value
        };
        var cacheContainer = {};
        cacheContainer[this._templatesVersion] = {
            templates: this._templateMap,
            skippedMarkup: this._$skippedMarkup
        };
        this._templateCacheStorage.setItem(this._templateCacheKey, JSON.stringify(cacheContainer, toJSONInterceptor, 4))
    },
    init: function() {
        var that = this;
        this._initDefaultLayout();
        if (!this._loadTemplatesFromCache()) {
            that._loadTemplatesFromMarkupCore(that.$root.children());
            return this._loadExternalTemplates().done(function() {
                that._processTemplates();
                that._putTemplatesToCache()
            })
        } else {
            return $.Deferred().resolve().promise()
        }
    },
    getViewTemplate: function(viewName) {
        return this._findTemplate(viewName, _VIEW_ROLE)
    },
    getViewTemplateInfo: function(name) {
        return this._findComponent(name, _VIEW_ROLE)
    },
    getLayoutTemplate: function(layoutName) {
        if (!layoutName) {
            return this._getDefaultLayoutTemplate()
        }
        return this._findTemplate(layoutName, _LAYOUT_ROLE)
    },
    getLayoutTemplateInfo: function(name) {
        return this._findComponent(name, _LAYOUT_ROLE)
    },
    loadTemplates: function(source) {
        var result;
        if ("string" === typeof source) {
            result = this._loadTemplatesFromURL(source)
        } else {
            this._loadTemplatesFromMarkupCore(source);
            result = $.Deferred().resolve().promise()
        }
        return result.done(this._processTemplates.bind(this))
    }
});
exports.ViewEngine = ViewEngine;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/double_click.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    domUtils = __webpack_require__(15),
    Class = __webpack_require__(5),
    registerEvent = __webpack_require__(47),
    clickEvent = __webpack_require__(11),
    eventUtils = __webpack_require__(3);
var DBLCLICK_EVENT_NAME = "dxdblclick",
    DBLCLICK_NAMESPACE = "dxDblClick",
    NAMESPACED_CLICK_EVENT = eventUtils.addNamespace(clickEvent.name, DBLCLICK_NAMESPACE),
    DBLCLICK_TIMEOUT = 300;
var DblClick = Class.inherit({
    ctor: function() {
        this._handlerCount = 0;
        this._forgetLastClick()
    },
    _forgetLastClick: function() {
        this._firstClickTarget = null;
        this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
    },
    add: function() {
        if (this._handlerCount <= 0) {
            $(document).on(NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this))
        }
        this._handlerCount++
    },
    _clickHandler: function(e) {
        var timeStamp = e.timeStamp || $.now();
        if (timeStamp - this._lastClickTimeStamp < DBLCLICK_TIMEOUT) {
            eventUtils.fireEvent({
                type: DBLCLICK_EVENT_NAME,
                target: domUtils.closestCommonParent(this._firstClickTarget, e.target),
                originalEvent: e
            });
            this._forgetLastClick()
        } else {
            this._firstClickTarget = e.target;
            this._lastClickTimeStamp = timeStamp
        }
    },
    remove: function() {
        this._handlerCount--;
        if (this._handlerCount <= 0) {
            this._forgetLastClick();
            $(document).off(NAMESPACED_CLICK_EVENT)
        }
    }
});
registerEvent(DBLCLICK_EVENT_NAME, new DblClick);
exports.name = DBLCLICK_EVENT_NAME;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/data.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DevExpress = __webpack_require__(82);
module.exports = DevExpress.data = DevExpress.data || {};
Object.defineProperty(DevExpress.data, "errorHandler", {
    get: function() {
        return __webpack_require__(29).errorHandler
    },
    set: function(value) {
        __webpack_require__(29).errorHandler = value
    }
});
Object.defineProperty(DevExpress.data, "_errorHandler", {
    get: function() {
        return __webpack_require__(29)._errorHandler
    },
    set: function(value) {
        __webpack_require__(29)._errorHandler = value
    }
});
DevExpress.data.DataSource = __webpack_require__(268);
DevExpress.data.query = __webpack_require__(35);
DevExpress.data.Store = __webpack_require__(96);
DevExpress.data.ArrayStore = __webpack_require__(67);
DevExpress.data.CustomStore = __webpack_require__(148);
DevExpress.data.LocalStore = __webpack_require__(270);
DevExpress.data.base64_encode = __webpack_require__(28).base64_encode;
DevExpress.data.Guid = __webpack_require__(34);
DevExpress.data.utils = {};
DevExpress.data.utils.compileGetter = __webpack_require__(14).compileGetter;
DevExpress.data.utils.compileSetter = __webpack_require__(14).compileSetter;
DevExpress.EndpointSelector = __webpack_require__(271);
DevExpress.data.queryImpl = __webpack_require__(35).queryImpl;
DevExpress.data.queryAdapters = __webpack_require__(147);
var dataUtils = __webpack_require__(28);
DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
DevExpress.data.utils.aggregators = dataUtils.aggregators;
DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
DevExpress.data.utils.toComparable = __webpack_require__(14).toComparable;
DevExpress.data.utils.multiLevelGroup = __webpack_require__(97).multiLevelGroup;
DevExpress.data.utils.arrangeSortingInfo = __webpack_require__(97).arrangeSortingInfo;
DevExpress.data.utils.normalizeDataSourceOptions = __webpack_require__(51).normalizeDataSourceOptions;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/proxy_url_formatter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    location = window.location,
    DXPROXY_HOST = "dxproxy.devexpress.com:8000",
    IS_DXPROXY_ORIGIN = location.host === DXPROXY_HOST,
    urlMapping = {};
var parseUrl = function() {
    var a = document.createElement("a"),
        props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
    var normalizePath = function(value) {
        if ("/" !== value.charAt(0)) {
            value = "/" + value
        }
        return value
    };
    return function(url) {
        a.href = url;
        var result = {};
        $.each(props, function() {
            result[this] = a[this]
        });
        result.pathname = normalizePath(result.pathname);
        return result
    }
}();
var extractProxyAppId = function() {
    return location.pathname.split("/")[1]
};
module.exports = {
    parseUrl: parseUrl,
    isProxyUsed: function() {
        return IS_DXPROXY_ORIGIN
    },
    formatProxyUrl: function(localUrl) {
        var urlData = parseUrl(localUrl);
        if (!/^(localhost$|127\.)/i.test(urlData.hostname)) {
            return localUrl
        }
        var proxyUrlPart = DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port;
        urlMapping[proxyUrlPart] = urlData.hostname + ":" + urlData.port;
        var resultUrl = "http://" + proxyUrlPart + urlData.pathname + urlData.search;
        return resultUrl
    },
    formatLocalUrl: function(proxyUrl) {
        if (proxyUrl.indexOf(DXPROXY_HOST) < 0) {
            return proxyUrl
        }
        var resultUrl = proxyUrl;
        for (var proxyUrlPart in urlMapping) {
            if (urlMapping.hasOwnProperty(proxyUrlPart)) {
                if (proxyUrl.indexOf(proxyUrlPart) >= 0) {
                    resultUrl = proxyUrl.replace(proxyUrlPart, urlMapping[proxyUrlPart]);
                    break
                }
            }
        }
        return resultUrl
    }
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/odata/store.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    odataUtils = __webpack_require__(78),
    proxyUrlFormatter = __webpack_require__(184),
    errors = __webpack_require__(29).errors,
    query = __webpack_require__(35),
    Store = __webpack_require__(96),
    mixins = __webpack_require__(186),
    when = __webpack_require__(10).when;
__webpack_require__(120);
var ANONYMOUS_KEY_NAME = "5d46402c-7899-4ea9-bd81-8b73c47c7683";

function expandKeyType(key, keyType) {
    var result = {};
    result[key] = keyType;
    return result
}

function mergeFieldTypesWithKeyType(fieldTypes, keyType) {
    var result = {};
    for (var field in fieldTypes) {
        result[field] = fieldTypes[field]
    }
    for (var keyName in keyType) {
        if (keyName in result) {
            if (result[keyName] !== keyType[keyName]) {
                errors.log("W4001", keyName)
            }
        } else {
            result[keyName] = keyType[keyName]
        }
    }
    return result
}
var ODataStore = Store.inherit({
    ctor: function(options) {
        this.callBase(options);
        this._extractServiceOptions(options);
        var key = this.key(),
            fieldTypes = options.fieldTypes,
            keyType = options.keyType;
        if (keyType) {
            var keyTypeIsString = "string" === typeof keyType;
            if (!key) {
                key = keyTypeIsString ? ANONYMOUS_KEY_NAME : Object.keys(keyType);
                this._legacyAnonymousKey = key
            }
            if (keyTypeIsString) {
                keyType = expandKeyType(key, keyType)
            }
            fieldTypes = mergeFieldTypesWithKeyType(fieldTypes, keyType)
        }
        this._fieldTypes = fieldTypes || {};
        if (2 === this.version()) {
            this._updateMethod = "MERGE"
        } else {
            this._updateMethod = "PATCH"
        }
    },
    _customLoadOptions: function() {
        return ["expand", "customQueryParams"]
    },
    _byKeyImpl: function(key, extraOptions) {
        var params = {};
        if (extraOptions) {
            if (extraOptions.expand) {
                params.$expand = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join()
            }
        }
        return this._sendRequest(this._byKeyUrl(key), "GET", params)
    },
    createQuery: function(loadOptions) {
        var url, queryOptions;
        loadOptions = loadOptions || {};
        queryOptions = {
            adapter: "odata",
            beforeSend: this._beforeSend,
            errorHandler: this._errorHandler,
            jsonp: this._jsonp,
            version: this._version,
            withCredentials: this._withCredentials,
            expand: loadOptions.expand,
            requireTotalCount: loadOptions.requireTotalCount,
            deserializeDates: this._deserializeDates,
            fieldTypes: this._fieldTypes
        };
        if (commonUtils.isDefined(loadOptions.urlOverride)) {
            url = loadOptions.urlOverride
        } else {
            url = this._url
        }
        if (loadOptions.customQueryParams) {
            var params = mixins.escapeServiceOperationParams(loadOptions.customQueryParams, this.version());
            if (4 === this.version()) {
                url = mixins.formatFunctionInvocationUrl(url, params)
            } else {
                queryOptions.params = params
            }
        }
        return query(url, queryOptions)
    },
    _insertImpl: function(values) {
        this._requireKey();
        var that = this,
            d = $.Deferred();
        when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
            d.resolve(values, that.keyOf(serverResponse))
        }).fail(d.reject);
        return d.promise()
    },
    _updateImpl: function(key, values) {
        var d = $.Deferred();
        when(this._sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function() {
            d.resolve(key, values)
        }).fail(d.reject);
        return d.promise()
    },
    _removeImpl: function(key) {
        var d = $.Deferred();
        when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
            d.resolve(key)
        }).fail(d.reject);
        return d.promise()
    },
    _convertKey: function(value) {
        var result = value,
            fieldTypes = this._fieldTypes,
            key = this.key() || this._legacyAnonymousKey;
        if (Array.isArray(key)) {
            result = {};
            for (var keyIndex in key) {
                var keyName = key[keyIndex];
                result[keyName] = odataUtils.convertPrimitiveValue(fieldTypes[keyName], value[keyName])
            }
        } else {
            if (fieldTypes[key]) {
                result = odataUtils.convertPrimitiveValue(fieldTypes[key], value)
            }
        }
        return result
    },
    _byKeyUrl: function(value, useOriginalHost) {
        var baseUrl = useOriginalHost ? proxyUrlFormatter.formatLocalUrl(this._url) : this._url;
        var convertedKey = this._convertKey(value);
        return baseUrl + "(" + encodeURIComponent(odataUtils.serializeKey(convertedKey, this._version)) + ")"
    }
}, "odata").include(mixins.SharedMethods);
module.exports = ODataStore;
module.exports.default = module.exports;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/odata/mixins.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    stringUtils = __webpack_require__(30),
    odataUtils = __webpack_require__(78);
__webpack_require__(120);
var DEFAULT_PROTOCOL_VERSION = 2;
var formatFunctionInvocationUrl = function(baseUrl, args) {
    return stringUtils.format("{0}({1})", baseUrl, $.map(args || {}, function(value, key) {
        return stringUtils.format("{0}={1}", key, value)
    }).join(","))
};
var escapeServiceOperationParams = function(params, version) {
    if (!params) {
        return params
    }
    var result = {};
    $.each(params, function(k, v) {
        result[k] = odataUtils.serializeValue(v, version)
    });
    return result
};
var SharedMethods = {
    _extractServiceOptions: function(options) {
        options = options || {};
        this._url = String(options.url).replace(/\/+$/, "");
        this._beforeSend = options.beforeSend;
        this._jsonp = options.jsonp;
        this._version = options.version || DEFAULT_PROTOCOL_VERSION;
        this._withCredentials = options.withCredentials;
        this._deserializeDates = options.deserializeDates
    },
    _sendRequest: function(url, method, params, payload) {
        return odataUtils.sendRequest(this.version(), {
            url: url,
            method: method,
            params: params || {},
            payload: payload
        }, {
            beforeSend: this._beforeSend,
            jsonp: this._jsonp,
            withCredentials: this._withCredentials,
            deserializeDates: this._deserializeDates
        })
    },
    version: function() {
        return this._version
    }
};
exports.SharedMethods = SharedMethods;
exports.escapeServiceOperationParams = escapeServiceOperationParams;
exports.formatFunctionInvocationUrl = formatFunctionInvocationUrl;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/dialog.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Component = __webpack_require__(106),
    isFunction = __webpack_require__(2).isFunction,
    Action = __webpack_require__(62),
    domUtils = __webpack_require__(15),
    viewPortUtils = __webpack_require__(54),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    devices = __webpack_require__(6),
    themes = __webpack_require__(20),
    errors = __webpack_require__(16),
    messageLocalization = __webpack_require__(8),
    Popup = __webpack_require__(68),
    config = __webpack_require__(31);
var DEFAULT_BUTTON = {
    text: "OK",
    onClick: function() {
        return true
    }
};
var DX_DIALOG_CLASSNAME = "dx-dialog",
    DX_DIALOG_WRAPPER_CLASSNAME = DX_DIALOG_CLASSNAME + "-wrapper",
    DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
    DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
    DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
    DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
    DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
var FakeDialogComponent = Component.inherit({
    ctor: function(element, options) {
        this.callBase(options)
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                width: 276
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                lWidth: "60%",
                pWidth: "80%"
            }
        }, {
            device: function(device) {
                var currentTheme = (themes.current() || "").split(".")[0];
                return !device.phone && "win8" === currentTheme
            },
            options: {
                width: function() {
                    return $(window).width()
                }
            }
        }, {
            device: function(device) {
                var currentTheme = (themes.current() || "").split(".")[0];
                return device.phone && "win8" === currentTheme
            },
            options: {
                position: {
                    my: "top center",
                    at: "top center",
                    of: window,
                    offset: "0 0"
                }
            }
        }])
    }
});
exports.FakeDialogComponent = FakeDialogComponent;
exports.title = "";
exports.custom = function(options) {
    var deferred = $.Deferred();
    var defaultOptions = (new FakeDialogComponent).option();
    options = extend(defaultOptions, options);
    var $element = $("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo(viewPortUtils.value());
    var $message = $("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
    var popupToolbarItems = [];
    var toolbarItemsOption = options.toolbarItems;
    if (toolbarItemsOption) {
        errors.log("W0001", "DevExpress.ui.dialog", "toolbarItems", "16.2", "Use the 'buttons' option instead")
    } else {
        toolbarItemsOption = options.buttons
    }
    $.each(toolbarItemsOption || [DEFAULT_BUTTON], function() {
        var action = new Action(this.onClick, {
            context: popupInstance
        });
        popupToolbarItems.push({
            toolbar: "bottom",
            location: devices.current().android ? "after" : "center",
            widget: "dxButton",
            options: extend({}, this, {
                onClick: function() {
                    var result = action.execute(arguments);
                    hide(result)
                }
            })
        })
    });
    var popupInstance = new Popup($element, {
        title: options.title || exports.title,
        showTitle: function() {
            var isTitle = void 0 === options.showTitle ? true : options.showTitle;
            return isTitle
        }(),
        height: "auto",
        width: function() {
            var isPortrait = $(window).height() > $(window).width(),
                key = (isPortrait ? "p" : "l") + "Width",
                widthOption = options.hasOwnProperty(key) ? options[key] : options.width;
            return isFunction(widthOption) ? widthOption() : widthOption
        },
        showCloseButton: options.showCloseButton || false,
        focusStateEnabled: false,
        onContentReady: function(args) {
            args.component.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message)
        },
        onShowing: function(e) {
            e.component.bottomToolbar().addClass(DX_DIALOG_BUTTONS_CLASSNAME).find(".dx-button").addClass(DX_DIALOG_BUTTON_CLASSNAME);
            domUtils.resetActiveElement()
        },
        onShown: function(e) {
            e.component.bottomToolbar().find(".dx-button").first().focus()
        },
        onHiding: function() {
            deferred.reject()
        },
        toolbarItems: popupToolbarItems,
        animation: {
            show: {
                type: "pop",
                duration: 400
            },
            hide: {
                type: "pop",
                duration: 400,
                to: {
                    opacity: 0,
                    scale: 0
                },
                from: {
                    opacity: 1,
                    scale: 1
                }
            }
        },
        rtlEnabled: config().rtlEnabled,
        boundaryOffset: {
            h: 10,
            v: 0
        }
    });
    popupInstance._wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
    if (options.position) {
        popupInstance.option("position", options.position)
    }
    popupInstance._wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);

    function show() {
        popupInstance.show();
        return deferred.promise()
    }

    function hide(value) {
        deferred.resolve(value);
        popupInstance.hide().done(function() {
            popupInstance.element().remove()
        })
    }
    return {
        show: show,
        hide: hide
    }
};
exports.alert = function(message, title, showTitle) {
    var options = isPlainObject(message) ? message : {
        title: title,
        message: message,
        showTitle: showTitle
    };
    return exports.custom(options).show()
};
exports.confirm = function(message, title, showTitle) {
    var options = isPlainObject(message) ? message : {
        title: title,
        message: message,
        showTitle: showTitle,
        buttons: [{
            text: messageLocalization.format("Yes"),
            onClick: function() {
                return true
            }
        }, {
            text: messageLocalization.format("No"),
            onClick: function() {
                return false
            }
        }]
    };
    return exports.custom(options).show()
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    isPlainObject = __webpack_require__(9).isPlainObject,
    registerComponent = __webpack_require__(4),
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    CollectionWidget = __webpack_require__(40),
    BindableTemplate = __webpack_require__(52);
var TOOLBAR_CLASS = "dx-toolbar",
    TOOLBAR_BEFORE_CLASS = "dx-toolbar-before",
    TOOLBAR_CENTER_CLASS = "dx-toolbar-center",
    TOOLBAR_AFTER_CLASS = "dx-toolbar-after",
    TOOLBAR_BOTTOM_CLASS = "dx-toolbar-bottom",
    TOOLBAR_MINI_CLASS = "dx-toolbar-mini",
    TOOLBAR_ITEM_CLASS = "dx-toolbar-item",
    TOOLBAR_LABEL_CLASS = "dx-toolbar-label",
    TOOLBAR_BUTTON_CLASS = "dx-toolbar-button",
    TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container",
    TOOLBAR_GROUP_CLASS = "dx-toolbar-group",
    TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS,
    TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = CollectionWidget.inherit({
    _initTemplates: function() {
        this.callBase();
        var template = new BindableTemplate(function($container, data, rawModel) {
            if (isPlainObject(data)) {
                if (data.text) {
                    $container.text(data.text).wrapInner("<div>")
                }
                if (data.html) {
                    $container.html(data.html)
                }
            } else {
                $container.text(String(data))
            }
            this._getTemplate("dx-polymorph-widget").render({
                container: $container,
                model: rawModel
            })
        }.bind(this), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
        this._defaultTemplates.item = template;
        this._defaultTemplates.menuItem = template
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            renderAs: "topToolbar"
        })
    },
    _itemContainer: function() {
        return this._$toolbarItemsContainer.find(["." + TOOLBAR_BEFORE_CLASS, "." + TOOLBAR_CENTER_CLASS, "." + TOOLBAR_AFTER_CLASS].join(","))
    },
    _itemClass: function() {
        return TOOLBAR_ITEM_CLASS
    },
    _itemDataKey: function() {
        return TOOLBAR_ITEM_DATA_KEY
    },
    _buttonClass: function() {
        return TOOLBAR_BUTTON_CLASS
    },
    _dimensionChanged: function() {
        this._arrangeItems()
    },
    _render: function() {
        this._renderToolbar();
        this._renderSections();
        this.setAria("role", "toolbar");
        this.callBase();
        this._arrangeItems()
    },
    _renderToolbar: function() {
        this.element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_BOTTOM_CLASS, "bottomToolbar" === this.option("renderAs"));
        this._$toolbarItemsContainer = $("<div>").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.element())
    },
    _renderSections: function() {
        var $container = this._$toolbarItemsContainer,
            that = this;
        $.each(["before", "center", "after"], function() {
            var sectionClass = "dx-toolbar-" + this,
                $section = $container.find("." + sectionClass);
            if (!$section.length) {
                that["_$" + this + "Section"] = $section = $("<div>").addClass(sectionClass).appendTo($container)
            }
        })
    },
    _arrangeItems: function(elementWidth) {
        elementWidth = elementWidth || this.element().width();
        this._$centerSection.css({
            margin: "0 auto",
            "float": "none"
        });
        var beforeRect = this._$beforeSection.get(0).getBoundingClientRect(),
            afterRect = this._$afterSection.get(0).getBoundingClientRect();
        this._alignCenterSection(beforeRect, afterRect);
        var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0),
            $section = $label.parent();
        if (!$label.length) {
            return
        }
        var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left,
            widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset,
            widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width,
            elemsAtSectionWidth = 0;
        $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
            elemsAtSectionWidth += $(this).outerWidth()
        });
        var freeSpace = elementWidth - elemsAtSectionWidth,
            labelPaddings = $label.outerWidth() - $label.width(),
            labelMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection - labelPaddings, 0);
        $label.css("max-width", labelMaxWidth)
    },
    _alignCenterSection: function(beforeRect, afterRect) {
        var isRTL = this.option("rtlEnabled"),
            leftRect = isRTL ? afterRect : beforeRect,
            rightRect = isRTL ? beforeRect : afterRect,
            centerRect = this._$centerSection.get(0).getBoundingClientRect();
        if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
            this._$centerSection.css({
                marginLeft: leftRect.width,
                marginRight: rightRect.width,
                "float": leftRect.width > rightRect.width ? "none" : "right"
            })
        }
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var location = item.location || "center",
            container = itemContainer || this._$toolbarItemsContainer.find(".dx-toolbar-" + location),
            itemHasText = Boolean(item.text) || Boolean(item.html),
            itemElement = this.callBase(index, item, container, $after);
        itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText);
        return itemElement
    },
    _renderGroupedItems: function() {
        var that = this;
        $.each(this.option("items"), function(groupIndex, group) {
            var groupItems = group.items,
                $container = $("<div>", {
                    "class": TOOLBAR_GROUP_CLASS
                }),
                location = group.location || "center";
            if (!groupItems.length) {
                return
            }
            $.each(groupItems, function(itemIndex, item) {
                that._renderItem(itemIndex, item, $container, null)
            });
            that._$toolbarItemsContainer.find(".dx-toolbar-" + location).append($container)
        })
    },
    _renderItems: function(items) {
        var grouped = items.length && items[0].items;
        grouped ? this._renderGroupedItems() : this.callBase(items)
    },
    _getToolbarItems: function() {
        return this.option("items") || []
    },
    _renderContentImpl: function() {
        var items = this._getToolbarItems();
        this.element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);
        if (this._renderedItemsCount) {
            this._renderItems(items.slice(this._renderedItemsCount))
        } else {
            this._renderItems(items)
        }
    },
    _renderEmptyMessage: commonUtils.noop,
    _clean: function() {
        this._$toolbarItemsContainer.children().empty();
        this.element().empty()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._arrangeItems()
        }
    },
    _isVisible: function() {
        return this.element().width() > 0 && this.element().height() > 0
    },
    _getIndexByItem: function(item) {
        return inArray(item, this._getToolbarItems())
    },
    _itemOptionChanged: function(item, property, value) {
        this.callBase.apply(this, [item, property, value]);
        this._arrangeItems()
    },
    _optionChanged: function(args) {
        var name = args.name;
        switch (name) {
            case "width":
                this.callBase.apply(this, arguments);
                this._dimensionChanged();
                break;
            case "renderAs":
                this._invalidate();
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    }
});
registerComponent("dxToolbarBase", ToolbarBase);
module.exports = ToolbarBase;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/selection/selection.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    deferredStrategy = __webpack_require__(278),
    standardStrategy = __webpack_require__(279),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2);
module.exports = Class.inherit({
    ctor: function(options) {
        this.options = extend(this._getDefaultOptions(), options, {
            selectedItemKeys: options.selectedKeys || []
        });
        this._selectionStrategy = this.options.deferred ? new deferredStrategy(this.options) : new standardStrategy(this.options);
        this._focusedItemIndex = -1;
        if (!this.options.equalByReference) {
            this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys)
        }
    },
    _getDefaultOptions: function() {
        return {
            deferred: false,
            equalByReference: false,
            mode: "multiple",
            selectedItems: [],
            selectionFilter: [],
            maxFilterLengthInRequest: 0,
            onSelectionChanged: commonUtils.noop,
            key: commonUtils.noop,
            keyOf: function(item) {
                return item
            },
            load: function() {
                return $.Deferred().resolve([])
            },
            totalCount: function() {
                return -1
            },
            isSelectableItem: function() {
                return true
            },
            isItemSelected: function() {
                return false
            },
            getItemData: function(item) {
                return item
            },
            dataFields: commonUtils.noop,
            filter: commonUtils.noop
        }
    },
    validate: function() {
        this._selectionStrategy.validate()
    },
    getSelectedItemKeys: function() {
        return this._selectionStrategy.getSelectedItemKeys()
    },
    getSelectedItems: function() {
        return this._selectionStrategy.getSelectedItems()
    },
    selectionFilter: function(value) {
        if (void 0 === value) {
            return this.options.selectionFilter
        }
        var filterIsChanged = this.options.selectionFilter !== value && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value);
        this.options.selectionFilter = value;
        filterIsChanged && this.onSelectionChanged()
    },
    setSelection: function(keys) {
        return this.selectedItemKeys(keys)
    },
    select: function(keys) {
        return this.selectedItemKeys(keys, true)
    },
    deselect: function(keys) {
        return this.selectedItemKeys(keys, true, true)
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
        var that = this;
        keys = keys || [];
        keys = Array.isArray(keys) ? keys : [keys];
        that.validate();
        return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
    },
    clearSelection: function() {
        return this.selectedItemKeys([])
    },
    _addSelectedItem: function(itemData, key) {
        this._selectionStrategy.addSelectedItem(key, itemData)
    },
    _removeSelectedItem: function(key) {
        this._selectionStrategy.removeSelectedItem(key)
    },
    _setSelectedItems: function(keys, items) {
        this._selectionStrategy.setSelectedItems(keys, items)
    },
    onSelectionChanged: function() {
        this._selectionStrategy.onSelectionChanged()
    },
    changeItemSelection: function(itemIndex, keys) {
        var isSelectedItemsChanged, items = this.options.plainItems(),
            item = items[itemIndex];
        if (!this.isSelectable() || !this.isDataItem(item)) {
            return false
        }
        var itemData = this.options.getItemData(item),
            itemKey = this.options.keyOf(itemData);
        keys = keys || {};
        if (keys.shift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
            isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items)
        } else {
            if (keys.control) {
                this._resetItemSelectionWhenShiftKeyPressed();
                var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
                if ("single" === this.options.mode) {
                    this.clearSelectedItems()
                }
                if (isSelected) {
                    this._removeSelectedItem(itemKey)
                } else {
                    this._addSelectedItem(itemData, itemKey)
                }
                isSelectedItemsChanged = true
            } else {
                this._resetItemSelectionWhenShiftKeyPressed();
                var isKeysEqual = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
                if (1 !== this.options.selectedItemKeys.length || !isKeysEqual) {
                    this._setSelectedItems([itemKey], [itemData]);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (isSelectedItemsChanged) {
            this._focusedItemIndex = itemIndex;
            this.onSelectionChanged();
            return true
        }
    },
    isDataItem: function(item) {
        return this.options.isSelectableItem(item)
    },
    isSelectable: function() {
        return "single" === this.options.mode || "multiple" === this.options.mode
    },
    isItemSelected: function(arg) {
        return this._selectionStrategy.isItemKeySelected(arg)
    },
    _resetItemSelectionWhenShiftKeyPressed: function() {
        delete this._shiftFocusedItemIndex
    },
    changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
        var itemIndexStep, index, isSelectedItemsChanged = false,
            keyOf = this.options.keyOf,
            focusedItem = items[this._focusedItemIndex],
            focusedData = this.options.getItemData(focusedItem),
            focusedKey = keyOf(focusedData),
            isFocusedItemSelected = focusedItem && this.isItemSelected(focusedKey);
        if (!commonUtils.isDefined(this._shiftFocusedItemIndex)) {
            this._shiftFocusedItemIndex = this._focusedItemIndex
        }
        var data, itemKey;
        if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
            itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
            for (index = this._focusedItemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                if (this.isDataItem(items[index])) {
                    itemKey = keyOf(this.options.getItemData(items[index]));
                    this._removeSelectedItem(itemKey);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (itemIndex !== this._shiftFocusedItemIndex) {
            itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
            for (index = itemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                if (this.isDataItem(items[index])) {
                    data = this.options.getItemData(items[index]);
                    itemKey = keyOf(data);
                    this._addSelectedItem(data, itemKey);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
            this._addSelectedItem(focusedData, focusedKey);
            isSelectedItemsChanged = true
        }
        return isSelectedItemsChanged
    },
    clearSelectedItems: function() {
        this._setSelectedItems([], [])
    },
    selectAll: function(isOnePage) {
        if (isOnePage) {
            return this._onePageSelectAll(false)
        } else {
            return this.selectedItemKeys([], true, false, true)
        }
    },
    deselectAll: function(isOnePage) {
        if (isOnePage) {
            return this._onePageSelectAll(true)
        } else {
            return this.selectedItemKeys([], true, true, true)
        }
    },
    _onePageSelectAll: function(isDeselect) {
        var items = this.options.plainItems();
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (this.isDataItem(item)) {
                var itemData = this.options.getItemData(item),
                    itemKey = this.options.keyOf(itemData),
                    isSelected = this.isItemSelected(itemKey);
                if (!isSelected && !isDeselect) {
                    this._addSelectedItem(itemData, itemKey)
                }
                if (isSelected && isDeselect) {
                    this._removeSelectedItem(itemKey)
                }
            }
        }
        this.onSelectionChanged();
        return $.Deferred().resolve()
    },
    getSelectAllState: function(visibleOnly) {
        return this._selectionStrategy.getSelectAllState(visibleOnly)
    }
});


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/selection/selection.strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    dataQuery = __webpack_require__(35),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    getKeyHash = commonUtils.getKeyHash,
    Class = __webpack_require__(5);
module.exports = Class.inherit({
    ctor: function(options) {
        this.options = options;
        this._clearItemKeys()
    },
    _clearItemKeys: function() {
        this._setOption("addedItemKeys", []);
        this._setOption("removedItemKeys", []);
        this._setOption("removedItems", []);
        this._setOption("addedItems", [])
    },
    validate: commonUtils.noop,
    _setOption: function(name, value) {
        this.options[name] = value
    },
    onSelectionChanged: function() {
        var addedItemKeys = this.options.addedItemKeys,
            removedItemKeys = this.options.removedItemKeys,
            addedItems = this.options.addedItems,
            removedItems = this.options.removedItems,
            selectedItems = this.options.selectedItems,
            selectedItemKeys = this.options.selectedItemKeys,
            onSelectionChanged = this.options.onSelectionChanged || commonUtils.noop;
        this._clearItemKeys();
        onSelectionChanged({
            selectedItems: selectedItems,
            selectedItemKeys: selectedItemKeys,
            addedItemKeys: addedItemKeys,
            removedItemKeys: removedItemKeys,
            addedItems: addedItems,
            removedItems: removedItems
        })
    },
    equalKeys: function(key1, key2) {
        if (this.options.equalByReference) {
            if (commonUtils.isObject(key1) && commonUtils.isObject(key2)) {
                return key1 === key2
            }
        }
        return commonUtils.equalByValue(key1, key2)
    },
    _clearSelection: function(keys, preserve, isDeselect, isSelectAll) {
        keys = keys || [];
        keys = Array.isArray(keys) ? keys : [keys];
        this.validate();
        return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
    },
    _loadFilteredData: function(remoteFilter, localFilter, select) {
        var filterLength = encodeURI(JSON.stringify(remoteFilter)).length,
            needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest,
            deferred = $.Deferred(),
            loadOptions = {
                filter: needLoadAllData ? void 0 : remoteFilter,
                select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
            };
        if (remoteFilter && 0 === remoteFilter.length) {
            deferred.resolve([])
        } else {
            this.options.load(loadOptions).done(function(items) {
                var filteredItems = typeUtils.isPlainObject(items) ? items.data : items;
                if (localFilter) {
                    filteredItems = filteredItems.filter(localFilter)
                } else {
                    if (needLoadAllData) {
                        filteredItems = dataQuery(filteredItems).filter(remoteFilter).toArray()
                    }
                }
                deferred.resolve(filteredItems)
            }).fail(deferred.reject.bind(deferred))
        }
        return deferred
    },
    updateSelectedItemKeyHash: function(keys) {
        for (var i = 0; i < keys.length; i++) {
            var keyHash = getKeyHash(keys[i]);
            if (!commonUtils.isObject(keyHash)) {
                this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
                var keyIndices = this.options.keyHashIndices[keyHash];
                keyIndices.push(i)
            }
        }
    },
    _isAnyItemSelected: function(items) {
        for (var i = 0; i < items.length; i++) {
            if (this.options.isItemSelected(items[i])) {
                return
            }
        }
        return false
    },
    _getFullSelectAllState: function() {
        var items = this.options.plainItems(),
            dataFilter = this.options.filter(),
            selectedItems = this.options.selectedItems;
        if (dataFilter) {
            selectedItems = dataQuery(selectedItems).filter(dataFilter).toArray()
        }
        var selectedItemsLength = selectedItems.length;
        if (!selectedItemsLength) {
            return this._isAnyItemSelected(items)
        }
        if (selectedItemsLength >= this.options.totalCount()) {
            return true
        }
        return
    },
    _getVisibleSelectAllState: function() {
        var items = this.options.plainItems(),
            hasSelectedItems = false,
            hasUnselectedItems = false;
        for (var i = 0; i < items.length; i++) {
            var item = items[i],
                itemData = this.options.getItemData(item),
                key = this.options.keyOf(itemData);
            if (this.options.isSelectableItem(item)) {
                if (this.isItemKeySelected(key)) {
                    hasSelectedItems = true
                } else {
                    hasUnselectedItems = true
                }
            }
        }
        if (hasSelectedItems) {
            return !hasUnselectedItems ? true : void 0
        } else {
            return false
        }
    }
});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toast.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    pointerEvents = __webpack_require__(17),
    registerComponent = __webpack_require__(4),
    Overlay = __webpack_require__(39);
var TOAST_CLASS = "dx-toast",
    TOAST_CLASS_PREFIX = TOAST_CLASS + "-",
    TOAST_WRAPPER_CLASS = TOAST_CLASS_PREFIX + "wrapper",
    TOAST_CONTENT_CLASS = TOAST_CLASS_PREFIX + "content",
    TOAST_MESSAGE_CLASS = TOAST_CLASS_PREFIX + "message",
    TOAST_ICON_CLASS = TOAST_CLASS_PREFIX + "icon",
    WIDGET_NAME = "dxToast",
    toastTypes = ["info", "warning", "error", "success"],
    TOAST_STACK = [],
    FIRST_Z_INDEX_OFFSET = 8e3,
    visibleToastInstance = null,
    POSITION_ALIASES = {
        top: {
            my: "top",
            at: "top",
            of: null,
            offset: "0 0"
        },
        bottom: {
            my: "bottom",
            at: "bottom",
            of: null,
            offset: "0 -20"
        },
        center: {
            my: "center",
            at: "center",
            of: null,
            offset: "0 0"
        },
        right: {
            my: "center right",
            at: "center right",
            of: null,
            offset: "0 0"
        },
        left: {
            my: "center left",
            at: "center left",
            of: null,
            offset: "0 0"
        }
    };
$(document).on(pointerEvents.down, function(e) {
    for (var i = TOAST_STACK.length - 1; i >= 0; i--) {
        if (!TOAST_STACK[i]._proxiedDocumentDownHandler(e)) {
            return
        }
    }
});
var Toast = Overlay.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            message: "",
            type: "info",
            displayTime: 2e3,
            position: "bottom center",
            animation: {
                show: {
                    type: "fade",
                    duration: 400,
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    duration: 400,
                    to: 0
                }
            },
            shading: false,
            height: "auto",
            closeOnBackButton: false,
            closeOnSwipe: true,
            closeOnClick: false,
            resizeEnabled: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return "win" === device.platform && device.version && 8 === device.version[0]
            },
            options: {
                position: "top center",
                width: function() {
                    return $(window).width()
                }
            }
        }, {
            device: function(device) {
                return "win" === device.platform && device.version && 10 === device.version[0]
            },
            options: {
                position: "bottom right",
                width: "auto"
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                closeOnOutsideClick: true,
                width: "auto",
                position: {
                    at: "bottom left",
                    my: "bottom left",
                    offset: "20 -20"
                },
                animation: {
                    show: {
                        type: "slide",
                        duration: 200,
                        from: {
                            top: $(window).height()
                        }
                    },
                    hide: {
                        type: "slide",
                        duration: 200,
                        to: {
                            top: $(window).height()
                        }
                    }
                }
            }
        }, {
            device: function(device) {
                var isPhone = "phone" === device.deviceType,
                    isAndroid = "android" === device.platform,
                    isWin10 = "win" === device.platform && device.version && 10 === device.version[0];
                return isPhone && (isAndroid || isWin10)
            },
            options: {
                width: function() {
                    return $(window).width()
                },
                position: {
                    at: "bottom center",
                    my: "bottom center",
                    offset: "0 0"
                }
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._posStringToObject()
    },
    _renderContentImpl: function() {
        if (this.option("message")) {
            this._message = $("<div>").addClass(TOAST_MESSAGE_CLASS).text(this.option("message")).appendTo(this.content())
        }
        this.setAria("role", "alert", this._message);
        if (inArray(this.option("type").toLowerCase(), toastTypes) > -1) {
            this.content().prepend($("<div>").addClass(TOAST_ICON_CLASS))
        }
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this.element().addClass(TOAST_CLASS);
        this._wrapper().addClass(TOAST_WRAPPER_CLASS);
        this._$content.addClass(TOAST_CLASS_PREFIX + String(this.option("type")).toLowerCase());
        this.content().addClass(TOAST_CONTENT_CLASS);
        this._toggleCloseEvents("Swipe");
        this._toggleCloseEvents("Click")
    },
    _renderScrollTerminator: commonUtils.noop,
    _toggleCloseEvents: function(event) {
        var dxEvent = "dx" + event.toLowerCase();
        this._$content.off(dxEvent);
        this.option("closeOn" + event) && this._$content.on(dxEvent, this.hide.bind(this))
    },
    _posStringToObject: function() {
        if (!commonUtils.isString(this.option("position"))) {
            return
        }
        var verticalPosition = this.option("position").split(" ")[0],
            horizontalPosition = this.option("position").split(" ")[1];
        this.option("position", extend({}, POSITION_ALIASES[verticalPosition]));
        switch (horizontalPosition) {
            case "center":
            case "left":
            case "right":
                this.option("position").at += " " + horizontalPosition;
                this.option("position").my += " " + horizontalPosition
        }
    },
    _show: function() {
        if (visibleToastInstance) {
            clearTimeout(visibleToastInstance._hideTimeout);
            visibleToastInstance.hide()
        }
        visibleToastInstance = this;
        return this.callBase.apply(this, arguments).done(function() {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = setTimeout(this.hide.bind(this), this.option("displayTime"))
        }.bind(this))
    },
    _hide: function() {
        visibleToastInstance = null;
        return this.callBase.apply(this, arguments)
    },
    _overlayStack: function() {
        return TOAST_STACK
    },
    _zIndexInitValue: function() {
        return this.callBase() + FIRST_Z_INDEX_OFFSET
    },
    _dispose: function() {
        clearTimeout(this._hideTimeout);
        visibleToastInstance = null;
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "type":
                this._$content.removeClass(TOAST_CLASS_PREFIX + args.previousValue);
                this._$content.addClass(TOAST_CLASS_PREFIX + String(args.value).toLowerCase());
                break;
            case "message":
                if (this._message) {
                    this._message.text(args.value)
                }
                break;
            case "closeOnSwipe":
                this._toggleCloseEvents("Swipe");
                break;
            case "closeOnClick":
                this._toggleCloseEvents("Click");
                break;
            case "displayTime":
            case "position":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent(WIDGET_NAME, Toast);
module.exports = Toast;
module.exports.default = module.exports;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/ui.text_editor.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var registerComponent = __webpack_require__(4),
    TextEditorMask = __webpack_require__(283);
registerComponent("dxTextEditor", TextEditorMask);
module.exports = TextEditorMask;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/utils.caret.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    browser = __webpack_require__(21);
var isFocusingOnCaretChange = browser.msie || browser.safari;
var getCaret = function(input) {
    if (isObsoleteBrowser(input)) {
        return getCaretForObsoleteBrowser(input)
    }
    return {
        start: input.selectionStart,
        end: input.selectionEnd
    }
};
var setCaret = function(input, position) {
    if (isObsoleteBrowser(input)) {
        setCaretForObsoleteBrowser(input, position);
        return
    }
    if (!$.contains(document, input)) {
        return
    }
    input.selectionStart = position.start;
    input.selectionEnd = position.end
};
var isObsoleteBrowser = function(input) {
    return !input.setSelectionRange
};
var getCaretForObsoleteBrowser = function(input) {
    var range = document.selection.createRange();
    var rangeCopy = range.duplicate();
    range.move("character", -input.value.length);
    range.setEndPoint("EndToStart", rangeCopy);
    return {
        start: range.text.length,
        end: range.text.length + rangeCopy.text.length
    }
};
var setCaretForObsoleteBrowser = function(input, position) {
    if (!$.contains(document, input)) {
        return
    }
    var range = input.createTextRange();
    range.collapse(true);
    range.moveStart("character", position.start);
    range.moveEnd("character", position.end - position.start);
    range.select()
};
var caret = function(input, position) {
    input = $(input).get(0);
    if (!commonUtils.isDefined(position)) {
        return getCaret(input)
    }
    if (isFocusingOnCaretChange && document.activeElement !== input) {
        return
    }
    setCaret(input, position)
};
module.exports = caret;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    EditDecorator = __webpack_require__(80),
    abstract = EditDecorator.abstract,
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    feedbackEvents = __webpack_require__(75);
var LIST_EDIT_DECORATOR = "dxListEditDecorator",
    POINTER_DOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, LIST_EDIT_DECORATOR),
    ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
    LIST_ITEM_CONTENT_CLASS = "dx-list-item-content",
    SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready",
    SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning",
    SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield",
    SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield",
    SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning",
    SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
var SwitchableEditDecorator = EditDecorator.inherit({
    _init: function() {
        this._$topShield = $("<div />").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
        this._$bottomShield = $("<div />").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
        this._$itemContentShield = $("<div />").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
        this._$topShield.on(POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        this._$bottomShield.on(POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        this._list.element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false))
    },
    handleClick: function() {
        return this._cancelDeleteReadyItem()
    },
    _cancelDeleteReadyItem: function() {
        if (!this._$readyToDeleteItem) {
            return false
        }
        this._cancelDelete(this._$readyToDeleteItem);
        return true
    },
    _cancelDelete: function($itemElement) {
        this._toggleDeleteReady($itemElement, false)
    },
    _toggleDeleteReady: function($itemElement, readyToDelete) {
        if (void 0 === readyToDelete) {
            readyToDelete = !this._isReadyToDelete($itemElement)
        }
        this._toggleShields($itemElement, readyToDelete);
        this._toggleScrolling(readyToDelete);
        this._cacheReadyToDeleteItem($itemElement, readyToDelete);
        this._animateToggleDelete($itemElement, readyToDelete)
    },
    _isReadyToDelete: function($itemElement) {
        return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _toggleShields: function($itemElement, enabled) {
        this._list.element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
        this._$topShield.toggle(enabled);
        this._$bottomShield.toggle(enabled);
        if (enabled) {
            this._updateShieldsHeight($itemElement)
        }
        this._toggleContentShield($itemElement, enabled)
    },
    _updateShieldsHeight: function($itemElement) {
        var $list = this._list.element(),
            listTopOffset = $list.offset().top,
            listHeight = $list.outerHeight(),
            itemTopOffset = $itemElement.offset().top,
            itemHeight = $itemElement.outerHeight(),
            dirtyTopShieldHeight = itemTopOffset - listTopOffset,
            dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
        this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
        this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0))
    },
    _toggleContentShield: function($itemElement, enabled) {
        if (enabled) {
            $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).first().append(this._$itemContentShield)
        } else {
            this._$itemContentShield.detach()
        }
    },
    _toggleScrolling: function(readyToDelete) {
        var scrollView = this._list.element().dxScrollView("instance");
        if (readyToDelete) {
            scrollView.on("start", this._cancelScrolling)
        } else {
            scrollView.off("start", this._cancelScrolling)
        }
    },
    _cancelScrolling: function(args) {
        args.jQueryEvent.cancel = true
    },
    _cacheReadyToDeleteItem: function($itemElement, cache) {
        if (cache) {
            this._$readyToDeleteItem = $itemElement
        } else {
            delete this._$readyToDeleteItem
        }
    },
    _animateToggleDelete: function($itemElement, readyToDelete) {
        if (readyToDelete) {
            this._enablePositioning($itemElement);
            this._prepareDeleteReady($itemElement);
            this._animatePrepareDeleteReady($itemElement)
        } else {
            this._forgetDeleteReady($itemElement);
            this._animateForgetDeleteReady($itemElement).done(this._disablePositioning.bind(this, $itemElement))
        }
    },
    _enablePositioning: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        $itemElement.on(ACTIVE_EVENT_NAME, noop)
    },
    _disablePositioning: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        $itemElement.off(ACTIVE_EVENT_NAME)
    },
    _prepareDeleteReady: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _forgetDeleteReady: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _animatePrepareDeleteReady: abstract,
    _animateForgetDeleteReady: abstract,
    _deleteItem: function($itemElement) {
        $itemElement = $itemElement || this._$readyToDeleteItem;
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        this._list.deleteItem($itemElement).always(this._cancelDelete.bind(this, $itemElement))
    },
    _isRtlEnabled: function() {
        return this._list.option("rtlEnabled")
    },
    dispose: function() {
        if (this._$topShield) {
            this._$topShield.remove()
        }
        if (this._$bottomShield) {
            this._$bottomShield.remove()
        }
        this.callBase.apply(this, arguments)
    }
});
module.exports = SwitchableEditDecorator;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator_menu_helper.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var EditDecoratorMenuHelperMixin = {
    _menuEnabled: function() {
        return !!this._menuItems().length
    },
    _menuItems: function() {
        return this._list.option("menuItems")
    },
    _deleteEnabled: function() {
        return this._list.option("allowItemDeleting")
    },
    _fireMenuAction: function($itemElement, action) {
        this._list._itemEventHandlerByHandler($itemElement, action, {}, {
            excludeValidators: ["disabled", "readOnly"]
        })
    }
};
module.exports = EditDecoratorMenuHelperMixin;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/action_sheet.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    messageLocalization = __webpack_require__(8),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    Button = __webpack_require__(25),
    CollectionWidget = __webpack_require__(40),
    Popup = __webpack_require__(68),
    Popover = __webpack_require__(98),
    BindableTemplate = __webpack_require__(52);
var ACTION_SHEET_CLASS = "dx-actionsheet",
    ACTION_SHEET_CONTAINER_CLASS = "dx-actionsheet-container",
    ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-actionsheet-popup-wrapper",
    ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-actionsheet-popover-wrapper",
    ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-actionsheet-cancel",
    ACTION_SHEET_ITEM_CLASS = "dx-actionsheet-item",
    ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData",
    ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-actionsheet-without-title";
var ActionSheet = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            usePopover: false,
            target: null,
            title: "",
            showTitle: true,
            showCancelButton: true,
            cancelText: messageLocalization.format("Cancel"),
            onCancelClick: null,
            visible: false,
            noDataText: "",
            focusStateEnabled: false,
            selectionByClick: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios",
                tablet: true
            },
            options: {
                usePopover: true
            }
        }])
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
            var button = new Button($("<div>"), extend({
                onClick: data && data.click
            }, data));
            $container.append(button.element())
        }, ["disabled", "icon", "text", "type", "onClick", "click"], this.option("integrationOptions.watchMethod"))
    },
    _itemContainer: function() {
        return this._$itemContainer
    },
    _itemClass: function() {
        return ACTION_SHEET_ITEM_CLASS
    },
    _itemDataKey: function() {
        return ACTION_SHEET_ITEM_DATA_KEY
    },
    _toggleVisibility: noop,
    _renderDimensions: noop,
    _render: function() {
        this.element().addClass(ACTION_SHEET_CLASS);
        this._createItemContainer();
        this._renderPopup()
    },
    _createItemContainer: function() {
        this._$itemContainer = $("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
        this._renderDisabled()
    },
    _renderDisabled: function() {
        this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"))
    },
    _renderPopup: function() {
        this._$popup = $("<div>").appendTo(this.element());
        this._isPopoverMode() ? this._createPopover() : this._createPopup();
        this._renderPopupTitle();
        this._mapPopupOption("visible")
    },
    _mapPopupOption: function(optionName) {
        this._popup.option(optionName, this.option(optionName))
    },
    _isPopoverMode: function() {
        return this.option("usePopover") && this.option("target")
    },
    _renderPopupTitle: function() {
        this._mapPopupOption("showTitle");
        this._popup._wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"))
    },
    _clean: function() {
        if (this._$popup) {
            this._$popup.remove()
        }
        this.callBase()
    },
    _overlayConfig: function() {
        return {
            onInitialized: function(args) {
                this._popup = args.component
            }.bind(this),
            disabled: false,
            showTitle: true,
            title: this.option("title"),
            deferRendering: !window.angular,
            onContentReady: this._popupContentReadyAction.bind(this),
            onHidden: this.hide.bind(this)
        }
    },
    _createPopover: function() {
        this._createComponent(this._$popup, Popover, extend(this._overlayConfig(), {
            width: this.option("width") || 200,
            height: this.option("height") || "auto",
            target: this.option("target")
        }));
        this._popup._wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS)
    },
    _createPopup: function() {
        this._createComponent(this._$popup, Popup, extend(this._overlayConfig(), {
            dragEnabled: false,
            width: this.option("width") || "100%",
            height: this.option("height") || "auto",
            showCloseButton: false,
            position: {
                my: "bottom",
                at: "bottom",
                of: window
            },
            animation: {
                show: {
                    type: "slide",
                    duration: 400,
                    from: {
                        position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }
                    },
                    to: {
                        position: {
                            my: "bottom",
                            at: "bottom",
                            of: window
                        }
                    }
                },
                hide: {
                    type: "slide",
                    duration: 400,
                    from: {
                        position: {
                            my: "bottom",
                            at: "bottom",
                            of: window
                        }
                    },
                    to: {
                        position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }
                    }
                }
            }
        }));
        this._popup._wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS)
    },
    _popupContentReadyAction: function() {
        this._popup.content().append(this._$itemContainer);
        this._attachClickEvent();
        this._attachHoldEvent();
        this._renderContent();
        this._renderCancelButton()
    },
    _renderCancelButton: function() {
        if (this._isPopoverMode()) {
            return
        }
        if (this._$cancelButton) {
            this._$cancelButton.remove()
        }
        if (this.option("showCancelButton")) {
            var cancelClickAction = this._createActionByOption("onCancelClick") || noop,
                that = this;
            this._$cancelButton = $("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup.content());
            this._createComponent(this._$cancelButton, Button, {
                disabled: false,
                text: this.option("cancelText"),
                onClick: function(e) {
                    var hidingArgs = {
                        jQueryEvent: e,
                        cancel: false
                    };
                    cancelClickAction(hidingArgs);
                    if (!hidingArgs.cancel) {
                        that.hide()
                    }
                },
                integrationOptions: {}
            })
        }
    },
    _attachItemClickEvent: noop,
    _itemClickHandler: function(e) {
        this.callBase(e);
        if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
            this.hide()
        }
    },
    _itemHoldHandler: function(e) {
        this.callBase(e);
        if (!$(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
            this.hide()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "width":
            case "height":
            case "visible":
            case "title":
                this._mapPopupOption(args.name);
                break;
            case "disabled":
                this._renderDisabled();
                break;
            case "showTitle":
                this._renderPopupTitle();
                break;
            case "showCancelButton":
            case "onCancelClick":
            case "cancelText":
                this._renderCancelButton();
                break;
            case "target":
            case "usePopover":
            case "items":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    toggle: function(showing) {
        var that = this,
            d = $.Deferred();
        that._popup.toggle(showing).done(function() {
            that.option("visible", showing);
            d.resolveWith(that)
        });
        return d.promise()
    },
    show: function() {
        return this.toggle(true)
    },
    hide: function() {
        return this.toggle(false)
    }
});
registerComponent("dxActionSheet", ActionSheet);
module.exports = ActionSheet;
module.exports.default = module.exports;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(295);
module.exports.default = module.exports;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scrollbar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    Widget = __webpack_require__(27),
    eventUtils = __webpack_require__(3),
    commonUtils = __webpack_require__(2),
    isPlainObject = __webpack_require__(9).isPlainObject,
    extend = __webpack_require__(1).extend,
    pointerEvents = __webpack_require__(17);
var SCROLLBAR = "dxScrollbar",
    SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
    SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = SCROLLABLE_SCROLLBAR_CLASS + "-active",
    SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll",
    SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content",
    HOVER_ENABLED_STATE = "dx-scrollbar-hoverable",
    HORIZONTAL = "horizontal",
    THUMB_MIN_SIZE = 15;
var SCROLLBAR_VISIBLE = {
    onScroll: "onScroll",
    onHover: "onHover",
    always: "always",
    never: "never"
};
var Scrollbar = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            direction: null,
            visible: false,
            activeStateEnabled: false,
            visibilityMode: SCROLLBAR_VISIBLE.onScroll,
            containerSize: 0,
            contentSize: 0,
            expandable: true
        })
    },
    _init: function() {
        this.callBase();
        this._isHovered = false
    },
    _render: function() {
        this._renderThumb();
        this.callBase();
        this._renderDirection();
        this._update();
        this._attachPointerDownHandler();
        this.option("hoverStateEnabled", this._isHoverMode());
        this.element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"))
    },
    _renderThumb: function() {
        this._$thumb = $("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
        $("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
        this.element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb)
    },
    isThumb: function($element) {
        return !!this.element().find($element).length
    },
    _isHoverMode: function() {
        var visibilityMode = this.option("visibilityMode");
        return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable")
    },
    _renderDirection: function() {
        var direction = this.option("direction");
        this.element().addClass("dx-scrollbar-" + direction);
        this._dimension = direction === HORIZONTAL ? "width" : "height";
        this._prop = direction === HORIZONTAL ? "left" : "top"
    },
    _attachPointerDownHandler: function() {
        this._$thumb.on(eventUtils.addNamespace(pointerEvents.down, SCROLLBAR), this.feedbackOn.bind(this))
    },
    feedbackOn: function() {
        this.element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = this
    },
    feedbackOff: function() {
        this.element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = null
    },
    cursorEnter: function() {
        this._isHovered = true;
        this.option("visible", true)
    },
    cursorLeave: function() {
        this._isHovered = false;
        this.option("visible", false)
    },
    _renderDimensions: function() {
        this._$thumb.css({
            width: this.option("width"),
            height: this.option("height")
        })
    },
    _toggleVisibility: function(visible) {
        if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
            this._$thumb.css("opacity")
        }
        visible = this._adjustVisibility(visible);
        this.option().visible = visible;
        this._$thumb.toggleClass("dx-state-invisible", !visible)
    },
    _adjustVisibility: function(visible) {
        if (this.containerToContentRatio() && !this._needScrollbar()) {
            return false
        }
        switch (this.option("visibilityMode")) {
            case SCROLLBAR_VISIBLE.onScroll:
                break;
            case SCROLLBAR_VISIBLE.onHover:
                visible = visible || !!this._isHovered;
                break;
            case SCROLLBAR_VISIBLE.never:
                visible = false;
                break;
            case SCROLLBAR_VISIBLE.always:
                visible = true
        }
        return visible
    },
    moveTo: function(location) {
        if (this._isHidden()) {
            return
        }
        if (isPlainObject(location)) {
            location = location[this._prop] || 0
        }
        var scrollBarLocation = {};
        scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
        translator.move(this._$thumb, scrollBarLocation)
    },
    _calculateScrollBarPosition: function(location) {
        return -location * this._thumbRatio
    },
    _update: function() {
        var containerSize = Math.round(this.option("containerSize")),
            contentSize = Math.round(this.option("contentSize"));
        this._containerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
        var thumbSize = Math.round(Math.max(Math.round(containerSize * this._containerToContentRatio), THUMB_MIN_SIZE));
        this._thumbRatio = (containerSize - thumbSize) / (contentSize - containerSize);
        this.option(this._dimension, thumbSize);
        this.element().css("display", this._needScrollbar() ? "" : "none")
    },
    _isHidden: function() {
        return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never
    },
    _needScrollbar: function() {
        return !this._isHidden() && this._containerToContentRatio < 1
    },
    containerToContentRatio: function() {
        return this._containerToContentRatio
    },
    _normalizeSize: function(size) {
        return isPlainObject(size) ? size[this._dimension] || 0 : size
    },
    _clean: function() {
        this.callBase();
        if (this === activeScrollbar) {
            activeScrollbar = null
        }
        this._$thumb.off("." + SCROLLBAR)
    },
    _optionChanged: function(args) {
        if (this._isHidden()) {
            return
        }
        switch (args.name) {
            case "containerSize":
            case "contentSize":
                this.option()[args.name] = this._normalizeSize(args.value);
                this._update();
                break;
            case "visibilityMode":
            case "direction":
                this._invalidate();
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    update: commonUtils.deferRenderer(function() {
        this._adjustVisibility() && this.option("visible", true)
    })
});
var activeScrollbar = null;
$(document).on(eventUtils.addNamespace(pointerEvents.up, SCROLLBAR), function() {
    if (activeScrollbar) {
        activeScrollbar.feedbackOff()
    }
});
module.exports = Scrollbar;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    math = Math,
    titleize = __webpack_require__(36).titleize,
    extend = __webpack_require__(1).extend,
    translator = __webpack_require__(19),
    Class = __webpack_require__(5),
    Animator = __webpack_require__(200),
    devices = __webpack_require__(6),
    eventUtils = __webpack_require__(3),
    commonUtils = __webpack_require__(2),
    Scrollbar = __webpack_require__(198),
    when = __webpack_require__(10).when;
var realDevice = devices.real;
var isSluggishPlatform = "win" === realDevice.platform || "android" === realDevice.platform;
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable",
    SCROLLABLE_STRATEGY = "dxScrollableStrategy",
    SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor",
    SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard",
    SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated",
    SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
    SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible",
    SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal",
    ACCELERATION = isSluggishPlatform ? .95 : .92,
    OUT_BOUNDS_ACCELERATION = .5,
    MIN_VELOCITY_LIMIT = 1,
    FRAME_DURATION = math.round(1e3 / 60),
    SCROLL_LINE_HEIGHT = 20,
    BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5,
    BOUNCE_DURATION = isSluggishPlatform ? 300 : 400,
    BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION,
    BOUNCE_ACCELERATION_SUM = (1 - math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
var KEY_CODES = {
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
};
var InertiaAnimator = Animator.inherit({
    ctor: function(scroller) {
        this.callBase();
        this.scroller = scroller
    },
    VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
    _isFinished: function() {
        return math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT
    },
    _step: function() {
        this.scroller._scrollStep(this.scroller._velocity);
        this.scroller._velocity *= this._acceleration()
    },
    _acceleration: function() {
        return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION
    },
    _complete: function() {
        this.scroller._scrollComplete()
    },
    _stop: function() {
        this.scroller._stopComplete()
    }
});
var BounceAnimator = InertiaAnimator.inherit({
    VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
    _isFinished: function() {
        return this.scroller._crossBoundOnNextStep() || this.callBase()
    },
    _acceleration: function() {
        return ACCELERATION
    },
    _complete: function() {
        this.scroller._move(this.scroller._bounceLocation);
        this.callBase()
    }
});
var isWheelEvent = function(e) {
    return "dxmousewheel" === e.type
};
var Scroller = Class.inherit({
    ctor: function(options) {
        this._initOptions(options);
        this._initAnimators();
        this._initScrollbar()
    },
    _initOptions: function(options) {
        this._location = 0;
        this._topReached = false;
        this._bottomReached = false;
        this._axis = options.direction === HORIZONTAL ? "x" : "y";
        this._prop = options.direction === HORIZONTAL ? "left" : "top";
        this._dimension = options.direction === HORIZONTAL ? "width" : "height";
        this._scrollProp = options.direction === HORIZONTAL ? "scrollLeft" : "scrollTop";
        $.each(options, function(optionName, optionValue) {
            this["_" + optionName] = optionValue
        }.bind(this))
    },
    _initAnimators: function() {
        this._inertiaAnimator = new InertiaAnimator(this);
        this._bounceAnimator = new BounceAnimator(this)
    },
    _initScrollbar: function() {
        this._scrollbar = new Scrollbar($("<div>").appendTo(this._$container), {
            direction: this._direction,
            visible: this._scrollByThumb,
            visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
            expandable: this._scrollByThumb
        });
        this._$scrollbar = this._scrollbar.element()
    },
    _visibilityModeNormalize: function(mode) {
        return true === mode ? "onScroll" : false === mode ? "never" : mode
    },
    _scrollStep: function(delta) {
        var prevLocation = this._location;
        this._location += delta;
        this._suppressBounce();
        this._move();
        if (Math.abs(prevLocation - this._location) < 1) {
            return
        }
        this._$container.triggerHandler({
            type: "scroll"
        })
    },
    _suppressBounce: function() {
        if (this._bounceEnabled || this._inBounds(this._location)) {
            return
        }
        this._velocity = 0;
        this._location = this._boundLocation()
    },
    _boundLocation: function(location) {
        location = void 0 !== location ? location : this._location;
        return math.max(math.min(location, this._maxOffset), this._minOffset)
    },
    _move: function(location) {
        this._location = void 0 !== location ? location : this._location;
        this._moveContent();
        this._moveScrollbar()
    },
    _moveContent: function() {
        var location = this._location;
        this._$container[this._scrollProp](-location);
        this._moveContentByTranslator(location)
    },
    _moveContentByTranslator: function(location) {
        var translateOffset, minOffset = -this._maxScrollPropValue;
        if (location > 0) {
            translateOffset = location
        } else {
            if (location <= minOffset) {
                translateOffset = location - minOffset
            } else {
                translateOffset = location % 1
            }
        }
        if (this._translateOffset === translateOffset) {
            return
        }
        var targetLocation = {};
        targetLocation[this._prop] = translateOffset;
        this._translateOffset = translateOffset;
        if (0 === translateOffset) {
            translator.resetPosition(this._$content);
            return
        }
        translator.move(this._$content, targetLocation)
    },
    _moveScrollbar: function() {
        this._scrollbar.moveTo(this._location)
    },
    _scrollComplete: function() {
        if (this._inBounds()) {
            this._hideScrollbar();
            if (this._completeDeferred) {
                this._completeDeferred.resolve()
            }
        }
        this._scrollToBounds()
    },
    _scrollToBounds: function() {
        if (this._inBounds()) {
            return
        }
        this._bounceAction();
        this._setupBounce();
        this._bounceAnimator.start()
    },
    _setupBounce: function() {
        var boundLocation = this._bounceLocation = this._boundLocation(),
            bounceDistance = boundLocation - this._location;
        this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM
    },
    _inBounds: function(location) {
        location = void 0 !== location ? location : this._location;
        return this._boundLocation(location) === location
    },
    _crossBoundOnNextStep: function() {
        var location = this._location,
            nextLocation = location + this._velocity;
        return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset
    },
    _initHandler: function(e) {
        this._stopDeferred = $.Deferred();
        this._stopScrolling();
        this._prepareThumbScrolling(e);
        return this._stopDeferred.promise()
    },
    _stopScrolling: commonUtils.deferRenderer(function() {
        this._hideScrollbar();
        this._inertiaAnimator.stop();
        this._bounceAnimator.stop()
    }),
    _prepareThumbScrolling: function(e) {
        if (isWheelEvent(e.originalEvent)) {
            return
        }
        var $target = $(e.originalEvent.target);
        var scrollbarClicked = this._isScrollbar($target);
        if (scrollbarClicked) {
            this._moveToMouseLocation(e)
        }
        this._thumbScrolling = scrollbarClicked || this._isThumb($target);
        this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
        if (this._thumbScrolling) {
            this._scrollbar.feedbackOn()
        }
    },
    _isThumbScrollingHandler: function($target) {
        return this._isThumb($target)
    },
    _moveToMouseLocation: function(e) {
        var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
        var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
        this._scrollStep(-Math.round(location))
    },
    _stopComplete: function() {
        if (this._stopDeferred) {
            this._stopDeferred.resolve()
        }
    },
    _startHandler: function() {
        this._showScrollbar()
    },
    _moveHandler: function(delta) {
        if (this._crossThumbScrolling) {
            return
        }
        if (this._thumbScrolling) {
            delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio())
        }
        this._scrollBy(delta)
    },
    _scrollBy: function(delta) {
        delta = delta[this._axis];
        if (!this._inBounds()) {
            delta *= OUT_BOUNDS_ACCELERATION
        }
        this._scrollStep(delta)
    },
    _scrollByHandler: function(delta) {
        this._scrollBy(delta);
        this._scrollComplete()
    },
    _containerToContentRatio: function() {
        return this._scrollbar.containerToContentRatio()
    },
    _endHandler: function(velocity) {
        this._completeDeferred = $.Deferred();
        this._velocity = velocity[this._axis];
        this._inertiaHandler();
        this._resetThumbScrolling();
        return this._completeDeferred.promise()
    },
    _inertiaHandler: function() {
        this._suppressInertia();
        this._inertiaAnimator.start()
    },
    _suppressInertia: function() {
        if (!this._inertiaEnabled || this._thumbScrolling) {
            this._velocity = 0
        }
    },
    _resetThumbScrolling: function() {
        this._thumbScrolling = false;
        this._crossThumbScrolling = false
    },
    _stopHandler: function() {
        if (this._thumbScrolling) {
            this._scrollComplete()
        }
        this._resetThumbScrolling();
        this._scrollToBounds()
    },
    _disposeHandler: function() {
        this._stopScrolling();
        this._$scrollbar.remove()
    },
    _updateHandler: function() {
        this._update();
        this._moveToBounds()
    },
    _update: function() {
        var that = this;
        that._stopScrolling();
        return commonUtils.deferUpdate(function() {
            that._updateLocation();
            that._updateBounds();
            that._updateScrollbar();
            commonUtils.deferRender(function() {
                that._moveScrollbar();
                that._scrollbar.update()
            })
        })
    },
    _updateLocation: function() {
        this._location = translator.locate(this._$content)[this._prop] - this._$container[this._scrollProp]()
    },
    _updateBounds: function() {
        this._maxOffset = Math.round(this._getMaxOffset());
        this._minOffset = Math.round(this._getMinOffset())
    },
    _getMaxOffset: function() {
        return 0
    },
    _getMinOffset: function() {
        this._maxScrollPropValue = math.max(this._contentSize() - this._containerSize(), 0);
        return -this._maxScrollPropValue
    },
    _updateScrollbar: commonUtils.deferUpdater(function() {
        var that = this,
            containerSize = that._containerSize(),
            contentSize = that._contentSize();
        commonUtils.deferRender(function() {
            that._scrollbar.option({
                containerSize: containerSize,
                contentSize: contentSize
            })
        })
    }),
    _moveToBounds: commonUtils.deferRenderer(commonUtils.deferUpdater(commonUtils.deferRenderer(function() {
        var location = this._boundLocation();
        var locationChanged = location !== this._location;
        this._location = location;
        this._move();
        if (locationChanged) {
            this._scrollAction()
        }
    }))),
    _createActionsHandler: function(actions) {
        this._scrollAction = actions.scroll;
        this._bounceAction = actions.bounce
    },
    _showScrollbar: function() {
        this._scrollbar.option("visible", true)
    },
    _hideScrollbar: function() {
        this._scrollbar.option("visible", false)
    },
    _containerSize: function() {
        return this._$container[this._dimension]()
    },
    _contentSize: function() {
        var isOverflowHidden = "hidden" === this._$content.css("overflow-" + this._axis),
            contentSize = this._$content[this._dimension]();
        if (!isOverflowHidden) {
            var containerScrollSize = this._$content[0]["scroll" + titleize(this._dimension)];
            contentSize = math.max(containerScrollSize, contentSize)
        }
        return contentSize
    },
    _validateEvent: function(e) {
        var $target = $(e.originalEvent.target);
        return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target)
    },
    _isThumb: function($element) {
        return this._scrollByThumb && this._scrollbar.isThumb($element)
    },
    _isScrollbar: function($element) {
        return this._scrollByThumb && $element && $element.is(this._$scrollbar)
    },
    _isContent: function($element) {
        return this._scrollByContent && !!$element.closest(this._$element).length
    },
    _reachedMin: function() {
        return this._location <= this._minOffset
    },
    _reachedMax: function() {
        return this._location >= this._maxOffset
    },
    _cursorEnterHandler: function() {
        this._scrollbar.cursorEnter()
    },
    _cursorLeaveHandler: function() {
        this._scrollbar.cursorLeave()
    },
    dispose: commonUtils.noop
});
var hoveredScrollable, activeScrollable;
var SimulatedStrategy = Class.inherit({
    ctor: function(scrollable) {
        this._init(scrollable)
    },
    _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.element();
        this._$container = scrollable._$container;
        this._$wrapper = scrollable._$wrapper;
        this._$content = scrollable._$content;
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable)
    },
    render: function() {
        this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
        this._createScrollers();
        if (this.option("useKeyboard")) {
            this._$container.prop("tabindex", 0)
        }
        this._attachKeyboardHandler();
        this._attachCursorHandlers()
    },
    _createScrollers: function() {
        this._scrollers = {};
        if (this._isDirection(HORIZONTAL)) {
            this._createScroller(HORIZONTAL)
        }
        if (this._isDirection(VERTICAL)) {
            this._createScroller(VERTICAL)
        }
        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option("showScrollbar"))
    },
    _createScroller: function(direction) {
        this._scrollers[direction] = new Scroller(this._scrollerOptions(direction))
    },
    _scrollerOptions: function(direction) {
        return {
            direction: direction,
            $content: this._$content,
            $container: this._$container,
            $wrapper: this._$wrapper,
            $element: this._$element,
            scrollByContent: this.option("scrollByContent"),
            scrollByThumb: this.option("scrollByThumb"),
            scrollbarVisible: this.option("showScrollbar"),
            bounceEnabled: this.option("bounceEnabled"),
            inertiaEnabled: this.option("inertiaEnabled"),
            isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
        }
    },
    _isAnyThumbScrolling: function($target) {
        var result = false;
        this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
            result = isThumbScrollingVertical || isThumbScrollingHorizontal
        });
        return result
    },
    handleInit: function(e) {
        this._suppressDirections(e);
        this._eventForUserAction = e;
        this._eventHandler("init", e).done(this._stopAction)
    },
    _suppressDirections: function(e) {
        if (isWheelEvent(e.originalEvent)) {
            this._prepareDirections(true);
            return
        }
        this._prepareDirections();
        this._eachScroller(function(scroller, direction) {
            var isValid = scroller._validateEvent(e);
            this._validDirections[direction] = isValid
        })
    },
    _prepareDirections: function(value) {
        value = value || false;
        this._validDirections = {};
        this._validDirections[HORIZONTAL] = value;
        this._validDirections[VERTICAL] = value
    },
    _eachScroller: function(callback) {
        callback = callback.bind(this);
        $.each(this._scrollers, function(direction, scroller) {
            callback(scroller, direction)
        })
    },
    handleStart: function(e) {
        this._eventForUserAction = e;
        this._eventHandler("start").done(this._startAction)
    },
    _saveActive: function() {
        activeScrollable = this
    },
    _resetActive: function() {
        if (activeScrollable === this) {
            activeScrollable = null
        }
    },
    handleMove: function(e) {
        if (this._isLocked()) {
            e.cancel = true;
            this._resetActive();
            return
        }
        this._saveActive();
        e.preventDefault && e.preventDefault();
        this._adjustDistance(e.delta);
        this._eventForUserAction = e;
        this._eventHandler("move", e.delta)
    },
    _adjustDistance: function(distance) {
        distance.x *= this._validDirections[HORIZONTAL];
        distance.y *= this._validDirections[VERTICAL]
    },
    handleEnd: function(e) {
        this._resetActive();
        this._refreshCursorState(e.originalEvent && e.originalEvent.target);
        this._adjustDistance(e.velocity);
        this._eventForUserAction = e;
        return this._eventHandler("end", e.velocity).done(this._endAction)
    },
    handleCancel: function(e) {
        this._resetActive();
        this._eventForUserAction = e;
        return this._eventHandler("end", {
            x: 0,
            y: 0
        })
    },
    handleStop: function() {
        this._resetActive();
        this._eventHandler("stop")
    },
    handleScroll: function() {
        this._scrollAction()
    },
    _attachKeyboardHandler: function() {
        this._$element.off("." + SCROLLABLE_SIMULATED_KEYBOARD);
        if (!this.option("disabled") && this.option("useKeyboard")) {
            this._$element.on(eventUtils.addNamespace("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this))
        }
    },
    _keyDownHandler: function(e) {
        if (!this._$container.is(document.activeElement)) {
            return
        }
        var handled = true;
        switch (e.keyCode) {
            case KEY_CODES.DOWN:
                this._scrollByLine({
                    y: 1
                });
                break;
            case KEY_CODES.UP:
                this._scrollByLine({
                    y: -1
                });
                break;
            case KEY_CODES.RIGHT:
                this._scrollByLine({
                    x: 1
                });
                break;
            case KEY_CODES.LEFT:
                this._scrollByLine({
                    x: -1
                });
                break;
            case KEY_CODES.PAGE_DOWN:
                this._scrollByPage(1);
                break;
            case KEY_CODES.PAGE_UP:
                this._scrollByPage(-1);
                break;
            case KEY_CODES.HOME:
                this._scrollToHome();
                break;
            case KEY_CODES.END:
                this._scrollToEnd();
                break;
            default:
                handled = false
        }
        if (handled) {
            e.stopPropagation();
            e.preventDefault()
        }
    },
    _scrollByLine: function(lines) {
        this.scrollBy({
            top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,
            left: (lines.x || 0) * -SCROLL_LINE_HEIGHT
        })
    },
    _scrollByPage: function(page) {
        var prop = this._wheelProp(),
            dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = page * -this._$container[dimension]();
        this.scrollBy(distance)
    },
    _dimensionByProp: function(prop) {
        return "left" === prop ? "width" : "height"
    },
    _scrollToHome: function() {
        var prop = this._wheelProp();
        var distance = {};
        distance[prop] = 0;
        this._component.scrollTo(distance)
    },
    _scrollToEnd: function() {
        var prop = this._wheelProp(),
            dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = this._$content[dimension]() - this._$container[dimension]();
        this._component.scrollTo(distance)
    },
    createActions: function() {
        this._startAction = this._createActionHandler("onStart");
        this._stopAction = this._createActionHandler("onStop");
        this._endAction = this._createActionHandler("onEnd");
        this._updateAction = this._createActionHandler("onUpdated");
        this._createScrollerActions()
    },
    _createScrollerActions: function() {
        this._scrollAction = this._createActionHandler("onScroll");
        this._bounceAction = this._createActionHandler("onBounce");
        this._eventHandler("createActions", {
            scroll: this._scrollAction,
            bounce: this._bounceAction
        })
    },
    _createActionHandler: function(optionName) {
        var that = this,
            actionHandler = that._createActionByOption(optionName);
        return function() {
            actionHandler(extend(that._createActionArgs(), arguments))
        }
    },
    _createActionArgs: function() {
        var scrollerX = this._scrollers[HORIZONTAL],
            scrollerY = this._scrollers[VERTICAL];
        var location = this.location();
        this._scrollOffset = {
            top: scrollerY && -location.top,
            left: scrollerX && -location.left
        };
        return {
            jQueryEvent: this._eventForUserAction,
            scrollOffset: this._scrollOffset,
            reachedLeft: scrollerX && scrollerX._reachedMax(),
            reachedRight: scrollerX && scrollerX._reachedMin(),
            reachedTop: scrollerY && scrollerY._reachedMax(),
            reachedBottom: scrollerY && scrollerY._reachedMin()
        }
    },
    _eventHandler: function(eventName) {
        var args = $.makeArray(arguments).slice(1),
            deferreds = $.map(this._scrollers, function(scroller) {
                return scroller["_" + eventName + "Handler"].apply(scroller, args)
            });
        return when.apply($, deferreds).promise()
    },
    location: function() {
        var location = translator.locate(this._$content);
        location.top -= this._$container.scrollTop();
        location.left -= this._$container.scrollLeft();
        return location
    },
    disabledChanged: function() {
        this._attachCursorHandlers()
    },
    _attachCursorHandlers: function() {
        this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
        if (!this.option("disabled") && this._isHoverMode()) {
            this._$element.on(eventUtils.addNamespace("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this)).on(eventUtils.addNamespace("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this))
        }
    },
    _isHoverMode: function() {
        return "onHover" === this.option("showScrollbar")
    },
    _cursorEnterHandler: function(e) {
        e = e || {};
        e.originalEvent = e.originalEvent || {};
        if (activeScrollable || e.originalEvent._hoverHandled) {
            return
        }
        if (hoveredScrollable) {
            hoveredScrollable._cursorLeaveHandler()
        }
        hoveredScrollable = this;
        this._eventHandler("cursorEnter");
        e.originalEvent._hoverHandled = true
    },
    _cursorLeaveHandler: function(e) {
        if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
            return
        }
        this._eventHandler("cursorLeave");
        hoveredScrollable = null;
        this._refreshCursorState(e && e.relatedTarget)
    },
    _refreshCursorState: function(target) {
        if (!this._isHoverMode() && (!target || activeScrollable)) {
            return
        }
        var $target = $(target);
        var $scrollable = $target.closest("." + SCROLLABLE_SIMULATED_CLASS + ":not(.dx-state-disabled)");
        var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
        if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
            hoveredScrollable._cursorLeaveHandler()
        }
        if (targetScrollable) {
            targetScrollable._cursorEnterHandler()
        }
    },
    update: function() {
        var that = this;
        var result = this._eventHandler("update").done(this._updateAction);
        return when(result, commonUtils.deferUpdate(function() {
            var allowedDirections = that._allowedDirections();
            commonUtils.deferRender(function() {
                var touchDirection = allowedDirections.vertical ? "pan-x" : "";
                touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
                touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
                that._$container.css("touchAction", touchDirection)
            });
            return when().promise()
        }))
    },
    _allowedDirections: function() {
        var bounceEnabled = this.option("bounceEnabled"),
            verticalScroller = this._scrollers[VERTICAL],
            horizontalScroller = this._scrollers[HORIZONTAL];
        return {
            vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
            horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
        }
    },
    updateBounds: function() {
        this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds()
    },
    scrollBy: function(distance) {
        var verticalScroller = this._scrollers[VERTICAL],
            horizontalScroller = this._scrollers[HORIZONTAL];
        if (verticalScroller) {
            distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location
        }
        if (horizontalScroller) {
            distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location
        }
        this._prepareDirections(true);
        this._startAction();
        this._eventHandler("scrollBy", {
            x: distance.left,
            y: distance.top
        });
        this._endAction()
    },
    validate: function(e) {
        if (this.option("disabled")) {
            return false
        }
        if (this.option("bounceEnabled")) {
            return true
        }
        return isWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e)
    },
    _validateWheel: function(e) {
        var scroller = this._scrollers[this._wheelDirection(e)];
        var reachedMin = scroller._reachedMin();
        var reachedMax = scroller._reachedMax();
        var contentGreaterThanContainer = !reachedMin || !reachedMax;
        var locatedNotAtBound = !reachedMin && !reachedMax;
        var scrollFromMin = reachedMin && e.delta > 0;
        var scrollFromMax = reachedMax && e.delta < 0;
        return contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax)
    },
    _validateMove: function(e) {
        if (!this.option("scrollByContent") && !$(e.target).closest("." + SCROLLABLE_SCROLLBAR_CLASS).length) {
            return false
        }
        return this._allowedDirection()
    },
    getDirection: function(e) {
        return isWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection()
    },
    _wheelProp: function() {
        return this._wheelDirection() === HORIZONTAL ? "left" : "top"
    },
    _wheelDirection: function(e) {
        switch (this.option("direction")) {
            case HORIZONTAL:
                return HORIZONTAL;
            case VERTICAL:
                return VERTICAL;
            default:
                return e && e.shiftKey ? HORIZONTAL : VERTICAL
        }
    },
    verticalOffset: function() {
        return 0
    },
    dispose: function() {
        this._resetActive();
        if (hoveredScrollable === this) {
            hoveredScrollable = null
        }
        this._eventHandler("dispose");
        this._detachEventHandlers();
        this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
        this._eventForUserAction = null;
        clearTimeout(this._gestureEndTimer)
    },
    _detachEventHandlers: function() {
        this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
        this._$container.off("." + SCROLLABLE_SIMULATED_KEYBOARD)
    }
});
exports.SimulatedStrategy = SimulatedStrategy;
exports.Scroller = Scroller;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/animator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    abstract = Class.abstract,
    animationFrame = __webpack_require__(87);
var Animator = Class.inherit({
    ctor: function() {
        this._finished = true;
        this._stopped = false;
        this._proxiedStepCore = this._stepCore.bind(this)
    },
    start: function() {
        this._stopped = false;
        this._finished = false;
        this._stepCore()
    },
    stop: function() {
        this._stopped = true;
        animationFrame.cancelAnimationFrame(this._stepAnimationFrame)
    },
    _stepCore: function() {
        if (this._isStopped()) {
            this._stop();
            return
        }
        if (this._isFinished()) {
            this._finished = true;
            this._complete();
            return
        }
        this._step();
        this._stepAnimationFrame = animationFrame.requestAnimationFrame(this._proxiedStepCore)
    },
    _step: abstract,
    _isFinished: noop,
    _stop: noop,
    _complete: noop,
    _isStopped: function() {
        return this._stopped
    },
    inProgress: function() {
        return !(this._stopped || this._finished)
    }
});
module.exports = Animator;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Calendar = __webpack_require__(311),
    DateBoxStrategy = __webpack_require__(127),
    dateUtils = __webpack_require__(55),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8);
var CalendarStrategy = DateBoxStrategy.inherit({
    NAME: "Calendar",
    supportedKeys: function() {
        return {
            rightArrow: function() {
                if (this.option("opened")) {
                    return true
                }
            },
            leftArrow: function() {
                if (this.option("opened")) {
                    return true
                }
            },
            enter: function(e) {
                if (this.dateBox.option("opened")) {
                    e.preventDefault();
                    if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
                        var contouredDate = this._widget._view.option("contouredDate");
                        contouredDate && this.dateBoxValue(contouredDate, e);
                        this.dateBox.close();
                        this.dateBox._valueChangeEventHandler(e)
                    } else {
                        return true
                    }
                } else {
                    this.dateBox._valueChangeEventHandler(e)
                }
            }.bind(this)
        }
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdate"
    },
    _getWidgetName: function() {
        return Calendar
    },
    _getWidgetOptions: function() {
        return extend(this.dateBox.option("calendarOptions"), {
            value: this.dateBoxValue() || null,
            _keyboardProcessor: this._widgetKeyboardProcessor,
            min: this.dateBox.dateOption("min"),
            max: this.dateBox.dateOption("max"),
            onValueChanged: this._valueChangedHandler.bind(this),
            onCellClick: this._cellClickHandler.bind(this),
            tabIndex: null,
            maxZoomLevel: this.dateBox.option("maxZoomLevel"),
            minZoomLevel: this.dateBox.option("minZoomLevel"),
            onContouredChanged: this._refreshActiveDescendant.bind(this),
            hasFocus: function() {
                return true
            }
        })
    },
    _refreshActiveDescendant: function(e) {
        this.dateBox.setAria("activedescendant", e.actionValue)
    },
    popupConfig: function(popupConfig) {
        var toolbarItems = popupConfig.toolbarItems,
            buttonsLocation = this.dateBox.option("buttonsLocation");
        var position = [];
        if ("default" !== buttonsLocation) {
            position = commonUtils.splitPair(buttonsLocation)
        } else {
            position = ["bottom", "center"]
        }
        if ("useButtons" === this.dateBox.option("applyValueMode")) {
            toolbarItems.unshift({
                widget: "dxButton",
                toolbar: position[0],
                location: "after" === position[1] ? "before" : position[1],
                options: {
                    onClick: function() {
                        this._widget._toTodayView()
                    }.bind(this),
                    text: messageLocalization.format("dxCalendar-todayButtonText"),
                    type: "today"
                }
            })
        }
        return extend(true, popupConfig, {
            toolbarItems: toolbarItems,
            position: {
                collision: "flipfit flip"
            }
        })
    },
    _valueChangedHandler: function(e) {
        var dateBox = this.dateBox,
            value = e.value,
            prevValue = e.previousValue;
        if (dateUtils.sameDate(value, prevValue)) {
            return
        }
        if ("instantly" === dateBox.option("applyValueMode")) {
            this.dateBoxValue(this.getValue(), e.jQueryEvent)
        }
    },
    _updateValue: function() {
        if (!this._widget) {
            return
        }
        this._widget.option("value", this.dateBoxValue())
    },
    textChangedHandler: function() {
        if (this.dateBox.option("opened") && this._widget) {
            this._updateValue(true)
        }
    },
    _cellClickHandler: function(e) {
        var dateBox = this.dateBox;
        if ("instantly" === dateBox.option("applyValueMode")) {
            dateBox.option("opened", false);
            this.dateBoxValue(this.getValue(), e.jQueryEvent)
        }
    },
    dispose: function() {
        this.dateBox.off("optionChanged");
        this.callBase()
    }
});
module.exports = CalendarStrategy;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/progress_bar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    TrackBar = __webpack_require__(326),
    extend = __webpack_require__(1).extend,
    isFunction = __webpack_require__(2).isFunction,
    registerComponent = __webpack_require__(4);
var PROGRESSBAR_CLASS = "dx-progressbar",
    PROGRESSBAR_CONTAINER_CLASS = "dx-progressbar-container",
    PROGRESSBAR_RANGE_CONTAINER_CLASS = "dx-progressbar-range-container",
    PROGRESSBAR_RANGE_CLASS = "dx-progressbar-range",
    PROGRESSBAR_WRAPPER_CLASS = "dx-progressbar-wrapper",
    PROGRESSBAR_STATUS_CLASS = "dx-progressbar-status",
    PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER = "dx-progressbar-animating-container",
    PROGRESSBAR_INDETERMINATE_SEGMENT = "dx-progressbar-animating-segment";
var ProgressBar = TrackBar.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: 0,
            statusFormat: function(ratio) {
                return "Progress: " + Math.round(100 * ratio) + "%"
            },
            showStatus: true,
            onComplete: null,
            activeStateEnabled: false,
            statusPosition: "bottom left",
            _animatingSegmentCount: 0
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "win"
            },
            options: {
                _animatingSegmentCount: 5
            }
        }, {
            device: function(device) {
                return "android" === device.platform
            },
            options: {
                _animatingSegmentCount: 2
            }
        }])
    },
    _init: function() {
        this.callBase()
    },
    _render: function() {
        this._createCompleteAction();
        this._renderStatus();
        this.callBase();
        this.element().addClass(PROGRESSBAR_CLASS);
        this.setAria("role", "progressbar");
        this._$wrapper.addClass(PROGRESSBAR_WRAPPER_CLASS);
        this._$bar.addClass(PROGRESSBAR_CONTAINER_CLASS);
        $("<div>").addClass(PROGRESSBAR_RANGE_CONTAINER_CLASS).appendTo(this._$wrapper).append(this._$bar);
        this._$range.addClass(PROGRESSBAR_RANGE_CLASS);
        this._toggleStatus(this.option("showStatus"))
    },
    _createCompleteAction: function() {
        this._completeAction = this._createActionByOption("onComplete")
    },
    _renderStatus: function() {
        this._$status = $("<div>").addClass(PROGRESSBAR_STATUS_CLASS)
    },
    _renderIndeterminateState: function() {
        this._$segmentContainer = $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER);
        var segments = this.option("_animatingSegmentCount");
        for (var i = 0; i < segments; i++) {
            $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT).addClass(PROGRESSBAR_INDETERMINATE_SEGMENT + "-" + (i + 1)).appendTo(this._$segmentContainer)
        }
        this._$segmentContainer.appendTo(this._$wrapper)
    },
    _toggleStatus: function(value) {
        var splitPosition = this.option("statusPosition").split(" ");
        if (value) {
            if ("top" === splitPosition[0] || "left" === splitPosition[0]) {
                this._$status.prependTo(this._$wrapper)
            } else {
                this._$status.appendTo(this._$wrapper)
            }
        } else {
            this._$status.detach()
        }
        this._togglePositionClass()
    },
    _togglePositionClass: function() {
        var position = this.option("statusPosition"),
            splitPosition = position.split(" ");
        this._$wrapper.removeClass("dx-position-top-left dx-position-top-right dx-position-bottom-left dx-position-bottom-right dx-position-left dx-position-right");
        var positionClass = "dx-position-" + splitPosition[0];
        if (splitPosition[1]) {
            positionClass += "-" + splitPosition[1]
        }
        this._$wrapper.addClass(positionClass)
    },
    _toggleIndeterminateState: function(value) {
        if (value) {
            this._renderIndeterminateState();
            this._$bar.toggle(false)
        } else {
            this._$bar.toggle(true);
            this._$segmentContainer.remove();
            delete this._$segmentContainer
        }
    },
    _renderValue: function() {
        var val = this.option("value"),
            max = this.option("max");
        if (!val && 0 !== val) {
            this._toggleIndeterminateState(true);
            return
        }
        if (this._$segmentContainer) {
            this._toggleIndeterminateState(false)
        }
        if (val === max) {
            this._completeAction()
        }
        this.callBase();
        this._setStatus()
    },
    _setStatus: function() {
        var format = this.option("statusFormat");
        if (isFunction(format)) {
            format = format.bind(this)
        } else {
            format = function(value) {
                return value
            }
        }
        var statusText = format(this._currentRatio, this.option("value"));
        this._$status.text(statusText)
    },
    _dispose: function() {
        this._$status.remove();
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "statusFormat":
                this._setStatus();
                break;
            case "showStatus":
                this._toggleStatus(args.value);
                break;
            case "statusPosition":
                this._toggleStatus(this.option("showStatus"));
                break;
            case "onComplete":
                this._createCompleteAction();
                break;
            case "_animatingSegmentCount":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxProgressBar", ProgressBar);
module.exports = ProgressBar;
module.exports.default = module.exports;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/responsive_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    errors = __webpack_require__(16),
    windowUtils = __webpack_require__(61),
    extend = __webpack_require__(1).extend,
    registerComponent = __webpack_require__(4),
    Box = __webpack_require__(154),
    CollectionWidget = __webpack_require__(40);
var RESPONSIVE_BOX_CLASS = "dx-responsivebox",
    SCREEN_SIZE_CLASS_PREFIX = RESPONSIVE_BOX_CLASS + "-screen-",
    BOX_ITEM_CLASS = "dx-box-item",
    BOX_ITEM_DATA_KEY = "dxBoxItemData";
var ResponsiveBox = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            rows: [],
            cols: [],
            screenByWidth: null,
            singleColumnScreen: "",
            height: "100%",
            width: "100%",
            activeStateEnabled: false,
            focusStateEnabled: false,
            onItemStateChanged: void 0,
            onLayoutChanged: null,
            currentScreenFactor: void 0,
            _layoutStrategy: void 0
        })
    },
    _init: function() {
        if (!this.option("screenByWidth")) {
            this._options.screenByWidth = windowUtils.defaultScreenFactorFunc
        }
        this.callBase();
        this._initLayoutChangedAction()
    },
    _initLayoutChangedAction: function() {
        this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
            excludeValidators: ["disabled", "readonly"]
        })
    },
    _itemClass: function() {
        return BOX_ITEM_CLASS
    },
    _itemDataKey: function() {
        return BOX_ITEM_DATA_KEY
    },
    _render: function() {
        this.callBase();
        this.element().addClass(RESPONSIVE_BOX_CLASS);
        this._updateRootBox()
    },
    _updateRootBox: function() {
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout(function() {
            if (this._$root) {
                this._$root.triggerHandler("dxupdate")
            }
        }.bind(this))
    },
    _renderItems: function() {
        this._setScreenSize();
        this._screenItems = this._itemsByScreen();
        this._prepareGrid();
        this._spreadItems();
        this._layoutItems();
        this._linkNodeToItem()
    },
    _setScreenSize: function() {
        var currentScreen = this._getCurrentScreen();
        this._removeScreenSizeClass();
        this.element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
        this.option("currentScreenFactor", currentScreen)
    },
    _removeScreenSizeClass: function() {
        var currentScreenFactor = this.option("currentScreenFactor");
        currentScreenFactor && this.element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor)
    },
    _prepareGrid: function() {
        var grid = this._grid = [];
        this._prepareRowsAndCols();
        $.each(this._rows, function() {
            var row = [];
            grid.push(row);
            $.each(this._cols, function() {
                row.push(this._createEmptyCell())
            }.bind(this))
        }.bind(this))
    },
    _prepareRowsAndCols: function() {
        if (this._isSingleColumnScreen()) {
            this._prepareSingleColumnScreenItems();
            this._rows = this._defaultSizeConfig(this._screenItems.length);
            this._cols = this._defaultSizeConfig(1)
        } else {
            this._rows = this._sizesByScreen(this.option("rows"));
            this._cols = this._sizesByScreen(this.option("cols"))
        }
    },
    _isSingleColumnScreen: function() {
        return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length
    },
    _prepareSingleColumnScreenItems: function() {
        this._screenItems.sort(function(item1, item2) {
            return item1.location.row - item2.location.row || item1.location.col - item2.location.col
        });
        $.each(this._screenItems, function(index, item) {
            extend(item.location, {
                row: index,
                col: 0,
                rowspan: 1,
                colspan: 1
            })
        })
    },
    _sizesByScreen: function(sizeConfigs) {
        return $.map(this._filterByScreen(sizeConfigs), function(sizeConfig) {
            return extend(this._defaultSizeConfig(), sizeConfig)
        }.bind(this))
    },
    _defaultSizeConfig: function(size) {
        var defaultSizeConfig = {
            ratio: 1,
            baseSize: 0,
            minSize: 0,
            maxSize: 0
        };
        if (!arguments.length) {
            return defaultSizeConfig
        }
        var result = [];
        for (var i = 0; i < size; i++) {
            result.push(defaultSizeConfig)
        }
        return result
    },
    _filterByScreen: function(items) {
        var screenRegExp = this._screenRegExp();
        return commonUtils.grep(items, function(item) {
            return !item.screen || screenRegExp.test(item.screen)
        })
    },
    _screenRegExp: function() {
        var screen = this._getCurrentScreen();
        return new RegExp("(^|\\s)" + screen + "($|\\s)", "i")
    },
    _getCurrentScreen: function() {
        var width = this._screenWidth();
        return this.option("screenByWidth")(width)
    },
    _screenWidth: function() {
        return $(window).width()
    },
    _createEmptyCell: function() {
        return {
            item: {},
            location: {
                colspan: 1,
                rowspan: 1
            }
        }
    },
    _spreadItems: function() {
        $.each(this._screenItems, function(_, itemInfo) {
            var location = itemInfo.location || {};
            var itemCol = location.col;
            var itemRow = location.row;
            var row = this._grid[itemRow];
            var itemCell = row && row[itemCol];
            this._occupyCells(itemCell, itemInfo)
        }.bind(this))
    },
    _itemsByScreen: function() {
        return $.map(this.option("items"), function(item) {
            var locations = item.location || {};
            locations = typeUtils.isPlainObject(locations) ? [locations] : locations;
            return $.map(this._filterByScreen(locations), function(location) {
                return {
                    item: item,
                    location: extend({
                        rowspan: 1,
                        colspan: 1
                    }, location)
                }
            })
        }.bind(this))
    },
    _occupyCells: function(itemCell, itemInfo) {
        if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
            return
        }
        extend(itemCell, itemInfo);
        this._markSpanningCell(itemCell)
    },
    _isItemCellOccupied: function(itemCell, itemInfo) {
        if (!typeUtils.isEmptyObject(itemCell.item)) {
            return true
        }
        var result = false;
        this._loopOverSpanning(itemInfo.location, function(cell) {
            result = result || !typeUtils.isEmptyObject(cell.item)
        });
        return result
    },
    _loopOverSpanning: function(location, callback) {
        var rowEnd = location.row + location.rowspan - 1;
        var colEnd = location.col + location.colspan - 1;
        var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
        var boundColEnd = Math.min(colEnd, this._cols.length - 1);
        location.rowspan -= rowEnd - boundRowEnd;
        location.colspan -= colEnd - boundColEnd;
        for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
            for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
                if (rowIndex !== location.row || colIndex !== location.col) {
                    callback(this._grid[rowIndex][colIndex])
                }
            }
        }
    },
    _markSpanningCell: function(itemCell) {
        this._loopOverSpanning(itemCell.location, function(cell) {
            extend(cell, {
                item: itemCell.item,
                spanningCell: itemCell
            })
        })
    },
    _linkNodeToItem: function() {
        $.each(this._itemElements(), function(_, itemNode) {
            var $item = $(itemNode),
                item = $item.data(BOX_ITEM_DATA_KEY);
            if (!item.box) {
                item.node = $item.children()
            }
        })
    },
    _layoutItems: function() {
        var rowsCount = this._grid.length;
        var colsCount = rowsCount && this._grid[0].length;
        if (!rowsCount && !colsCount) {
            return
        }
        var result = this._layoutBlock({
            direction: "col",
            row: {
                start: 0,
                end: rowsCount - 1
            },
            col: {
                start: 0,
                end: colsCount - 1
            }
        });
        var rootBox = this._prepareBoxConfig(result.box || {
            direction: "row",
            items: [extend(result, {
                ratio: 1
            })]
        });
        extend(rootBox, this._rootBoxConfig());
        this._$root = $("<div>").appendTo(this._itemContainer());
        this._createComponent(this._$root, Box, rootBox)
    },
    _rootBoxConfig: function() {
        return extend({
            width: "100%",
            height: "100%",
            itemTemplate: this._getTemplateByOption("itemTemplate"),
            itemHoldTimeout: this.option("itemHoldTimeout"),
            onItemHold: this._createActionByOption("onItemHold"),
            onItemClick: this._createActionByOption("onItemClick"),
            onItemContextMenu: this._createActionByOption("onItemContextMenu"),
            onItemRendered: this._createActionByOption("onItemRendered")
        }, {
            _layoutStrategy: this.option("_layoutStrategy")
        })
    },
    _prepareBoxConfig: function(config) {
        return extend(config || {}, {
            crossAlign: "stretch",
            onItemStateChanged: this.option("onItemStateChanged")
        })
    },
    _layoutBlock: function(options) {
        if (this._isSingleItem(options)) {
            return this._itemByCell(options.row.start, options.col.start)
        }
        return this._layoutDirection(options)
    },
    _isSingleItem: function(options) {
        var firstCellLocation = this._grid[options.row.start][options.col.start].location;
        var isItemRowSpanned = options.row.end - options.row.start === firstCellLocation.rowspan - 1;
        var isItemColSpanned = options.col.end - options.col.start === firstCellLocation.colspan - 1;
        return isItemRowSpanned && isItemColSpanned
    },
    _itemByCell: function(rowIndex, colIndex) {
        var itemCell = this._grid[rowIndex][colIndex];
        return itemCell.spanningCell ? null : itemCell.item
    },
    _layoutDirection: function(options) {
        var items = [];
        var direction = options.direction;
        var crossDirection = this._crossDirection(direction);
        var block;
        while (block = this._nextBlock(options)) {
            if (this._isBlockIndivisible(options.prevBlockOptions, block)) {
                throw errors.Error("E1025")
            }
            var item = this._layoutBlock({
                direction: crossDirection,
                row: block.row,
                col: block.col,
                prevBlockOptions: options
            });
            if (item) {
                extend(item, this._blockSize(block, crossDirection));
                items.push(item)
            }
            options[crossDirection].start = block[crossDirection].end + 1
        }
        return {
            box: this._prepareBoxConfig({
                direction: direction,
                items: items
            })
        }
    },
    _isBlockIndivisible: function(options, block) {
        return options && options.col.start === block.col.start && options.col.end === block.col.end && options.row.start === block.row.start && options.row.end === block.row.end
    },
    _crossDirection: function(direction) {
        return "col" === direction ? "row" : "col"
    },
    _nextBlock: function(options) {
        var direction = options.direction;
        var crossDirection = this._crossDirection(direction);
        var startIndex = options[direction].start;
        var endIndex = options[direction].end;
        var crossStartIndex = options[crossDirection].start;
        if (crossStartIndex > options[crossDirection].end) {
            return null
        }
        var crossSpan = 1;
        for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
            var lineCrossSpan = 1;
            for (var index = startIndex; index <= endIndex; index++) {
                var cell = this._cellByDirection(direction, index, crossIndex);
                lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"])
            }
            var lineCrossEndIndex = crossIndex + lineCrossSpan;
            var crossEndIndex = crossStartIndex + crossSpan;
            if (lineCrossEndIndex > crossEndIndex) {
                crossSpan += lineCrossEndIndex - crossEndIndex
            }
        }
        var result = {};
        result[direction] = {
            start: startIndex,
            end: endIndex
        };
        result[crossDirection] = {
            start: crossStartIndex,
            end: crossStartIndex + crossSpan - 1
        };
        return result
    },
    _cellByDirection: function(direction, index, crossIndex) {
        return "col" === direction ? this._grid[crossIndex][index] : this._grid[index][crossIndex]
    },
    _blockSize: function(block, direction) {
        var sizeConfigs = "row" === direction ? this._rows : this._cols;
        var result = {
            ratio: 0,
            baseSize: 0,
            minSize: 0,
            maxSize: 0
        };
        for (var index = block[direction].start; index <= block[direction].end; index++) {
            var sizeConfig = sizeConfigs[index];
            result.ratio += sizeConfig.ratio;
            result.baseSize += sizeConfig.baseSize;
            result.minSize += sizeConfig.minSize;
            result.maxSize += sizeConfig.maxSize
        }
        result.minSize = result.minSize ? result.minSize : "auto";
        result.maxSize = result.maxSize ? result.maxSize : "auto";
        this._isSingleColumnScreen() && (result.baseSize = "auto");
        return result
    },
    _update: function() {
        var $existingRoot = this._$root;
        this._renderItems();
        $existingRoot && $existingRoot.detach();
        this._saveAssistantRoot($existingRoot);
        this._layoutChangedAction();
        this._updateRootBox()
    },
    _saveAssistantRoot: function($root) {
        this._assistantRoots = this._assistantRoots || [];
        this._assistantRoots.push($root)
    },
    _dispose: function() {
        clearTimeout(this._updateTimer);
        this._cleanUnusedRoots();
        this.callBase.apply(this, arguments)
    },
    _cleanUnusedRoots: function() {
        if (!this._assistantRoots) {
            return
        }
        $.each(this._assistantRoots, function() {
            $(this).remove()
        })
    },
    _clearItemNodeTemplates: function() {
        $.each(this.option("items"), function() {
            delete this.node
        })
    },
    _toggleVisibility: function(visible) {
        this.callBase(visible);
        if (visible) {
            this._updateRootBox()
        }
    },
    _attachClickEvent: commonUtils.noop,
    _optionChanged: function(args) {
        switch (args.name) {
            case "rows":
            case "cols":
            case "screenByWidth":
            case "_layoutStrategy":
            case "singleColumnScreen":
                this._clearItemNodeTemplates();
                this._invalidate();
                break;
            case "width":
            case "height":
                this.callBase(args);
                this._update();
                break;
            case "onLayoutChanged":
                this._initLayoutChangedAction();
                break;
            case "itemTemplate":
                this._clearItemNodeTemplates();
                this.callBase(args);
                break;
            case "currentScreenFactor":
                break;
            default:
                this.callBase(args)
        }
    },
    _dimensionChanged: function() {
        if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
            this._update()
        }
    },
    repaint: function() {
        this._update()
    }
});
registerComponent("dxResponsiveBox", ResponsiveBox);
module.exports = ResponsiveBox;
module.exports.default = module.exports;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tab_panel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    MultiView = __webpack_require__(331),
    Tabs = __webpack_require__(205),
    iconUtils = __webpack_require__(77),
    BindableTemplate = __webpack_require__(52);
var TABPANEL_CLASS = "dx-tabpanel",
    TABPANEL_TABS_CLASS = "dx-tabpanel-tabs",
    TABPANEL_CONTAINER_CLASS = "dx-tabpanel-container",
    TABS_ITEM_TEXT_CLASS = "dx-tab-text";
var TabPanel = MultiView.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            itemTitleTemplate: "title",
            hoverStateEnabled: true,
            showNavButtons: false,
            scrollByContent: true,
            scrollingEnabled: true,
            onTitleClick: null,
            onTitleHold: null,
            onTitleRendered: null
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return !support.touch
            },
            options: {
                swipeEnabled: false
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                animationEnabled: false
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.element().addClass(TABPANEL_CLASS);
        this.setAria("role", "tabpanel")
    },
    _render: function() {
        this._createTitleActions();
        this._renderLayout();
        this.callBase()
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.title = new BindableTemplate(function($container, data) {
            $container.text(data.title || String(data));
            var icon = data.icon,
                iconSrc = data.iconSrc,
                $iconElement = iconUtils.getImageContainer(icon || iconSrc);
            $container.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
            $iconElement && $iconElement.prependTo($container)
        }, ["title", "html", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"))
    },
    _createTitleActions: function() {
        this._createTitleClickAction();
        this._createTitleHoldAction();
        this._createTitleRenderedAction()
    },
    _createTitleClickAction: function() {
        this._titleClickAction = this._createActionByOption("onTitleClick")
    },
    _createTitleHoldAction: function() {
        this._titleHoldAction = this._createActionByOption("onTitleHold")
    },
    _createTitleRenderedAction: function() {
        this._titleRenderedAction = this._createActionByOption("onTitleRendered")
    },
    _renderContent: function() {
        var that = this;
        this.callBase();
        if (this.option("templatesRenderAsynchronously")) {
            this._resizeEventTimer = setTimeout(function() {
                that._updateLayout()
            }, 0)
        }
    },
    _renderLayout: function() {
        if (this._tabs) {
            return
        }
        var $element = this.element();
        this._$tabContainer = $("<div>").addClass(TABPANEL_TABS_CLASS).appendTo($element);
        var $tabs = $("<div>").appendTo(this._$tabContainer);
        this._tabs = this._createComponent($tabs, Tabs, this._tabConfig());
        this._$container = $("<div>").addClass(TABPANEL_CONTAINER_CLASS).appendTo($element);
        this._$container.append(this._$wrapper);
        this._updateLayout()
    },
    _updateLayout: function() {
        var tabsHeight = this._$tabContainer.outerHeight();
        this._$container.css({
            "margin-top": -tabsHeight,
            "padding-top": tabsHeight
        })
    },
    _refreshActiveDescendant: function() {
        var tabs = this._tabs,
            tabItems = tabs.itemElements(),
            $activeTab = $(tabItems[tabs.option("selectedIndex")]),
            id = this.getFocusedItemId();
        this.setAria("controls", void 0, $(tabItems));
        this.setAria("controls", id, $activeTab)
    },
    _tabConfig: function() {
        return {
            selectOnFocus: true,
            focusStateEnabled: this.option("focusStateEnabled"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            tabIndex: this.option("tabIndex"),
            selectedIndex: this.option("selectedIndex"),
            onItemClick: this._titleClickAction.bind(this),
            onItemHold: this._titleHoldAction.bind(this),
            itemHoldTimeout: this.option("itemHoldTimeout"),
            onSelectionChanged: function(e) {
                this.option("selectedIndex", e.component.option("selectedIndex"));
                this._refreshActiveDescendant()
            }.bind(this),
            onItemRendered: this._titleRenderedAction.bind(this),
            itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
            items: this.option("items"),
            noDataText: null,
            scrollingEnabled: this.option("scrollingEnabled"),
            scrollByContent: this.option("scrollByContent"),
            showNavButtons: this.option("showNavButtons"),
            itemTemplateProperty: "tabTemplate",
            loopItemFocus: this.option("loop"),
            selectionRequired: true,
            onOptionChanged: function(args) {
                var name = args.name,
                    value = args.value;
                if ("focusedElement" === name) {
                    var id = value ? value.index() : value;
                    var newItem = value ? this._itemElements().eq(id) : value;
                    this.option("focusedElement", newItem)
                }
            }.bind(this),
            onFocusIn: function(args) {
                this._focusInHandler(args.jQueryEvent)
            }.bind(this),
            onFocusOut: function(args) {
                this._focusOutHandler(args.jQueryEvent)
            }.bind(this)
        }
    },
    _renderFocusTarget: function() {
        this._focusTarget().attr("tabindex", -1);
        this._refreshActiveDescendant()
    },
    _updateFocusState: function(e, isFocused) {
        this.callBase(e, isFocused);
        if (e.target === this._tabs._focusTarget().get(0)) {
            this._toggleFocusClass(isFocused, this._focusTarget())
        }
    },
    _setTabsOption: function(name, value) {
        if (this._tabs) {
            this._tabs.option(name, value)
        }
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._tabs._dimensionChanged();
            this._updateLayout()
        }
    },
    _optionChanged: function(args) {
        var name = args.name,
            value = args.value,
            fullName = args.fullName;
        switch (name) {
            case "dataSource":
                this.callBase(args);
                break;
            case "items":
                this._setTabsOption(fullName, value);
                this._updateLayout();
                this._tabs.repaint();
                this.callBase(args);
                break;
            case "selectedIndex":
            case "selectedItem":
            case "itemHoldTimeout":
            case "focusStateEnabled":
            case "hoverStateEnabled":
                this._setTabsOption(fullName, value);
                this.callBase(args);
                break;
            case "scrollingEnabled":
            case "scrollByContent":
            case "showNavButtons":
                this._setTabsOption(fullName, value);
                break;
            case "focusedElement":
                var id = value ? value.index() : value;
                var newItem = value ? this._tabs._itemElements().eq(id) : value;
                this._setTabsOption("focusedElement", newItem);
                this.callBase(args);
                this._tabs.focus();
                break;
            case "itemTitleTemplate":
                this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
                break;
            case "onTitleClick":
                this._createTitleClickAction();
                this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
                break;
            case "onTitleHold":
                this._createTitleHoldAction();
                this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
                break;
            case "onTitleRendered":
                this._createTitleRenderedAction();
                this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
                break;
            case "loop":
                this._setTabsOption("loopItemFocus", value);
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        clearTimeout(this._resizeEventTimer);
        this.callBase()
    }
});
registerComponent("dxTabPanel", TabPanel);
module.exports = TabPanel;
module.exports.default = module.exports;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tabs.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    Button = __webpack_require__(25),
    inkRipple = __webpack_require__(43),
    eventUtils = __webpack_require__(3),
    domUtils = __webpack_require__(15),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    pointerEvents = __webpack_require__(17),
    TabsItem = __webpack_require__(332),
    themes = __webpack_require__(20),
    holdEvent = __webpack_require__(66),
    Scrollable = __webpack_require__(70),
    CollectionWidget = __webpack_require__(40),
    iconUtils = __webpack_require__(77),
    BindableTemplate = __webpack_require__(52);
var TABS_CLASS = "dx-tabs",
    TABS_WRAPPER_CLASS = "dx-tabs-wrapper",
    TABS_EXPANDED_CLASS = "dx-tabs-expanded",
    TABS_SCROLLABLE_CLASS = "dx-tabs-scrollable",
    TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons",
    TABS_ITEM_CLASS = "dx-tab",
    TABS_ITEM_SELECTED_CLASS = "dx-tab-selected",
    TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button",
    TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left",
    TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right",
    TABS_ITEM_TEXT_CLASS = "dx-tab-text",
    TABS_ITEM_DATA_KEY = "dxTabData",
    FEEDBACK_HIDE_TIMEOUT = 100,
    FEEDBACK_DURATION_INTERVAL = 5,
    FEEDBACK_SCROLL_TIMEOUT = 300,
    TAB_OFFSET = 30;
var Tabs = CollectionWidget.inherit({
    _activeStateUnit: "." + TABS_ITEM_CLASS,
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            showNavButtons: false,
            scrollByContent: true,
            scrollingEnabled: true,
            selectionMode: "single",
            activeStateEnabled: true,
            selectionRequired: false,
            selectOnFocus: true,
            loopItemFocus: false,
            useInkRipple: false,
            badgeExpr: function(data) {
                return data ? data.badge : void 0
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "generic"
            },
            options: {
                showNavButtons: true,
                scrollByContent: false
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.setAria("role", "tablist");
        this.element().addClass(TABS_CLASS);
        this._renderMultiple();
        this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
            if (isPlainObject(data)) {
                if (data.text) {
                    $container.text(data.text)
                }
                if (data.html) {
                    $container.html(data.html)
                }
            } else {
                $container.text(String(data))
            }
            var icon = data.icon,
                iconSrc = data.iconSrc,
                $iconElement = iconUtils.getImageContainer(icon || iconSrc);
            $container.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
            $iconElement && $iconElement.prependTo($container)
        }, ["text", "html", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"))
    },
    _itemClass: function() {
        return TABS_ITEM_CLASS
    },
    _selectedItemClass: function() {
        return TABS_ITEM_SELECTED_CLASS
    },
    _itemDataKey: function() {
        return TABS_ITEM_DATA_KEY
    },
    _renderContent: function() {
        var that = this;
        this.callBase();
        if (this.option("templatesRenderAsynchronously")) {
            this._resizeEventTimer = setTimeout(function() {
                domUtils.triggerResizeEvent(that.element())
            }, 0)
        }
    },
    _render: function() {
        this.callBase();
        this._renderWrapper();
        this._renderScrolling();
        this.setAria("role", "tab", this.itemElements());
        this.option("useInkRipple") && this._renderInkRipple()
    },
    _renderScrolling: function() {
        this.element().removeClass(TABS_EXPANDED_CLASS);
        if (this._allowScrolling()) {
            if (!this._scrollable) {
                this._renderScrollable();
                this._renderNavButtons()
            }
            this._scrollable.update();
            this._updateNavButtonsVisibility();
            if (this.option("rtlEnabled")) {
                this._scrollable.scrollTo({
                    left: this._scrollable.scrollWidth() - this._scrollable.clientWidth()
                })
            }
            this._scrollToItem(this.option("selectedItem"))
        }
        if (!this._allowScrolling()) {
            this._cleanScrolling();
            this.element().removeClass(TABS_NAV_BUTTONS_CLASS).addClass(TABS_EXPANDED_CLASS)
        }
    },
    _cleanNavButtons: function() {
        if (!this._leftButton || !this._rightButton) {
            return
        }
        this._leftButton.element().remove();
        this._rightButton.element().remove();
        this._leftButton = null;
        this._rightButton = null
    },
    _cleanScrolling: function() {
        if (!this._scrollable) {
            return
        }
        this._scrollable.content().children("." + TABS_WRAPPER_CLASS).appendTo(this._itemContainer());
        this._scrollable.element().remove();
        this._scrollable = null;
        this._cleanNavButtons()
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _renderMultiple: function() {
        if ("multiple" === this.option("selectionMode")) {
            this.option("selectOnFocus", false)
        }
    },
    _renderWrapper: function() {
        this.element().wrapInner($("<div>").addClass(TABS_WRAPPER_CLASS))
    },
    _renderScrollable: function() {
        var $itemContainer = this.element().wrapInner($("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
        this._scrollable = this._createComponent($itemContainer, Scrollable, {
            direction: "horizontal",
            showScrollbar: false,
            useKeyboard: false,
            useNative: false,
            scrollByContent: this.option("scrollByContent"),
            onScroll: this._updateNavButtonsVisibility.bind(this)
        });
        this.element().append(this._scrollable.element())
    },
    _scrollToItem: function(itemData) {
        if (!this._scrollable) {
            return
        }
        var $item = this._editStrategy.getItemElement(itemData);
        this._scrollable.scrollToElement($item)
    },
    _allowScrolling: function() {
        if (!this.option("scrollingEnabled")) {
            return false
        }
        var tabItemsWidth = 0;
        this.itemElements().each(function(_, tabItem) {
            tabItemsWidth += $(tabItem).outerWidth(true)
        });
        return tabItemsWidth - 1 > this.element().width()
    },
    _renderNavButtons: function() {
        this.element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
        if (!this.option("showNavButtons")) {
            return
        }
        this._leftButton = this._createNavButton(-TAB_OFFSET, "chevronprev");
        var $leftButton = this._leftButton.element();
        $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
        this.element().prepend($leftButton);
        this._rightButton = this._createNavButton(TAB_OFFSET, "chevronnext");
        var $rightButton = this._rightButton.element();
        $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
        this.element().append($rightButton)
    },
    _updateNavButtonsVisibility: function() {
        this._leftButton && this._leftButton.option("disabled", this._scrollable.scrollLeft() <= 0);
        this._rightButton && this._rightButton.option("disabled", this._scrollable.scrollLeft() >= Math.round(this._scrollable.scrollWidth() - this._scrollable.clientWidth()))
    },
    _updateScrollPosition: function(offset, duration) {
        this._scrollable.update();
        this._scrollable.scrollBy(offset / duration)
    },
    _createNavButton: function(offset, icon) {
        var that = this;
        var holdAction = that._createAction(function() {
                that._holdInterval = setInterval(function() {
                    that._updateScrollPosition(offset, FEEDBACK_DURATION_INTERVAL)
                }, FEEDBACK_DURATION_INTERVAL)
            }),
            holdEventName = eventUtils.addNamespace(holdEvent.name, "dxNavButton"),
            pointerUpEventName = eventUtils.addNamespace(pointerEvents.up, "dxNavButton"),
            pointerOutEventName = eventUtils.addNamespace(pointerEvents.out, "dxNavButton");
        var navButton = this._createComponent($("<div>").addClass(TABS_NAV_BUTTON_CLASS), Button, {
            focusStateEnabled: false,
            icon: icon,
            onClick: function() {
                that._updateScrollPosition(offset, 1)
            },
            integrationOptions: {}
        });
        navButton.element().on(holdEventName, {
            timeout: FEEDBACK_SCROLL_TIMEOUT
        }, function(e) {
            holdAction({
                jQueryEvent: e
            })
        }.bind(this)).on(pointerUpEventName, function() {
            that._clearInterval()
        }).on(pointerOutEventName, function() {
            that._clearInterval()
        });
        return navButton
    },
    _clearInterval: function() {
        if (this._holdInterval) {
            clearInterval(this._holdInterval)
        }
    },
    _renderSelection: function(addedSelection) {
        this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]), {
            left: 1,
            right: 1
        })
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _dimensionChanged: function() {
        if (this.option("scrollingEnabled")) {
            this._renderScrolling()
        }
    },
    _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
            return
        }
        this.callBase(e)
    },
    _clean: function() {
        this._scrollable = null;
        clearTimeout(this._resizeEventTimer);
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
            case "scrollingEnabled":
            case "showNavButtons":
                this._invalidate();
                break;
            case "scrollByContent":
                this._scrollable && this._scrollable.option(args.name, args.value);
                break;
            case "selectionMode":
                this._renderMultiple();
                this.callBase(args);
                break;
            case "badgeExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
Tabs.ItemClass = TabsItem;
registerComponent("dxTabs", Tabs);
module.exports = Tabs;
module.exports.default = module.exports;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    themes = __webpack_require__(20),
    registerComponent = __webpack_require__(4),
    grep = __webpack_require__(2).grep,
    extend = __webpack_require__(1).extend,
    ActionSheetStrategy = __webpack_require__(335),
    DropDownMenuStrategy = __webpack_require__(336),
    ListBottomStrategy = __webpack_require__(338),
    ListTopStrategy = __webpack_require__(339),
    ToolbarBase = __webpack_require__(188),
    ChildDefaultTemplate = __webpack_require__(74);
var STRATEGIES = {
    actionSheet: ActionSheetStrategy,
    dropDownMenu: DropDownMenuStrategy,
    listBottom: ListBottomStrategy,
    listTop: ListTopStrategy
};
var TOOLBAR_AUTO_HIDE_ITEM_CLASS = "dx-toolbar-item-auto-hide",
    TOOLBAR_AUTO_HIDE_TEXT_CLASS = "dx-toolbar-text-auto-hide",
    TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var Toolbar = ToolbarBase.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            menuItemTemplate: "menuItem",
            submenuType: "dropDownMenu"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return /ios7.*/.test(themes.current())
            },
            options: {
                submenuType: "actionSheet"
            }
        }, {
            device: function() {
                return /android5.*/.test(themes.current())
            },
            options: {
                submenuType: "dropDownMenu"
            }
        }, {
            device: function() {
                return /win8.*/.test(themes.current())
            },
            options: {
                submenuType: "listBottom"
            }
        }, {
            device: function() {
                return /win10.*/.test(themes.current())
            },
            options: {
                submenuType: "listTop"
            }
        }])
    },
    _dimensionChanged: function(dimension) {
        if ("height" === dimension) {
            return
        }
        this._menuStrategy.toggleMenuVisibility(false, true);
        this.callBase();
        this._menuStrategy.renderMenuItems()
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.actionSheetItem = new ChildDefaultTemplate("item", this)
    },
    _render: function() {
        this.callBase();
        this._menuStrategy.renderMenuItems()
    },
    _renderContentImpl: function() {
        this.callBase();
        this._hideOverflowItems();
        this._renderMenu()
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var itemElement = this.callBase(index, item, itemContainer, $after);
        if ("auto" === item.locateInMenu) {
            itemElement.addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS)
        }
        if ("dxButton" === item.widget && "inMenu" === item.showText) {
            itemElement.toggleClass(TOOLBAR_AUTO_HIDE_TEXT_CLASS)
        }
        return itemElement
    },
    _hideOverflowItems: function(elementWidth) {
        var overflowItems = this.element().find("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS);
        if (!overflowItems.length) {
            return
        }
        elementWidth = elementWidth || this.element().width();
        $(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
        var beforeWidth = this._$beforeSection.outerWidth(),
            centerWidth = this._$centerSection.outerWidth(),
            afterWidth = this._$afterSection.outerWidth(),
            itemsWidth = beforeWidth + centerWidth + afterWidth;
        while (overflowItems.length && elementWidth < itemsWidth) {
            var $item = overflowItems.eq(-1);
            itemsWidth -= $item.outerWidth();
            $item.addClass(TOOLBAR_HIDDEN_ITEM);
            overflowItems.splice(-1, 1)
        }
    },
    _getMenuItems: function() {
        var that = this;
        var menuItems = grep(this.option("items") || [], function(item) {
            return that._isMenuItem(item)
        });
        var $hiddenItems = this._itemContainer().children("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS + "." + TOOLBAR_HIDDEN_ITEM).not(".dx-state-invisible");
        this._restoreItems = this._restoreItems || [];
        var overflowItems = $.map($hiddenItems, function(item) {
            var itemData = that._getItemData(item),
                $itemContainer = $(item).children(),
                $itemMarkup = $itemContainer.children();
            return extend({
                menuItemTemplate: function() {
                    that._restoreItems.push({
                        container: $itemContainer,
                        item: $itemMarkup
                    });
                    var $container = $("<div>").addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS);
                    return $container.append($itemMarkup)
                }
            }, itemData)
        });
        return $.merge(overflowItems, menuItems)
    },
    _getToolbarItems: function() {
        var that = this;
        return grep(this.option("items") || [], function(item) {
            return !that._isMenuItem(item)
        })
    },
    _renderMenu: function() {
        this._renderMenuStrategy();
        this._menuStrategy.render()
    },
    _renderMenuStrategy: function() {
        var strategyName = this.option("submenuType");
        if (this._requireDropDownStrategy()) {
            strategyName = "dropDownMenu"
        }
        var strategy = STRATEGIES[strategyName];
        if (!(this._menuStrategy && this._menuStrategy.NAME === strategyName)) {
            this._menuStrategy = new strategy(this)
        }
    },
    _requireDropDownStrategy: function() {
        var strategyName = this.option("submenuType");
        if (("listBottom" === strategyName || "listTop" === strategyName) && "topToolbar" === this.option("renderAs")) {
            return true
        }
        var items = this.option("items") || [],
            result = false;
        $.each(items, function(index, item) {
            if ("auto" === item.locateInMenu) {
                result = true
            } else {
                if ("always" === item.locateInMenu && item.widget) {
                    result = true
                }
            }
        });
        return result
    },
    _arrangeItems: function() {
        if (this.element().is(":hidden")) {
            return
        }
        this._$centerSection.css({
            margin: "0 auto",
            "float": "none"
        });
        $.each(this._restoreItems || [], function(_, obj) {
            $(obj.container).append(obj.item)
        });
        this._restoreItems = [];
        var elementWidth = this.element().width();
        this._hideOverflowItems(elementWidth);
        this.callBase(elementWidth)
    },
    _itemOptionChanged: function(item, property, value) {
        if (this._isMenuItem(item)) {
            this._menuStrategy.renderMenuItems()
        } else {
            if (this._isToolbarItem(item)) {
                this.callBase(item, property, value)
            } else {
                this.callBase(item, property, value);
                this._menuStrategy.renderMenuItems()
            }
        }
    },
    _isMenuItem: function(itemData) {
        return "menu" === itemData.location || "always" === itemData.locateInMenu
    },
    _isToolbarItem: function(itemData) {
        return void 0 === itemData.location || "never" === itemData.locateInMenu
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        switch (name) {
            case "submenuType":
                this._invalidate();
                break;
            case "visible":
                this.callBase.apply(this, arguments);
                this._menuStrategy.handleToolbarVisibilityChange(value);
                break;
            case "menuItemTemplate":
                this._changeMenuOption("itemTemplate", this._getTemplate(value));
                break;
            case "onItemClick":
                this._changeMenuOption(name, value);
                this.callBase.apply(this, arguments);
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    _changeMenuOption: function(name, value) {
        this._menuStrategy.widgetOption(name, value)
    }
});
registerComponent("dxToolbar", Toolbar);
module.exports = Toolbar;
module.exports.default = module.exports;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    ToolbarStrategy = __webpack_require__(156),
    translator = __webpack_require__(19),
    hideTopOverlayCallback = __webpack_require__(108).hideCallback,
    fx = __webpack_require__(22),
    Overlay = __webpack_require__(39),
    List = __webpack_require__(124);
var TOOLBAR_LIST_VISIBLE_CLASS = "dx-toolbar-list-visible",
    SUBMENU_ANIMATION_EASING = "easeOutCubic",
    SUBMENU_HIDE_DURATION = 200,
    SUBMENU_SHOW_DURATION = 400;
var ListStrategy = ToolbarStrategy.inherit({
    render: function() {
        this._renderListOverlay();
        this.callBase();
        this._changeListVisible(this._toolbar.option("visible"))
    },
    _renderWidget: function() {
        if (!this._hasVisibleMenuItems()) {
            return
        }
        this.callBase()
    },
    _menuWidgetClass: function() {
        return List
    },
    _menuContainer: function() {
        return this._listOverlay.content()
    },
    _menuButtonOptions: function() {
        return extend({}, this.callBase(), {
            activeStateEnabled: false,
            text: "..."
        })
    },
    _widgetOptions: function() {
        return extend({}, this.callBase(), {
            width: "100%",
            indicateLoading: false
        })
    },
    _renderListOverlay: function() {
        var $listOverlay = $("<div>").appendTo(this._toolbar.element());
        this._listOverlay = this._toolbar._createComponent($listOverlay, Overlay, this._listOverlayConfig())
    },
    _listOverlayConfig: function() {
        return {
            container: false,
            deferRendering: false,
            shading: false,
            height: "auto",
            width: "100%",
            showTitle: false,
            closeOnOutsideClick: this._listOutsideClickHandler.bind(this),
            position: null,
            animation: null,
            closeOnBackButton: false
        }
    },
    _listOutsideClickHandler: function(e) {
        if (!$(e.target).closest(this._listOverlay.content()).length) {
            this._toggleMenu(false, true)
        }
    },
    _getListHeight: function() {
        var listHeight = this._listOverlay.content().find(".dx-list").height(),
            semiHiddenHeight = this._toolbar._$toolbarItemsContainer.height() - this._toolbar.element().height();
        return listHeight + semiHiddenHeight
    },
    _hideTopOverlayHandler: function() {
        this._toggleMenu(false, true)
    },
    _toggleHideTopOverlayCallback: function() {
        if (this._closeCallback) {
            hideTopOverlayCallback.remove(this._closeCallback)
        }
        if (this._menuShown) {
            this._closeCallback = this._hideTopOverlayHandler.bind(this);
            hideTopOverlayCallback.add(this._closeCallback)
        }
    },
    _calculatePixelOffset: function(offset) {
        offset = (offset || 0) - 1;
        var maxOffset = this._getListHeight();
        return offset * maxOffset
    },
    _renderMenuPosition: function(offset, animate) {
        var pos = this._calculatePixelOffset(offset),
            element = this._listOverlay.content();
        if (animate) {
            return this._animateMenuToggling(element, pos, this._menuShown)
        }
        translator.move(element, {
            top: pos
        });
        return $.Deferred().resolve().promise()
    },
    _animateMenuToggling: function($element, position, isShowAnimation) {
        var duration = isShowAnimation ? SUBMENU_SHOW_DURATION : SUBMENU_HIDE_DURATION;
        return fx.animate($element, {
            type: "slide",
            to: {
                top: position
            },
            easing: SUBMENU_ANIMATION_EASING,
            duration: duration
        })
    },
    _toggleMenu: function(visible, animate) {
        this.callBase.apply(this, arguments);
        this._toggleHideTopOverlayCallback();
        this._renderMenuPosition(this._menuShown ? 0 : 1, animate).done(function() {
            this._toolbar.element().toggleClass(TOOLBAR_LIST_VISIBLE_CLASS, visible)
        }.bind(this))
    },
    _changeListVisible: function(value) {
        if (this._listOverlay) {
            this._listOverlay.option("visible", value);
            this._toggleMenu(false, false)
        }
    },
    handleToolbarVisibilityChange: function(value) {
        this._changeListVisible(value)
    }
});
module.exports = ListStrategy;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tooltip.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(209);
module.exports.show = __webpack_require__(210).show;
module.exports.hide = __webpack_require__(210).hide;
module.exports.default = module.exports;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tooltip/tooltip.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    Popover = __webpack_require__(98),
    TOOLTIP_CLASS = "dx-tooltip",
    TOOLTIP_WRAPPER_CLASS = "dx-tooltip-wrapper";
var Tooltip = Popover.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            toolbarItems: [],
            showCloseButton: false,
            showTitle: false,
            title: null,
            titleTemplate: null,
            onTitleRendered: null,
            bottomTemplate: null,
            propagateOutsideClick: true
        })
    },
    _render: function() {
        this.element().addClass(TOOLTIP_CLASS);
        this._wrapper().addClass(TOOLTIP_WRAPPER_CLASS);
        this.callBase()
    },
    _renderContent: function() {
        this.callBase();
        this._contentId = "dx-" + new Guid;
        this._$content.attr({
            id: this._contentId,
            role: "tooltip"
        });
        this._toggleAriaDescription(true)
    },
    _toggleAriaDescription: function(showing) {
        var $target = $(this.option("target")),
            label = showing ? this._contentId : void 0;
        this.setAria("describedby", label, $target)
    }
});
registerComponent("dxTooltip", Tooltip);
module.exports = Tooltip;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tooltip/ui.tooltip.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Tooltip = __webpack_require__(209),
    extend = __webpack_require__(1).extend,
    viewPortUtils = __webpack_require__(54);
var tooltip = null;
var removeTooltipElement = null;
var createTooltip = function(options) {
    options = extend({
        position: "top"
    }, options);
    var content = options.content;
    delete options.content;
    var $tooltip = $("<div />").html(content).appendTo(viewPortUtils.value());
    removeTooltipElement = function() {
        $tooltip.remove()
    };
    tooltip = new Tooltip($tooltip, options)
};
var removeTooltip = function() {
    if (!tooltip) {
        return
    }
    removeTooltipElement();
    tooltip = null
};
exports.show = function(options) {
    removeTooltip();
    createTooltip(options);
    return tooltip.show()
};
exports.hide = function() {
    if (!tooltip) {
        return $.Deferred().resolve()
    }
    return tooltip.hide().done(removeTooltip).promise()
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validation_group.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    DOMComponent = __webpack_require__(45),
    ValidationSummary = __webpack_require__(157),
    ValidationEngine = __webpack_require__(58),
    Validator = __webpack_require__(129);
var VALIDATION_ENGINE_CLASS = "dx-validationgroup";
var ValidationGroup = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return this.callBase()
    },
    _init: function() {
        this.callBase()
    },
    _render: function() {
        var $element = this.element();
        $element.addClass(VALIDATION_ENGINE_CLASS);
        $element.find(".dx-validator").each(function(_, validatorContainer) {
            Validator.getInstance($(validatorContainer))._initGroupRegistration()
        });
        $element.find(".dx-validationsummary").each(function(_, summaryContainer) {
            ValidationSummary.getInstance($(summaryContainer))._initGroupRegistration()
        });
        this.callBase()
    },
    validate: function() {
        return ValidationEngine.validateGroup(this)
    },
    reset: function() {
        return ValidationEngine.resetGroup(this)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            default: this.callBase(args)
        }
    },
    _dispose: function() {
        ValidationEngine.removeGroup(this);
        this.element().removeClass(VALIDATION_ENGINE_CLASS);
        this.callBase()
    }
});
registerComponent("dxValidationGroup", ValidationGroup);
module.exports = ValidationGroup;
module.exports.default = module.exports;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/context_menu/ui.menu_base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    inkRipple = __webpack_require__(43),
    HierarchicalCollectionWidget = __webpack_require__(213),
    MenuBaseEditStrategy = __webpack_require__(345),
    devices = __webpack_require__(6),
    themes = __webpack_require__(20);
var DX_MENU_CLASS = "dx-menu",
    DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS + "-no-icons",
    DX_MENU_BASE_CLASS = "dx-menu-base",
    ITEM_CLASS = DX_MENU_CLASS + "-item",
    DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected",
    DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS + "-wrapper",
    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
    DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS + "-expanded",
    DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator",
    DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item",
    DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text",
    DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon",
    DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu",
    DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout",
    DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container",
    DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text",
    SINGLE_SELECTION_MODE = "single",
    DEFAULT_DELAY = {
        show: 50,
        hide: 300
    };
var MenuBase = HierarchicalCollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            items: [],
            cssClass: "",
            activeStateEnabled: true,
            showSubmenuMode: {
                name: "onHover",
                delay: {
                    show: 50,
                    hide: 300
                }
            },
            animation: {
                show: {
                    type: "fade",
                    from: 0,
                    to: 1,
                    duration: 100
                },
                hide: {
                    type: "fade",
                    from: 1,
                    to: 0,
                    duration: 100
                }
            },
            selectByClick: false,
            focusOnSelectedItem: false,
            keyExpr: null,
            _itemAttributes: {
                role: "menuitem"
            },
            useInkRipple: false
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            selectionByClick: {
                since: "16.1",
                alias: "selectByClick"
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _activeStateUnit: "." + ITEM_CLASS,
    _itemDataKey: function() {
        return "dxMenuItemDataKey"
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _setAriaSelected: commonUtils.noop,
    _selectedItemClass: function() {
        return DX_MENU_SELECTED_ITEM_CLASS
    },
    _widgetClass: function() {
        return DX_MENU_BASE_CLASS
    },
    _focusTarget: function() {
        return this._itemContainer()
    },
    _supportedKeys: function() {
        var selectItem = function() {
            var $item = this.option("focusedElement");
            if (!$item || !this._isSelectionEnabled()) {
                return
            }
            this.selectItem($item[0])
        };
        return extend(this.callBase(), {
            space: selectItem,
            pageUp: commonUtils.noop,
            pageDown: commonUtils.noop
        })
    },
    _isSelectionEnabled: function() {
        return this.option("selectionMode") === SINGLE_SELECTION_MODE
    },
    _init: function() {
        this.callBase();
        this._renderSelectedItem();
        this._initActions()
    },
    _getTextContainer: function(itemData) {
        var itemText = itemData.text,
            $itemContainer = $("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS),
            itemContent = typeUtils.isPlainObject(itemData) ? itemText : String(itemData);
        return itemText && $itemContainer.html(itemContent)
    },
    _getPopoutContainer: function(itemData) {
        var $popOutContainer, items = itemData.items;
        if (items && items.length) {
            var $popOutImage = $("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
            $popOutContainer = $("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage)
        }
        return $popOutContainer
    },
    _getDataAdapterOptions: function() {
        return {
            rootValue: 0,
            multipleSelection: false,
            recursiveSelection: false,
            recursiveExpansion: false,
            searchValue: ""
        }
    },
    _selectByItem: function(selectedItem) {
        if (!selectedItem) {
            return
        }
        var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
        this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true)
    },
    _renderSelectedItem: function() {
        var selectedKeys = this._dataAdapter.getSelectedNodesKeys(),
            selectedKey = selectedKeys.length && selectedKeys[0],
            selectedItem = this.option("selectedItem");
        if (!selectedKey) {
            this._selectByItem(selectedItem);
            return
        }
        var node = this._dataAdapter.getNodeByKey(selectedKey);
        if (false === node.selectable) {
            return
        }
        if (!selectedItem) {
            this.option("selectedItem", node.internalFields.item);
            return
        }
        if (selectedItem !== node.internalFields.item) {
            this._dataAdapter.toggleSelection(selectedKey, false);
            this._selectByItem(selectedItem)
        }
    },
    _initActions: commonUtils.noop,
    _render: function() {
        this.callBase();
        this._addCustomCssClass(this.element());
        this.option("useInkRipple") && this._renderInkRipple()
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _getShowSubmenuMode: function() {
        var defaultValue = "onClick",
            optionValue = this.option("showSubmenuMode");
        optionValue = commonUtils.isObject(optionValue) ? optionValue.name : optionValue;
        return this._isDesktopDevice() ? optionValue : defaultValue
    },
    _initSelectedItems: commonUtils.noop,
    _isDesktopDevice: function() {
        return "desktop" === devices.real().deviceType
    },
    _initEditStrategy: function() {
        var Strategy = MenuBaseEditStrategy;
        this._editStrategy = new Strategy(this)
    },
    _addCustomCssClass: function($element) {
        $element.addClass(this.option("cssClass"))
    },
    _itemWrapperSelector: function() {
        return "." + DX_MENU_ITEM_WRAPPER_CLASS
    },
    _hoverStartHandler: function(e) {
        var that = this,
            $itemElement = that._getItemElementByEventArgs(e);
        if (!$itemElement || that._isItemDisabled($itemElement)) {
            return
        }
        e.stopPropagation();
        if ("onHover" === that._getShowSubmenuMode()) {
            clearTimeout(this._showSubmenusTimeout);
            this._showSubmenusTimeout = setTimeout(that._showSubmenu.bind(that, $itemElement), that._getSubmenuDelay("show"))
        }
    },
    _getAvailableItems: function($itemElements) {
        return this.callBase($itemElements).filter(function() {
            return "hidden" !== $(this).css("visibility")
        })
    },
    _isItemDisabled: function($item) {
        return this._disabledGetter($item.data(this._itemDataKey()))
    },
    _showSubmenu: function($itemElement) {
        this._addExpandedClass($itemElement)
    },
    _addExpandedClass: function($itemElement) {
        $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
    },
    _getSubmenuDelay: function(action) {
        var delay = this.option("showSubmenuMode").delay;
        if (!commonUtils.isDefined(delay)) {
            return DEFAULT_DELAY[action]
        }
        return commonUtils.isObject(delay) ? delay[action] : delay
    },
    _getItemElementByEventArgs: function(eventArgs) {
        var $target = $(eventArgs.target);
        if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
            return $target
        }
        while (!$target.hasClass(this._itemClass())) {
            $target = $target.parent();
            if ($target.hasClass("dx-submenu")) {
                return null
            }
        }
        return $target
    },
    _hoverEndHandler: function() {
        clearTimeout(this._showSubmenusTimeout)
    },
    _hasSubmenu: function(node) {
        return node.internalFields.childrenKeys.length
    },
    _renderContentImpl: function() {
        this._renderItems(this._dataAdapter.getRootNodes())
    },
    _renderItems: function(nodes, submenuContainer) {
        var $nodeContainer, that = this;
        if (nodes.length) {
            this.hasIcons = false;
            $nodeContainer = this._renderContainer(this.element(), submenuContainer);
            $.each(nodes, function(index, node) {
                that._renderItem(index, node, $nodeContainer)
            });
            if (!this.hasIcons) {
                $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS)
            }
        }
    },
    _renderContainer: function($wrapper) {
        return $("<ul>").appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
    },
    _createDOMElement: function($nodeContainer) {
        var $node = $("<li>").appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
        return $node
    },
    _renderItem: function(index, node, $nodeContainer) {
        var $itemFrame, items = this.option("items");
        this._renderSeparator(node, index, $nodeContainer);
        if (false === node.internalFields.item.visible) {
            return
        }
        var $node = this._createDOMElement($nodeContainer);
        if (items[index + 1] && items[index + 1].beginGroup) {
            $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM)
        }
        $itemFrame = this.callBase(index, node.internalFields.item, $node);
        if (node.internalFields.item === this.option("selectedItem")) {
            $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS)
        }
        this._addContentClasses(node, $itemFrame);
        $itemFrame.attr("tabindex", -1);
        if (this._hasSubmenu(node)) {
            this.setAria("haspopup", "true", $itemFrame)
        }
    },
    _addContentClasses: function(node, $itemFrame) {
        if (this._displayGetter(node)) {
            $itemFrame.addClass(DX_ITEM_HAS_TEXT)
        }
        if (node.icon || node.iconSrc) {
            $itemFrame.addClass(DX_ITEM_HAS_ICON);
            this.hasIcons = true
        }
        if (this._hasSubmenu(node)) {
            $itemFrame.addClass(DX_ITEM_HAS_SUBMENU)
        }
    },
    _postprocessRenderItem: function(args) {
        var node, $itemElement = $(args.itemElement),
            selectedIndex = this._dataAdapter.getSelectedNodesKeys();
        if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
            this._setAriaSelected($itemElement, "false");
            return
        }
        node = this._dataAdapter.getNodeByItem(args.itemData);
        if (node.internalFields.key === selectedIndex[0]) {
            $itemElement.addClass(this._selectedItemClass());
            this._setAriaSelected($itemElement, "true")
        } else {
            this._setAriaSelected($itemElement, "false")
        }
    },
    _isItemSelectable: function(item) {
        return false !== item.selectable
    },
    _renderSeparator: function(node, index, $itemsContainer) {
        if (node.beginGroup && index > 0) {
            this._needSeparate = true
        }
        if (false !== node.visible && this._needSeparate) {
            if (index > 0) {
                $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS)
            }
            this._needSeparate = false
        }
    },
    _itemClickHandler: function(e) {
        if (e._skipHandling) {
            return
        }
        var itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
        this._itemJQueryEventHandler(e, "onItemClick", {}, {
            afterExecute: itemClickActionHandler.bind(this)
        });
        e._skipHandling = true
    },
    _updateSubmenuVisibilityOnClick: function(actionArgs) {
        this._updateSelectedItemOnClick(actionArgs);
        if ("onClick" === this._getShowSubmenuMode()) {
            this._addExpandedClass(actionArgs.args[0].itemElement)
        }
    },
    _updateSelectedItemOnClick: function(actionArgs) {
        var selectedItemKey, args = actionArgs.args ? actionArgs.args[0] : actionArgs;
        if (!this._isItemSelectionAllowed(args.itemData)) {
            return
        }
        selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
        var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
        if (selectedNode) {
            this._toggleItemSelection(selectedNode, false)
        }
        if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
            this.selectItem(args.itemData)
        } else {
            this._fireSelectionChangeEvent(null, this.option("selectedItem"));
            this._setOptionSilent("selectedItem", null)
        }
    },
    _isItemSelectionAllowed: function(item) {
        var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
        return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item)
    },
    _isContainerEmpty: function() {
        return this._itemContainer().is(":empty")
    },
    _syncSelectionOptions: commonUtils.noop,
    _optionChanged: function(args) {
        if (this._cancelOptionChange === args.name) {
            return
        }
        switch (args.name) {
            case "showSubmenuMode":
                break;
            case "selectedItem":
                var itemData = args.value,
                    node = this._dataAdapter.getNodeByItem(itemData),
                    selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
                if (node && node.internalFields.key !== selectedKey) {
                    if (false === node.selectable) {
                        break
                    }
                    if (selectedKey) {
                        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
                    }
                    this._toggleItemSelection(node, true);
                    this._updateSelectedItems()
                }
                break;
            case "cssClass":
            case "position":
            case "selectByClick":
            case "animation":
            case "useInkRipple":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _toggleItemSelection: function(node, value) {
        var itemElement = this._getElementByItem(node.internalFields.item);
        itemElement && $(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
        this._dataAdapter.toggleSelection(node.internalFields.key, value)
    },
    _getElementByItem: function(itemData) {
        var result, that = this;
        $.each(this._itemElements(), function(_, itemElement) {
            if ($(itemElement).data(that._itemDataKey()) !== itemData) {
                return true
            }
            result = itemElement;
            return false
        });
        return result
    },
    _updateSelectedItems: function(oldSelection, newSelection) {
        if (oldSelection || newSelection) {
            this._updateSelection(newSelection, oldSelection);
            this._fireSelectionChangeEvent(newSelection, oldSelection)
        }
    },
    _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
        this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })({
            addedItems: [addedSelection],
            removedItems: [removedSelection]
        })
    },
    selectItem: function(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
            node = this._dataAdapter.getNodeByItem(itemData),
            selectedKey = this._dataAdapter.getSelectedNodesKeys()[0],
            selectedItem = this.option("selectedItem");
        if (node.internalFields.key !== selectedKey) {
            if (selectedKey) {
                this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
            }
            this._toggleItemSelection(node, true);
            this._updateSelectedItems(selectedItem, itemData);
            this._setOptionSilent("selectedItem", itemData)
        }
    },
    unselectItem: function(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
            node = this._dataAdapter.getNodeByItem(itemData),
            selectedItem = this.option("selectedItem");
        if (node.internalFields.selected) {
            this._toggleItemSelection(node, false);
            this._updateSelectedItems(selectedItem, null);
            this._setOptionSilent("selectedItem", null)
        }
    }
});
module.exports = MenuBase;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/hierarchical_collection/ui.hierarchical_collection_widget.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    dataCoreUtils = __webpack_require__(14),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    iconUtils = __webpack_require__(77),
    HierarchicalDataAdapter = __webpack_require__(343),
    CollectionWidget = __webpack_require__(40),
    BindableTemplate = __webpack_require__(52),
    isFunction = commonUtils.isFunction,
    noop = commonUtils.noop;
var DISABLED_STATE_CLASS = "dx-state-disabled";
var HierarchicalCollectionWidget = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            keyExpr: "id",
            displayExpr: "text",
            selectedExpr: "selected",
            disabledExpr: "disabled",
            itemsExpr: "items",
            hoverStateEnabled: true,
            parentIdExpr: "parentId",
            expandedExpr: "expanded"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initAccessors();
        this._initDataAdapter();
        this._initDynamicTemplates()
    },
    _initDataSource: function() {
        this.callBase();
        this._dataSource && this._dataSource.paginate(false)
    },
    _initDataAdapter: function() {
        var accessors = this._createDataAdapterAccessors();
        this._dataAdapter = new HierarchicalDataAdapter(extend({
            dataAccessors: {
                getters: accessors.getters,
                setters: accessors.setters
            },
            items: this.option("items")
        }, this._getDataAdapterOptions()))
    },
    _getDataAdapterOptions: noop,
    _initDynamicTemplates: function() {
        this._defaultTemplates.item = new BindableTemplate(function($container, itemData) {
            $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopoutContainer(itemData))
        }.bind(this), ["text", "html", "items", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"), {
            text: this._displayGetter,
            items: this._itemsGetter
        })
    },
    _getIconContainer: function(itemData) {
        var icon = itemData.icon || itemData.iconSrc;
        return icon ? iconUtils.getImageContainer(icon) : void 0
    },
    _getTextContainer: function(itemData) {
        return $("<span>").text(itemData.text)
    },
    _getPopoutContainer: noop,
    _initAccessors: function() {
        var that = this;
        $.each(this._getAccessors(), function(_, accessor) {
            that._compileAccessor(accessor)
        })
    },
    _getAccessors: function() {
        return ["key", "display", "selected", "items", "disabled", "parentId", "expanded"]
    },
    _getChildNodes: function(node) {
        var that = this,
            arr = [];
        $.each(node.internalFields.childrenKeys, function(_, key) {
            var childNode = that._dataAdapter.getNodeByKey(key);
            arr.push(childNode)
        });
        return arr
    },
    _hasChildren: function(node) {
        return node && node.internalFields.childrenKeys.length
    },
    _compileAccessor: function(optionName) {
        var getter = "_" + optionName + "Getter",
            setter = "_" + optionName + "Setter",
            optionExpr = this.option(optionName + "Expr");
        if (!optionExpr) {
            this[getter] = noop;
            this[setter] = noop;
            return
        } else {
            if (isFunction(optionExpr)) {
                this[setter] = function(obj, value) {
                    obj[optionExpr()] = value
                };
                this[getter] = function(obj) {
                    return obj[optionExpr()]
                };
                return
            }
        }
        this[getter] = dataCoreUtils.compileGetter(optionExpr);
        this[setter] = dataCoreUtils.compileSetter(optionExpr)
    },
    _createDataAdapterAccessors: function() {
        var that = this,
            accessors = {
                getters: {},
                setters: {}
            };
        $.each(this._getAccessors(), function(_, accessor) {
            var getterName = "_" + accessor + "Getter",
                setterName = "_" + accessor + "Setter",
                newAccessor = "parentId" === accessor ? "parentKey" : accessor;
            accessors.getters[newAccessor] = that[getterName];
            accessors.setters[newAccessor] = that[setterName]
        });
        return accessors
    },
    _render: function() {
        this.callBase();
        this._focusTarget().addClass(this._widgetClass())
    },
    _widgetClass: noop,
    _renderItemFrame: function(index, itemData) {
        var $itemFrame = this.callBase.apply(this, arguments);
        $itemFrame.toggleClass(DISABLED_STATE_CLASS, !!this._disabledGetter(itemData));
        return $itemFrame
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "displayExpr":
            case "keyExpr":
                this._initAccessors();
                this._initDynamicTemplates();
                this.repaint();
                break;
            case "itemsExpr":
            case "selectedExpr":
            case "disabledExpr":
            case "expandedExpr":
            case "parentIdExpr":
                this._initAccessors();
                this._initDataAdapter();
                this.repaint();
                break;
            case "items":
                this._initDataAdapter();
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
module.exports = HierarchicalCollectionWidget;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_headers.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    columnsView = __webpack_require__(101),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8);
var CELL_CONTENT_CLASS = "text-content",
    HEADERS_CLASS = "headers",
    NOWRAP_CLASS = "nowrap",
    HEADER_ROW_CLASS = "dx-header-row",
    COLUMN_LINES_CLASS = "dx-column-lines",
    CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
    CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
    CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
    VISIBILITY_HIDDEN_CLASS = "dx-visibility-hidden",
    TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX = "dx-text-content-alignment-",
    SORT_INDICATOR_CLASS = "dx-sort-indicator",
    HEADER_FILTER_INDICATOR_CLASS = "dx-header-filter-indicator";
module.exports = {
    defaultOptions: function() {
        return {
            showColumnHeaders: true,
            cellHintEnabled: true
        }
    },
    views: {
        columnHeadersView: columnsView.ColumnsView.inherit(function() {
            var createCellContent = function(that, $cell, options) {
                var showColumnLines, $cellContent = $("<div />").addClass(that.addWidgetPrefix(CELL_CONTENT_CLASS));
                addCssClassesToCellContent(that, $cell, options.column, $cellContent);
                showColumnLines = that.option("showColumnLines");
                return $cellContent[showColumnLines || "right" === options.column.alignment ? "appendTo" : "prependTo"]($cell)
            };
            var addCssClassesToCellContent = function(that, $cell, column, $cellContent) {
                var $indicatorElements = that._getIndicatorElements($cell, true),
                    $visibleIndicatorElements = that._getIndicatorElements($cell),
                    indicatorCount = $indicatorElements && $indicatorElements.length,
                    columnAlignment = that._getColumnAlignment(column.alignment);
                $cellContent = $cellContent || $cell.children("." + that.addWidgetPrefix(CELL_CONTENT_CLASS));
                $cellContent.toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + columnAlignment, indicatorCount > 0).toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass(SORT_INDICATOR_CLASS, !!$visibleIndicatorElements.filter("." + that._getIndicatorClassName("sort")).length).toggleClass(HEADER_FILTER_INDICATOR_CLASS, !!$visibleIndicatorElements.filter("." + that._getIndicatorClassName("headerFilter")).length)
            };
            return {
                _createTable: function() {
                    var $table = this.callBase.apply(this, arguments);
                    $table.on("mousedown selectstart", this.createAction(function(e) {
                        var event = e.jQueryEvent;
                        if (event.shiftKey) {
                            event.preventDefault()
                        }
                    }));
                    return $table
                },
                _getDefaultTemplate: function(column) {
                    var template, that = this;
                    if (column.command) {
                        template = function($container, options) {
                            var column = options.column;
                            $container.html("&nbsp;");
                            $container.addClass(column.cssClass)
                        }
                    } else {
                        template = function($container, options) {
                            var $content = createCellContent(that, $container, options);
                            $content.text(column.caption)
                        }
                    }
                    return template
                },
                _getHeaderTemplate: function(column) {
                    return !column.command && column.headerCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: this._getDefaultTemplate(column)
                    }
                },
                _processTemplate: function(template, options) {
                    var resultTemplate, that = this,
                        column = options.column,
                        renderingTemplate = that.callBase(template);
                    if (renderingTemplate && column.headerCellTemplate) {
                        resultTemplate = {
                            render: function(options) {
                                var $content = createCellContent(that, options.container, options.model);
                                renderingTemplate.render(extend({}, options, {
                                    container: $content
                                }))
                            }
                        }
                    } else {
                        resultTemplate = renderingTemplate
                    }
                    return resultTemplate
                },
                _handleDataChanged: function() {
                    if (this._isGroupingChanged || this._requireReady) {
                        this._isGroupingChanged = false;
                        this.render()
                    }
                },
                _renderCell: function($row, options) {
                    var $cell = this.callBase($row, options);
                    if ("header" === options.row.rowType) {
                        $cell.addClass(CELL_FOCUS_DISABLED_CLASS);
                        if (!commonUtils.isDefined(options.column.command)) {
                            this.setAria("role", "columnheader", $cell);
                            this.setAria("label", options.column.caption + " " + messageLocalization.format("dxDataGrid-ariaColumn"), $cell)
                        }
                    }
                    return $cell
                },
                _createRow: function(row) {
                    var $row = this.callBase(row).toggleClass(COLUMN_LINES_CLASS, this.option("showColumnLines"));
                    if ("header" === row.rowType) {
                        $row.addClass(HEADER_ROW_CLASS)
                    }
                    return $row
                },
                _renderCore: function() {
                    var that = this,
                        $container = that.element();
                    if (that._tableElement && !that._dataController.isLoaded() && !that._hasRowElements) {
                        return
                    }
                    $container.addClass(that.addWidgetPrefix(HEADERS_CLASS)).toggleClass(that.addWidgetPrefix(NOWRAP_CLASS), !that.option("wordWrapEnabled")).empty();
                    that._updateContent(that._renderTable());
                    that.callBase.apply(that, arguments)
                },
                _renderRows: function() {
                    var that = this;
                    if (that._dataController.isLoaded() || that._hasRowElements) {
                        that.callBase.apply(that, arguments);
                        that._hasRowElements = true
                    }
                },
                _getRowVisibleColumns: function(rowIndex) {
                    return this._columnsController.getVisibleColumns(rowIndex)
                },
                _renderRow: function($table, options) {
                    options.columns = this._getRowVisibleColumns(options.row.rowIndex);
                    this.callBase($table, options)
                },
                _createCell: function(options) {
                    var column = options.column,
                        $cellElement = this.callBase.apply(this, arguments);
                    column.rowspan > 1 && $cellElement.attr("rowspan", column.rowspan);
                    return $cellElement
                },
                _getRows: function() {
                    var i, result = [],
                        rowCount = this.getRowCount();
                    if (this.option("showColumnHeaders")) {
                        for (i = 0; i < rowCount; i++) {
                            result.push({
                                rowType: "header",
                                rowIndex: i
                            })
                        }
                    }
                    return result
                },
                _getCellTemplate: function(options) {
                    if ("header" === options.rowType) {
                        return this._getHeaderTemplate(options.column)
                    }
                },
                _columnOptionChanged: function(e) {
                    var changeTypes = e.changeTypes,
                        optionNames = e.optionNames;
                    if (changeTypes.grouping) {
                        this._isGroupingChanged = true;
                        return
                    }
                    this.callBase(e);
                    if (optionNames.width || optionNames.visible) {
                        this.resizeCompleted.fire()
                    }
                },
                _isElementVisible: function(elementOptions) {
                    return elementOptions && elementOptions.visible
                },
                _alignCaptionByCenter: function($cell) {
                    var $indicatorsContainer = this._getIndicatorContainer($cell, true);
                    if ($indicatorsContainer && $indicatorsContainer.length) {
                        $indicatorsContainer.filter("." + VISIBILITY_HIDDEN_CLASS).remove();
                        $indicatorsContainer = this._getIndicatorContainer($cell);
                        $indicatorsContainer.clone().addClass(VISIBILITY_HIDDEN_CLASS).css("float", "").insertBefore($cell.children("." + this.addWidgetPrefix(CELL_CONTENT_CLASS)))
                    }
                },
                _updateCell: function($cell, options) {
                    if ("header" === options.rowType && "center" === options.column.alignment) {
                        this._alignCaptionByCenter($cell)
                    }
                    this.callBase.apply(this, arguments)
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    var $indicatorElement = this.callBase.apply(this, arguments);
                    if ("center" === column.alignment) {
                        this._alignCaptionByCenter($cell)
                    }
                    addCssClassesToCellContent(this, $cell, column);
                    return $indicatorElement
                },
                _getIndicatorContainer: function($cell, returnAll) {
                    var $indicatorsContainer = this.callBase($cell);
                    return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(." + VISIBILITY_HIDDEN_CLASS + ")")
                },
                _isSortableElement: function() {
                    return true
                },
                getHeadersRowHeight: function() {
                    var $tableElement = this._getTableElement(),
                        $headerRows = $tableElement && $tableElement.find("." + HEADER_ROW_CLASS);
                    if ($headerRows && $headerRows.length) {
                        return $headerRows.first().height() * $headerRows.length
                    }
                    return 0
                },
                getHeaderElement: function(index) {
                    var columnElements = this.getColumnElements();
                    return columnElements && columnElements.eq(index)
                },
                getColumnElements: function(index, bandColumnIndex) {
                    var rowIndex, result, $cellElement, visibleColumns, that = this,
                        columnsController = that._columnsController,
                        rowCount = that.getRowCount();
                    if (that.option("showColumnHeaders")) {
                        if (rowCount > 1 && (!commonUtils.isDefined(index) || commonUtils.isDefined(bandColumnIndex))) {
                            result = [];
                            visibleColumns = commonUtils.isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
                            $.each(visibleColumns, function(_, column) {
                                rowIndex = commonUtils.isDefined(index) ? index : columnsController.getRowIndex(column.index);
                                $cellElement = that.getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
                                $cellElement && result.push($cellElement.get(0))
                            });
                            return $(result)
                        } else {
                            if (!index || index < rowCount) {
                                return that.getCellElements(index || 0)
                            }
                        }
                    }
                },
                getColumnWidths: function() {
                    var $columnElements = this.getColumnElements();
                    if ($columnElements && $columnElements.length) {
                        return this._getWidths($columnElements)
                    }
                    return this.callBase.apply(this, arguments)
                },
                allowDragging: function(column, sourceLocation, draggingPanels) {
                    var i, draggingPanel, rowIndex = column && this._columnsController.getRowIndex(column.index),
                        columns = this.getColumns(0 === rowIndex ? 0 : null),
                        draggableColumnCount = 0,
                        allowDrag = function(column) {
                            return column.allowReordering || column.allowGrouping || column.allowHiding
                        };
                    for (i = 0; i < columns.length; i++) {
                        if (allowDrag(columns[i])) {
                            draggableColumnCount++
                        }
                    }
                    if (draggableColumnCount <= 1) {
                        return false
                    } else {
                        if (!draggingPanels) {
                            return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering
                        }
                    }
                    for (i = 0; i < draggingPanels.length; i++) {
                        draggingPanel = draggingPanels[i];
                        if (draggingPanel && draggingPanel.allowDragging(column, sourceLocation)) {
                            return true
                        }
                    }
                    return false
                },
                getBoundingRect: function() {
                    var offset, that = this,
                        $columnElements = that.getColumnElements();
                    if ($columnElements && $columnElements.length) {
                        offset = that._getTableElement().offset();
                        return {
                            top: offset.top
                        }
                    }
                    return null
                },
                getName: function() {
                    return "headers"
                },
                getColumnCount: function() {
                    var $columnElements = this.getColumnElements();
                    return $columnElements ? $columnElements.length : 0
                },
                isVisible: function() {
                    return this.option("showColumnHeaders")
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case "showColumnHeaders":
                        case "wordWrapEnabled":
                        case "showColumnLines":
                            that._invalidate(true, true);
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                },
                getHeight: function() {
                    return this.getElementHeight()
                },
                getContextMenuItems: function(options) {
                    var onItemClick, sortingOptions, that = this,
                        column = options.column;
                    if (options.row && "header" === options.row.rowType) {
                        sortingOptions = that.option("sorting");
                        if (sortingOptions && "none" !== sortingOptions.mode && column && column.allowSorting) {
                            onItemClick = function(params) {
                                setTimeout(function() {
                                    that._columnsController.changeSortOrder(column.index, params.itemData.value)
                                })
                            };
                            return [{
                                text: sortingOptions.ascendingText,
                                value: "asc",
                                disabled: "asc" === column.sortOrder,
                                icon: CONTEXT_MENU_SORT_ASC_ICON,
                                onItemClick: onItemClick
                            }, {
                                text: sortingOptions.descendingText,
                                value: "desc",
                                disabled: "desc" === column.sortOrder,
                                icon: CONTEXT_MENU_SORT_DESC_ICON,
                                onItemClick: onItemClick
                            }, {
                                text: sortingOptions.clearText,
                                value: "none",
                                disabled: !column.sortOrder,
                                icon: CONTEXT_MENU_SORT_NONE_ICON,
                                onItemClick: onItemClick
                            }]
                        }
                    }
                },
                getRowCount: function() {
                    return this._columnsController && this._columnsController.getRowCount()
                },
                setRowsOpacity: function(columnIndex, value, rowIndex) {
                    var i, columnElements, that = this,
                        rowCount = that.getRowCount(),
                        columns = that._columnsController.getColumns(),
                        column = columns && columns[columnIndex],
                        columnID = column && column.isBand && column.index,
                        setColumnOpacity = function(index, column) {
                            if (column.ownerBand === columnID) {
                                columnElements.eq(index).css({
                                    opacity: value
                                });
                                if (column.isBand) {
                                    that.setRowsOpacity(column.index, value, i + 1)
                                }
                            }
                        };
                    if (commonUtils.isDefined(columnID)) {
                        rowIndex = rowIndex || 0;
                        for (i = rowIndex; i < rowCount; i++) {
                            columnElements = that.getCellElements(i);
                            $.each(that.getColumns(i), setColumnOpacity)
                        }
                    }
                }
            }
        }())
    }
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    isWrapped = __webpack_require__(41).isWrapped,
    dataCoreUtils = __webpack_require__(14),
    commonUtils = __webpack_require__(2),
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    config = __webpack_require__(31),
    isDefined = commonUtils.isDefined,
    objectUtils = __webpack_require__(84),
    errors = __webpack_require__(16),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    normalizeSortingInfo = gridCoreUtils.normalizeSortingInfo,
    equalSortParameters = gridCoreUtils.equalSortParameters,
    normalizeIndexes = __webpack_require__(7).normalizeIndexes,
    inflector = __webpack_require__(36),
    dateSerialization = __webpack_require__(71),
    numberLocalization = __webpack_require__(44),
    dateLocalization = __webpack_require__(32),
    messageLocalization = __webpack_require__(8),
    when = __webpack_require__(10).when,
    DataSourceModule = __webpack_require__(51),
    normalizeDataSourceOptions = DataSourceModule.normalizeDataSourceOptions;
var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"],
    USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1),
    COMMAND_EXPAND_CLASS = "dx-command-expand";
module.exports = {
    defaultOptions: function() {
        return {
            commonColumnSettings: {
                allowFiltering: true,
                allowHiding: true,
                allowSorting: true,
                allowEditing: true,
                encodeHtml: true,
                trueText: messageLocalization.format("dxDataGrid-trueText"),
                falseText: messageLocalization.format("dxDataGrid-falseText")
            },
            allowColumnReordering: false,
            allowColumnResizing: false,
            columnResizingMode: "nextColumn",
            columnMinWidth: void 0,
            adaptColumnWidthByRatio: true,
            columns: void 0,
            regenerateColumnsByVisibleItems: false,
            customizeColumns: null,
            dateSerializationFormat: void 0
        }
    },
    controllers: {
        columns: modules.Controller.inherit(function() {
            var DEFAULT_COLUMN_OPTIONS = {
                    visible: true,
                    showInColumnChooser: true
                },
                DATATYPE_OPERATIONS = {
                    number: ["=", "<>", "<", ">", "<=", ">=", "between"],
                    string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
                    date: ["=", "<>", "<", ">", "<=", ">=", "between"]
                },
                COLUMN_INDEX_OPTIONS = {
                    visibleIndex: true,
                    groupIndex: true,
                    grouped: true,
                    sortIndex: true,
                    sortOrder: true
                },
                GROUP_LOCATION = "group",
                COLUMN_CHOOSER_LOCATION = "columnChooser";
            var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
                var calculatedColumnOptions, commonColumnOptions = {};
                if (columnOptions) {
                    if (commonUtils.isString(columnOptions)) {
                        columnOptions = {
                            dataField: columnOptions
                        }
                    }
                    if (columnOptions.command) {
                        return extend(true, {}, columnOptions)
                    } else {
                        commonColumnOptions = that.getCommonSettings();
                        if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
                            columnOptions = extend({}, columnOptions, {
                                dataField: userStateColumnOptions.dataField
                            })
                        }
                        calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
                        return extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions, {
                            selector: null
                        })
                    }
                }
            };
            var createColumnsFromOptions = function(that, columnsOptions, bandColumn) {
                var result = [];
                if (columnsOptions) {
                    $.each(columnsOptions, function(index, columnOptions) {
                        var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],
                            column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
                        if (column) {
                            if (bandColumn) {
                                column.ownerBand = bandColumn
                            }
                            result.push(column);
                            if (column.isBand) {
                                result = result.concat(createColumnsFromOptions(that, column.columns, column));
                                delete column.columns
                            }
                        }
                    })
                }
                return result
            };
            var getParentBandColumns = function(columnIndex, columnParentByIndex) {
                var result = [],
                    parent = columnParentByIndex[columnIndex];
                while (parent) {
                    result.unshift(parent);
                    columnIndex = parent.index;
                    parent = columnParentByIndex[columnIndex]
                }
                return result
            };
            var getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
                var column, result = [],
                    children = columnChildrenByIndex[columnIndex];
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        column = children[i];
                        if (!isDefined(column.groupIndex) || column.showWhenGrouped) {
                            result.push(column);
                            if (recursive && column.isBand) {
                                result = result.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive))
                            }
                        }
                    }
                }
                return result
            };
            var getColumnByIndexes = function(that, columnIndexes) {
                var result, columns = that._columns,
                    callbackFilter = function(column) {
                        return column.ownerBand === result.index
                    };
                for (var i = 0; i < columnIndexes.length; i++) {
                    result = columns[columnIndexes[i]];
                    if (result) {
                        columns = that._columns.filter(callbackFilter)
                    }
                }
                return result
            };
            var calculateColspan = function(that, columnID) {
                var colspan = 0,
                    columns = that.getChildrenByBandColumn(columnID, true);
                $.each(columns, function(_, column) {
                    if (column.isBand) {
                        column.colspan = column.colspan || calculateColspan(that, column.index);
                        colspan += column.colspan
                    } else {
                        colspan += 1
                    }
                });
                return colspan
            };
            var processBandColumns = function(that, columns, bandColumnsCache) {
                var i, column, rowspan, rowCount = that.getRowCount();
                for (i = 0; i < columns.length; i++) {
                    column = columns[i];
                    if (column.visible || column.command) {
                        if (column.isBand) {
                            column.colspan = column.colspan || calculateColspan(that, column.index)
                        }
                        if (!column.isBand || !column.colspan) {
                            rowspan = rowCount - (!column.command && !isDefined(column.groupIndex) ? getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length : 0);
                            if (rowspan > 1) {
                                column.rowspan = rowspan
                            }
                        }
                    }
                }
            };
            var getValueDataType = function(value) {
                var dataType = commonUtils.type(value);
                if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
                    dataType = void 0
                }
                return dataType
            };
            var getSerializationFormat = function(dataType, value) {
                switch (dataType) {
                    case "date":
                        return dateSerialization.getDateSerializationFormat(value);
                    case "number":
                        if (commonUtils.isString(value)) {
                            return "string"
                        }
                        if (commonUtils.isNumeric(value)) {
                            return null
                        }
                }
            };
            var updateSerializers = function(options, dataType) {
                if (!options.deserializeValue) {
                    if ("date" === dataType) {
                        options.deserializeValue = function(value) {
                            return dateSerialization.deserializeDate(value)
                        };
                        options.serializeValue = function(value) {
                            return dateSerialization.serializeDate(value, this.serializationFormat)
                        }
                    }
                    if ("number" === dataType) {
                        options.deserializeValue = function(value) {
                            var parsedValue = parseFloat(value);
                            return isNaN(parsedValue) ? value : parsedValue
                        };
                        options.serializeValue = function(value) {
                            return isDefined(value) && "string" === this.serializationFormat ? value.toString() : value
                        }
                    }
                }
            };
            var getAlignmentByDataType = function(dataType, isRTL) {
                switch (dataType) {
                    case "number":
                        return "right";
                    case "boolean":
                        return "center";
                    default:
                        return getDefaultAlignment(isRTL)
                }
            };
            var getCustomizeTextByDataType = function(dataType) {
                if ("boolean" === dataType) {
                    return function(e) {
                        if (true === e.value) {
                            return this.trueText || "true"
                        } else {
                            if (false === e.value) {
                                return this.falseText || "false"
                            } else {
                                return e.valueText || ""
                            }
                        }
                    }
                }
            };
            var createColumnsFromDataSource = function(that, dataSource) {
                var fieldName, i, firstItems = that._getFirstItems(dataSource),
                    processedFields = {},
                    result = [];
                for (i = 0; i < firstItems.length; i++) {
                    if (firstItems[i]) {
                        for (fieldName in firstItems[i]) {
                            if (!commonUtils.isFunction(firstItems[i][fieldName]) || isWrapped(firstItems[i][fieldName])) {
                                processedFields[fieldName] = true
                            }
                        }
                    }
                }
                for (fieldName in processedFields) {
                    if (0 !== fieldName.indexOf("__")) {
                        var column = createColumn(that, fieldName);
                        result.push(column)
                    }
                }
                return result
            };
            var updateColumnIndexes = function(that) {
                $.each(that._columns, function(index, column) {
                    column.index = index
                });
                $.each(that._columns, function(index, column) {
                    if (commonUtils.isObject(column.ownerBand)) {
                        column.ownerBand = column.ownerBand.index
                    }
                });
                $.each(that._commandColumns, function(index, column) {
                    column.index = -(index + 1)
                })
            };
            var updateColumnGroupIndexes = function(that, currentColumn) {
                normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
                    var grouped = column.grouped;
                    delete column.grouped;
                    return grouped
                })
            };
            var updateColumnSortIndexes = function(that, currentColumn) {
                $.each(that._columns, function(index, column) {
                    if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
                        delete column.sortIndex
                    }
                });
                normalizeIndexes(that._columns, "sortIndex", currentColumn, function(column) {
                    return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)
                })
            };
            var updateColumnVisibleIndexes = function(that, currentColumn) {
                var i, key, column, bandColumnIndex, parentBandColumns, bandColumns = {},
                    columns = [],
                    bandColumnsCache = that.getBandColumnsCache();
                for (i = 0; i < that._columns.length; i++) {
                    column = that._columns[i];
                    parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
                    if (parentBandColumns.length) {
                        bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;
                        bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];
                        bandColumns[bandColumnIndex].push(column)
                    } else {
                        columns.push(column)
                    }
                }
                for (key in bandColumns) {
                    normalizeIndexes(bandColumns[key], "visibleIndex", currentColumn)
                }
                normalizeIndexes(columns, "visibleIndex", currentColumn)
            };
            var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                var column, rowIndex = commonUtils.isObject(visibleIndex) ? visibleIndex.rowIndex : null,
                    columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);
                visibleIndex = commonUtils.isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
                column = columns[visibleIndex];
                return column && isDefined(column.index) ? column.index : -1
            };
            var moveColumnToGroup = function(that, column, groupIndex) {
                var i, groupColumns = that.getGroupColumns();
                if (groupIndex >= 0) {
                    for (i = 0; i < groupColumns.length; i++) {
                        if (groupColumns[i].groupIndex >= groupIndex) {
                            groupColumns[i].groupIndex++
                        }
                    }
                } else {
                    groupIndex = 0;
                    for (i = 0; i < groupColumns.length; i++) {
                        groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                    }
                }
                column.groupIndex = groupIndex
            };
            var checkUserStateColumn = function(column, userStateColumn) {
                return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name)
            };
            var applyUserState = function(that) {
                var column, columnUserState, userStateColumnIndex, i, columnsUserState = that._columnsUserState,
                    ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],
                    columns = that._columns,
                    columnCountById = {},
                    resultColumns = [],
                    allColumnsHaveState = true,
                    userStateColumnIndexes = [];

                function applyFieldsState(column, userStateColumn) {
                    var fieldName;
                    if (!userStateColumn) {
                        return
                    }
                    for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
                        fieldName = USER_STATE_FIELD_NAMES[index];
                        if (inArray(fieldName, ignoreColumnOptionNames) >= 0) {
                            continue
                        }
                        if ("dataType" === fieldName) {
                            column[fieldName] = column[fieldName] || userStateColumn[fieldName]
                        } else {
                            if (inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                                if (fieldName in userStateColumn) {
                                    column[fieldName] = userStateColumn[fieldName]
                                }
                            } else {
                                column[fieldName] = userStateColumn[fieldName]
                            }
                        }
                    }
                }

                function findUserStateColumn(columnsUserState, column) {
                    var id = column.name || column.dataField,
                        count = columnCountById[id] || 0;
                    for (var j = 0; j < columnsUserState.length; j++) {
                        if (checkUserStateColumn(column, columnsUserState[j])) {
                            if (count) {
                                count--
                            } else {
                                columnCountById[id] = columnCountById[id] || 0;
                                columnCountById[id]++;
                                return j
                            }
                        }
                    }
                    return -1
                }
                if (columnsUserState) {
                    for (i = 0; i < columns.length; i++) {
                        userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);
                        allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
                        userStateColumnIndexes.push(userStateColumnIndex)
                    }
                    for (i = 0; i < columns.length; i++) {
                        column = columns[i];
                        userStateColumnIndex = userStateColumnIndexes[i];
                        if (that._hasUserState || allColumnsHaveState) {
                            applyFieldsState(column, columnsUserState[userStateColumnIndex])
                        }
                        if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
                            resultColumns[userStateColumnIndex] = column
                        } else {
                            resultColumns.push(column)
                        }
                    }
                    for (i = 0; i < columnsUserState.length; i++) {
                        columnUserState = columnsUserState[i];
                        if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {
                            column = createColumn(that, columnUserState.added);
                            applyFieldsState(column, columnUserState);
                            resultColumns.push(column)
                        }
                    }
                    assignColumns(that, resultColumns)
                }
            };
            var updateIndexes = function(that, column) {
                updateColumnIndexes(that);
                updateColumnGroupIndexes(that, column);
                updateColumnSortIndexes(that, column);
                updateColumnVisibleIndexes(that, column)
            };
            var resetColumnsCache = function(that) {
                that._visibleColumns = void 0;
                that._fixedColumns = void 0;
                that._rowCount = void 0;
                that._bandColumnsCache = void 0
            };
            var assignColumns = function(that, columns) {
                that._columns = columns;
                resetColumnsCache(that);
                that.updateColumnDataTypes()
            };
            var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                var columnChanges = that._columnChanges || {
                    optionNames: {
                        length: 0
                    },
                    changeTypes: {
                        length: 0
                    },
                    columnIndex: columnIndex
                };
                optionName = optionName || "all";
                optionName = optionName.split(".")[0];
                var changeTypes = columnChanges.changeTypes;
                if (changeType && !changeTypes[changeType]) {
                    changeTypes[changeType] = true;
                    changeTypes.length++
                }
                var optionNames = columnChanges.optionNames;
                if (optionName && !optionNames[optionName]) {
                    optionNames[optionName] = true;
                    optionNames.length++
                }
                if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
                    delete columnChanges.columnIndex
                }
                that._columnChanges = columnChanges;
                resetColumnsCache(that)
            };
            var fireColumnsChanged = function(that) {
                var onColumnsChanging = that.option("onColumnsChanging"),
                    columnChanges = that._columnChanges;
                if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                    if (onColumnsChanging) {
                        that._updateLockCount++;
                        onColumnsChanging(extend({
                            component: that.component
                        }, columnChanges));
                        that._updateLockCount--
                    }
                    that._columnChanges = void 0;
                    if (columnChanges.optionNames && (columnChanges.optionNames.dataField || columnChanges.optionNames.lookup)) {
                        that.reinit()
                    } else {
                        that.columnsChanged.fire(columnChanges)
                    }
                }
            };
            var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                var prevValue, optionSetter, columns, changeType, optionGetter = dataCoreUtils.compileGetter(optionName),
                    columnIndex = column.index;
                if (3 === arguments.length) {
                    return optionGetter(column, {
                        functionsAsIs: true
                    })
                }
                prevValue = optionGetter(column, {
                    functionsAsIs: true
                });
                if (prevValue !== value) {
                    if ("groupIndex" === optionName) {
                        changeType = "grouping"
                    } else {
                        if ("sortIndex" === optionName || "sortOrder" === optionName) {
                            changeType = "sorting"
                        } else {
                            changeType = "columns"
                        }
                    }
                    optionSetter = dataCoreUtils.compileSetter(optionName);
                    optionSetter(column, value, {
                        functionsAsIs: true
                    });
                    if (!isDefined(prevValue) && !isDefined(value) && 0 !== optionName.indexOf("buffer")) {
                        notFireEvent = true
                    }
                    if (!notFireEvent) {
                        if (inArray(optionName, USER_STATE_FIELD_NAMES) < 0 && "visibleWidth" !== optionName) {
                            columns = that.option("columns");
                            column = columns && columns[columnIndex];
                            if (commonUtils.isString(column)) {
                                column = columns[columnIndex] = {
                                    dataField: column
                                }
                            }
                            if (column) {
                                optionSetter(column, value, {
                                    functionsAsIs: true
                                })
                            }
                        }
                        updateColumnChanges(that, changeType, optionName, columnIndex)
                    } else {
                        resetColumnsCache(that)
                    }
                }
            };
            var isSortOrderValid = function(sortOrder) {
                return "asc" === sortOrder || "desc" === sortOrder
            };
            var addExpandColumn = function(that) {
                that.addCommandColumn({
                    command: "expand",
                    width: "auto",
                    cssClass: COMMAND_EXPAND_CLASS,
                    allowEditing: false,
                    allowGrouping: false,
                    allowSorting: false,
                    allowResizing: false,
                    allowReordering: false,
                    allowHiding: false
                })
            };
            var defaultSetCellValue = function(data, value) {
                var name, i, path = this.dataField.split("."),
                    dotCount = path.length - 1;
                if (this.serializeValue) {
                    value = this.serializeValue(value)
                }
                for (i = 0; i < dotCount; i++) {
                    name = path[i];
                    data = data[name] = data[name] || {}
                }
                data[path[dotCount]] = value
            };
            var getDataColumns = function(columns, rowIndex, bandColumnID) {
                var result = [];
                rowIndex = rowIndex || 0;
                columns[rowIndex] && $.each(columns[rowIndex], function(_, column) {
                    if (column.ownerBand === bandColumnID || isDefined(column.groupIndex)) {
                        if (!column.isBand || !column.colspan) {
                            if (!column.command || rowIndex < 1) {
                                result.push(column)
                            }
                        } else {
                            result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index))
                        }
                    }
                });
                return result
            };
            var getRowCount = function(that, level, bandColumnIndex) {
                var rowCount = 1,
                    bandColumnsCache = that.getBandColumnsCache(),
                    columnParentByIndex = bandColumnsCache.columnParentByIndex;
                that._columns.forEach(function(column) {
                    var parents = getParentBandColumns(column.index, columnParentByIndex),
                        invisibleParents = parents.filter(function(column) {
                            return !column.visible
                        });
                    if (column.visible && !invisibleParents.length) {
                        rowCount = Math.max(rowCount, parents.length + 1)
                    }
                });
                return rowCount
            };
            var getFixedPosition = function(column) {
                return !column.fixedPosition ? "left" : column.fixedPosition
            };
            var processExpandColumns = function(columns, expandColumns, columnIndex) {
                var rowspan = columns[columnIndex] && columns[columnIndex].rowspan,
                    expandColumnsByRow = expandColumns.slice(0);
                if (rowspan > 1) {
                    expandColumnsByRow = $.map(expandColumnsByRow, function(expandColumn) {
                        return extend({}, expandColumn, {
                            rowspan: rowspan
                        })
                    })
                }
                expandColumnsByRow.unshift(columnIndex, 0);
                columns.splice.apply(columns, expandColumnsByRow);
                return rowspan || 1
            };
            var digitsCount = function(number) {
                var i;
                for (i = 0; number > 1; i++) {
                    number /= 10
                }
                return i
            };
            var numberToString = function(number, digitsCount) {
                var str = number ? number.toString() : "0";
                while (str.length < digitsCount) {
                    str = "0" + str
                }
                return str
            };
            return {
                _getFirstItems: function(dataSource) {
                    var groupsCount, items = [];
                    var getFirstItemsCore = function(items, groupsCount) {
                        var i, childItems;
                        if (!items || !groupsCount) {
                            return items
                        }
                        for (i = 0; i < items.length; i++) {
                            childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
                            if (childItems && childItems.length) {
                                return childItems
                            }
                        }
                    };
                    if (dataSource && dataSource.items().length > 0) {
                        groupsCount = normalizeSortingInfo(dataSource.group()).length;
                        items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                    }
                    return items
                },
                _endUpdateCore: function() {
                    fireColumnsChanged(this)
                },
                init: function() {
                    var that = this,
                        columns = that.option("columns");
                    that._commandColumns = that._commandColumns || [];
                    that._columns = that._columns || [];
                    addExpandColumn(that);
                    that._isColumnsFromOptions = !!columns;
                    if (that._isColumnsFromOptions) {
                        assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                        applyUserState(that)
                    } else {
                        assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns)
                    }
                    if (that._dataSourceApplied) {
                        that.applyDataSource(that._dataSource, true)
                    } else {
                        updateIndexes(that)
                    }
                },
                callbackNames: function() {
                    return ["columnsChanged"]
                },
                optionChanged: function(args) {
                    switch (args.name) {
                        case "adaptColumnWidthByRatio":
                            args.handled = true;
                            break;
                        case "columns":
                            args.handled = true;
                            if (args.name === args.fullName) {
                                this._columnsUserState = null;
                                this._ignoreColumnOptionNames = null;
                                this.init()
                            } else {
                                this._columnOptionChanged(args)
                            }
                            break;
                        case "commonColumnSettings":
                        case "columnAutoWidth":
                        case "allowColumnResizing":
                        case "allowColumnReordering":
                        case "columnFixing":
                        case "grouping":
                        case "groupPanel":
                        case "regenerateColumnsByVisibleItems":
                        case "customizeColumns":
                        case "editing":
                        case "columnHidingEnabled":
                        case "dateSerializationFormat":
                        case "columnResizingMode":
                        case "columnMinWidth":
                            args.handled = true;
                            this.reinit();
                            break;
                        case "rtlEnabled":
                            this.reinit();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _columnOptionChanged: function(args) {
                    var column, columnIndexes = [],
                        columnOptionValue = {},
                        columnOptionName = args.fullName.replace(/columns\[(\d+)\]\.?/gi, function(_, columnIndex) {
                            columnIndexes.push(parseInt(columnIndex));
                            return ""
                        });
                    if (columnIndexes.length) {
                        column = getColumnByIndexes(this, columnIndexes);
                        if (columnOptionName) {
                            columnOptionValue[columnOptionName] = args.value
                        } else {
                            columnOptionValue = args.value
                        }
                    }
                    if (column) {
                        this.columnOption(column.index, columnOptionValue)
                    }
                },
                publicMethods: function() {
                    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns"]
                },
                applyDataSource: function(dataSource, forceApplying) {
                    var that = this,
                        isDataSourceLoaded = dataSource && dataSource.isLoaded();
                    that._dataSource = dataSource;
                    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
                        if (isDataSourceLoaded) {
                            if (!that._isColumnsFromOptions) {
                                var columnsFromDataSource = createColumnsFromDataSource(that, dataSource);
                                if (columnsFromDataSource.length) {
                                    assignColumns(that, columnsFromDataSource);
                                    that._dataSourceColumnsCount = that._columns.length;
                                    applyUserState(that)
                                }
                            }
                            return that.updateColumns(dataSource, forceApplying)
                        } else {
                            that._dataSourceApplied = false
                        }
                    } else {
                        if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {
                            updateColumnChanges(that, "columns");
                            fireColumnsChanged(that);
                            return $.Deferred().reject().promise()
                        }
                    }
                },
                reset: function() {
                    this._dataSourceApplied = false;
                    this._dataSourceColumnsCount = void 0;
                    this.reinit()
                },
                reinit: function() {
                    this._columnsUserState = this.getUserState();
                    this._ignoreColumnOptionNames = null;
                    this.init()
                },
                isInitialized: function() {
                    return !!this._columns.length || !!this.option("columns")
                },
                isDataSourceApplied: function() {
                    return this._dataSourceApplied
                },
                getCommonSettings: function() {
                    var commonColumnSettings = this.option("commonColumnSettings") || {},
                        groupingOptions = this.option("grouping") || {},
                        groupPanelOptions = this.option("groupPanel") || {};
                    return extend({
                        allowFixing: this.option("columnFixing.enabled"),
                        allowResizing: this.option("allowColumnResizing"),
                        allowReordering: this.option("allowColumnReordering"),
                        minWidth: this.option("columnMinWidth"),
                        autoExpandGroup: groupingOptions.autoExpandAll,
                        allowCollapsing: groupingOptions.allowCollapsing,
                        allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
                    }, commonColumnSettings)
                },
                isColumnOptionUsed: function(optionName) {
                    for (var i = 0; i < this._columns.length; i++) {
                        if (this._columns[i][optionName]) {
                            return true
                        }
                    }
                },
                isAllDataTypesDefined: function(checkSerializers) {
                    var i, columns = this._columns;
                    if (!columns.length) {
                        return false
                    }
                    for (i = 0; i < columns.length; i++) {
                        if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {
                            return false
                        }
                    }
                    return true
                },
                getColumns: function() {
                    return this._columns
                },
                getGroupColumns: function() {
                    var result = [];
                    $.each(this._columns, function() {
                        var column = this;
                        if (isDefined(column.groupIndex)) {
                            result[column.groupIndex] = column
                        }
                    });
                    return result
                },
                getVisibleColumns: function(rowIndex) {
                    this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
                    rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
                    return this._visibleColumns[rowIndex] || []
                },
                getFixedColumns: function(rowIndex) {
                    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
                    rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
                    return this._fixedColumns[rowIndex] || []
                },
                _getFixedColumnsCore: function() {
                    var i, j, column, prevColumn, notFixedColumnCount, transparentColumnIndex, lastFixedPosition, visibleColumns, that = this,
                        result = [],
                        rowCount = that.getRowCount(),
                        isColumnFixing = that._isColumnFixing(),
                        transparentColumn = {
                            command: "transparent"
                        },
                        transparentColspan = 0;
                    if (isColumnFixing) {
                        for (i = 0; i <= rowCount; i++) {
                            notFixedColumnCount = 0;
                            lastFixedPosition = null;
                            transparentColumnIndex = null;
                            visibleColumns = that.getVisibleColumns(i);
                            for (j = 0; j < visibleColumns.length; j++) {
                                prevColumn = visibleColumns[j - 1];
                                column = visibleColumns[j];
                                if (!column.command) {
                                    if (!column.fixed) {
                                        if (0 === i) {
                                            if (column.isBand && column.colspan) {
                                                transparentColspan += column.colspan
                                            } else {
                                                transparentColspan++
                                            }
                                        }
                                        notFixedColumnCount++;
                                        if (!isDefined(transparentColumnIndex)) {
                                            transparentColumnIndex = j
                                        }
                                    } else {
                                        if (prevColumn && prevColumn.fixed && getFixedPosition(prevColumn) !== getFixedPosition(column)) {
                                            if (!isDefined(transparentColumnIndex)) {
                                                transparentColumnIndex = j
                                            }
                                        } else {
                                            lastFixedPosition = column.fixedPosition
                                        }
                                    }
                                }
                            }
                            if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
                                return []
                            }
                            if (!isDefined(transparentColumnIndex)) {
                                transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length
                            }
                            result[i] = visibleColumns.slice(0);
                            if (!transparentColumn.colspan) {
                                transparentColumn.colspan = transparentColspan
                            }
                            result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn)
                        }
                    }
                    return result
                },
                _isColumnFixing: function() {
                    var isColumnFixing = this.option("columnFixing.enabled");
                    !isColumnFixing && $.each(this._columns, function(_, column) {
                        if (column.fixed) {
                            isColumnFixing = true;
                            return false
                        }
                    });
                    return isColumnFixing
                },
                _getExpandColumnsCore: function() {
                    return this.getGroupColumns()
                },
                getExpandColumns: function() {
                    var expandColumn, expandColumns = this._getExpandColumnsCore();
                    if (expandColumns.length) {
                        expandColumn = this.columnOption("command:expand")
                    }
                    expandColumns = $.map(expandColumns, function(column) {
                        return extend({}, column, {
                            visibleWidth: null,
                            minWidth: null
                        }, expandColumn, {
                            index: column.index
                        })
                    });
                    return expandColumns
                },
                getBandColumnsCache: function() {
                    if (!this._bandColumnsCache) {
                        var columns = this._columns,
                            columnChildrenByIndex = {},
                            columnParentByIndex = {};
                        columns.forEach(function(column) {
                            var parentIndex = column.ownerBand,
                                parent = columns[parentIndex];
                            if (column.colspan) {
                                column.colspan = void 0
                            }
                            if (column.rowspan) {
                                column.rowspan = void 0
                            }
                            if (parent) {
                                columnParentByIndex[column.index] = parent
                            } else {
                                parentIndex = -1
                            }
                            columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
                            columnChildrenByIndex[parentIndex].push(column)
                        });
                        this._bandColumnsCache = {
                            columnChildrenByIndex: columnChildrenByIndex,
                            columnParentByIndex: columnParentByIndex
                        }
                    }
                    return this._bandColumnsCache
                },
                _isColumnVisible: function(column) {
                    return column.visible && this.isParentColumnVisible(column.index)
                },
                _getVisibleColumnsCore: function() {
                    var i, firstPositiveIndexColumn, isFixedToEnd, that = this,
                        result = [],
                        rowspanExpandColumns = 0,
                        expandColumns = that.getExpandColumns(),
                        rowCount = that.getRowCount(),
                        positiveIndexedColumns = [],
                        negativeIndexedColumns = [],
                        notGroupedColumnsCount = 0,
                        rtlEnabled = that.option("rtlEnabled"),
                        columns = extend(true, [], that._columns.length ? that._commandColumns.concat(that._columns) : []),
                        bandColumnsCache = that.getBandColumnsCache(),
                        columnDigitsCount = digitsCount(columns.length);
                    processBandColumns(that, columns, bandColumnsCache);
                    for (i = 0; i < rowCount; i++) {
                        result[i] = [];
                        negativeIndexedColumns[i] = [{}];
                        positiveIndexedColumns[i] = [{}, {}, {}]
                    }
                    $.each(columns, function() {
                        var rowIndex, indexedColumns, column = this,
                            visibleIndex = column.visibleIndex,
                            parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex),
                            visible = that._isColumnVisible(column);
                        if (visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                            rowIndex = parentBandColumns.length;
                            if (visibleIndex < 0) {
                                visibleIndex = -visibleIndex;
                                indexedColumns = negativeIndexedColumns[rowIndex]
                            } else {
                                column.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : column.fixed;
                                column.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : column.fixedPosition;
                                if (column.fixed || column.command) {
                                    isFixedToEnd = "right" === column.fixedPosition;
                                    if (rtlEnabled) {
                                        isFixedToEnd = !isFixedToEnd
                                    }
                                    if (isFixedToEnd || column.command) {
                                        indexedColumns = positiveIndexedColumns[rowIndex][2]
                                    } else {
                                        indexedColumns = positiveIndexedColumns[rowIndex][0]
                                    }
                                } else {
                                    indexedColumns = positiveIndexedColumns[rowIndex][1]
                                }
                            }
                            if (parentBandColumns.length) {
                                visibleIndex = numberToString(visibleIndex, columnDigitsCount);
                                for (i = parentBandColumns.length - 1; i >= 0; i--) {
                                    visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex
                                }
                            }
                            indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                            indexedColumns[visibleIndex].push(column);
                            notGroupedColumnsCount++
                        }
                    });
                    $.each(result, function(rowIndex) {
                        objectUtils.orderEach(negativeIndexedColumns[rowIndex], function(_, columns) {
                            result[rowIndex].unshift.apply(result[rowIndex], columns)
                        });
                        firstPositiveIndexColumn = result[rowIndex].length;
                        $.each(positiveIndexedColumns[rowIndex], function(index, columnsByFixing) {
                            objectUtils.orderEach(columnsByFixing, function(_, columnsByVisibleIndex) {
                                result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex)
                            })
                        });
                        if (rowspanExpandColumns < rowIndex + 1) {
                            rowspanExpandColumns += processExpandColumns(result[rowIndex], expandColumns, firstPositiveIndexColumn)
                        }
                    });
                    result.push(getDataColumns(result));
                    if (!notGroupedColumnsCount && that._columns.length) {
                        result[rowCount].push({
                            command: "empty"
                        })
                    }
                    return result
                },
                getInvisibleColumns: function(columns, bandColumnIndex) {
                    var hiddenColumnsByBand, that = this,
                        result = [];
                    columns = columns || that._columns;
                    $.each(columns, function(_, column) {
                        if (column.ownerBand !== bandColumnIndex) {
                            return
                        }
                        if (column.isBand) {
                            if (!column.visible) {
                                hiddenColumnsByBand = that.getChildrenByBandColumn(column.index)
                            } else {
                                hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index)
                            }
                            if (hiddenColumnsByBand.length) {
                                result.push(column);
                                result = result.concat(hiddenColumnsByBand)
                            }
                            return
                        }
                        if (!column.visible) {
                            result.push(column)
                        }
                    });
                    return result
                },
                getChooserColumns: function(getAllColumns) {
                    var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
                    return commonUtils.grep(columns, function(column) {
                        return column.showInColumnChooser
                    })
                },
                allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var that = this,
                        columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                        sourceColumn = that._columns[columnIndex];
                    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                        if (sourceLocation === targetLocation) {
                            if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
                                return false
                            }
                            fromVisibleIndex = commonUtils.isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
                            toVisibleIndex = commonUtils.isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                            return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                        } else {
                            if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
                                return sourceColumn && sourceColumn.allowGrouping
                            } else {
                                if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
                                    return sourceColumn && sourceColumn.allowHiding
                                }
                            }
                        }
                        return true
                    }
                    return false
                },
                moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var targetGroupIndex, column, that = this,
                        fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                        toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation),
                        isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION;
                    if (fromIndex >= 0) {
                        column = that._columns[fromIndex];
                        toVisibleIndex = commonUtils.isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                        targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                        if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                            if (targetGroupIndex > column.groupIndex) {
                                targetGroupIndex--
                            }
                            delete column.groupIndex;
                            delete column.sortOrder;
                            updateColumnGroupIndexes(that)
                        }
                        if (targetLocation === GROUP_LOCATION) {
                            moveColumnToGroup(that, column, targetGroupIndex);
                            updateColumnGroupIndexes(that)
                        } else {
                            if (toVisibleIndex >= 0) {
                                var targetColumn = that._columns[toIndex];
                                if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
                                    column.visibleIndex = void 0
                                } else {
                                    if (column.fixed ^ targetColumn.fixed) {
                                        column.visibleIndex = void 0
                                    } else {
                                        column.visibleIndex = targetColumn.visibleIndex
                                    }
                                }
                                updateColumnVisibleIndexes(that, column)
                            }
                        }
                        var isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION,
                            changeType = isGroupMoving ? "grouping" : "columns";
                        if (column.visible !== isVisible) {
                            column.visible = isVisible;
                            updateColumnChanges(that, changeType, "visible", column.index)
                        } else {
                            updateColumnChanges(that, changeType)
                        }
                        fireColumnsChanged(that)
                    }
                },
                changeSortOrder: function(columnIndex, sortOrder) {
                    var that = this,
                        sortingOptions = that.option("sorting"),
                        sortingMode = sortingOptions && sortingOptions.mode,
                        needResetSorting = "single" === sortingMode || !sortOrder,
                        allowSorting = "single" === sortingMode || "multiple" === sortingMode,
                        column = that._columns[columnIndex],
                        nextSortOrder = function(column) {
                            if ("ctrl" === sortOrder) {
                                if (!("sortOrder" in column && "sortIndex" in column)) {
                                    return false
                                }
                                delete column.sortOrder;
                                delete column.sortIndex
                            } else {
                                if (isDefined(column.groupIndex) || isDefined(column.sortIndex)) {
                                    column.sortOrder = "desc" === column.sortOrder ? "asc" : "desc"
                                } else {
                                    column.sortOrder = "asc"
                                }
                            }
                            return true
                        },
                        isSortingChanged = false;
                    if (allowSorting && column && column.allowSorting) {
                        if (needResetSorting && !isDefined(column.groupIndex)) {
                            $.each(that._columns, function(index) {
                                if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
                                    delete this.sortOrder;
                                    delete this.sortIndex;
                                    isSortingChanged = true
                                }
                            })
                        }
                        if (isSortOrderValid(sortOrder)) {
                            if (column.sortOrder !== sortOrder) {
                                column.sortOrder = sortOrder;
                                isSortingChanged = true
                            }
                        } else {
                            if ("none" === sortOrder) {
                                if (column.sortOrder) {
                                    delete column.sortIndex;
                                    delete column.sortOrder;
                                    isSortingChanged = true
                                }
                            } else {
                                isSortingChanged = nextSortOrder(column)
                            }
                        }
                    }
                    if (isSortingChanged) {
                        updateColumnSortIndexes(that);
                        updateColumnChanges(that, "sorting");
                        fireColumnsChanged(that)
                    }
                },
                getSortDataSourceParameters: function(useLocalSelector) {
                    var that = this,
                        sortColumns = [],
                        sort = [];
                    $.each(that._columns, function() {
                        if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
                            sortColumns[this.sortIndex] = this
                        }
                    });
                    $.each(sortColumns, function() {
                        var sortOrder = this && this.sortOrder;
                        if (isSortOrderValid(sortOrder)) {
                            var sortItem = {
                                selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                                desc: "desc" === this.sortOrder
                            };
                            if (this.sortingMethod) {
                                sortItem.compare = this.sortingMethod.bind(this)
                            }
                            sort.push(sortItem)
                        }
                    });
                    return sort.length > 0 ? sort : null
                },
                getGroupDataSourceParameters: function(useLocalSelector) {
                    var group = [];
                    $.each(this.getGroupColumns(), function() {
                        var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                        if (selector) {
                            var groupItem = {
                                selector: selector,
                                desc: "desc" === this.sortOrder,
                                isExpanded: !!this.autoExpandGroup
                            };
                            if (this.sortingMethod) {
                                groupItem.compare = this.sortingMethod.bind(this)
                            }
                            group.push(groupItem)
                        }
                    });
                    return group.length > 0 ? group : null
                },
                refresh: function(updateNewLookupsOnly) {
                    var deferreds = [];
                    $.each(this._columns, function() {
                        var lookup = this.lookup;
                        if (lookup && !this.calculateDisplayValue) {
                            if (updateNewLookupsOnly && lookup.valueMap) {
                                return
                            }
                            if (lookup.update) {
                                deferreds.push(lookup.update())
                            }
                        }
                    });
                    return when.apply($, deferreds).done(resetColumnsCache.bind(null, this))
                },
                _updateColumnOptions: function(column) {
                    column.selector = column.selector || function(data) {
                        return column.calculateCellValue(data)
                    };
                    $.each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], function(_, calculateCallbackName) {
                        var calculateCallback = column[calculateCallbackName];
                        if (commonUtils.isFunction(calculateCallback) && !calculateCallback.originalCallback) {
                            column[calculateCallbackName] = function(data) {
                                return calculateCallback.call(column, data)
                            };
                            column[calculateCallbackName].originalCallback = calculateCallback
                        }
                    });
                    if (commonUtils.isString(column.calculateDisplayValue)) {
                        column.displayField = column.calculateDisplayValue;
                        column.calculateDisplayValue = dataCoreUtils.compileGetter(column.displayField)
                    }
                    if (column.calculateDisplayValue) {
                        column.displayValueMap = column.displayValueMap || {}
                    }
                    updateSerializers(column, column.dataType);
                    var lookup = column.lookup;
                    if (lookup) {
                        updateSerializers(lookup, lookup.dataType)
                    }
                    var dataType = lookup ? lookup.dataType : column.dataType;
                    if (dataType) {
                        column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
                        column.format = column.format || gridCoreUtils.getFormatByDataType(dataType);
                        column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                        if (!isDefined(column.filterOperations)) {
                            column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || []
                        }
                        column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                        column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate
                    }
                },
                updateColumnDataTypes: function(dataSource) {
                    var that = this,
                        dateSerializationFormat = that.option("dateSerializationFormat"),
                        firstItems = that._getFirstItems(dataSource),
                        isColumnDataTypesUpdated = false;
                    $.each(that._columns, function(index, column) {
                        var i, value, dataType, lookupDataType, valueDataType, lookup = column.lookup;
                        if ("date" === column.dataType && void 0 === column.serializationFormat) {
                            column.serializationFormat = dateSerializationFormat
                        }
                        if (lookup && "date" === lookup.dataType && void 0 === column.serializationFormat) {
                            lookup.serializationFormat = dateSerializationFormat
                        }
                        if (column.calculateCellValue && firstItems.length) {
                            if (!column.dataType || lookup && !lookup.dataType) {
                                for (i = 0; i < firstItems.length; i++) {
                                    value = column.calculateCellValue(firstItems[i]);
                                    valueDataType = column.dataType || getValueDataType(value);
                                    dataType = dataType || valueDataType;
                                    if (dataType && valueDataType && dataType !== valueDataType) {
                                        dataType = "string"
                                    }
                                    if (lookup) {
                                        valueDataType = lookup.dataType || getValueDataType(gridCoreUtils.getDisplayValue(column, value, firstItems[i]));
                                        lookupDataType = lookupDataType || valueDataType;
                                        if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                                            lookupDataType = "string"
                                        }
                                    }
                                }
                                column.dataType = dataType;
                                if (lookup) {
                                    lookup.dataType = lookupDataType
                                }
                                if (dataType) {
                                    isColumnDataTypesUpdated = true
                                }
                            }
                            if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
                                for (i = 0; i < firstItems.length; i++) {
                                    value = column.calculateCellValue(firstItems[i], true);
                                    if (void 0 === column.serializationFormat) {
                                        column.serializationFormat = getSerializationFormat(column.dataType, value)
                                    }
                                    if (lookup && void 0 === lookup.serializationFormat) {
                                        lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                    }
                                }
                            }
                        }
                        that._updateColumnOptions(column)
                    });
                    return isColumnDataTypesUpdated
                },
                _customizeColumns: function(columns) {
                    var that = this,
                        customizeColumns = that.option("customizeColumns");
                    if (customizeColumns) {
                        customizeColumns(columns);
                        assignColumns(that, createColumnsFromOptions(that, columns))
                    }
                },
                updateColumns: function(dataSource, forceApplying) {
                    var sortParameters, groupParameters, that = this;
                    if (!forceApplying) {
                        that.updateSortingGrouping(dataSource)
                    }
                    if (!dataSource || dataSource.isLoaded()) {
                        sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
                        groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
                        that._customizeColumns(that._columns);
                        updateIndexes(that);
                        var columns = that._columns;
                        return when(that.refresh(true)).always(function() {
                            if (that._columns !== columns) {
                                return
                            }
                            that._updateChanges(dataSource, {
                                sorting: sortParameters,
                                grouping: groupParameters
                            });
                            fireColumnsChanged(that)
                        })
                    }
                },
                _updateChanges: function(dataSource, parameters) {
                    var that = this;
                    if (dataSource) {
                        that.updateColumnDataTypes(dataSource);
                        that._dataSourceApplied = true
                    }
                    if (!equalSortParameters(parameters.sorting, that.getSortDataSourceParameters())) {
                        updateColumnChanges(that, "sorting")
                    }
                    if (!equalSortParameters(parameters.grouping, that.getGroupDataSourceParameters())) {
                        updateColumnChanges(that, "grouping")
                    }
                    updateColumnChanges(that, "columns")
                },
                updateSortingGrouping: function(dataSource, fromDataSource) {
                    var sortParameters, groupParameters, columnsGroupParameters, columnsSortParameters, isColumnsChanged, that = this,
                        updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                            var i, selector, isExpanded;
                            $.each(columns, function(index, column) {
                                delete column[indexParameterName];
                                if (sortParameters) {
                                    for (i = 0; i < sortParameters.length; i++) {
                                        selector = sortParameters[i].selector;
                                        isExpanded = sortParameters[i].isExpanded;
                                        if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {
                                            column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
                                            if (void 0 !== isExpanded) {
                                                column.autoExpandGroup = isExpanded
                                            }
                                            column[indexParameterName] = i;
                                            break
                                        }
                                    }
                                }
                            })
                        };
                    if (dataSource) {
                        sortParameters = normalizeSortingInfo(dataSource.sort());
                        groupParameters = normalizeSortingInfo(dataSource.group());
                        columnsGroupParameters = that.getGroupDataSourceParameters();
                        columnsSortParameters = that.getSortDataSourceParameters();
                        if (!that._columns.length) {
                            $.each(groupParameters, function(index, group) {
                                that._columns.push(group.selector)
                            });
                            $.each(sortParameters, function(index, sort) {
                                that._columns.push(sort.selector)
                            });
                            assignColumns(that, createColumnsFromOptions(that, that._columns))
                        }
                        if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !equalSortParameters(groupParameters, columnsGroupParameters)) {
                            updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                            if (fromDataSource) {
                                updateColumnChanges(that, "grouping");
                                isColumnsChanged = true
                            }
                        }
                        if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !equalSortParameters(sortParameters, columnsSortParameters)) {
                            updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                            if (fromDataSource) {
                                updateColumnChanges(that, "sorting");
                                isColumnsChanged = true
                            }
                        }
                        if (isColumnsChanged) {
                            fireColumnsChanged(that)
                        }
                    }
                },
                updateFilter: function(filter, remoteFiltering, columnIndex) {
                    var that = this;
                    if (!Array.isArray(filter)) {
                        return filter
                    }
                    var column, i;
                    filter = extend([], filter);
                    columnIndex = filter.columnIndex || columnIndex;
                    if (commonUtils.isString(filter[0])) {
                        column = that.columnOption(filter[0]);
                        if (remoteFiltering) {
                            if (config().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
                                filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1])
                            }
                        } else {
                            if (column && column.selector) {
                                filter[0] = column.selector;
                                filter[0].columnIndex = column.index
                            }
                        }
                    } else {
                        if (commonUtils.isFunction(filter[0])) {
                            filter[0].columnIndex = columnIndex
                        }
                    }
                    for (i = 0; i < filter.length; i++) {
                        filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex)
                    }
                    return filter
                },
                columnCount: function() {
                    return this._columns.length
                },
                columnOption: function(identifier, option, value, notFireEvent) {
                    var i, needUpdateIndexes, column, that = this,
                        identifierOptionName = commonUtils.isString(identifier) && identifier.substr(0, identifier.indexOf(":")),
                        columns = identifier < 0 || "command" === identifierOptionName ? that._commandColumns : that._columns;
                    if (void 0 === identifier) {
                        return
                    }
                    if (identifierOptionName) {
                        identifier = identifier.substr(identifierOptionName.length + 1)
                    }
                    for (i = 0; i < columns.length; i++) {
                        if (identifierOptionName) {
                            if ("" + columns[i][identifierOptionName] === identifier) {
                                column = columns[i];
                                break
                            }
                        } else {
                            if (columns[i].index === identifier || columns[i].name === identifier || columns[i].dataField === identifier || columns[i].caption === identifier) {
                                column = columns[i];
                                break
                            }
                        }
                    }
                    if (column) {
                        if (1 === arguments.length) {
                            return extend({}, column)
                        }
                        if (commonUtils.isString(option)) {
                            if (2 === arguments.length) {
                                return columnOptionCore(that, column, option)
                            } else {
                                needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[option];
                                columnOptionCore(that, column, option, value, notFireEvent)
                            }
                        } else {
                            if (commonUtils.isObject(option)) {
                                $.each(option, function(optionName, value) {
                                    needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[optionName];
                                    columnOptionCore(that, column, optionName, value, notFireEvent)
                                })
                            }
                        }
                        if (needUpdateIndexes) {
                            updateIndexes(that, column)
                        }
                        fireColumnsChanged(that)
                    }
                },
                clearSorting: function() {
                    var i, that = this,
                        columnCount = this.columnCount();
                    that.beginUpdate();
                    for (i = 0; i < columnCount; i++) {
                        that.columnOption(i, "sortOrder", void 0)
                    }
                    that.endUpdate()
                },
                clearGrouping: function() {
                    var i, that = this,
                        columnCount = this.columnCount();
                    that.beginUpdate();
                    for (i = 0; i < columnCount; i++) {
                        that.columnOption(i, "groupIndex", void 0)
                    }
                    that.endUpdate()
                },
                getVisibleIndex: function(index, rowIndex) {
                    var i, columns = this.getVisibleColumns(rowIndex);
                    for (i = columns.length - 1; i >= 0; i--) {
                        if (columns[i].index === index) {
                            return i
                        }
                    }
                    return -1
                },
                addColumn: function(options) {
                    var that = this,
                        column = createColumn(that, options);
                    column.added = options;
                    that._columns.push(column);
                    updateIndexes(that, column);
                    that.updateColumns(that._dataSource)
                },
                deleteColumn: function(id) {
                    var that = this,
                        columnIndex = that.columnOption(id, "index");
                    if (columnIndex >= 0) {
                        that._columns.splice(columnIndex, 1);
                        updateIndexes(that);
                        that.updateColumns(that._dataSource)
                    }
                },
                addCommandColumn: function(options) {
                    var i, commandColumns = this._commandColumns;
                    for (i = 0; i < commandColumns.length; i++) {
                        if (commandColumns[i].command === options.command) {
                            return
                        }
                    }
                    commandColumns.push(options)
                },
                getUserState: function() {
                    var i, columns = this._columns,
                        result = [];

                    function handleStateField(index, value) {
                        if (void 0 !== columns[i][value]) {
                            result[i][value] = columns[i][value]
                        }
                    }
                    for (i = 0; i < columns.length; i++) {
                        result[i] = {};
                        $.each(USER_STATE_FIELD_NAMES, handleStateField)
                    }
                    return result
                },
                setUserState: function(state) {
                    var commonColumnSettings, that = this,
                        ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
                    if (!ignoreColumnOptionNames) {
                        ignoreColumnOptionNames = [];
                        commonColumnSettings = that.getCommonSettings();
                        if (!that.option("columnChooser.enabled")) {
                            ignoreColumnOptionNames.push("visible")
                        }
                        if ("none" === that.option("sorting.mode")) {
                            ignoreColumnOptionNames.push("sortIndex", "sortOrder")
                        }
                        if (!commonColumnSettings.allowGrouping) {
                            ignoreColumnOptionNames.push("groupIndex")
                        }
                        if (!commonColumnSettings.allowFixing) {
                            ignoreColumnOptionNames.push("fixed", "fixedPosition")
                        }
                        if (!commonColumnSettings.allowResizing) {
                            ignoreColumnOptionNames.push("width", "visibleWidth")
                        }
                        if (!that.option("filterRow.visible")) {
                            ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation")
                        }
                        if (!that.option("headerFilter.visible")) {
                            ignoreColumnOptionNames.push("filterValues", "filterType")
                        }
                    }
                    that._columnsUserState = state;
                    that._ignoreColumnOptionNames = ignoreColumnOptionNames;
                    that._hasUserState = !!state;
                    that.init()
                },
                _createCalculatedColumnOptions: function(columnOptions, bandColumn) {
                    var getter, calculatedColumnOptions = {},
                        dataField = columnOptions.dataField;
                    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
                        calculatedColumnOptions.isBand = true;
                        dataField = null
                    }
                    if (dataField) {
                        if (commonUtils.isString(dataField)) {
                            getter = dataCoreUtils.compileGetter(dataField);
                            calculatedColumnOptions = {
                                caption: inflector.captionize(dataField),
                                calculateCellValue: function(data, skipDeserialization) {
                                    var value = getter(data);
                                    return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                },
                                setCellValue: defaultSetCellValue,
                                parseValue: function(text) {
                                    var result, parsedValue, column = this;
                                    if ("number" === column.dataType) {
                                        if (commonUtils.isString(text)) {
                                            parsedValue = numberLocalization.parse(text);
                                            if (commonUtils.isNumeric(parsedValue)) {
                                                result = parsedValue
                                            }
                                        } else {
                                            if (isDefined(text)) {
                                                result = Number(text)
                                            }
                                        }
                                    } else {
                                        if ("boolean" === column.dataType) {
                                            if (text === column.trueText) {
                                                result = true
                                            } else {
                                                if (text === column.falseText) {
                                                    result = false
                                                }
                                            }
                                        } else {
                                            if ("date" === column.dataType) {
                                                parsedValue = dateLocalization.parse(text, column.format);
                                                if (parsedValue) {
                                                    result = parsedValue
                                                }
                                            } else {
                                                result = text
                                            }
                                        }
                                    }
                                    return result
                                }
                            }
                        }
                        calculatedColumnOptions.allowFiltering = true
                    } else {
                        calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression
                    }
                    calculatedColumnOptions.calculateFilterExpression = function() {
                        return gridCoreUtils.defaultCalculateFilterExpression.apply(this, arguments)
                    };
                    calculatedColumnOptions.createFilterExpression = function() {
                        var result;
                        if (this.calculateFilterExpression) {
                            result = this.calculateFilterExpression.apply(this, arguments)
                        }
                        if (commonUtils.isFunction(result)) {
                            result = [result, "=", true]
                        } else {
                            if (result) {
                                result.columnIndex = this.index
                            }
                        }
                        return result
                    };
                    if (!dataField || !commonUtils.isString(dataField)) {
                        extend(true, calculatedColumnOptions, {
                            allowSorting: false,
                            allowGrouping: false,
                            calculateCellValue: function() {
                                return null
                            }
                        })
                    }
                    if (bandColumn) {
                        calculatedColumnOptions.allowFixing = false
                    }
                    if (columnOptions.dataType) {
                        calculatedColumnOptions.userDataType = columnOptions.dataType
                    }
                    if (columnOptions.selectedFilterOperation) {
                        calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation
                    }
                    if (columnOptions.lookup) {
                        calculatedColumnOptions.lookup = {
                            calculateCellValue: function(value, skipDeserialization) {
                                if (this.valueExpr) {
                                    value = this.valueMap && this.valueMap[value]
                                }
                                return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                            },
                            updateValueMap: function() {
                                var calculateValue, calculateDisplayValue, item, i;
                                this.valueMap = {};
                                if (this.items) {
                                    calculateValue = dataCoreUtils.compileGetter(this.valueExpr);
                                    calculateDisplayValue = dataCoreUtils.compileGetter(this.displayExpr);
                                    for (i = 0; i < this.items.length; i++) {
                                        item = this.items[i];
                                        var displayValue = calculateDisplayValue(item);
                                        this.valueMap[calculateValue(item)] = displayValue;
                                        this.dataType = this.dataType || getValueDataType(displayValue)
                                    }
                                }
                            },
                            update: function() {
                                var dataSourceOptions, that = this,
                                    dataSource = that.dataSource;
                                if (dataSource) {
                                    if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
                                        dataSource = dataSource({})
                                    }
                                    if (commonUtils.isObject(dataSource) || Array.isArray(dataSource)) {
                                        if (that.valueExpr) {
                                            dataSourceOptions = normalizeDataSourceOptions(dataSource);
                                            dataSourceOptions.paginate = false;
                                            dataSource = new DataSourceModule.DataSource(dataSourceOptions);
                                            return dataSource.load().done(function(data) {
                                                that.items = data;
                                                that.updateValueMap && that.updateValueMap()
                                            })
                                        }
                                    } else {
                                        errors.log("E1016")
                                    }
                                } else {
                                    that.updateValueMap && that.updateValueMap()
                                }
                            }
                        }
                    }
                    calculatedColumnOptions.resizedCallbacks = $.Callbacks();
                    if (columnOptions.resized) {
                        calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions))
                    }
                    $.each(calculatedColumnOptions, function(optionName) {
                        var defaultOptionName;
                        if (commonUtils.isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
                            defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
                            calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]
                        }
                    });
                    return calculatedColumnOptions
                },
                getRowCount: function() {
                    this._rowCount = this._rowCount || getRowCount(this);
                    return this._rowCount
                },
                getRowIndex: function(columnIndex, alwaysGetRowIndex) {
                    var column = this._columns[columnIndex],
                        bandColumnsCache = this.getBandColumnsCache();
                    return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0
                },
                getChildrenByBandColumn: function(bandColumnIndex, onlyVisibleDirectChildren) {
                    var that = this,
                        bandColumnsCache = that.getBandColumnsCache(),
                        result = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
                    if (onlyVisibleDirectChildren) {
                        return result.filter(function(column) {
                            return column.visible && !column.command
                        }).sort(function(column1, column2) {
                            return column1.visibleIndex - column2.visibleIndex
                        })
                    }
                    return result
                },
                isParentBandColumn: function(columnIndex, bandColumnIndex) {
                    var result = false,
                        column = this._columns[columnIndex],
                        bandColumnsCache = this.getBandColumnsCache(),
                        parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
                    if (parentBandColumns) {
                        $.each(parentBandColumns, function(_, bandColumn) {
                            if (bandColumn.index === bandColumnIndex) {
                                result = true;
                                return false
                            }
                        })
                    }
                    return result
                },
                isParentColumnVisible: function(columnIndex) {
                    var result = true,
                        bandColumnsCache = this.getBandColumnsCache(),
                        bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
                    bandColumns && $.each(bandColumns, function(_, bandColumn) {
                        result = result && bandColumn.visible;
                        return result
                    });
                    return result
                }
            }
        }())
    }
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.data_source_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    gridCore = __webpack_require__(12),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    ArrayStore = __webpack_require__(67),
    when = __webpack_require__(10).when;
module.exports = gridCore.Controller.inherit(function() {
    function cloneItems(items, groupCount) {
        if (items) {
            items = items.slice(0);
            if (groupCount) {
                for (var i = 0; i < items.length; i++) {
                    items[i] = extend({
                        key: items[i].key
                    }, items[i]);
                    items[i].items = cloneItems(items[i].items, groupCount - 1)
                }
            }
        }
        return items
    }

    function calculateOperationTypes(loadOptions, lastLoadOptions) {
        var operationTypes = {};
        if (lastLoadOptions) {
            operationTypes = {
                sorting: !gridCore.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
                grouping: !gridCore.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
                filtering: !gridCore.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
                skip: loadOptions.skip !== lastLoadOptions.skip,
                take: loadOptions.take !== lastLoadOptions.take
            };
            operationTypes.reload = operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
            operationTypes.paging = operationTypes.skip || operationTypes.take
        }
        return operationTypes
    }

    function executeTask(action, timeout) {
        if (commonUtils.isDefined(timeout)) {
            commonUtils.executeAsync(action, timeout)
        } else {
            action()
        }
    }
    return {
        init: function(dataSource, remoteOperations) {
            var that = this;
            that._dataSource = dataSource;
            that._remoteOperations = remoteOperations || {};
            that._isLastPage = !dataSource.isLastPage();
            that._hasLastPage = false;
            that._currentTotalCount = 0;
            that.changed = $.Callbacks();
            that.loadingChanged = $.Callbacks();
            that.loadError = $.Callbacks();
            that.customizeStoreLoadOptions = $.Callbacks();
            that._dataChangedHandler = that._handleDataChanged.bind(that);
            that._dataLoadingHandler = that._handleDataLoading.bind(that);
            that._dataLoadedHandler = that._handleDataLoaded.bind(that);
            that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
            that._loadErrorHandler = that._handleLoadError.bind(that);
            dataSource.on("changed", that._dataChangedHandler);
            dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
            dataSource.on("customizeLoadResult", that._dataLoadedHandler);
            dataSource.on("loadingChanged", that._loadingChangedHandler);
            dataSource.on("loadError", that._loadErrorHandler);
            $.each(dataSource, function(memberName, member) {
                if (!that[memberName] && commonUtils.isFunction(member)) {
                    that[memberName] = function() {
                        return this._dataSource[memberName].apply(this._dataSource, arguments)
                    }
                }
            })
        },
        remoteOperations: function() {
            return this._remoteOperations
        },
        dispose: function(isSharedDataSource) {
            var that = this,
                dataSource = that._dataSource;
            dataSource.off("changed", that._dataChangedHandler);
            dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
            dataSource.off("customizeLoadResult", that._dataLoadedHandler);
            dataSource.off("loadingChanged", that._loadingChangedHandler);
            dataSource.off("loadError", that._loadErrorHandler);
            if (!isSharedDataSource) {
                dataSource.dispose()
            }
        },
        refresh: function(options, isReload, operationTypes) {
            var that = this,
                dataSource = that._dataSource;
            if (isReload || operationTypes.reload) {
                that._currentTotalCount = 0;
                that._isLastPage = !dataSource.paginate();
                that._hasLastPage = that._isLastPage
            }
        },
        _customizeRemoteOperations: function(options, isReload, operationTypes) {
            var that = this,
                cachedStoreData = that._cachedStoreData,
                cachedPagingData = that._cachedPagingData;
            if (isReload) {
                cachedStoreData = void 0;
                cachedPagingData = void 0
            } else {
                if (operationTypes.reload) {
                    cachedPagingData = void 0
                }
                $.each(operationTypes, function(operationType, value) {
                    if (value && options.remoteOperations[operationType]) {
                        cachedStoreData = void 0;
                        cachedPagingData = void 0
                    }
                })
            }
            if (cachedPagingData) {
                options.remoteOperations.paging = false
            }
            options.cachedStoreData = cachedStoreData;
            options.cachedPagingData = cachedPagingData;
            if (!options.isCustomLoading) {
                that._cachedStoreData = cachedStoreData;
                that._cachedPagingData = cachedPagingData
            }
        },
        _handleDataLoading: function(options) {
            var loadOptions, operationTypes, that = this,
                dataSource = that._dataSource,
                lastLoadOptions = that._lastLoadOptions;
            that.customizeStoreLoadOptions.fire(options);
            options.delay = this.option("loadingTimeout");
            options.originalStoreLoadOptions = options.storeLoadOptions;
            options.remoteOperations = extend({}, this.remoteOperations());
            var isReload = !that.isLoaded() && !that._isRefreshing;
            loadOptions = extend({}, options.storeLoadOptions);
            operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions);
            that._customizeRemoteOperations(options, isReload, operationTypes);
            if (!options.isCustomLoading) {
                that._lastLoadOptions = loadOptions;
                that._isRefreshing = true;
                when(that.refresh(options, isReload, operationTypes)).always(function() {
                    if (that._lastOperationId === options.operationId) {
                        that.load()
                    }
                    that._isRefreshing = false
                });
                dataSource.cancel(that._lastOperationId);
                that._lastOperationId = options.operationId;
                if (that._isRefreshing) {
                    dataSource.cancel(that._lastOperationId)
                }
            }
            this._handleDataLoadingCore(options)
        },
        _handleDataLoadingCore: function(options) {
            var remoteOperations = options.remoteOperations;
            options.loadOptions = {};
            var localLoadOptionNames = {
                filter: !remoteOperations.filtering,
                sort: !remoteOperations.sorting,
                group: !remoteOperations.grouping,
                summary: !remoteOperations.summary,
                skip: !remoteOperations.paging,
                take: !remoteOperations.paging,
                requireTotalCount: !remoteOperations.paging
            };
            $.each(options.storeLoadOptions, function(optionName, optionValue) {
                if (localLoadOptionNames[optionName]) {
                    options.loadOptions[optionName] = optionValue;
                    delete options.storeLoadOptions[optionName]
                }
            });
            options.data = options.cachedStoreData
        },
        _handleDataLoaded: function(options) {
            var loadOptions = options.loadOptions,
                localPaging = options.remoteOperations && !options.remoteOperations.paging,
                isCaching = false !== this.option("cacheEnabled") && localPaging && options.storeLoadOptions,
                needStoreCache = isCaching && !options.isCustomLoading;
            if (!loadOptions) {
                this._dataSource.cancel(options.operationId);
                return
            }
            if (localPaging) {
                options.skip = loadOptions.skip;
                options.take = loadOptions.take;
                delete loadOptions.skip;
                delete loadOptions.take
            }
            if (loadOptions.group) {
                loadOptions.group = options.group || loadOptions.group
            }
            var groupCount = gridCore.normalizeSortingInfo(options.storeLoadOptions.group || loadOptions.group).length;
            if (isCaching && options.cachedPagingData) {
                options.data = cloneItems(options.cachedPagingData, groupCount)
            } else {
                if (needStoreCache) {
                    if (!this._cachedStoreData) {
                        this._cachedStoreData = cloneItems(options.data, gridCore.normalizeSortingInfo(options.storeLoadOptions.group).length)
                    } else {
                        if (options.mergeStoreLoadData) {
                            options.data = this._cachedStoreData = this._cachedStoreData.concat(options.data)
                        }
                    }
                }
                new ArrayStore(options.data).load(loadOptions).done(function(data) {
                    options.data = data
                });
                if (needStoreCache) {
                    this._cachedPagingData = cloneItems(options.data, groupCount)
                }
            }
            if (loadOptions.requireTotalCount && localPaging) {
                options.extra = typeUtils.isPlainObject(options.extra) ? options.extra : {};
                options.extra.totalCount = options.data.length
            }
            this._handleDataLoadedCore(options);
            options.storeLoadOptions = options.originalStoreLoadOptions
        },
        _handleDataLoadedCore: function(options) {
            if (options.remoteOperations && !options.remoteOperations.paging && Array.isArray(options.data)) {
                if (void 0 !== options.skip) {
                    options.data = options.data.slice(options.skip)
                }
                if (void 0 !== options.take) {
                    options.data = options.data.slice(0, options.take)
                }
            }
        },
        _handleLoadingChanged: function(isLoading) {
            this.loadingChanged.fire(isLoading)
        },
        _handleLoadError: function(error) {
            this.changed.fire({
                changeType: "loadError",
                error: error
            });
            this.loadError.fire(error)
        },
        _handleDataChanged: function(args) {
            var currentTotalCount, that = this,
                dataSource = that._dataSource,
                isLoading = false,
                itemsCount = that.itemsCount();
            that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
            if (that._isLastPage) {
                that._hasLastPage = true
            }
            if (dataSource.totalCount() >= 0) {
                if (dataSource.pageIndex() >= that.pageCount()) {
                    dataSource.pageIndex(that.pageCount() - 1);
                    dataSource.load();
                    isLoading = true
                }
            } else {
                currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                if (0 === itemsCount && dataSource.pageIndex() >= that.pageCount()) {
                    dataSource.pageIndex(that.pageCount() - 1);
                    if ("infinite" !== that.option("scrolling.mode")) {
                        dataSource.load();
                        isLoading = true
                    }
                }
            }
            if (!isLoading) {
                this.component._optionCache = {};
                this.changed.fire(args);
                this.component._optionCache = void 0
            }
        },
        isLastPage: function() {
            return this._isLastPage
        },
        totalCount: function() {
            return parseInt(this._currentTotalCount || this._dataSource.totalCount())
        },
        itemsCount: function() {
            return this._dataSource.items().length
        },
        totalItemsCount: function() {
            return this.totalCount()
        },
        pageSize: function() {
            var dataSource = this._dataSource;
            if (!arguments.length && !dataSource.paginate()) {
                return 0
            }
            return dataSource.pageSize.apply(dataSource, arguments)
        },
        pageCount: function() {
            var that = this,
                count = that.totalItemsCount(),
                pageSize = that.pageSize();
            if (pageSize && count > 0) {
                return Math.max(1, Math.ceil(count / pageSize))
            }
            return 1
        },
        hasKnownLastPage: function() {
            return this._hasLastPage || this._dataSource.totalCount() >= 0
        },
        loadFromStore: function(loadOptions) {
            var dataSource = this._dataSource,
                d = $.Deferred();
            if (!dataSource) {
                return
            }
            dataSource.store().load(loadOptions).done(function(data, extra) {
                if (data && !Array.isArray(data) && Array.isArray(data.data)) {
                    extra = data;
                    data = data.data
                }
                d.resolve(data, extra)
            }).fail(d.reject);
            return d
        },
        load: function(options) {
            var store, loadResult, dataSourceLoadOptions, that = this,
                dataSource = that._dataSource,
                d = $.Deferred();
            if (options) {
                store = dataSource.store();
                dataSourceLoadOptions = dataSource.loadOptions();
                loadResult = {
                    storeLoadOptions: options,
                    isCustomLoading: true
                };
                $.each(store._customLoadOptions() || [], function(_, optionName) {
                    if (!(optionName in loadResult.storeLoadOptions)) {
                        loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName]
                    }
                });
                dataSource._scheduleLoadCallbacks(d);
                that._handleDataLoading(loadResult);
                executeTask(function() {
                    if (!dataSource.store()) {
                        return
                    }
                    when(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done(function(data, extra) {
                        loadResult.data = data;
                        loadResult.extra = extra || {};
                        that._handleDataLoaded(loadResult);
                        if (options.requireTotalCount && void 0 === loadResult.extra.totalCount) {
                            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions)
                        }
                        when(loadResult.data, loadResult.extra.totalCount).done(function(data, totalCount) {
                            loadResult.extra.totalCount = totalCount;
                            d.resolve(data, loadResult.extra)
                        }).fail(d.reject)
                    }).fail(d.reject)
                }, that.option("loadingTimeout"));
                return d.fail(function() {
                    that.fireEvent("loadError", arguments)
                }).promise()
            } else {
                return dataSource.load()
            }
        },
        reload: function(full) {
            return full ? this._dataSource.reload() : this._dataSource.load()
        }
    }
}());


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.data_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    ArrayStore = __webpack_require__(67),
    CustomStore = __webpack_require__(148),
    errors = __webpack_require__(16),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    DataHelperMixin = __webpack_require__(121),
    equalKeys = commonUtils.equalByValue,
    when = __webpack_require__(10).when;
module.exports = {
    defaultOptions: function() {
        return {
            loadingTimeout: 0,
            dataSource: null,
            cacheEnabled: true,
            onDataErrorOccurred: null,
            remoteOperations: "auto",
            paging: {
                enabled: true,
                pageSize: void 0,
                pageIndex: void 0
            }
        }
    },
    controllers: {
        data: modules.Controller.inherit({}).include(DataHelperMixin).inherit(function() {
            var members = {
                init: function() {
                    var that = this;
                    that._items = [];
                    that._columnsController = that.getController("columns");
                    that._columnsChangedHandler = that._handleColumnsChanged.bind(that);
                    that._dataChangedHandler = that._handleDataChanged.bind(that);
                    that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
                    that._loadErrorHandler = that._handleLoadError.bind(that);
                    that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
                    that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                    that._isLoading = false;
                    that._isCustomLoading = false;
                    that._changes = [];
                    that.createAction("onDataErrorOccurred");
                    that.dataErrorOccurred.add(function(error) {
                        return that.executeAction("onDataErrorOccurred", {
                            error: error
                        })
                    });
                    that._refreshDataSource()
                },
                callbackNames: function() {
                    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
                },
                callbackFlags: function(name) {
                    if ("dataErrorOccurred" === name) {
                        return {
                            stopOnFalse: true
                        }
                    }
                },
                publicMethods: function() {
                    return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getDataSource", "getVisibleRows", "repaintRows"]
                },
                optionChanged: function(args) {
                    var that = this;

                    function handled() {
                        args.handled = true
                    }

                    function reload() {
                        that._columnsController.reset();
                        that._items = [];
                        that._refreshDataSource()
                    }
                    if ("dataSource" === args.name && args.name === args.fullName && args.value === args.previousValue) {
                        handled();
                        that.refresh();
                        return
                    }
                    switch (args.name) {
                        case "cacheEnabled":
                        case "loadingTimeout":
                        case "remoteOperations":
                            handled();
                            break;
                        case "keyExpr":
                        case "dataSource":
                        case "scrolling":
                        case "paging":
                            handled();
                            reload();
                            break;
                        case "rtlEnabled":
                            reload();
                            break;
                        default:
                            that.callBase(args)
                    }
                },
                isReady: function() {
                    return !this._isLoading
                },
                getDataSource: function() {
                    return this._dataSource && this._dataSource._dataSource
                },
                getCombinedFilter: function(returnDataField) {
                    return this.combinedFilter(void 0, returnDataField)
                },
                combinedFilter: function(filter, returnDataField) {
                    var additionalFilter, that = this,
                        dataSource = that._dataSource,
                        columnsController = that._columnsController;
                    if (dataSource) {
                        if (void 0 === filter) {
                            filter = dataSource.filter()
                        }
                        additionalFilter = that._calculateAdditionalFilter();
                        if (additionalFilter) {
                            if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined()) {
                                filter = gridCoreUtils.combineFilters([additionalFilter, filter])
                            }
                        }
                        filter = columnsController.updateFilter(filter, returnDataField || dataSource.remoteOperations().filtering)
                    }
                    return filter
                },
                _endUpdateCore: function() {
                    var changes = this._changes;
                    if (changes.length) {
                        this._changes = [];
                        this.updateItems(1 === changes.length ? changes[0] : {})
                    }
                },
                _handleCustomizeStoreLoadOptions: function(e) {
                    var columnsController = this._columnsController,
                        dataSource = this._dataSource,
                        storeLoadOptions = e.storeLoadOptions;
                    if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
                        return
                    }
                    storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
                    if (!columnsController.isDataSourceApplied()) {
                        columnsController.updateColumnDataTypes(dataSource)
                    }
                    this._columnsUpdating = true;
                    columnsController.updateSortingGrouping(dataSource, !this._isFirstLoading);
                    this._columnsUpdating = false;
                    storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
                    storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
                    dataSource.sort(storeLoadOptions.sort);
                    dataSource.group(storeLoadOptions.group);
                    storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
                    e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
                    this._isFirstLoading = false
                },
                _handleColumnsChanged: function(e) {
                    var filterValue, filterValues, that = this,
                        changeTypes = e.changeTypes,
                        optionNames = e.optionNames;
                    var updateItemsHandler = function() {
                        that._columnsController.columnsChanged.remove(updateItemsHandler);
                        that.updateItems()
                    };
                    if (changeTypes.sorting || changeTypes.grouping) {
                        if (that._dataSource && !that._columnsUpdating) {
                            that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                            that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                            that.reload()
                        }
                        that.pageChanged.fire()
                    } else {
                        if (changeTypes.columns) {
                            if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation) {
                                filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                                filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                                if (Array.isArray(filterValues) || void 0 === e.columnIndex || commonUtils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
                                    that._applyFilter()
                                }
                            }
                            if (!that._needApplyFilter && !gridCoreUtils.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                            }
                            if (commonUtils.isDefined(optionNames.visible)) {
                                var column = that._columnsController.columnOption(e.columnIndex);
                                if (column && (commonUtils.isDefined(column.filterValue) || commonUtils.isDefined(column.filterValues))) {
                                    that._applyFilter()
                                }
                            }
                        }
                    }
                },
                _handleDataChanged: function(e) {
                    var that = this,
                        dataSource = that._dataSource,
                        columnsController = that._columnsController,
                        isAllDataTypesDefined = columnsController.isAllDataTypesDefined(),
                        isAsyncDataSourceApplying = false;
                    if (dataSource && !that._isDataSourceApplying) {
                        that._isDataSourceApplying = true;
                        when(that._columnsController.applyDataSource(dataSource)).done(function() {
                            if (that._isLoading) {
                                that._handleLoadingChanged(false)
                            }
                            if (isAsyncDataSourceApplying && e && e.isDelayed) {
                                e.isDelayed = false
                            }
                            that._isDataSourceApplying = false;
                            var additionalFilter = that._calculateAdditionalFilter(),
                                needApplyFilter = that._needApplyFilter;
                            that._needApplyFilter = false;
                            if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
                                errors.log("W1005", that.component.NAME);
                                that._applyFilter()
                            } else {
                                that.updateItems(e)
                            }
                        }).fail(function() {
                            that._isDataSourceApplying = false
                        });
                        if (that._isDataSourceApplying) {
                            isAsyncDataSourceApplying = true;
                            that._handleLoadingChanged(true)
                        }
                        that._needApplyFilter = !that._columnsController.isDataSourceApplied()
                    }
                },
                _handleLoadingChanged: function(isLoading) {
                    this._isLoading = isLoading;
                    this._fireLoadingChanged()
                },
                _handleLoadError: function(e) {
                    this.dataErrorOccurred.fire(e)
                },
                _setPagingOptions: function(dataSource) {
                    var pageIndex = this.option("paging.pageIndex"),
                        pageSize = this.option("paging.pageSize"),
                        pagingEnabled = this.option("paging.enabled"),
                        scrollingMode = this.option("scrolling.mode"),
                        appendMode = "infinite" === scrollingMode,
                        virtualMode = "virtual" === scrollingMode;
                    dataSource.requireTotalCount(!appendMode);
                    if (void 0 !== pagingEnabled) {
                        dataSource.paginate(pagingEnabled || virtualMode || appendMode)
                    }
                    if (void 0 !== pageSize) {
                        dataSource.pageSize(pageSize)
                    }
                    if (void 0 !== pageIndex) {
                        dataSource.pageIndex(pageIndex)
                    }
                },
                _getSpecificDataSourceOption: function() {
                    var dataSource = this.option("dataSource");
                    if (Array.isArray(dataSource)) {
                        return {
                            store: {
                                type: "array",
                                data: dataSource,
                                key: this.option("keyExpr")
                            }
                        }
                    }
                    return dataSource
                },
                _initDataSource: function() {
                    var that = this,
                        dataSource = this.option("dataSource"),
                        oldDataSource = this._dataSource;
                    that.callBase();
                    dataSource = that._dataSource;
                    that._isFirstLoading = true;
                    if (dataSource) {
                        that._setPagingOptions(dataSource);
                        that.setDataSource(dataSource)
                    } else {
                        if (oldDataSource) {
                            that.updateItems()
                        }
                    }
                },
                _loadDataSource: function() {
                    var dataSource = this._dataSource,
                        result = $.Deferred();
                    when(this._columnsController.refresh(true)).always(function() {
                        if (dataSource) {
                            dataSource.load().done(result.resolve).fail(result.reject)
                        } else {
                            result.resolve()
                        }
                    });
                    return result.promise()
                },
                _processItems: function(items, changeType) {
                    var that = this,
                        visibleColumns = that._columnsController.getVisibleColumns(),
                        visibleItems = that._items,
                        dataIndex = "append" === changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1].dataIndex + 1 : 0,
                        options = {
                            visibleColumns: visibleColumns,
                            dataIndex: dataIndex
                        },
                        result = [];
                    $.each(items, function(index, item) {
                        if (commonUtils.isDefined(item)) {
                            options.rowIndex = index;
                            item = that._processItem(item, options);
                            result.push(item)
                        }
                    });
                    return result
                },
                _processItem: function(item, options) {
                    item = this._generateDataItem(item);
                    item = this._processDataItem(item, options);
                    item.dataIndex = options.dataIndex++;
                    return item
                },
                _generateDataItem: function(data) {
                    return {
                        rowType: "data",
                        data: data,
                        key: this.keyOf(data)
                    }
                },
                _processDataItem: function(dataItem, options) {
                    dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
                    return dataItem
                },
                generateDataValues: function(data, columns) {
                    var column, value, values = [];
                    for (var i = 0; i < columns.length; i++) {
                        column = columns[i];
                        value = null;
                        if (column.command) {
                            value = null
                        } else {
                            if (column.calculateCellValue) {
                                value = column.calculateCellValue(data)
                            } else {
                                if (column.dataField) {
                                    value = data[column.dataField]
                                }
                            }
                        }
                        values.push(value)
                    }
                    return values
                },
                _updateItemsCore: function(change) {
                    var items, that = this,
                        dataSource = that._dataSource,
                        changeType = change.changeType || "refresh";
                    change.changeType = changeType;
                    if (dataSource) {
                        items = change.items || dataSource.items();
                        items = that._processItems(items.slice(0), changeType);
                        change.items = items;
                        switch (changeType) {
                            case "prepend":
                                that._items.unshift.apply(that._items, items);
                                break;
                            case "append":
                                that._items.push.apply(that._items, items);
                                break;
                            case "update":
                                var prevIndex = -1,
                                    rowIndices = change.rowIndices.slice(0),
                                    rowIndexCorrection = 0;
                                rowIndices.sort(function(a, b) {
                                    return a - b
                                });
                                for (var i = 0; i < rowIndices.length; i++) {
                                    if (rowIndices[i] < 0) {
                                        rowIndices.splice(i, 1);
                                        i--
                                    }
                                }
                                change.items = [];
                                change.rowIndices = [];
                                change.changeTypes = [];
                                var equalItems = function(item1, item2, strict) {
                                    var result = item1 && item2 && equalKeys(item1.key, item2.key);
                                    if (result && strict) {
                                        result = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing)
                                    }
                                    return result
                                };
                                $.each(rowIndices, function(index, rowIndex) {
                                    var oldItem, newItem, oldNextItem, newNextItem, strict;
                                    rowIndex += rowIndexCorrection;
                                    if (prevIndex === rowIndex) {
                                        return
                                    }
                                    prevIndex = rowIndex;
                                    oldItem = that._items[rowIndex];
                                    oldNextItem = that._items[rowIndex + 1];
                                    newItem = items[rowIndex];
                                    newNextItem = items[rowIndex + 1];
                                    strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
                                    if (newItem) {
                                        change.items.push(newItem)
                                    }
                                    if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
                                        changeType = "update";
                                        that._items[rowIndex] = newItem;
                                        if (oldItem.visible !== newItem.visible) {
                                            change.items.splice(-1, 1, {
                                                visible: newItem.visible
                                            })
                                        }
                                    } else {
                                        if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
                                            changeType = "insert";
                                            that._items.splice(rowIndex, 0, newItem);
                                            rowIndexCorrection++
                                        } else {
                                            if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
                                                changeType = "remove";
                                                that._items.splice(rowIndex, 1);
                                                rowIndexCorrection--;
                                                prevIndex = -1
                                            } else {
                                                if (newItem) {
                                                    changeType = "update";
                                                    that._items[rowIndex] = newItem
                                                } else {
                                                    return
                                                }
                                            }
                                        }
                                    }
                                    change.rowIndices.push(rowIndex);
                                    change.changeTypes.push(changeType)
                                });
                                break;
                            default:
                                that._items = items.slice(0)
                        }
                        $.each(that._items, function(index, item) {
                            item.rowIndex = index
                        })
                    } else {
                        that._items = []
                    }
                },
                updateItems: function(change) {
                    change = change || {};
                    var that = this;
                    if (that._updateLockCount) {
                        that._changes.push(change);
                        return
                    }
                    that._updateItemsCore(change);
                    commonUtils.deferRender(function() {
                        that.changed.fire(change)
                    })
                },
                isLoading: function() {
                    return this._isLoading || this._isCustomLoading
                },
                _fireLoadingChanged: function(messageText) {
                    this.loadingChanged.fire(this.isLoading(), messageText)
                },
                _calculateAdditionalFilter: function() {
                    return null
                },
                _applyFilter: function() {
                    var that = this,
                        dataSource = that._dataSource;
                    if (dataSource) {
                        dataSource.pageIndex(0);
                        return that.reload().done(that.pageChanged.fire.bind(that.pageChanged))
                    }
                },
                filter: function(filterExpr) {
                    var dataSource = this._dataSource,
                        filter = dataSource.filter();
                    if (0 === arguments.length) {
                        return dataSource ? dataSource.filter() : void 0
                    }
                    filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                    if (gridCoreUtils.equalFilterParameters(filter, filterExpr)) {
                        return
                    }
                    if (dataSource) {
                        dataSource.filter(filterExpr)
                    }
                    this._applyFilter()
                },
                clearFilter: function(filterName) {
                    var that = this,
                        columnsController = that._columnsController,
                        clearColumnOption = function(optionName) {
                            var index, columnCount = columnsController.columnCount();
                            for (index = 0; index < columnCount; index++) {
                                columnsController.columnOption(index, optionName, void 0)
                            }
                        };
                    that.component.beginUpdate();
                    if (arguments.length > 0) {
                        switch (filterName) {
                            case "dataSource":
                                that.filter(null);
                                break;
                            case "search":
                                that.searchByText("");
                                break;
                            case "header":
                                clearColumnOption("filterValues");
                                break;
                            case "row":
                                clearColumnOption("filterValue")
                        }
                    } else {
                        that.filter(null);
                        that.searchByText("");
                        clearColumnOption("filterValue");
                        clearColumnOption("filterValues")
                    }
                    that.component.endUpdate()
                },
                _fireDataSourceChanged: function() {
                    var that = this;
                    var changedHandler = function() {
                        that.changed.remove(changedHandler);
                        that.dataSourceChanged.fire()
                    };
                    that.changed.add(changedHandler)
                },
                _getDataSourceAdapter: commonUtils.noop,
                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                    var dataSourceAdapterProvider = this._getDataSourceAdapter(),
                        dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
                    dataSourceAdapter.init(dataSource, remoteOperations);
                    return dataSourceAdapter
                },
                isLocalStore: function(store) {
                    store = store || this.store();
                    return store instanceof ArrayStore
                },
                isCustomStore: function(store) {
                    store = store || this.store();
                    return store instanceof CustomStore
                },
                _createDataSourceAdapter: function(dataSource) {
                    var remoteOperations = this.option("remoteOperations"),
                        store = dataSource.store(),
                        enabledRemoteOperations = {
                            filtering: true,
                            sorting: true,
                            paging: true,
                            grouping: true,
                            summary: true
                        };
                    if (remoteOperations && remoteOperations.groupPaging) {
                        remoteOperations = extend({}, enabledRemoteOperations, remoteOperations)
                    }
                    if ("auto" === remoteOperations) {
                        remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
                            filtering: true,
                            sorting: true,
                            paging: true
                        }
                    }
                    if (true === remoteOperations) {
                        remoteOperations = enabledRemoteOperations
                    }
                    return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                },
                setDataSource: function(dataSource) {
                    var that = this,
                        oldDataSource = that._dataSource;
                    if (!dataSource && oldDataSource) {
                        oldDataSource.changed.remove(that._dataChangedHandler);
                        oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
                        oldDataSource.loadError.remove(that._loadErrorHandler);
                        oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
                        oldDataSource.dispose(that._isSharedDataSource)
                    }
                    if (dataSource) {
                        dataSource = that._createDataSourceAdapter(dataSource)
                    }
                    that._dataSource = dataSource;
                    if (dataSource) {
                        that._fireDataSourceChanged();
                        that._isLoading = !dataSource.isLoaded();
                        that._needApplyFilter = true;
                        dataSource.changed.add(that._dataChangedHandler);
                        dataSource.loadingChanged.add(that._loadingChangedHandler);
                        dataSource.loadError.add(that._loadErrorHandler);
                        dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler)
                    }
                },
                items: function() {
                    return this._items
                },
                isEmpty: function() {
                    return !this.items().length
                },
                pageCount: function() {
                    return this._dataSource ? this._dataSource.pageCount() : 1
                },
                dataSource: function() {
                    return this._dataSource
                },
                store: function() {
                    var dataSource = this._dataSource;
                    return dataSource && dataSource.store()
                },
                loadAll: function(data) {
                    var that = this,
                        d = $.Deferred(),
                        dataSource = that._dataSource;
                    if (dataSource) {
                        if (data) {
                            var options = {
                                data: data,
                                isCustomLoading: true,
                                storeLoadOptions: {},
                                loadOptions: {
                                    group: dataSource.group(),
                                    sort: dataSource.sort()
                                }
                            };
                            dataSource._handleDataLoaded(options);
                            when(options.data).done(function(data) {
                                d.resolve(that._processItems(data, "loadingAll"), options.extra && options.extra.summary)
                            }).fail(d.reject)
                        } else {
                            if (!that.isLoading()) {
                                var loadOptions = extend({}, dataSource.loadOptions(), {
                                    isLoadingAll: true,
                                    requireTotalCount: false
                                });
                                dataSource.load(loadOptions).done(function(items, extra) {
                                    items = that._processItems(items.slice(0), "loadingAll");
                                    d.resolve(items, extra && extra.summary)
                                }).fail(d.reject)
                            } else {
                                d.reject()
                            }
                        }
                    } else {
                        d.resolve([])
                    }
                    return d
                },
                getKeyByRowIndex: function(rowIndex) {
                    var item = this.items()[rowIndex];
                    if (item) {
                        return item.key
                    }
                },
                getRowIndexByKey: function(key) {
                    return gridCoreUtils.getIndexByKey(key, this.items())
                },
                keyOf: function(data) {
                    var store = this.store();
                    if (store) {
                        return store.keyOf(data)
                    }
                },
                byKey: function(key) {
                    var result, store = this.store(),
                        rowIndex = this.getRowIndexByKey(key);
                    if (!store) {
                        return
                    }
                    if (rowIndex >= 0) {
                        result = $.Deferred().resolve(this.items()[rowIndex].data)
                    }
                    return result || store.byKey(key)
                },
                key: function() {
                    var store = this.store();
                    if (store) {
                        return store.key()
                    }
                },
                getRowIndexOffset: function() {
                    return 0
                },
                getDataByKeys: function(rowKeys) {
                    var that = this,
                        result = $.Deferred(),
                        deferreds = [],
                        data = [];
                    $.each(rowKeys, function(index, key) {
                        deferreds.push(that.byKey(key).done(function(keyData) {
                            data[index] = keyData
                        }))
                    });
                    when.apply($, deferreds).always(function() {
                        result.resolve(data)
                    });
                    return result
                },
                pageIndex: function(value) {
                    var that = this,
                        pagingOptions = that.option("paging"),
                        dataSource = that._dataSource;
                    if (dataSource) {
                        if (void 0 !== value) {
                            if (dataSource.pageIndex() !== value) {
                                dataSource.pageIndex(value);
                                if (pagingOptions) {
                                    pagingOptions.pageIndex = value
                                }
                                return dataSource.load().done(that.pageChanged.fire.bind(that.pageChanged))
                            }
                        }
                        return dataSource.pageIndex()
                    }
                    return 0
                },
                pageSize: function(value) {
                    var that = this,
                        pagingOptions = that.option("paging"),
                        dataSource = that._dataSource;
                    if (void 0 === value) {
                        return dataSource ? dataSource.pageSize() : 0
                    }
                    if (dataSource) {
                        if (dataSource.pageSize() !== value) {
                            dataSource.pageIndex(0);
                            dataSource.pageSize(value);
                            if (pagingOptions) {
                                pagingOptions.pageSize = value
                            }
                            return dataSource.reload().done(that.pageChanged.fire.bind(that.pageChanged))
                        }
                    }
                },
                beginCustomLoading: function(messageText) {
                    this._isCustomLoading = true;
                    this._fireLoadingChanged(messageText || "")
                },
                endCustomLoading: function() {
                    this._isCustomLoading = false;
                    this._fireLoadingChanged()
                },
                refresh: function() {
                    var that = this,
                        d = $.Deferred();
                    when(this._columnsController.refresh()).always(function() {
                        when(that.reload(true)).done(d.resolve).fail(d.reject)
                    });
                    return d
                },
                getVisibleRows: function() {
                    return this.items()
                },
                _disposeDataSource: function() {
                    this.setDataSource(null)
                },
                repaintRows: function(rowIndexes) {
                    rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
                    if (rowIndexes.length > 1 || commonUtils.isDefined(rowIndexes[0])) {
                        this.updateItems({
                            changeType: "update",
                            rowIndices: rowIndexes
                        })
                    }
                }
            };
            gridCoreUtils.proxyMethod(members, "load");
            gridCoreUtils.proxyMethod(members, "reload");
            gridCoreUtils.proxyMethod(members, "itemsCount", 0);
            gridCoreUtils.proxyMethod(members, "totalItemsCount", 0);
            gridCoreUtils.proxyMethod(members, "hasKnownLastPage", true);
            gridCoreUtils.proxyMethod(members, "isLoaded", true);
            gridCoreUtils.proxyMethod(members, "totalCount", 0);
            return members
        }())
    }
};


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.sorting.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    clickEvent = __webpack_require__(11),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    sortingMixin = __webpack_require__(354),
    messageLocalization = __webpack_require__(8),
    eventUtils = __webpack_require__(3);
var COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
var ColumnHeadersViewSortingExtender = extend({}, sortingMixin, {
    _createRow: function(row) {
        var that = this,
            $row = that.callBase(row);
        if ("header" === row.rowType) {
            $row.on(eventUtils.addNamespace(clickEvent.name, COLUMN_HEADERS_VIEW_NAMESPACE), "> td", that.createAction(function(e) {
                var keyName = null,
                    event = e.jQueryEvent,
                    $cellElementFromEvent = $(event.currentTarget),
                    rowIndex = $cellElementFromEvent.parent().index(),
                    columnIndex = $.map(that.getCellElements(rowIndex), function($cellElement, index) {
                        if ($cellElement === $cellElementFromEvent.get(0)) {
                            return index
                        }
                    })[0],
                    visibleColumns = that._columnsController.getVisibleColumns(rowIndex),
                    column = visibleColumns[columnIndex],
                    editingController = that.getController("editing"),
                    editingMode = that.option("editing.mode"),
                    isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
                if (isCellEditing || !that._isSortableElement($(event.target))) {
                    return
                }
                if (column && !commonUtils.isDefined(column.groupIndex) && !column.command) {
                    if (event.shiftKey) {
                        keyName = "shift"
                    } else {
                        if (event.ctrlKey) {
                            keyName = "ctrl"
                        }
                    }
                    setTimeout(function() {
                        that._columnsController.changeSortOrder(column.index, keyName)
                    })
                }
            }))
        }
        return $row
    },
    _renderCellContent: function($cell, options) {
        var that = this,
            column = options.column;
        if (!column.command && "header" === options.rowType) {
            that._applyColumnState({
                name: "sort",
                rootElement: $cell,
                column: column,
                showColumnLines: that.option("showColumnLines")
            })
        }
        that.callBase($cell, options)
    },
    _columnOptionChanged: function(e) {
        var changeTypes = e.changeTypes;
        if (1 === changeTypes.length && changeTypes.sorting) {
            this._updateIndicators("sort");
            return
        }
        this.callBase(e)
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "sorting":
                that._invalidate();
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
var HeaderPanelSortingExtender = extend({}, sortingMixin, {
    _createGroupPanelItem: function($rootElement, groupColumn) {
        var that = this,
            $item = that.callBase.apply(that, arguments);
        $item.on(eventUtils.addNamespace(clickEvent.name, "dxDataGridHeaderPanel"), that.createAction(function() {
            setTimeout(function() {
                that.getController("columns").changeSortOrder(groupColumn.index)
            })
        }));
        that._applyColumnState({
            name: "sort",
            rootElement: $item,
            column: {
                alignment: that.option("rtlEnabled") ? "right" : "left",
                allowSorting: groupColumn.allowSorting,
                sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc"
            },
            showColumnLines: true
        });
        return $item
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "sorting":
                that._invalidate();
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            sorting: {
                mode: "single",
                ascendingText: messageLocalization.format("dxDataGrid-sortingAscendingText"),
                descendingText: messageLocalization.format("dxDataGrid-sortingDescendingText"),
                clearText: messageLocalization.format("dxDataGrid-sortingClearText")
            }
        }
    },
    extenders: {
        views: {
            columnHeadersView: ColumnHeadersViewSortingExtender,
            headerPanel: HeaderPanelSortingExtender
        }
    }
};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.rows.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    stringUtils = __webpack_require__(30),
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    compileGetter = __webpack_require__(14).compileGetter,
    gridCoreUtils = __webpack_require__(26),
    columnsView = __webpack_require__(101),
    Scrollable = __webpack_require__(70),
    removeEvent = __webpack_require__(86),
    messageLocalization = __webpack_require__(8),
    isDefined = commonUtils.isDefined;
var ROWS_VIEW_CLASS = "rowsview",
    CONTENT_CLASS = "content",
    NOWRAP_CLASS = "nowrap",
    GROUP_ROW_CLASS = "dx-group-row",
    GROUP_CELL_CLASS = "dx-group-cell",
    DATA_ROW_CLASS = "dx-data-row",
    FREE_SPACE_CLASS = "dx-freespace-row",
    ROW_LINES_CLASS = "dx-row-lines",
    COLUMN_LINES_CLASS = "dx-column-lines",
    ROW_ALTERNATION_CLASS = "dx-row-alt",
    LAST_ROW_BORDER = "dx-last-row-border",
    LOADPANEL_HIDE_TIMEOUT = 200;
module.exports = {
    defaultOptions: function() {
        return {
            hoverStateEnabled: false,
            scrolling: {
                useNative: "auto"
            },
            loadPanel: {
                enabled: "auto",
                text: messageLocalization.format("Loading"),
                width: 200,
                height: 90,
                showIndicator: true,
                indicatorSrc: "",
                showPane: true
            },
            rowTemplate: null,
            columnAutoWidth: false,
            noDataText: messageLocalization.format("dxDataGrid-noDataText"),
            wordWrapEnabled: false,
            showColumnLines: true,
            showRowLines: false,
            rowAlternationEnabled: false,
            activeStateEnabled: false,
            twoWayBindingEnabled: true
        }
    },
    views: {
        rowsView: columnsView.ColumnsView.inherit(function() {
            var appendFreeSpaceRowTemplate = {
                render: function(options) {
                    var $tbody = options.container.find("tbody");
                    if ($tbody.length) {
                        $tbody.last().append(options.content)
                    } else {
                        options.container.append(options.content)
                    }
                }
            };
            return {
                _getDefaultTemplate: function(column) {
                    switch (column.command) {
                        case "empty":
                            return function(container) {
                                container.html("&nbsp;")
                            };
                        default:
                            return function($container, options) {
                                var isDataTextEmpty = stringUtils.isEmpty(options.text) && "data" === options.rowType,
                                    text = isDataTextEmpty ? "&nbsp;" : options.text,
                                    container = $container.get(0);
                                if (column.encodeHtml && !isDataTextEmpty) {
                                    container.textContent = text
                                } else {
                                    container.innerHTML = text
                                }
                            }
                    }
                },
                _getDefaultGroupTemplate: function(column) {
                    var that = this,
                        summaryTexts = that.option("summary.texts");
                    return function($container, options) {
                        var data = options.data,
                            text = options.column.caption + ": " + options.text,
                            container = $container.get(0);
                        if (options.summaryItems && options.summaryItems.length) {
                            text += " " + gridCoreUtils.getGroupRowSummaryText(options.summaryItems, summaryTexts)
                        }
                        if (data) {
                            if (options.groupContinuedMessage && options.groupContinuesMessage) {
                                text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")"
                            } else {
                                if (options.groupContinuesMessage) {
                                    text += " (" + options.groupContinuesMessage + ")"
                                } else {
                                    if (options.groupContinuedMessage) {
                                        text += " (" + options.groupContinuedMessage + ")"
                                    }
                                }
                            }
                        }
                        $container.addClass(GROUP_CELL_CLASS);
                        if (column.encodeHtml) {
                            container.textContent = text
                        } else {
                            container.innerHTML = text
                        }
                    }
                },
                _update: function() {},
                _getCellTemplate: function(options) {
                    var template, that = this,
                        column = options.column;
                    if ("group" === options.rowType && isDefined(column.groupIndex) && !column.showWhenGrouped) {
                        template = column.groupCellTemplate || {
                            allowRenderToDetachedContainer: true,
                            render: that._getDefaultGroupTemplate(column)
                        }
                    } else {
                        template = column.cellTemplate || {
                            allowRenderToDetachedContainer: true,
                            render: that._getDefaultTemplate(column)
                        }
                    }
                    return template
                },
                _createRow: function(row) {
                    var isGroup, isDataRow, isRowExpanded, $row = this.callBase(row);
                    if (row) {
                        isGroup = "group" === row.rowType;
                        isDataRow = "data" === row.rowType;
                        isDataRow && $row.addClass(DATA_ROW_CLASS);
                        isDataRow && row.dataIndex % 2 === 1 && this.option("rowAlternationEnabled") && $row.addClass(ROW_ALTERNATION_CLASS);
                        isDataRow && this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS);
                        this.option("showColumnLines") && $row.addClass(COLUMN_LINES_CLASS);
                        if (false === row.visible) {
                            $row.hide()
                        }
                        if (isGroup) {
                            $row.addClass(GROUP_ROW_CLASS);
                            isRowExpanded = row.isExpanded;
                            this.setAria("role", "rowgroup", $row);
                            this.setAria("expanded", isDefined(isRowExpanded) && isRowExpanded.toString(), $row)
                        }
                    }
                    return $row
                },
                _afterRowPrepared: function(e) {
                    var arg = e.args[0],
                        dataController = this._dataController,
                        watch = this.option("integrationOptions.watchMethod");
                    if (!arg.data || "data" !== arg.rowType || arg.inserted || !this.option("twoWayBindingEnabled") || !watch) {
                        return
                    }
                    var dispose = watch(function() {
                        return dataController.generateDataValues(arg.data, arg.columns)
                    }, function() {
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [arg.rowIndex]
                        })
                    }, {
                        deep: true,
                        skipImmediate: true
                    });
                    arg.rowElement.on(removeEvent, dispose)
                },
                _renderScrollable: function(force) {
                    var that = this,
                        $element = that.element();
                    if (!$element.children().length) {
                        $element.append("<div />")
                    }
                    if (force || !that._loadPanel) {
                        that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore())
                    }
                    if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
                        var columns = that.getColumns(),
                            allColumnsHasWidth = true;
                        for (var i = 0; i < columns.length; i++) {
                            if (!columns[i].width && !columns[i].minWidth) {
                                allColumnsHasWidth = false;
                                break
                            }
                        }
                        if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
                            that._renderScrollableCore($element)
                        }
                    }
                },
                _handleScroll: function(e) {
                    var that = this;
                    that._isScrollByEvent = !!e.jQueryEvent;
                    that._scrollTop = e.scrollOffset.top;
                    that._scrollLeft = e.scrollOffset.left;
                    that.scrollChanged.fire(e.scrollOffset, that.name)
                },
                _renderScrollableCore: function($element) {
                    var that = this,
                        dxScrollableOptions = that._createScrollableOptions(),
                        scrollHandler = that._handleScroll.bind(that);
                    dxScrollableOptions.onScroll = scrollHandler;
                    dxScrollableOptions.onStop = scrollHandler;
                    that._scrollable = that._createComponent($element, Scrollable, dxScrollableOptions);
                    that._scrollableContainer = that._scrollable && that._scrollable._$container
                },
                _renderLoadPanel: gridCoreUtils.renderLoadPanel,
                _renderContent: function(contentElement, tableElement) {
                    contentElement.replaceWith($("<div>").addClass(this.addWidgetPrefix(CONTENT_CLASS)).append(tableElement));
                    return this._findContentElement()
                },
                _updateContent: function(newTableElement, change) {
                    var that = this,
                        tableElement = that._getTableElement(),
                        contentElement = that._findContentElement(),
                        changeType = change && change.changeType,
                        executors = [];
                    switch (changeType) {
                        case "update":
                            $.each(change.rowIndices, function(index, rowIndex) {
                                var $newRowElement = that._getRowElements(newTableElement).eq(index),
                                    changeType = change.changeTypes[index],
                                    item = change.items && change.items[index];
                                executors.push(function() {
                                    var $rowsElement = that._getRowElements(),
                                        $rowElement = $rowsElement.eq(rowIndex);
                                    switch (changeType) {
                                        case "update":
                                            if (item) {
                                                if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
                                                    $rowElement.toggle(item.visible)
                                                } else {
                                                    $rowElement.replaceWith($newRowElement)
                                                }
                                            }
                                            break;
                                        case "insert":
                                            if (!$rowsElement.length) {
                                                $newRowElement.prependTo(tableElement)
                                            } else {
                                                if ($rowElement.length) {
                                                    $newRowElement.insertBefore($rowElement)
                                                } else {
                                                    $newRowElement.insertAfter($rowsElement.last())
                                                }
                                            }
                                            break;
                                        case "remove":
                                            $rowElement.remove()
                                    }
                                })
                            });
                            $.each(executors, function() {
                                this()
                            });
                            newTableElement.remove();
                            break;
                        default:
                            that._setTableElement(newTableElement);
                            contentElement.addClass(that.addWidgetPrefix(CONTENT_CLASS));
                            that._renderContent(contentElement, newTableElement)
                    }
                },
                _renderFreeSpaceRow: function(tableElement) {
                    var i, that = this,
                        freeSpaceRowElement = that._createRow(),
                        columns = this.getColumns();
                    freeSpaceRowElement.addClass(FREE_SPACE_CLASS).toggleClass(COLUMN_LINES_CLASS, that.option("showColumnLines"));
                    for (i = 0; i < columns.length; i++) {
                        freeSpaceRowElement.append(that._createCell({
                            column: columns[i],
                            rowType: "freeSpace"
                        }))
                    }
                    that._appendRow(tableElement, freeSpaceRowElement, appendFreeSpaceRowTemplate)
                },
                _needUpdateRowHeight: function(itemsCount) {
                    return itemsCount > 0 && !this._rowHeight
                },
                _getRowsHeight: function($tableElement) {
                    var $rowElements = $tableElement.children("tbody").children().not("." + FREE_SPACE_CLASS);
                    return $rowElements.toArray().reduce(function(sum, row) {
                        return sum + row.offsetHeight
                    }, 0)
                },
                _updateRowHeight: function() {
                    var rowsHeight, that = this,
                        $tableElement = that._getTableElement(),
                        itemsCount = that._dataController.items().length;
                    if ($tableElement && that._needUpdateRowHeight(itemsCount)) {
                        rowsHeight = that._getRowsHeight($tableElement);
                        that._rowHeight = rowsHeight / itemsCount
                    }
                },
                _findContentElement: function() {
                    var $content = this.element(),
                        scrollable = this.getScrollable();
                    if ($content) {
                        if (scrollable) {
                            $content = scrollable.content()
                        }
                        return $content.children().first()
                    }
                },
                _getRowElements: function(tableElement) {
                    var $rows = this.callBase(tableElement);
                    return $rows && $rows.not("." + FREE_SPACE_CLASS)
                },
                _getFreeSpaceRowElements: function($table) {
                    var tableElements = $table || this.getTableElements();
                    return tableElements && tableElements.children("tbody").children("." + FREE_SPACE_CLASS)
                },
                _getNoDataText: function() {
                    return this.option("noDataText")
                },
                _rowClick: function(e) {
                    var item = this._dataController.items()[e.rowIndex] || {};
                    this.executeAction("onRowClick", extend({
                        evaluate: function(expr) {
                            var getter = compileGetter(expr);
                            return getter(item.data)
                        }
                    }, e, item))
                },
                _getGroupCellOptions: function(options) {
                    var columnIndex = (options.row.groupIndex || 0) + options.columnsCountBeforeGroups;
                    return {
                        columnIndex: columnIndex,
                        colspan: options.columns.length - columnIndex - 1
                    }
                },
                _renderCells: function($row, options) {
                    if ("group" === options.row.rowType) {
                        this._renderGroupedCells($row, options)
                    } else {
                        if (options.row.values) {
                            this.callBase($row, options)
                        }
                    }
                },
                _renderGroupedCells: function($row, options) {
                    var i, isExpanded, groupColumn, groupColumnAlignment, row = options.row,
                        columns = options.columns,
                        rowIndex = row.rowIndex,
                        groupCellOptions = this._getGroupCellOptions(options);
                    for (i = 0; i <= groupCellOptions.columnIndex; i++) {
                        if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && "infinite" !== options.scrollingMode) {
                            isExpanded = !!row.isExpanded
                        } else {
                            isExpanded = null
                        }
                        this._renderCell($row, {
                            value: isExpanded,
                            row: row,
                            rowIndex: rowIndex,
                            column: {
                                command: "expand",
                                cssClass: columns[i].cssClass
                            },
                            columnIndex: i
                        })
                    }
                    groupColumnAlignment = getDefaultAlignment(this.option("rtlEnabled"));
                    groupColumn = extend({}, columns[groupCellOptions.columnIndex], {
                        command: null,
                        cssClass: null,
                        showWhenGrouped: false,
                        alignment: groupColumnAlignment
                    });
                    if (groupCellOptions.colspan > 1) {
                        groupColumn.colspan = groupCellOptions.colspan
                    }
                    this._renderCell($row, {
                        value: row.values[row.groupIndex],
                        row: row,
                        rowIndex: rowIndex,
                        column: groupColumn,
                        columnIndex: groupCellOptions.columnIndex
                    })
                },
                _renderRows: function($table, options) {
                    var i, that = this,
                        columns = options.columns,
                        columnsCountBeforeGroups = 0,
                        scrollingMode = that.option("scrolling.mode");
                    for (i = 0; i < columns.length; i++) {
                        if ("expand" === columns[i].command) {
                            columnsCountBeforeGroups = i;
                            break
                        }
                    }
                    that.callBase($table, extend({
                        scrollingMode: scrollingMode,
                        columnsCountBeforeGroups: columnsCountBeforeGroups
                    }, options));
                    that._renderFreeSpaceRow($table);
                    if (!that._hasHeight) {
                        that.updateFreeSpaceRowHeight($table)
                    }
                },
                _renderRow: function($table, options) {
                    var that = this,
                        row = options.row,
                        rowTemplate = that.option("rowTemplate");
                    if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
                        that.renderTemplate($table, rowTemplate, extend({
                            columns: options.columns
                        }, row), true)
                    } else {
                        that.callBase($table, options)
                    }
                },
                _renderTable: function(options) {
                    var that = this,
                        $table = that.callBase(options),
                        resizeCompletedHandler = function() {
                            var scrollableInstance = that.getScrollable();
                            if (scrollableInstance && that.element().closest(document).length) {
                                that.resizeCompleted.remove(resizeCompletedHandler);
                                scrollableInstance._visibilityChanged(true)
                            }
                        };
                    if (!isDefined(that._getTableElement())) {
                        that._setTableElement($table);
                        that._renderScrollable(true);
                        that.resizeCompleted.add(resizeCompletedHandler)
                    } else {
                        that._renderScrollable()
                    }
                    return $table
                },
                _createTable: function() {
                    var $table = this.callBase.apply(this, arguments);
                    if (this.option("rowTemplate")) {
                        $table.appendTo(this.component.element())
                    }
                    return $table
                },
                _renderCore: function(change) {
                    var $table, that = this,
                        $element = that.element();
                    $element.addClass(that.addWidgetPrefix(ROWS_VIEW_CLASS)).toggleClass(that.addWidgetPrefix(NOWRAP_CLASS), !that.option("wordWrapEnabled"));
                    $table = that._renderTable({
                        change: change
                    });
                    that._updateContent($table, change);
                    that.callBase(change);
                    that._lastColumnWidths = null
                },
                _getRows: function(change) {
                    return change && change.items || this._dataController.items()
                },
                _getCellOptions: function(options) {
                    var parameters, groupingTextsOptions, scrollingMode, that = this,
                        column = options.column,
                        row = options.row,
                        data = row.data,
                        summaryCells = row && row.summaryCells,
                        value = options.value,
                        displayValue = gridCoreUtils.getDisplayValue(column, value, data, row.rowType);
                    parameters = this.callBase(options);
                    parameters.value = value;
                    parameters.displayValue = displayValue;
                    parameters.row = row;
                    parameters.key = row.key;
                    parameters.data = data;
                    parameters.rowType = row.rowType;
                    parameters.values = row.values;
                    parameters.text = !column.command ? gridCoreUtils.formatValue(displayValue, column) : "";
                    parameters.rowIndex = row.rowIndex;
                    parameters.summaryItems = summaryCells && summaryCells[options.columnIndex];
                    parameters.resized = column.resizedCallbacks;
                    if (isDefined(column.groupIndex)) {
                        groupingTextsOptions = that.option("grouping.texts");
                        scrollingMode = that.option("scrolling.mode");
                        if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                            parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
                            parameters.groupContinuedMessage = data && data.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage
                        }
                    }
                    return parameters
                },
                renderNoDataText: gridCoreUtils.renderNoDataText,
                getCellOptions: function(rowIndex, columnIdentifier) {
                    var cellOptions, column, rowOptions = this._dataController.items()[rowIndex];
                    if (rowOptions) {
                        column = this._columnsController.columnOption(columnIdentifier);
                        if (column) {
                            cellOptions = this._getCellOptions({
                                value: column.calculateCellValue(rowOptions.data),
                                rowIndex: rowOptions.rowIndex,
                                row: rowOptions,
                                column: column
                            })
                        }
                    }
                    return cellOptions
                },
                getRow: function(index) {
                    var rows = this._getRowElements();
                    if (rows.length > index) {
                        return $(rows[index])
                    }
                },
                getCellIndex: function($cell) {
                    var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
                    return cellIndex
                },
                updateFreeSpaceRowHeight: function($table) {
                    var freeSpaceRowCount, scrollingMode, that = this,
                        itemCount = that._dataController.items().length,
                        contentElement = that._findContentElement(),
                        freeSpaceRowElements = that._getFreeSpaceRowElements($table);
                    if (freeSpaceRowElements && contentElement) {
                        var isFreeSpaceRowVisible = false;
                        if (itemCount > 0) {
                            if (!that._hasHeight) {
                                freeSpaceRowCount = that._dataController.pageSize() - itemCount;
                                scrollingMode = that.option("scrolling.mode");
                                if (freeSpaceRowCount > 0 && that._dataController.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                                    freeSpaceRowElements.height(freeSpaceRowCount * that._rowHeight);
                                    isFreeSpaceRowVisible = true
                                }
                                if (!isFreeSpaceRowVisible && $table) {
                                    freeSpaceRowElements.height(0)
                                } else {
                                    freeSpaceRowElements.css("display", isFreeSpaceRowVisible ? "" : "none")
                                }
                                that._updateLastRowBorder(isFreeSpaceRowVisible)
                            } else {
                                freeSpaceRowElements.css("display", "none");
                                commonUtils.deferUpdate(function() {
                                    var scrollbarWidth = that.getScrollbarWidth(true),
                                        elementHeightWithoutScrollbar = that.element().height() - scrollbarWidth,
                                        contentHeight = contentElement.outerHeight(),
                                        showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0,
                                        rowsHeight = that._getRowsHeight(contentElement.children().first()),
                                        resultHeight = elementHeightWithoutScrollbar - rowsHeight;
                                    if (showFreeSpaceRow) {
                                        commonUtils.deferRender(function() {
                                            freeSpaceRowElements.height(resultHeight);
                                            isFreeSpaceRowVisible = true;
                                            freeSpaceRowElements.css("display", "")
                                        })
                                    }
                                    commonUtils.deferRender(function() {
                                        that._updateLastRowBorder(isFreeSpaceRowVisible)
                                    })
                                })
                            }
                        } else {
                            freeSpaceRowElements.height(0);
                            freeSpaceRowElements.css("display", "");
                            that._updateLastRowBorder(true)
                        }
                    }
                },
                _columnOptionChanged: function(e) {
                    var optionNames = e.optionNames;
                    if (e.changeTypes.grouping) {
                        return
                    }
                    if (optionNames.width || optionNames.visibleWidth) {
                        this.callBase(e);
                        this._fireColumnResizedCallbacks()
                    }
                },
                getScrollable: function() {
                    return this._scrollable
                },
                init: function() {
                    var that = this,
                        dataController = that.getController("data");
                    that.callBase();
                    that._editorFactoryController = that.getController("editorFactory");
                    that._rowHeight = 0;
                    that._scrollTop = 0;
                    that._scrollLeft = -1;
                    that._hasHeight = false;
                    dataController.loadingChanged.add(function(isLoading, messageText) {
                        that.setLoading(isLoading, messageText)
                    });
                    dataController.dataSourceChanged.add(function() {
                        that._handleScroll({
                            scrollOffset: {
                                top: that._scrollTop,
                                left: that._scrollLeft
                            }
                        })
                    })
                },
                _handleDataChanged: function(change) {
                    var that = this;
                    switch (change.changeType) {
                        case "refresh":
                        case "prepend":
                        case "append":
                        case "update":
                            that.render(null, change);
                            break;
                        default:
                            that._update(change)
                    }
                },
                publicMethods: function() {
                    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"]
                },
                contentWidth: function() {
                    return this.element().width() - this.getScrollbarWidth()
                },
                getScrollbarWidth: function(isHorizontal) {
                    var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
                        scrollbarWidth = 0;
                    if (scrollableContainer) {
                        if (!isHorizontal) {
                            scrollbarWidth = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0
                        } else {
                            scrollbarWidth = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0
                        }
                    }
                    return scrollbarWidth > 0 ? scrollbarWidth : 0
                },
                _fireColumnResizedCallbacks: function() {
                    var i, that = this,
                        lastColumnWidths = that._lastColumnWidths || [],
                        columnWidths = [],
                        columns = that.getColumns();
                    for (i = 0; i < columns.length; i++) {
                        columnWidths[i] = columns[i].visibleWidth;
                        if (columns[i].resizedCallbacks && !isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
                            columns[i].resizedCallbacks.fire(columnWidths[i])
                        }
                    }
                    that._lastColumnWidths = columnWidths
                },
                _updateLastRowBorder: function(isFreeSpaceRowVisible) {
                    if (this.option("showBorders") && this.option("showRowLines") && !isFreeSpaceRowVisible) {
                        this.element().addClass(LAST_ROW_BORDER)
                    } else {
                        this.element().removeClass(LAST_ROW_BORDER)
                    }
                },
                _updateScrollable: function() {
                    var dxScrollable = Scrollable.getInstance(this.element());
                    if (dxScrollable) {
                        dxScrollable.update();
                        this._updateHorizontalScrollPosition()
                    }
                },
                _updateHorizontalScrollPosition: function() {
                    var scrollable = this.getScrollable(),
                        scrollLeft = scrollable && scrollable.scrollOffset().left;
                    if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
                        scrollable.scrollTo({
                            x: this._scrollLeft
                        })
                    }
                },
                _resizeCore: function() {
                    var that = this;
                    that._fireColumnResizedCallbacks();
                    that._updateRowHeight();
                    commonUtils.deferRender(function() {
                        that._renderScrollable();
                        that.renderNoDataText();
                        that.updateFreeSpaceRowHeight()
                    });
                    that._updateScrollable();
                    that.setLoading(that._dataController.isLoading())
                },
                scrollTo: function(location) {
                    var $element = this.element(),
                        dxScrollable = $element && Scrollable.getInstance($element);
                    if (dxScrollable) {
                        dxScrollable.scrollTo(location)
                    }
                },
                height: function(height, hasHeight) {
                    var that = this,
                        $element = this.element();
                    if (isDefined(height)) {
                        that._hasHeight = void 0 === hasHeight ? "auto" !== height : hasHeight;
                        if ($element) {
                            $element.css("height", height)
                        }
                    } else {
                        return $element ? $element.outerHeight(true) : 0
                    }
                },
                setLoading: function(isLoading, messageText) {
                    var visibilityOptions, that = this,
                        loadPanel = that._loadPanel,
                        dataController = that._dataController,
                        loadPanelOptions = that.option("loadPanel") || {},
                        animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
                        $element = that.element();
                    if (!loadPanel && void 0 !== messageText && dataController.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
                        that._renderLoadPanel($element, $element.parent());
                        loadPanel = that._loadPanel
                    }
                    if (loadPanel) {
                        visibilityOptions = {
                            message: messageText || loadPanelOptions.text,
                            animation: animation,
                            visible: isLoading
                        };
                        clearTimeout(that._hideLoadingTimeoutID);
                        if (loadPanel.option("visible") && !isLoading) {
                            that._hideLoadingTimeoutID = setTimeout(function() {
                                loadPanel.option(visibilityOptions)
                            }, LOADPANEL_HIDE_TIMEOUT)
                        } else {
                            loadPanel.option(visibilityOptions)
                        }
                    }
                },
                setRowsOpacity: function(columnIndex, value) {
                    var i, that = this,
                        columnsController = that._columnsController,
                        visibleColumns = that.getColumns(),
                        columns = columnsController.getColumns(),
                        column = columns && columns[columnIndex],
                        columnID = column && column.isBand && column.index,
                        $rows = that._getRowElements().not("." + GROUP_ROW_CLASS) || [];
                    $.each($rows, function(rowIndex, row) {
                        if (!$(row).hasClass(GROUP_ROW_CLASS)) {
                            for (i = 0; i < visibleColumns.length; i++) {
                                if (commonUtils.isNumeric(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
                                    that.getCellElements(rowIndex).eq(i).css({
                                        opacity: value
                                    });
                                    if (!commonUtils.isNumeric(columnID)) {
                                        break
                                    }
                                }
                            }
                        }
                    })
                },
                _getCellElementsCore: function(rowIndex) {
                    var groupCellIndex, $cells = this.callBase(rowIndex);
                    if ($cells) {
                        groupCellIndex = $cells.filter("." + GROUP_CELL_CLASS).index();
                        if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
                            $cells.length = groupCellIndex + 1
                        }
                    }
                    return $cells
                },
                getTopVisibleItemIndex: function() {
                    var rowElements, rowElement, that = this,
                        itemIndex = 0,
                        prevOffsetTop = 0,
                        offsetTop = 0,
                        scrollPosition = that._scrollTop,
                        contentElementOffsetTop = that._findContentElement().offset().top,
                        items = that._dataController.items(),
                        tableElement = that._getTableElement();
                    if (items.length && tableElement) {
                        rowElements = tableElement.children("tbody").children(".dx-row:visible, .dx-error-row").not("." + FREE_SPACE_CLASS);
                        for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            prevOffsetTop = offsetTop;
                            rowElement = rowElements.eq(itemIndex);
                            if (rowElement.length) {
                                offsetTop = rowElement.offset().top - contentElementOffsetTop;
                                if (offsetTop > scrollPosition) {
                                    if (2 * scrollPosition < offsetTop + prevOffsetTop && itemIndex) {
                                        itemIndex--
                                    }
                                    break
                                }
                            }
                        }
                        if (itemIndex && itemIndex === items.length) {
                            itemIndex--
                        }
                    }
                    return itemIndex
                },
                getTopVisibleRowData: function() {
                    var itemIndex = this.getTopVisibleItemIndex(),
                        items = this._dataController.items();
                    if (items[itemIndex]) {
                        return items[itemIndex].data
                    }
                },
                optionChanged: function(args) {
                    var that = this;
                    that.callBase(args);
                    switch (args.name) {
                        case "wordWrapEnabled":
                        case "showColumnLines":
                        case "showRowLines":
                        case "rowAlternationEnabled":
                        case "rowTemplate":
                        case "twoWayBindingEnabled":
                            that._invalidate(true, true);
                            args.handled = true;
                            break;
                        case "scrolling":
                            that._rowHeight = null;
                            that._tableElement = null;
                            args.handled = true;
                            break;
                        case "rtlEnabled":
                            that._rowHeight = null;
                            that._tableElement = null;
                            break;
                        case "loadPanel":
                            that._tableElement = null;
                            that._invalidate(true, true);
                            args.handled = true;
                            break;
                        case "noDataText":
                            that.renderNoDataText();
                            args.handled = true
                    }
                },
                dispose: function() {
                    clearTimeout(this._hideLoadingTimeoutID)
                },
                setScrollerSpacing: function() {}
            }
        }())
    }
};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.context_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    modules = __webpack_require__(23),
    ContextMenu = __webpack_require__(130);
var CONTEXT_MENU = "dx-context-menu",
    viewName = {
        columnHeadersView: "header",
        rowsView: "content",
        footerView: "footer",
        headerPanel: "headerPanel"
    },
    VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
var ContextMenuController = modules.ViewController.inherit({
    init: function() {
        this.createAction("onContextMenuPreparing")
    },
    getContextMenuItems: function(jQueryEvent) {
        if (!jQueryEvent) {
            return false
        }
        var view, options, rowIndex, columnIndex, rowOptions, $element, $targetRowElement, $targetCellElement, menuItems, that = this,
            $targetElement = $(jQueryEvent.target);
        $.each(VIEW_NAMES, function() {
            view = that.getView(this);
            $element = view && view.element();
            if ($element && ($element.is($targetElement) || $element.find($targetElement).length)) {
                $targetCellElement = $targetElement.closest("td");
                $targetRowElement = $targetCellElement.closest(".dx-row");
                rowIndex = view.getRowIndex($targetRowElement);
                columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
                rowOptions = $targetRowElement.data("options");
                options = {
                    jQueryEvent: jQueryEvent,
                    targetElement: $targetElement,
                    target: viewName[this],
                    rowIndex: rowIndex,
                    row: view._getRows()[rowIndex],
                    columnIndex: columnIndex,
                    column: rowOptions && rowOptions.cells[columnIndex].column
                };
                options.items = view.getContextMenuItems && view.getContextMenuItems(options);
                that.executeAction("onContextMenuPreparing", options);
                that._contextMenuPrepared(options);
                menuItems = options.items;
                if (menuItems) {
                    return false
                }
            }
        });
        return menuItems
    },
    _contextMenuPrepared: noop
});
var ContextMenuView = modules.View.inherit({
    _renderCore: function() {
        var that = this;
        this._createComponent(that.element().addClass(CONTEXT_MENU), ContextMenu, {
            onPositioning: function(actionArgs) {
                var event = actionArgs.jQueryEvent,
                    contextMenuInstance = actionArgs.component,
                    items = that.getController("contextMenu").getContextMenuItems(event);
                if (items) {
                    contextMenuInstance.option("items", items);
                    event.stopPropagation()
                } else {
                    actionArgs.cancel = true
                }
            },
            onItemClick: function(params) {
                params.itemData.onItemClick && params.itemData.onItemClick(params)
            },
            cssClass: that.getWidgetContainerClass(),
            target: that.component.element()
        })
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            onContextMenuPreparing: null
        }
    },
    controllers: {
        contextMenu: ContextMenuController
    },
    views: {
        contextMenuView: ContextMenuView
    }
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.error_handling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    clickEvent = __webpack_require__(11),
    modules = __webpack_require__(23);
var ERROR_ROW_CLASS = "dx-error-row",
    ERROR_MESSAGE_CLASS = "dx-error-message",
    ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
    ACTION_CLASS = "action";
var ErrorHandlingController = modules.ViewController.inherit({
    init: function() {
        var that = this;
        that._columnHeadersView = that.getView("columnHeadersView");
        that._rowsView = that.getView("rowsView")
    },
    _createErrorRow: function(message, $tableElements) {
        var $errorRow, $closeButton, that = this,
            $errorMessage = $("<div/>").addClass(ERROR_MESSAGE_CLASS).text(message);
        if ($tableElements) {
            $errorRow = $("<tr />").addClass(ERROR_ROW_CLASS);
            $closeButton = $("<div/>").addClass(ERROR_CLOSEBUTTON_CLASS).addClass(that.addWidgetPrefix(ACTION_CLASS));
            $closeButton.on(clickEvent.name, that.createAction(function(args) {
                var $errorRow, e = args.jQueryEvent,
                    errorRowIndex = $(e.currentTarget).closest("." + ERROR_ROW_CLASS).index();
                e.stopPropagation();
                $.each($tableElements, function(_, tableElement) {
                    $errorRow = $(tableElement).children("tbody").children("tr").eq(errorRowIndex);
                    that.removeErrorRow($errorRow)
                })
            }));
            $("<td/>").attr({
                colspan: that.getController("columns").getVisibleColumns().length,
                role: "presentation"
            }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
            return $errorRow
        }
        return $errorMessage
    },
    renderErrorRow: function(message, rowIndex, $popupContent) {
        var $row, $errorMessageElement, rowElements, viewElement, $tableElements, that = this;
        if ($popupContent) {
            $popupContent.find("." + ERROR_MESSAGE_CLASS).remove();
            $errorMessageElement = that._createErrorRow(message);
            $popupContent.prepend($errorMessageElement);
            return
        }
        viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView, $tableElements = $popupContent || viewElement.getTableElements();
        $.each($tableElements, function(_, tableElement) {
            $errorMessageElement = that._createErrorRow(message, $tableElements);
            rowElements = $(tableElement).children("tbody").children("tr");
            if (rowIndex >= 0) {
                $row = viewElement._getRowElements($(tableElement)).eq(rowIndex);
                that.removeErrorRow(rowElements.eq($row.index() + 1));
                $errorMessageElement.insertAfter($row)
            } else {
                that.removeErrorRow(rowElements.last());
                $(tableElement).append($errorMessageElement)
            }
        })
    },
    removeErrorRow: function($row) {
        var $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
        $row = $row || $columnHeaders && $columnHeaders.find("." + ERROR_ROW_CLASS);
        $row && $row.hasClass(ERROR_ROW_CLASS) && $row.remove()
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "errorRowEnabled":
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            errorRowEnabled: true
        }
    },
    controllers: {
        errorHandling: ErrorHandlingController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    var that = this,
                        errorHandlingController = that.getController("errorHandling");
                    that.callBase();
                    that.dataErrorOccurred.add(function(error, $popupContent) {
                        var message = error && error.message || error;
                        if (that.option("errorRowEnabled")) {
                            errorHandlingController.renderErrorRow(message, void 0, $popupContent)
                        }
                    });
                    that.changed.add(function() {
                        var errorHandlingController = that.getController("errorHandling"),
                            editingController = that.getController("editing");
                        if (editingController && !editingController.hasChanges()) {
                            errorHandlingController && errorHandlingController.removeErrorRow()
                        }
                    })
                }
            }
        }
    }
};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.grid_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    commonUtils = __webpack_require__(2),
    messageLocalization = __webpack_require__(8),
    when = __webpack_require__(10).when;
var TABLE_CLASS = "table",
    BORDERS_CLASS = "borders",
    TABLE_FIXED_CLASS = "table-fixed",
    IMPORTANT_MARGIN_CLASS = "important-margin",
    TEXT_CONTENT_CLASS = "text-content",
    HIDDEN_CLASS = "dx-hidden",
    HIDDEN_COLUMNS_WIDTH = "adaptiveHidden",
    EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])",
    EMPTY_GRID_ROWS_HEIGHT = 100,
    LOADPANEL_MARGIN = 50,
    VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView"];
var isPercentWidth = function(width) {
    return commonUtils.isString(width) && "%" === width.slice(-1)
};
var mergeArraysByMaxValue = function(values1, values2) {
    var i, result = [];
    if (values1 && values2 && values1.length && values1.length === values2.length) {
        for (i = 0; i < values1.length; i++) {
            result.push(values1[i] > values2[i] ? values1[i] : values2[i])
        }
    } else {
        if (values1 && values1.length) {
            result = values1
        } else {
            if (values2) {
                result = values2
            }
        }
    }
    return result
};
var getContainerHeight = function($container) {
    var clientHeight = $container.get(0).clientHeight,
        paddingTop = parseFloat($container.css("paddingTop")),
        paddingBottom = parseFloat($container.css("paddingBottom"));
    return clientHeight - paddingTop - paddingBottom
};
var ResizingController = modules.ViewController.inherit({
    _initPostRenderHandlers: function() {
        var that = this;
        if (!that._refreshSizesHandler) {
            that._refreshSizesHandler = function(e) {
                that._dataController.changed.remove(that._refreshSizesHandler);
                var resizeDeferred, changeType = e && e.changeType,
                    isDelayed = e && e.isDelayed;
                if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
                    if (!isDelayed) {
                        resizeDeferred = that.resize()
                    }
                } else {
                    if ("update" === changeType) {
                        if (that._dataController.items().length > 1 || "insert" !== e.changeTypes[0]) {
                            that._rowsView.resize()
                        } else {
                            resizeDeferred = that.resize()
                        }
                    }
                }
                if (changeType && "updateSelection" !== changeType && !isDelayed) {
                    when(resizeDeferred).done(function() {
                        that.component._fireContentReadyAction()
                    })
                }
            };
            that._dataController.changed.add(function() {
                that._dataController.changed.add(that._refreshSizesHandler)
            })
        }
    },
    _getBestFitWidths: function() {
        var rowsColumnWidths, headerColumnWidths, footerColumnWidths, resultWidths, that = this;
        rowsColumnWidths = that._rowsView.getColumnWidths();
        headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths();
        footerColumnWidths = that._footerView && that._footerView.getColumnWidths();
        resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
        resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
        return resultWidths
    },
    _setVisibleWidths: function(visibleColumns, widths) {
        var columnsController = this._columnsController;
        columnsController.beginUpdate();
        $.each(visibleColumns, function(index, column) {
            var columnId = column.command ? "command:" + column.command : column.index;
            columnsController.columnOption(columnId, "visibleWidth", widths[index])
        });
        columnsController.endUpdate()
    },
    _toggleBestFitMode: function(isBestFit) {
        var $element = this.component.element();
        $element.find("." + this.addWidgetPrefix(TABLE_CLASS)).toggleClass(this.addWidgetPrefix(TABLE_FIXED_CLASS), !isBestFit);
        $element.find(EDITORS_INPUT_SELECTOR).toggleClass(HIDDEN_CLASS, isBestFit);
        $element.find(".dx-group-cell").toggleClass(HIDDEN_CLASS, isBestFit);
        $element.find(".dx-header-row ." + this.addWidgetPrefix(TEXT_CONTENT_CLASS)).css("max-width", "")
    },
    _synchronizeColumns: function() {
        var resetBestFitMode, that = this,
            columnsController = that._columnsController,
            visibleColumns = columnsController.getVisibleColumns(),
            columnAutoWidth = that.option("columnAutoWidth"),
            needBestFit = that._needBestFit(),
            hasMinWidth = false,
            isColumnWidthsCorrected = false,
            resultWidths = [],
            normalizeWidthsByExpandColumns = function() {
                var expandColumnWidth;
                $.each(visibleColumns, function(index, column) {
                    if ("expand" === column.command) {
                        expandColumnWidth = resultWidths[index]
                    }
                });
                $.each(visibleColumns, function(index, column) {
                    if ("expand" === column.command && expandColumnWidth) {
                        resultWidths[index] = expandColumnWidth
                    }
                })
            };
        !needBestFit && $.each(visibleColumns, function(index, column) {
            if ("auto" === column.width || column.fixed) {
                needBestFit = true;
                return false
            }
        });
        $.each(visibleColumns, function(index, column) {
            if (column.minWidth) {
                hasMinWidth = true;
                return false
            }
        });
        that._setVisibleWidths(visibleColumns, []);
        if (needBestFit) {
            that._toggleBestFitMode(true);
            resetBestFitMode = true
        }
        commonUtils.deferUpdate(function() {
            if (needBestFit) {
                resultWidths = that._getBestFitWidths();
                $.each(visibleColumns, function(index, column) {
                    var columnId = column.command ? "command:" + column.command : column.index;
                    columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
                })
            } else {
                if (hasMinWidth) {
                    resultWidths = that._getBestFitWidths()
                }
            }
            $.each(visibleColumns, function(index) {
                if ("auto" !== this.width) {
                    if (this.width) {
                        resultWidths[index] = this.width
                    } else {
                        if (!columnAutoWidth && !this.minWidth) {
                            resultWidths[index] = void 0
                        }
                    }
                }
            });
            isColumnWidthsCorrected = that._correctColumnWidths(resultWidths, visibleColumns);
            if (columnAutoWidth) {
                normalizeWidthsByExpandColumns();
                that._processStretch(resultWidths, visibleColumns)
            }
            commonUtils.deferRender(function() {
                if (resetBestFitMode) {
                    that._toggleBestFitMode(false);
                    resetBestFitMode = false
                }
                if (needBestFit || isColumnWidthsCorrected) {
                    that._setVisibleWidths(visibleColumns, resultWidths)
                }
            })
        })
    },
    _needBestFit: function() {
        return this.option("columnAutoWidth") || this._maxHeightHappened
    },
    _correctColumnWidths: function(resultWidths, visibleColumns) {
        var lastColumnIndex, that = this,
            hasPercentWidth = false,
            hasAutoWidth = false,
            isColumnWidthsCorrected = false,
            $element = that.component.element(),
            hasWidth = that._hasWidth;
        $.each(visibleColumns, function(index) {
            var isMinWidthApplied = false,
                isHiddenColumn = resultWidths[index] === HIDDEN_COLUMNS_WIDTH;
            if (resultWidths[index] < this.minWidth && !isHiddenColumn) {
                resultWidths[index] = this.minWidth;
                isColumnWidthsCorrected = true;
                isMinWidthApplied = true
            }
            if ("auto" !== this.width) {
                if (this.width) {
                    if (!isHiddenColumn && !isMinWidthApplied) {
                        resultWidths[index] = this.width
                    }
                } else {
                    hasAutoWidth = true
                }
            }
            if (isPercentWidth(this.width)) {
                hasPercentWidth = true
            }
        });
        if ($element && that._maxWidth) {
            delete that._maxWidth;
            $element.css("max-width", "")
        }
        if (!hasAutoWidth && resultWidths.length) {
            var contentWidth = that._rowsView.contentWidth(),
                scrollbarWidth = that._rowsView.getScrollbarWidth(),
                totalWidth = that._getTotalWidth(resultWidths, contentWidth);
            if (totalWidth <= contentWidth) {
                lastColumnIndex = resultWidths.length - 1;
                while (lastColumnIndex >= 0 && visibleColumns[lastColumnIndex] && (visibleColumns[lastColumnIndex].command || resultWidths[lastColumnIndex] === HIDDEN_COLUMNS_WIDTH)) {
                    lastColumnIndex--
                }
                if (lastColumnIndex >= 0) {
                    resultWidths[lastColumnIndex] = "auto";
                    isColumnWidthsCorrected = true;
                    if (!hasWidth && !hasPercentWidth) {
                        that._maxWidth = totalWidth + scrollbarWidth + (that.option("showBorders") ? 2 : 0);
                        $element.css("max-width", that._maxWidth)
                    }
                }
            }
        }
        return isColumnWidthsCorrected
    },
    _processStretch: function(resultSizes, visibleColumns) {
        var diff, diffElement, onePixelElementsCount, i, groupSize = this._rowsView.contentWidth(),
            tableSize = this._getTotalWidth(resultSizes, groupSize),
            unusedIndexes = {
                length: 0
            };
        if (!resultSizes.length) {
            return
        }
        $.each(visibleColumns, function(index) {
            if (this.width || resultSizes[index] === HIDDEN_COLUMNS_WIDTH) {
                unusedIndexes[index] = true;
                unusedIndexes.length++
            }
        });
        diff = groupSize - tableSize;
        diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
        onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
        if (diff >= 0) {
            for (i = 0; i < resultSizes.length; i++) {
                if (unusedIndexes[i]) {
                    continue
                }
                resultSizes[i] += diffElement;
                if (onePixelElementsCount) {
                    resultSizes[i]++;
                    onePixelElementsCount--
                }
            }
        }
    },
    _getTotalWidth: function(widths, groupWidth) {
        var width, i, result = 0;
        for (i = 0; i < widths.length; i++) {
            width = widths[i];
            if (width && width !== HIDDEN_COLUMNS_WIDTH) {
                result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
            }
        }
        return Math.round(result)
    },
    updateSize: function($rootElement) {
        var $groupElement, width, that = this,
            importantMarginClass = that.addWidgetPrefix(IMPORTANT_MARGIN_CLASS);
        if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible")) {
            $groupElement = $rootElement.children("." + that.getWidgetContainerClass());
            if ($groupElement.length) {
                $groupElement.detach()
            }
            that._hasHeight = !!getContainerHeight($rootElement);
            width = $rootElement.width();
            $rootElement.addClass(importantMarginClass);
            that._hasWidth = $rootElement.width() === width;
            $rootElement.removeClass(importantMarginClass);
            if ($groupElement.length) {
                $groupElement.appendTo($rootElement)
            }
        }
    },
    publicMethods: function() {
        return ["resize", "updateDimensions"]
    },
    resize: function() {
        return !this.component._requireResize && this.updateDimensions()
    },
    updateDimensions: function(checkSize) {
        var that = this,
            $element = that.component.element(),
            maxHeight = parseFloat($element.css("maxHeight")),
            minHeight = parseFloat($element.css("minHeight"));
        that._initPostRenderHandlers();
        if (!that._checkSize(checkSize)) {
            return
        }
        return commonUtils.deferRender(function() {
            var scrollTop, scrollable = that._rowsView.getScrollable();
            if (that._dataController.isLoaded()) {
                that._synchronizeColumns();
                if (maxHeight || minHeight) {
                    scrollTop = scrollable && scrollable._container().get(0).scrollTop;
                    that._rowsView.height("auto")
                }
            }
            commonUtils.deferUpdate(function() {
                commonUtils.deferRender(function() {
                    commonUtils.deferUpdate(function() {
                        that._updateDimensionsCore(maxHeight, scrollTop)
                    })
                })
            })
        })
    },
    _checkSize: function(checkSize) {
        var $rootElement = this.component.element();
        if (checkSize && (this._lastWidth === $rootElement.width() && this._lastHeight === $rootElement.height() || !$rootElement.is(":visible"))) {
            return false
        }
        return true
    },
    _updateDimensionsCore: function(maxHeight, scrollTop) {
        var rowsViewHeight, $testDiv, that = this,
            scrollable = that._rowsView.getScrollable(),
            dataController = that._dataController,
            rowsView = that._rowsView,
            columnHeadersView = that._columnHeadersView,
            footerView = that._footerView,
            $rootElement = that.component.element(),
            rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height()),
            maxHeightHappened = maxHeight && rootElementHeight >= maxHeight,
            hasHeight = that._hasHeight || maxHeightHappened,
            loadPanelOptions = that.option("loadPanel"),
            height = that.option("height") || $rootElement.get(0).style.height,
            editorFactory = that.getController("editorFactory");
        that._maxHeightHappened = maxHeightHappened;
        that.updateSize($rootElement);
        if (height && that._hasHeight ^ "auto" !== height) {
            $testDiv = $("<div>").height(height).appendTo($rootElement);
            that._hasHeight = !!$testDiv.height();
            $testDiv.remove()
        }
        if (that.option("scrolling") && (that._hasHeight && rootElementHeight > 0 || maxHeightHappened)) {
            rowsViewHeight = rootElementHeight;
            $.each(that.getViews(), function() {
                if (this.isVisible() && this.getHeight) {
                    rowsViewHeight -= this.getHeight()
                }
            })
        } else {
            if (!that._hasHeight && 0 === dataController.items().length) {
                rowsViewHeight = loadPanelOptions && loadPanelOptions.enabled ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT
            } else {
                rowsViewHeight = "auto"
            }
        }
        commonUtils.deferRender(function() {
            rowsView.height(rowsViewHeight, hasHeight);
            if (scrollTop && scrollable) {
                scrollable._container().get(0).scrollTop = scrollTop
            }
            if (!dataController.isLoaded()) {
                rowsView.setLoading(true);
                return
            }
            commonUtils.deferUpdate(function() {
                that._updateLastSizes($rootElement);
                var vScrollbarWidth = hasHeight ? rowsView.getScrollbarWidth() : 0;
                var hScrollbarWidth = rowsView.getScrollbarWidth(true);
                commonUtils.deferRender(function() {
                    columnHeadersView && columnHeadersView.setScrollerSpacing(vScrollbarWidth);
                    footerView && footerView.setScrollerSpacing(vScrollbarWidth);
                    rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth)
                });
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view) {
                        view.resize()
                    }
                });
                editorFactory && editorFactory.resize()
            })
        })
    },
    _updateLastSizes: function($rootElement) {
        this._lastWidth = $rootElement.width();
        this._lastHeight = $rootElement.height()
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "width":
            case "height":
                this.component._renderDimensions();
                this.resize();
            default:
                this.callBase(args)
        }
    },
    init: function() {
        var that = this;
        that._dataController = that.getController("data");
        that._columnsController = that.getController("columns");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._footerView = that.getView("footerView");
        that._rowsView = that.getView("rowsView")
    }
});
var SynchronizeScrollingController = modules.ViewController.inherit({
    _scrollChangedHandler: function(views, pos, viewName) {
        for (var j = 0; j < views.length; j++) {
            if (views[j] && views[j].name !== viewName) {
                views[j].scrollTo({
                    left: pos.left,
                    top: pos.top
                })
            }
        }
    },
    init: function() {
        var view, i, views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
        for (i = 0; i < views.length; i++) {
            view = views[i];
            if (view) {
                view.scrollChanged.add(this._scrollChangedHandler.bind(this, views))
            }
        }
    }
});
var GridView = modules.View.inherit({
    _endUpdateCore: function() {
        if (this.component._requireResize) {
            this.component._requireResize = false;
            this._resizingController.resize()
        }
    },
    _getWidgetAriaLabel: function() {
        return "dxDataGrid-ariaDataGrid"
    },
    init: function() {
        var that = this;
        that._resizingController = this.getController("resizing");
        that._dataController = that.getController("data")
    },
    getView: function(name) {
        return this.component._views[name]
    },
    element: function() {
        return this._groupElement
    },
    optionChanged: function(args) {
        var that = this;
        if (commonUtils.isDefined(that._groupElement) && "showBorders" === args.name) {
            that._groupElement.toggleClass(that.addWidgetPrefix(BORDERS_CLASS), !!args.value);
            args.handled = true
        } else {
            that.callBase(args)
        }
    },
    _renderViews: function($groupElement) {
        var that = this;
        $.each(VIEW_NAMES, function(index, viewName) {
            var view = that.getView(viewName);
            if (view) {
                view.render($groupElement)
            }
        })
    },
    render: function($rootElement) {
        var that = this,
            isFirstRender = !that._groupElement,
            $groupElement = that._groupElement || $("<div>").addClass(that.getWidgetContainerClass());
        $groupElement.toggleClass(that.addWidgetPrefix(BORDERS_CLASS), !!that.option("showBorders"));
        that.component.setAria({
            role: "application",
            label: messageLocalization.format(that._getWidgetAriaLabel())
        }, $rootElement);
        that._rootElement = $rootElement || that._rootElement;
        if (isFirstRender) {
            that._groupElement = $groupElement;
            that.getController("resizing").updateSize($rootElement);
            $groupElement.appendTo($rootElement)
        }
        that._renderViews($groupElement);
        that.update()
    },
    update: function() {
        var that = this,
            $rootElement = that._rootElement,
            $groupElement = that._groupElement,
            resizingController = that.getController("resizing");
        if ($rootElement && $groupElement) {
            resizingController.resize();
            if (that._dataController.isLoaded()) {
                that.component._fireContentReadyAction()
            }
        }
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            showBorders: false
        }
    },
    controllers: {
        resizing: ResizingController,
        synchronizeScrolling: SynchronizeScrollingController
    },
    views: {
        gridView: GridView
    }
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_panel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Toolbar = __webpack_require__(206),
    columnsView = __webpack_require__(101),
    commonUtils = __webpack_require__(2),
    domUtils = __webpack_require__(15);
__webpack_require__(155);
var HEADER_PANEL_CLASS = "header-panel",
    TOOLBAR_BUTTON_CLASS = "toolbar-button";
var HeaderPanel = columnsView.ColumnsView.inherit({
    _getToolbarItems: function() {
        return []
    },
    _getButtonContainer: function() {
        return $("<div />").addClass(this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS))
    },
    _getToolbarButtonClass: function(specificClass) {
        var secondClass = specificClass ? " " + specificClass : "";
        return this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS) + secondClass
    },
    _getToolbarOptions: function() {
        var toolbarItems, options = {
            toolbarOptions: {
                items: this._getToolbarItems(),
                onItemRendered: function(e) {
                    var itemRenderedCallback = e.itemData.onItemRendered;
                    if (itemRenderedCallback) {
                        itemRenderedCallback(e)
                    }
                }
            }
        };
        this.executeAction("onToolbarPreparing", options);
        if (options.toolbarOptions && !commonUtils.isDefined(options.toolbarOptions.visible)) {
            toolbarItems = options.toolbarOptions.items;
            options.toolbarOptions.visible = !!(toolbarItems && toolbarItems.length)
        }
        return options.toolbarOptions
    },
    _renderCore: function() {
        if (!this._toolbar) {
            this.element().addClass(this.addWidgetPrefix(HEADER_PANEL_CLASS));
            this._toolbar = this._createComponent($("<div />").appendTo(this.element()), Toolbar, this._toolbarOptions)
        } else {
            this._toolbar.option(this._toolbarOptions)
        }
    },
    _columnOptionChanged: commonUtils.noop,
    init: function() {
        this.callBase();
        this.createAction("onToolbarPreparing", {
            excludeValidators: ["designMode", "disabled", "readOnly"]
        })
    },
    render: function() {
        this._toolbarOptions = this._getToolbarOptions();
        this.callBase.apply(this, arguments)
    },
    setToolbarItemDisabled: function(name, optionValue) {
        var toolbarInstance = this._toolbar;
        if (toolbarInstance) {
            var items = toolbarInstance.option("items") || [],
                itemIndex = items.indexOf(items.filter(function(item) {
                    return item.name === name
                })[0]);
            if (itemIndex >= 0) {
                var itemOptionPrefix = "items[" + itemIndex + "]";
                if (toolbarInstance.option(itemOptionPrefix + ".options")) {
                    toolbarInstance.option(itemOptionPrefix + ".options.disabled", optionValue)
                } else {
                    toolbarInstance.option(itemOptionPrefix + ".disabled", optionValue)
                }
            }
        }
    },
    getHeaderPanel: function() {
        return this.element()
    },
    getHeight: function() {
        return this.getElementHeight()
    },
    optionChanged: function(args) {
        if ("onToolbarPreparing" === args.name) {
            this._invalidate();
            args.handled = true
        }
        this.callBase(args)
    },
    isVisible: function() {
        return this._toolbarOptions && this._toolbarOptions.visible
    },
    allowDragging: commonUtils.noop
});
module.exports = {
    defaultOptions: function() {
        return {}
    },
    views: {
        headerPanel: HeaderPanel
    },
    extenders: {
        controllers: {
            resizing: {
                _updateDimensionsCore: function() {
                    this.callBase.apply(this, arguments);
                    var $headerPanelElement = this.getView("headerPanel").element();
                    if ($headerPanelElement) {
                        domUtils.triggerResizeEvent($headerPanelElement)
                    }
                }
            }
        }
    }
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.selection.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    gridCore = __webpack_require__(12),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    support = __webpack_require__(24),
    clickEvent = __webpack_require__(11),
    messageLocalization = __webpack_require__(8),
    eventUtils = __webpack_require__(3),
    holdEvent = __webpack_require__(66),
    Selection = __webpack_require__(189);
var EDITOR_CELL_CLASS = "dx-editor-cell",
    ROW_CLASS = "dx-row",
    ROW_SELECTION_CLASS = "dx-selection",
    SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
    CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
    COMMAND_SELECT_CLASS = "dx-command-select",
    SELECTION_DISABLED_CLASS = "dx-selection-disabled",
    DATA_ROW_CLASS = "dx-data-row";
var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode",
    SELECTION_MODE = "selection.mode";
var processLongTap = function(that, jQueryEvent) {
    var selectionController = that.getController("selection"),
        rowsView = that.getView("rowsView"),
        $row = $(jQueryEvent.target).closest("." + DATA_ROW_CLASS),
        rowIndex = rowsView.getRowIndex($row);
    if (rowIndex < 0) {
        return
    }
    if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
        if (selectionController.isSelectionWithCheckboxes()) {
            selectionController.stopSelectionWithCheckboxes()
        } else {
            selectionController.startSelectionWithCheckboxes()
        }
    } else {
        if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
            selectionController.startSelectionWithCheckboxes()
        }
        if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
            selectionController.changeItemSelection(rowIndex, {
                control: true
            })
        }
    }
};
exports.SelectionController = gridCore.Controller.inherit(function() {
    var isSeveralRowsSelected = function(that, selectionFilter) {
        var keyIndex = 0,
            store = that.getController("data").store(),
            key = store && store.key(),
            isComplexKey = Array.isArray(key);
        if (!selectionFilter.length) {
            return false
        }
        if (isComplexKey && Array.isArray(selectionFilter[0]) && "and" === selectionFilter[1]) {
            for (var i = 0; i < selectionFilter.length; i++) {
                if (Array.isArray(selectionFilter[i])) {
                    if (selectionFilter[i][0] !== key[keyIndex] || "=" !== selectionFilter[i][1]) {
                        return true
                    }
                    keyIndex++
                }
            }
            return false
        }
        return key !== selectionFilter[0]
    };
    return {
        init: function() {
            var that = this,
                dataController = that.getController("data"),
                selectionOptions = that.option("selection") || {};
            that._selectionMode = that.option(SELECTION_MODE);
            that._isSelectionWithCheckboxes = false;
            that._selection = that._createSelection({
                selectedKeys: that.option("selectedRowKeys"),
                mode: that._selectionMode,
                deferred: selectionOptions.deferred,
                maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
                selectionFilter: that.option("selectionFilter"),
                key: function() {
                    return dataController && dataController.key()
                },
                keyOf: function(item) {
                    return dataController && dataController.keyOf(item)
                },
                dataFields: function() {
                    return dataController.dataSource() && dataController.dataSource().select()
                },
                load: function(options) {
                    return dataController.dataSource() && dataController.dataSource().load(options) || $.Deferred().resolve([])
                },
                plainItems: function() {
                    return dataController.items()
                },
                isItemSelected: function(item) {
                    return item.selected
                },
                isSelectableItem: function(item) {
                    return item && "data" === item.rowType && !item.inserted
                },
                getItemData: function(item) {
                    return item && (item.oldData || item.data || item)
                },
                filter: function() {
                    return dataController.getCombinedFilter()
                },
                totalCount: function() {
                    return dataController.totalCount()
                },
                onSelectionChanged: that._updateSelectedItems.bind(this)
            });
            that._updateSelectColumn();
            that.createAction("onSelectionChanged", {
                excludeValidators: ["disabled", "readOnly"]
            })
        },
        _updateSelectColumn: function() {
            var columnsController = this.getController("columns"),
                isSelectColumnVisible = this.isSelectColumnVisible();
            columnsController.addCommandColumn({
                command: "select",
                visible: isSelectColumnVisible,
                visibleIndex: -1,
                dataType: "boolean",
                alignment: "center",
                cssClass: COMMAND_SELECT_CLASS,
                width: "auto"
            });
            columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
        },
        _createSelection: function(options) {
            return new Selection(options)
        },
        _fireSelectionChanged: function() {
            var argument = this.option("selection.deferred") ? {
                selectionFilter: this.option("selectionFilter")
            } : {
                selectedRowKeys: this.option("selectedRowKeys")
            };
            this.selectionChanged.fire(argument)
        },
        _updateCheckboxesState: function(options) {
            var isDeferredMode = options.isDeferredMode,
                selectionFilter = options.selectionFilter,
                selectedItemKeys = options.selectedItemKeys,
                removedItemKeys = options.removedItemKeys;
            if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
                if (isDeferredMode ? selectionFilter && isSeveralRowsSelected(this, selectionFilter) : selectedItemKeys.length > 1) {
                    this.startSelectionWithCheckboxes()
                } else {
                    if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
                        this.stopSelectionWithCheckboxes()
                    }
                }
            }
        },
        _updateSelectedItems: function(args) {
            var that = this,
                isDeferredMode = that.option("selection.deferred"),
                selectionFilter = that._selection.selectionFilter(),
                dataController = that.getController("data"),
                items = dataController.items();
            if (!items) {
                return
            }
            var isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
            var changedItemIndexes = that.getChangedItemIndexes(items);
            that._updateCheckboxesState({
                selectedItemKeys: args.selectedItemKeys,
                removedItemKeys: args.removedItemKeys,
                selectionFilter: selectionFilter,
                isDeferredMode: isDeferredMode
            });
            if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
                dataController.updateItems({
                    changeType: "updateSelection",
                    itemIndexes: changedItemIndexes
                })
            }
            if (isDeferredMode) {
                that.option("selectionFilter", selectionFilter);
                that._fireSelectionChanged();
                that.executeAction("onSelectionChanged", {})
            } else {
                if (args.addedItemKeys.length || args.removedItemKeys.length) {
                    that._selectedItemsInternalChange = true;
                    that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
                    that._selectedItemsInternalChange = false;
                    that.executeAction("onSelectionChanged", {
                        selectedRowsData: args.selectedItems,
                        selectedRowKeys: args.selectedItemKeys,
                        currentSelectedRowKeys: args.addedItemKeys,
                        currentDeselectedRowKeys: args.removedItemKeys
                    })
                }
                that._fireSelectionChanged()
            }
        },
        getChangedItemIndexes: function(items) {
            var that = this,
                itemIndexes = [],
                isDeferredSelection = this.option("selection.deferred");
            for (var i = 0, length = items.length; i < length; i++) {
                var row = items[i];
                var isItemSelected = that._selection.isItemSelected(isDeferredSelection ? row.data : row.key);
                if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
                    itemIndexes.push(i)
                }
            }
            return itemIndexes
        },
        callbackNames: function() {
            return ["selectionChanged"]
        },
        optionChanged: function(args) {
            var that = this;
            that.callBase(args);
            switch (args.name) {
                case "selection":
                    var oldSelectionMode = that._selectionMode;
                    that.init();
                    var selectionMode = that._selectionMode;
                    var selectedRowKeys = that.option("selectedRowKeys");
                    if (oldSelectionMode !== selectionMode) {
                        if ("single" === selectionMode) {
                            if (selectedRowKeys.length > 1) {
                                selectedRowKeys = [selectedRowKeys[0]]
                            }
                        } else {
                            if ("multiple" !== selectionMode) {
                                selectedRowKeys = []
                            }
                        }
                    }
                    that.selectRows(selectedRowKeys).always(function() {
                        that._fireSelectionChanged()
                    });
                    that.getController("columns").updateColumns();
                    args.handled = true;
                    break;
                case "selectionFilter":
                    this._selection.selectionFilter(args.value);
                    args.handled = true;
                    break;
                case "selectedRowKeys":
                    if (Array.isArray(args.value) && !that._selectedItemsInternalChange && that.component.getDataSource()) {
                        that.selectRows(args.value)
                    }
                    args.handled = true
            }
        },
        publicMethods: function() {
            return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
        },
        isRowSelected: function(arg) {
            return this._selection.isItemSelected(arg)
        },
        isSelectColumnVisible: function() {
            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
        },
        _isOnePageSelectAll: function() {
            return "page" === this.option("selection.selectAllMode")
        },
        isSelectAll: function() {
            return this._selection.getSelectAllState(this._isOnePageSelectAll())
        },
        selectAll: function() {
            if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
                this.startSelectionWithCheckboxes()
            }
            return this._selection.selectAll(this._isOnePageSelectAll())
        },
        deselectAll: function() {
            return this._selection.deselectAll(this._isOnePageSelectAll())
        },
        clearSelection: function() {
            return this.selectedItemKeys([])
        },
        refresh: function() {
            var selectedRowKeys = this.option("selectedRowKeys") || [];
            if (!this.option("selection.deferred") && selectedRowKeys.length) {
                return this.selectedItemKeys(selectedRowKeys)
            }
            return $.Deferred().resolve().promise()
        },
        selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
            return this._selection.selectedItemKeys(value, preserve, isDeselect, isSelectAll)
        },
        getSelectedRowKeys: function() {
            return this._selection.getSelectedItemKeys()
        },
        selectRows: function(keys, preserve) {
            return this.selectedItemKeys(keys, preserve)
        },
        deselectRows: function(keys) {
            return this.selectedItemKeys(keys, true, true)
        },
        selectRowsByIndexes: function(indexes) {
            var items = this.getController("data").items(),
                keys = [];
            if (!Array.isArray(indexes)) {
                indexes = Array.prototype.slice.call(arguments, 0)
            }
            $.each(indexes, function() {
                var item = items[this];
                if (item && "data" === item.rowType) {
                    keys.push(item.key)
                }
            });
            return this.selectRows(keys)
        },
        getSelectedRowsData: function() {
            return this._selection.getSelectedItems()
        },
        changeItemSelection: function(itemIndex, keys) {
            keys = keys || {};
            if (this.isSelectionWithCheckboxes()) {
                keys.control = true
            }
            return this._selection.changeItemSelection(itemIndex, keys)
        },
        focusedItemIndex: function(itemIndex) {
            var that = this;
            if (commonUtils.isDefined(itemIndex)) {
                that._selection._focusedItemIndex = itemIndex
            } else {
                return that._selection._focusedItemIndex
            }
        },
        isSelectionWithCheckboxes: function() {
            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
        },
        startSelectionWithCheckboxes: function() {
            var that = this;
            if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
                that._isSelectionWithCheckboxes = true;
                that._updateSelectColumn();
                return true
            }
            return false
        },
        stopSelectionWithCheckboxes: function() {
            var that = this;
            if (that._isSelectionWithCheckboxes) {
                that._isSelectionWithCheckboxes = false;
                that._updateSelectColumn();
                return true
            }
            return false
        }
    }
}());
module.exports = {
    defaultOptions: function() {
        return {
            selection: {
                mode: "none",
                showCheckBoxesMode: "onClick",
                allowSelectAll: true,
                selectAllMode: "allPages",
                maxFilterLengthInRequest: 1500,
                deferred: false
            },
            selectionFilter: [],
            selectedRowKeys: []
        }
    },
    controllers: {
        selection: exports.SelectionController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    var selectionController = this.getController("selection"),
                        isDeferredMode = this.option("selection.deferred");
                    this.callBase.apply(this, arguments);
                    if (isDeferredMode) {
                        selectionController._updateCheckboxesState({
                            isDeferredMode: true,
                            selectionFilter: this.option("selectionFilter")
                        })
                    }
                },
                _loadDataSource: function() {
                    var that = this;
                    return that.callBase().done(function() {
                        that.getController("selection").refresh()
                    })
                },
                pageIndex: function(value) {
                    var that = this,
                        dataSource = that._dataSource;
                    if (dataSource && value && dataSource.pageIndex() !== value) {
                        that.getController("selection").focusedItemIndex(-1)
                    }
                    return that.callBase(value)
                },
                _processDataItem: function(item, options) {
                    var that = this,
                        selectionController = that.getController("selection"),
                        hasSelectColumn = selectionController.isSelectColumnVisible(),
                        isDeferredSelection = options.isDeferredSelection = void 0 === options.isDeferredSelection ? this.option("selection.deferred") : options.isDeferredSelection,
                        dataItem = this.callBase.apply(this, arguments);
                    dataItem.isSelected = selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
                    if (hasSelectColumn && dataItem.values) {
                        for (var i = 0; i < options.visibleColumns.length; i++) {
                            if ("select" === options.visibleColumns[i].command) {
                                dataItem.values[i] = dataItem.isSelected;
                                break
                            }
                        }
                    }
                    return dataItem
                },
                refresh: function() {
                    var that = this,
                        d = $.Deferred();
                    this.callBase.apply(this, arguments).done(function() {
                        that.getController("selection").refresh().done(d.resolve).fail(d.reject)
                    }).fail(d.reject);
                    return d.promise()
                }
            },
            contextMenu: {
                _contextMenuPrepared: function(options) {
                    var jQueryEvent = options.jQueryEvent;
                    if (jQueryEvent.originalEvent && "dxhold" !== jQueryEvent.originalEvent.type || options.items && options.items.length > 0) {
                        return
                    }
                    processLongTap(this, jQueryEvent)
                }
            }
        },
        views: {
            columnHeadersView: {
                init: function() {
                    var that = this;
                    that.callBase();
                    that.getController("selection").selectionChanged.add(that._updateSelectAllValue.bind(that))
                },
                _updateSelectAllValue: function() {
                    var that = this,
                        $element = that.element(),
                        $editor = $element && $element.find("." + SELECT_CHECKBOX_CLASS);
                    if ($element && $editor.length && "multiple" === that.option("selection.mode")) {
                        $editor.dxCheckBox("instance").option("value", that.getController("selection").isSelectAll())
                    }
                },
                _handleDataChanged: function(e) {
                    this.callBase(e);
                    if (!e || "refresh" === e.changeType) {
                        this._updateSelectAllValue()
                    }
                },
                _getDefaultTemplate: function(column) {
                    var that = this;
                    if ("select" === column.command) {
                        return function($cell, options) {
                            var column = options.column;
                            if ("select" === column.command) {
                                $cell.addClass(EDITOR_CELL_CLASS);
                                that._renderSelectAllCheckBox($cell, column);
                                that._attachSelectAllCheckBoxClickEvent($cell)
                            }
                        }
                    } else {
                        return that.callBase(column)
                    }
                },
                _renderSelectAllCheckBox: function($container, column) {
                    var groupElement, that = this,
                        selectionController = that.getController("selection");
                    groupElement = $("<div />").appendTo($container).addClass(SELECT_CHECKBOX_CLASS);
                    that.setAria("label", messageLocalization.format("dxDataGrid-ariaSelectAll"), $container);
                    that.getController("editorFactory").createEditor(groupElement, extend({}, column, {
                        parentType: "headerRow",
                        dataType: "boolean",
                        value: selectionController.isSelectAll(),
                        editorOptions: {
                            visible: that.option("selection.allowSelectAll") || false !== selectionController.isSelectAll()
                        },
                        tabIndex: -1,
                        setValue: function(value, e) {
                            var allowSelectAll = that.option("selection.allowSelectAll");
                            e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
                            if (!e.jQueryEvent || selectionController.isSelectAll() === value) {
                                return
                            }
                            if (e.value && !allowSelectAll) {
                                e.component.option("value", false)
                            } else {
                                e.value ? selectionController.selectAll() : selectionController.deselectAll()
                            }
                            e.jQueryEvent.preventDefault()
                        }
                    }));
                    return groupElement
                },
                _attachSelectAllCheckBoxClickEvent: function($element) {
                    $element.on(clickEvent.name, this.createAction(function(e) {
                        var event = e.jQueryEvent;
                        if (!$(event.target).closest("." + SELECT_CHECKBOX_CLASS).length) {
                            $(event.currentTarget).children().trigger(clickEvent.name)
                        }
                        event.preventDefault()
                    }))
                }
            },
            rowsView: {
                _getDefaultTemplate: function(column) {
                    var that = this;
                    if ("select" === column.command) {
                        return function(container, options) {
                            that.renderSelectCheckBoxContainer(column, container, options)
                        }
                    } else {
                        return that.callBase(column)
                    }
                },
                renderSelectCheckBoxContainer: function(column, container, options) {
                    if ("data" === options.rowType && !options.row.inserted) {
                        container.addClass(EDITOR_CELL_CLASS);
                        this._attachCheckBoxClickEvent(container);
                        this.setAria("label", messageLocalization.format("dxDataGrid-ariaSelectRow"), container);
                        this._renderSelectCheckBox(container, options.value, column)
                    }
                },
                _renderSelectCheckBox: function(container, value, column) {
                    var groupElement = $("<div />").addClass(SELECT_CHECKBOX_CLASS).appendTo(container);
                    this.getController("editorFactory").createEditor(groupElement, extend({}, column, {
                        parentType: "dataRow",
                        dataType: "boolean",
                        value: value,
                        tabIndex: -1,
                        setValue: function(value, e) {
                            if (e && e.jQueryEvent && "keydown" === e.jQueryEvent.type) {
                                container.trigger(clickEvent.name, e)
                            }
                        }
                    }));
                    return groupElement
                },
                _attachCheckBoxClickEvent: function($element) {
                    $element.on(clickEvent.name, this.createAction(function(e) {
                        var selectionController = this.getController("selection"),
                            event = e.jQueryEvent,
                            rowIndex = this.getRowIndex($(event.currentTarget).closest("." + ROW_CLASS));
                        if (rowIndex >= 0) {
                            selectionController.startSelectionWithCheckboxes();
                            selectionController.changeItemSelection(rowIndex, {
                                shift: event.shiftKey
                            });
                            if ($(event.target).closest("." + SELECT_CHECKBOX_CLASS).length) {
                                this.getController("data").updateItems({
                                    changeType: "updateSelection",
                                    itemIndexes: [rowIndex]
                                })
                            }
                        }
                    }))
                },
                _update: function(change) {
                    var that = this,
                        tableElements = that.getTableElements();
                    if ("updateSelection" === change.changeType) {
                        if (tableElements.length > 0) {
                            $.each(tableElements, function(_, tableElement) {
                                $.each(change.itemIndexes || [], function(_, index) {
                                    var $row, isSelected;
                                    if (change.items[index]) {
                                        $row = that._getRowElements($(tableElement)).eq(index);
                                        isSelected = !!change.items[index].isSelected;
                                        $row.toggleClass(ROW_SELECTION_CLASS, isSelected).find("." + SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
                                        that.setAria("selected", isSelected, $row)
                                    }
                                })
                            });
                            that._updateCheckboxesClass()
                        }
                    } else {
                        that.callBase(change)
                    }
                },
                _createTable: function() {
                    var that = this,
                        selectionMode = that.option("selection.mode"),
                        $table = that.callBase.apply(that, arguments);
                    if ("none" !== selectionMode) {
                        if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !support.touch) {
                            $table.on(eventUtils.addNamespace(holdEvent.name, "dxDataGridRowsView"), "." + DATA_ROW_CLASS, that.createAction(function(e) {
                                processLongTap(that.component, e.jQueryEvent);
                                e.jQueryEvent.stopPropagation()
                            }))
                        }
                        $table.on("mousedown selectstart", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            if (event.shiftKey) {
                                event.preventDefault()
                            }
                        }))
                    }
                    return $table
                },
                _createRow: function(row) {
                    var isSelected, $row = this.callBase(row);
                    if (row) {
                        isSelected = !!row.isSelected;
                        if (isSelected) {
                            $row.addClass(ROW_SELECTION_CLASS)
                        }
                        this.setAria("selected", isSelected, $row)
                    }
                    return $row
                },
                _rowClick: function(e) {
                    var that = this,
                        jQueryEvent = e.jQueryEvent,
                        isSelectionDisabled = $(jQueryEvent.target).closest("." + SELECTION_DISABLED_CLASS).length;
                    if (!that.isClickableElement($(jQueryEvent.target))) {
                        if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
                            if (that.getController("selection").changeItemSelection(e.rowIndex, {
                                    control: jQueryEvent.ctrlKey || jQueryEvent.metaKey,
                                    shift: jQueryEvent.shiftKey
                                })) {
                                jQueryEvent.preventDefault();
                                e.handled = true
                            }
                        }
                        that.callBase(e)
                    }
                },
                isClickableElement: function($target) {
                    var isCommandSelect = $target.closest("." + COMMAND_SELECT_CLASS).length;
                    return !!isCommandSelect
                },
                _renderCore: function(change) {
                    this.callBase(change);
                    this._updateCheckboxesClass()
                },
                _updateCheckboxesClass: function() {
                    var tableElements = this.getTableElements(),
                        selectionController = this.getController("selection"),
                        isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                    $.each(tableElements, function(_, tableElement) {
                        $(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                    })
                }
            }
        }
    }
};


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_chooser.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    columnsView = __webpack_require__(101),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8),
    themes = __webpack_require__(20),
    Button = __webpack_require__(25),
    TreeView = __webpack_require__(132),
    devices = __webpack_require__(6),
    Popup = __webpack_require__(68);
var COLUMN_CHOOSER_CLASS = "column-chooser",
    COLUMN_CHOOSER_BUTTON_CLASS = "column-chooser-button",
    NOTOUCH_ACTION_CLASS = "notouch-action",
    COLUMN_CHOOSER_LIST_CLASS = "column-chooser-list",
    COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag",
    COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select",
    COLUMN_CHOOSER_ICON_NAME = "column-chooser",
    COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
    CLICK_TIMEOUT = 300,
    processItems = function(that, chooserColumns) {
        var item, items = [],
            isSelectMode = "select" === that.option("columnChooser.mode");
        if (chooserColumns.length) {
            $.each(chooserColumns, function(index, column) {
                item = {
                    text: column.caption,
                    cssClass: column.cssClass,
                    allowHiding: column.allowHiding,
                    expanded: true,
                    id: column.index,
                    parentId: commonUtils.isDefined(column.ownerBand) ? column.ownerBand : null
                };
                if (isSelectMode) {
                    item.selected = column.visible
                }
                items.push(item)
            })
        }
        return items
    };
var ColumnChooserController = modules.ViewController.inherit({
    renderShowColumnChooserButton: function($element) {
        var $columnChooserButton, that = this,
            columnChooserButtonClass = that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS),
            columnChooserEnabled = that.option("columnChooser.enabled"),
            $showColumnChooserButton = $element.find("." + columnChooserButtonClass);
        if (columnChooserEnabled) {
            if (!$showColumnChooserButton.length) {
                $columnChooserButton = $("<div />").addClass(columnChooserButtonClass).appendTo($element);
                that._createComponent($columnChooserButton, Button, {
                    icon: COLUMN_CHOOSER_ICON_NAME,
                    onClick: function() {
                        that.getView("columnChooserView").showColumnChooser()
                    },
                    hint: that.option("columnChooser.title"),
                    integrationOptions: {}
                })
            } else {
                $showColumnChooserButton.show()
            }
        } else {
            $showColumnChooserButton.hide()
        }
    },
    getPosition: function() {
        var rowsView = this.getView("rowsView");
        return {
            my: "right bottom",
            at: "right bottom",
            of: rowsView && rowsView.element(),
            collision: "fit",
            offset: "-2 -2",
            boundaryOffset: "2 2"
        }
    }
});
var ColumnChooserView = columnsView.ColumnsView.inherit({
    _resizeCore: commonUtils.noop,
    _isWinDevice: function() {
        return !!devices.real().win
    },
    _updateList: function(allowUpdate) {
        var items, $popupContent = this._popupContainer.content(),
            isSelectMode = "select" === this.option("columnChooser.mode"),
            chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
        if (!isSelectMode || !this._columnChooserList || allowUpdate) {
            this._popupContainer._wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
            items = processItems(this, chooserColumns);
            this._renderColumnChooserList($popupContent, items)
        }
    },
    _initializePopupContainer: function() {
        var that = this,
            $element = that.element().addClass(that.addWidgetPrefix(COLUMN_CHOOSER_CLASS)),
            columnChooserOptions = that.option("columnChooser"),
            theme = themes.current(),
            isGenericTheme = theme && theme.indexOf("generic") > -1,
            isAndroid5Theme = theme && theme.indexOf("android5") > -1,
            dxPopupOptions = {
                visible: false,
                shading: false,
                showCloseButton: false,
                dragEnabled: true,
                resizeEnabled: true,
                toolbarItems: [{
                    text: columnChooserOptions.title,
                    toolbar: "top",
                    location: isGenericTheme || isAndroid5Theme ? "before" : "center"
                }],
                position: that.getController("columnChooser").getPosition(),
                width: columnChooserOptions.width,
                height: columnChooserOptions.height,
                rtlEnabled: that.option("rtlEnabled"),
                onHidden: function() {
                    if (that._isWinDevice()) {
                        $(document.body).removeClass(that.addWidgetPrefix(NOTOUCH_ACTION_CLASS))
                    }
                },
                container: columnChooserOptions.container
            };
        if (isGenericTheme) {
            extend(dxPopupOptions, {
                showCloseButton: true
            })
        } else {
            dxPopupOptions.toolbarItems[dxPopupOptions.toolbarItems.length] = {
                shortcut: "cancel"
            }
        }
        if (!commonUtils.isDefined(this._popupContainer)) {
            that._popupContainer = that._createComponent($element, Popup, dxPopupOptions);
            that._popupContainer.on("optionChanged", function(args) {
                if ("visible" === args.name) {
                    that.renderCompleted.fire()
                }
            })
        } else {
            this._popupContainer.option(dxPopupOptions)
        }
    },
    _renderCore: function(allowUpdate) {
        if (this._popupContainer) {
            this._updateList(allowUpdate)
        }
    },
    _renderColumnChooserList: function($container, items) {
        var scrollTop, scrollableInstance, isSelectMode = "select" === this.option("columnChooser.mode"),
            listConfig = {
                items: items,
                dataStructure: "plain",
                activeStateEnabled: true,
                focusStateEnabled: true,
                hoverStateEnabled: true,
                itemTemplate: "item",
                showCheckBoxesMode: "none",
                rootValue: null
            };
        if (isSelectMode) {
            scrollableInstance = $container.find(".dx-scrollable").data("dxScrollable");
            scrollTop = scrollableInstance && scrollableInstance.scrollTop();
            listConfig.onContentReady = function(e) {
                if (scrollTop) {
                    var scrollable = e.element.find(".dx-scrollable").data("dxScrollable");
                    scrollable && scrollable.scrollTo({
                        y: scrollTop
                    })
                }
            }
        }
        if (this._isWinDevice()) {
            listConfig.useNativeScrolling = false
        }
        extend(listConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
        if (this._columnChooserList) {
            this._columnChooserList.option(listConfig)
        } else {
            this._columnChooserList = this._createComponent($container, TreeView, listConfig);
            $container.addClass(this.addWidgetPrefix(COLUMN_CHOOSER_LIST_CLASS))
        }
    },
    _prepareDragModeConfig: function() {
        var columnChooserOptions = this.option("columnChooser");
        return {
            noDataText: columnChooserOptions.emptyPanelText,
            activeStateEnabled: false,
            focusStateEnabled: false,
            hoverStateEnabled: false,
            itemTemplate: function(data, index, $item) {
                $item.text(data.text).parent().addClass(data.cssClass).addClass(COLUMN_CHOOSER_ITEM_CLASS)
            }
        }
    },
    _prepareSelectModeConfig: function() {
        var that = this,
            selectionChangedHandler = function(e) {
                var visibleColumns = that._columnsController.getVisibleColumns().filter(function(item) {
                        return !item.command
                    }),
                    isLastColumnUnselected = 1 === visibleColumns.length && !e.itemData.selected;
                if (isLastColumnUnselected) {
                    e.component.selectItem(e.itemElement)
                } else {
                    setTimeout(function() {
                        that._columnsController.columnOption(e.itemData.id, "visible", e.itemData.selected)
                    }, CLICK_TIMEOUT)
                }
            };
        return {
            selectNodesRecursive: false,
            showCheckBoxesMode: "normal",
            onItemSelectionChanged: selectionChangedHandler
        }
    },
    _columnOptionChanged: function(e) {
        var changeTypes = e.changeTypes,
            optionNames = e.optionNames,
            isSelectMode = "select" === this.option("columnChooser.mode");
        this.callBase(e);
        if (isSelectMode) {
            if (optionNames.showInColumnChooser || optionNames.visible || changeTypes.columns && optionNames.all) {
                this.render(null, true)
            }
        }
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "columnChooser":
                this.render(null, true);
                break;
            default:
                this.callBase(args)
        }
    },
    getColumnElements: function() {
        var $content = this._popupContainer && this._popupContainer.content();
        return $content && $content.find("." + COLUMN_CHOOSER_ITEM_CLASS)
    },
    getName: function() {
        return "columnChooser"
    },
    getColumns: function() {
        return this._columnsController.getChooserColumns()
    },
    allowDragging: function(column, sourceLocation) {
        var columnVisible = column && column.allowHiding && ("columnChooser" !== sourceLocation || !column.visible && this._columnsController.isParentColumnVisible(column.index));
        return this.isColumnChooserVisible() && columnVisible
    },
    getBoundingRect: function() {
        var offset, that = this,
            container = that._popupContainer && that._popupContainer._container();
        if (container && container.is(":visible")) {
            offset = container.offset();
            return {
                left: offset.left,
                top: offset.top,
                right: offset.left + container.outerWidth(),
                bottom: offset.top + container.outerHeight()
            }
        }
        return null
    },
    showColumnChooser: function() {
        if (!this._popupContainer) {
            this._initializePopupContainer();
            this.render()
        }
        this._popupContainer.show();
        if (this._isWinDevice()) {
            $(document.body).addClass(this.addWidgetPrefix(NOTOUCH_ACTION_CLASS))
        }
    },
    hideColumnChooser: function() {
        if (this._popupContainer) {
            this._popupContainer.hide()
        }
    },
    isColumnChooserVisible: function() {
        var popupContainer = this._popupContainer;
        return popupContainer && popupContainer.option("visible")
    },
    publicMethods: function() {
        return ["showColumnChooser", "hideColumnChooser"]
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            columnChooser: {
                enabled: false,
                mode: "dragAndDrop",
                width: 250,
                height: 260,
                title: messageLocalization.format("dxDataGrid-columnChooserTitle"),
                emptyPanelText: messageLocalization.format("dxDataGrid-columnChooserEmptyText"),
                container: void 0
            }
        }
    },
    controllers: {
        columnChooser: ColumnChooserController
    },
    views: {
        columnChooserView: ColumnChooserView
    },
    extenders: {
        views: {
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase();
                    return this._appendColumnChooserItem(items)
                },
                _appendColumnChooserItem: function(items) {
                    var that = this,
                        columnChooserEnabled = that.option("columnChooser.enabled");
                    if (columnChooserEnabled) {
                        var onClickHandler = function() {
                                that.component.getView("columnChooserView").showColumnChooser()
                            },
                            onInitialized = function(e) {
                                e.element.addClass(that._getToolbarButtonClass(that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS)))
                            },
                            hintText = that.option("columnChooser.title"),
                            toolbarItem = {
                                widget: "dxButton",
                                options: {
                                    icon: COLUMN_CHOOSER_ICON_NAME,
                                    onClick: onClickHandler,
                                    hint: hintText,
                                    text: hintText,
                                    onInitialized: onInitialized
                                },
                                showText: "inMenu",
                                location: "after",
                                name: "columnChooserButton",
                                locateInMenu: "auto",
                                sortIndex: 40
                            };
                        items.push(toolbarItem)
                    }
                    return items
                },
                optionChanged: function(args) {
                    switch (args.name) {
                        case "columnChooser":
                            this._invalidate();
                            args.handled = true;
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                isVisible: function() {
                    var that = this,
                        columnChooserEnabled = that.option("columnChooser.enabled");
                    return that.callBase() || columnChooserEnabled
                }
            }
        },
        controllers: {
            columns: {
                allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var columnChooserMode = this.option("columnChooser.mode"),
                        isMoveColumnDisallowed = "select" === columnChooserMode && "columnChooser" === targetLocation;
                    return isMoveColumnDisallowed ? false : this.callBase(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation)
                }
            }
        }
    }
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.grouping.core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    gridCore = __webpack_require__(12),
    normalizeSortingInfo = __webpack_require__(28).normalizeSortingInfo,
    when = __webpack_require__(10).when;
exports.createGroupFilter = function(path, storeLoadOptions) {
    var i, groups = normalizeSortingInfo(storeLoadOptions.group),
        filter = [];
    for (i = 0; i < path.length; i++) {
        filter.push([groups[i].selector, "=", path[i]])
    }
    if (storeLoadOptions.filter) {
        filter.push(storeLoadOptions.filter)
    }
    return gridCore.combineFilters(filter)
};
exports.createOffsetFilter = function(path, storeLoadOptions) {
    var i, j, filterElement, selector, groups = normalizeSortingInfo(storeLoadOptions.group),
        filter = [];
    for (i = 0; i < path.length; i++) {
        filterElement = [];
        for (j = 0; j <= i; j++) {
            selector = groups[j].selector;
            if (i === j && (null === path[j] || false === path[j] || true === path[j])) {
                if (false === path[j]) {
                    filterElement.push([selector, "=", groups[j].desc ? true : null])
                } else {
                    if (path[j] ? !groups[j].desc : groups[j].desc) {
                        filterElement.push([selector, "<>", path[j]])
                    } else {
                        filterElement.push([selector, "<>", null]);
                        filterElement.push([selector, "=", null])
                    }
                }
            } else {
                filterElement.push([selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]])
            }
        }
        filter.push(gridCore.combineFilters(filterElement))
    }
    filter = gridCore.combineFilters(filter, "or");
    return gridCore.combineFilters([filter, storeLoadOptions.filter])
};
exports.GroupingHelper = Class.inherit(function() {
    var findGroupInfoByKey = function(groupsInfo, key) {
        var hash = groupsInfo.hash;
        return hash && hash[key]
    };
    var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
        var index, leftIndex = 0,
            rightIndex = groupsInfo.length - 1;
        if (!groupsInfo.length) {
            return 0
        }
        do {
            var middleIndex = rightIndex + leftIndex >> 1;
            if (groupsInfo[middleIndex].offset > offset) {
                rightIndex = middleIndex
            } else {
                leftIndex = middleIndex
            }
        } while (rightIndex - leftIndex > 1);
        for (index = leftIndex; index <= rightIndex; index++) {
            if (groupsInfo[index].offset > offset) {
                break
            }
        }
        return index
    };
    var updateGroupInfoOffsets = function(groupsInfo, parents) {
        var groupInfo, index;
        parents = parents || [];
        for (index = 0; index < groupsInfo.length; index++) {
            groupInfo = groupsInfo[index];
            if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
                groupInfo.offset = groupInfo.data.offset;
                for (var parentIndex = 0; parentIndex < parents.length; parentIndex++) {
                    parents[parentIndex].offset = groupInfo.offset
                }
            }
        }
        groupsInfo.sort(function(a, b) {
            return a.offset - b.offset
        })
    };
    var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
        var i;
        for (i = 0; i < groupsInfo.length; i++) {
            if (groupIndex + 1 >= groupsCount) {
                groupsInfo[i].children = []
            } else {
                cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
            }
        }
    };
    return {
        ctor: function(dataSourceAdapter) {
            this._dataSource = dataSourceAdapter;
            this.reset()
        },
        reset: function() {
            this._groupsInfo = [];
            this._totalCountCorrection = 0;
            this._itemsCount = 0
        },
        totalCountCorrection: function() {
            return this._totalCountCorrection
        },
        updateTotalItemsCount: function(totalCountCorrection) {
            this._totalCountCorrection = totalCountCorrection || 0
        },
        _isGroupItemCountable: function(item) {
            return !this._isVirtualPaging() || !item.isContinuation
        },
        _isVirtualPaging: function() {
            var scrollingMode = this._dataSource.option("scrolling.mode");
            return "virtual" === scrollingMode || "infinite" === scrollingMode
        },
        itemsCount: function() {
            return this._itemsCount
        },
        updateItemsCount: function(data, groupsCount) {
            function calculateItemsCount(that, items, groupsCount) {
                var i, result = 0;
                if (items) {
                    if (!groupsCount) {
                        result = items.length
                    } else {
                        for (i = 0; i < items.length; i++) {
                            if (that._isGroupItemCountable(items[i])) {
                                result++
                            }
                            result += calculateItemsCount(that, items[i].items, groupsCount - 1)
                        }
                    }
                }
                return result
            }
            this._itemsCount = calculateItemsCount(this, data, groupsCount)
        },
        foreachGroups: function(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {
            var that = this;

            function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
                var i, callbackResult, callbackResults = [];

                function executeCallback(callback, data, parents, callbackResults) {
                    var callbackResult = data && callback(data, parents);
                    callbackResult && callbackResults.push(callbackResult);
                    return callbackResult
                }
                for (i = 0; i < groupsInfo.length; i++) {
                    parents.push(groupsInfo[i].data);
                    if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {
                        return false
                    }
                    if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {
                        callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
                        callbackResult && callbackResults.push(callbackResult);
                        if (false === callbackResult) {
                            return false
                        }
                    }
                    if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {
                        return false
                    }
                    if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {
                        updateOffsets = true
                    }
                    parents.pop()
                }
                var currentParents = updateParentOffsets && parents.slice(0);
                return updateOffsets && when.apply($, callbackResults).always(function() {
                    updateGroupInfoOffsets(groupsInfo, currentParents)
                })
            }
            return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
        },
        findGroupInfo: function(path) {
            var pathIndex, groupInfo, that = this,
                groupsInfo = that._groupsInfo;
            for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                groupsInfo = groupInfo && groupInfo.children
            }
            return groupInfo && groupInfo.data
        },
        addGroupInfo: function(groupInfoData) {
            var index, groupInfo, pathIndex, that = this,
                path = groupInfoData.path,
                groupsInfo = that._groupsInfo;
            for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                if (!groupInfo) {
                    groupInfo = {
                        key: path[pathIndex],
                        offset: groupInfoData.offset,
                        data: {
                            offset: groupInfoData.offset,
                            isExpanded: true,
                            path: path.slice(0, pathIndex + 1)
                        },
                        children: []
                    };
                    index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
                    groupsInfo.splice(index, 0, groupInfo);
                    groupsInfo.hash = groupsInfo.hash || {};
                    groupsInfo.hash[groupInfo.key] = groupInfo
                }
                if (pathIndex === path.length - 1) {
                    groupInfo.data = groupInfoData;
                    if (groupInfo.offset !== groupInfoData.offset) {
                        updateGroupInfoOffsets(groupsInfo)
                    }
                }
                groupsInfo = groupInfo.children
            }
        },
        allowCollapseAll: function() {
            return true
        },
        refresh: function(options) {
            var groupIndex, that = this,
                storeLoadOptions = options.storeLoadOptions,
                oldGroups = normalizeSortingInfo(that._group || []),
                groups = normalizeSortingInfo(storeLoadOptions.group || []),
                groupsCount = Math.min(oldGroups.length, groups.length);
            that._group = storeLoadOptions.group;
            for (groupIndex = 0; groupIndex < groupsCount; groupIndex++) {
                if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
                    groupsCount = groupIndex;
                    break
                }
            }
            if (!groupsCount) {
                that.reset()
            } else {
                cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
            }
        },
        handleDataLoading: function() {},
        handleDataLoaded: function(options, callBase) {
            callBase(options)
        },
        handleDataLoadedCore: function(options, callBase) {
            callBase(options)
        }
    }
}());


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.master_detail.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    gridCoreUtils = __webpack_require__(26),
    commonUtils = __webpack_require__(2);
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
    MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
    ROW_LINES_CLASS = "dx-row-lines";
module.exports = {
    defaultOptions: function() {
        return {
            masterDetail: {
                enabled: false,
                autoExpandAll: false,
                template: null
            }
        }
    },
    extenders: {
        controllers: {
            columns: {
                _getExpandColumnsCore: function() {
                    var expandColumns = this.callBase();
                    if (this.option("masterDetail.enabled")) {
                        expandColumns.push({})
                    }
                    return expandColumns
                }
            },
            data: function() {
                var initMasterDetail = function(that) {
                    that._expandedItems = [];
                    that._isExpandAll = that.option("masterDetail.autoExpandAll")
                };
                return {
                    init: function() {
                        var that = this;
                        initMasterDetail(that);
                        that.callBase()
                    },
                    expandAll: function(groupIndex) {
                        var that = this;
                        if (groupIndex < 0) {
                            that._isExpandAll = true;
                            that._expandedItems = [];
                            that.updateItems()
                        } else {
                            that.callBase.apply(that, arguments)
                        }
                    },
                    collapseAll: function(groupIndex) {
                        var that = this;
                        if (groupIndex < 0) {
                            that._isExpandAll = false;
                            that._expandedItems = [];
                            that.updateItems()
                        } else {
                            that.callBase.apply(that, arguments)
                        }
                    },
                    isRowExpanded: function(key) {
                        var that = this,
                            expandIndex = gridCoreUtils.getIndexByKey(key, that._expandedItems);
                        if (Array.isArray(key)) {
                            return that.callBase.apply(that, arguments)
                        } else {
                            return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
                        }
                    },
                    _getRowIndicesForExpand: function(key) {
                        var rowIndex = this.getRowIndexByKey(key);
                        return [rowIndex, rowIndex + 1]
                    },
                    _changeRowExpandCore: function(key) {
                        var expandIndex, that = this;
                        if (Array.isArray(key)) {
                            return that.callBase.apply(that, arguments)
                        } else {
                            expandIndex = gridCoreUtils.getIndexByKey(key, that._expandedItems);
                            if (expandIndex >= 0) {
                                var visible = that._expandedItems[expandIndex].visible;
                                that._expandedItems[expandIndex].visible = !visible
                            } else {
                                that._expandedItems.push({
                                    key: key,
                                    visible: true
                                })
                            }
                            that.updateItems({
                                changeType: "update",
                                rowIndices: that._getRowIndicesForExpand(key)
                            })
                        }
                    },
                    _processDataItem: function(data, options) {
                        var that = this,
                            dataItem = that.callBase.apply(that, arguments);
                        dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                        if (void 0 === options.detailColumnIndex) {
                            options.detailColumnIndex = -1;
                            $.each(options.visibleColumns, function(index, column) {
                                if ("expand" === column.command && !commonUtils.isDefined(column.groupIndex)) {
                                    options.detailColumnIndex = index;
                                    return false
                                }
                            })
                        }
                        if (options.detailColumnIndex >= 0) {
                            dataItem.values[options.detailColumnIndex] = dataItem.isExpanded
                        }
                        return dataItem
                    },
                    _processItems: function(items, changeType) {
                        var expandIndex, that = this,
                            result = [];
                        items = that.callBase.apply(that, arguments);
                        if ("loadingAll" === changeType) {
                            return items
                        }
                        if ("refresh" === changeType) {
                            that._expandedItems = commonUtils.grep(that._expandedItems, function(item) {
                                return item.visible
                            })
                        }
                        $.each(items, function(index, item) {
                            result.push(item);
                            expandIndex = gridCoreUtils.getIndexByKey(item.key, that._expandedItems);
                            if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.inserted) {
                                result.push({
                                    visible: item.isExpanded,
                                    rowType: "detail",
                                    key: item.key,
                                    data: item.data,
                                    values: []
                                })
                            }
                        });
                        return result
                    },
                    optionChanged: function(args) {
                        var value, previousValue, isEnabledChanged, isAutoExpandAllChanged, that = this;
                        if ("masterDetail" === args.name) {
                            args.name = "dataSource";
                            switch (args.fullName) {
                                case "masterDetail":
                                    value = args.value || {};
                                    previousValue = args.previousValue || {};
                                    isEnabledChanged = value.enabled !== previousValue.enabled;
                                    isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                    break;
                                case "masterDetail.enabled":
                                    isEnabledChanged = true;
                                    break;
                                case "masterDetail.autoExpandAll":
                                    isAutoExpandAllChanged = true
                            }
                            if (isEnabledChanged || isAutoExpandAllChanged) {
                                initMasterDetail(that)
                            }
                        }
                        that.callBase(args)
                    }
                }
            }()
        },
        views: {
            rowsView: function() {
                return {
                    _getCellTemplate: function(options) {
                        var template, that = this,
                            column = options.column,
                            editingController = that.getController("editing"),
                            isEditRow = editingController && editingController.isEditRow(options.rowIndex);
                        if ("detail" === column.command && !isEditRow) {
                            template = that.option("masterDetail.template") || that._getDefaultTemplate(column)
                        } else {
                            template = that.callBase.apply(that, arguments)
                        }
                        return template
                    },
                    _cellPrepared: function($cell, options) {
                        var that = this,
                            component = that.component;
                        that.callBase.apply(that, arguments);
                        if (that._isFixedColumns && "detail" === options.rowType && "detail" === options.column.command) {
                            $cell.find("." + that.getWidgetContainerClass()).each(function() {
                                var dataGrid = $(this).parent().data("dxDataGrid");
                                if (dataGrid) {
                                    dataGrid.on("contentReady", function() {
                                        var $rows = component.getRowElement(options.rowIndex);
                                        if ($rows && 2 === $rows.length && $rows.eq(0).height() !== $rows.eq(1).height()) {
                                            component.updateDimensions()
                                        }
                                    })
                                }
                            })
                        }
                    },
                    _isDetailRow: function(row) {
                        return row && row.rowType && 0 === row.rowType.indexOf("detail")
                    },
                    _createRow: function(row) {
                        var $row = this.callBase(row);
                        if (row && this._isDetailRow(row)) {
                            this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS);
                            $row.addClass(MASTER_DETAIL_ROW_CLASS);
                            if (commonUtils.isDefined(row.visible)) {
                                $row.toggle(row.visible)
                            }
                        }
                        return $row
                    },
                    _getGroupCellOptions: function(options) {
                        var row = options.row,
                            groupColumns = this._columnsController.getGroupColumns(),
                            columnIndex = groupColumns.length + options.columnsCountBeforeGroups,
                            emptyCellsCount = columnIndex + Number(this.option("masterDetail.enabled"));
                        if (row && this._isDetailRow(row)) {
                            return {
                                columnIndex: columnIndex,
                                emptyCellsCount: emptyCellsCount,
                                colspan: options.columns.length - emptyCellsCount
                            }
                        }
                        return this.callBase(options)
                    },
                    _renderCells: function($row, options) {
                        var $detailCell, groupCellOptions, i, row = options.row;
                        if (row.rowType && this._isDetailRow(row)) {
                            groupCellOptions = this._getGroupCellOptions(options);
                            for (i = 0; i < groupCellOptions.emptyCellsCount; i++) {
                                this._renderCell($row, {
                                    value: null,
                                    row: row,
                                    rowIndex: row.rowIndex,
                                    column: options.columns[i]
                                })
                            }
                            $detailCell = this._renderCell($row, {
                                value: null,
                                row: row,
                                rowIndex: row.rowIndex,
                                column: {
                                    command: "detail"
                                },
                                columnIndex: groupCellOptions.columnIndex
                            });
                            $detailCell.addClass(CELL_FOCUS_DISABLED_CLASS).addClass(MASTER_DETAIL_CELL_CLASS).attr("colspan", groupCellOptions.colspan)
                        } else {
                            this.callBase.apply(this, arguments)
                        }
                    }
                }
            }()
        }
    }
};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.editor_factory.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    isWrapped = __webpack_require__(41).isWrapped,
    compileGetter = __webpack_require__(14).compileGetter,
    modules = __webpack_require__(23),
    browser = __webpack_require__(21),
    extend = __webpack_require__(1).extend,
    devices = __webpack_require__(6),
    positionUtils = __webpack_require__(46),
    eventUtils = __webpack_require__(3),
    clickEvent = __webpack_require__(11),
    contextMenuEvent = __webpack_require__(146),
    pointerEvents = __webpack_require__(17),
    normalizeDataSourceOptions = __webpack_require__(51).normalizeDataSourceOptions,
    compareVersion = __webpack_require__(37).compare,
    addNamespace = eventUtils.addNamespace;
__webpack_require__(69);
__webpack_require__(81);
__webpack_require__(99);
__webpack_require__(128);
__webpack_require__(153);
var CHECKBOX_SIZE_CLASS = "checkbox-size",
    FOCUS_OVERLAY_CLASS = "focus-overlay",
    CONTENT_CLASS = "content",
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
    EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
    MODULE_NAMESPACE = "dxDataGridEditorFactory",
    UPDATE_FOCUS_EVENTS = addNamespace([pointerEvents.down, "focusin", clickEvent.name].join(" "), MODULE_NAMESPACE),
    FOCUSED_ELEMENT_CLASS = "dx-focused",
    POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
    POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
    FOCUSED_ELEMENT_SELECTOR = "td[tabindex]:focus, input:focus, textarea:focus, .dx-lookup-field:focus",
    DX_HIDDEN = "dx-hidden",
    TAB_KEY = 9;
var EditorFactoryController = modules.ViewController.inherit(function() {
    var getResultConfig = function(config, options) {
        return extend(config, {
            readOnly: options.readOnly,
            placeholder: options.placeholder,
            inputAttr: {
                id: options.id
            },
            tabIndex: options.tabIndex
        }, options.editorOptions)
    };
    var checkEnterBug = function() {
        return browser.msie && parseInt(browser.version) <= 11 || devices.real().ios
    };
    var getTextEditorConfig = function(options) {
        var isValueChanged = false,
            data = {},
            isEnterBug = checkEnterBug(),
            sharedData = options.sharedData || data;
        return getResultConfig({
            placeholder: options.placeholder,
            width: options.width,
            value: options.value,
            onValueChanged: function(e) {
                var updateValue = function(e, notFireEvent) {
                    isValueChanged = false;
                    options && options.setValue(e.value, notFireEvent)
                };
                window.clearTimeout(data.valueChangeTimeout);
                if (e.jQueryEvent && "keyup" === e.jQueryEvent.type && !options.updateValueImmediately) {
                    if ("filterRow" === options.parentType || "searchPanel" === options.parentType) {
                        sharedData.valueChangeTimeout = data.valueChangeTimeout = window.setTimeout(function() {
                            updateValue(e, data.valueChangeTimeout !== sharedData.valueChangeTimeout)
                        }, commonUtils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0)
                    } else {
                        isValueChanged = true
                    }
                } else {
                    updateValue(e)
                }
            },
            onFocusOut: function(e) {
                if (isEnterBug && isValueChanged) {
                    isValueChanged = false;
                    options.setValue(e.component.option("value"))
                }
            },
            onKeyDown: function(e) {
                if (isEnterBug && isValueChanged && 13 === e.jQueryEvent.keyCode) {
                    isValueChanged = false;
                    options.setValue(e.component.option("value"))
                }
            },
            valueChangeEvent: "change" + ("filterRow" === options.parentType || isEnterBug ? " keyup" : "")
        }, options)
    };
    var prepareDateBox = function(options) {
        options.editorName = "dxDateBox";
        options.editorOptions = getResultConfig({
            value: options.value,
            onValueChanged: function(args) {
                options.setValue(args.value)
            },
            onKeyDown: function(e) {
                if (checkEnterBug() && 13 === e.jQueryEvent.keyCode) {
                    e.component.blur();
                    e.component.focus()
                }
            },
            displayFormat: options.format,
            formatWidthCalculator: null,
            width: "auto"
        }, options)
    };
    var prepareTextBox = function(options) {
        var config = getTextEditorConfig(options),
            isSearching = "searchPanel" === options.parentType,
            toString = function(value) {
                return commonUtils.isDefined(value) ? value.toString() : ""
            };
        config.value = toString(options.value);
        config.valueChangeEvent += isSearching ? " keyup search" : "";
        config.mode = isSearching ? "search" : "text";
        options.editorName = "dxTextBox";
        options.editorOptions = config
    };
    var prepareNumberBox = function(options) {
        var config = getTextEditorConfig(options);
        config.value = commonUtils.isDefined(options.value) ? options.value : null;
        options.editorName = "dxNumberBox";
        options.editorOptions = config
    };
    var prepareBooleanEditor = function(options) {
        if ("filterRow" === options.parentType) {
            prepareSelectBox(extend(options, {
                lookup: {
                    displayExpr: function(data) {
                        if (true === data) {
                            return options.trueText || "true"
                        } else {
                            if (false === data) {
                                return options.falseText || "false"
                            }
                        }
                    },
                    dataSource: [true, false]
                }
            }))
        } else {
            prepareCheckBox(options)
        }
    };
    var prepareSelectBox = function(options) {
        var displayGetter, dataSource, postProcess, lookup = options.lookup,
            isFilterRow = "filterRow" === options.parentType;
        if (lookup) {
            displayGetter = compileGetter(lookup.displayExpr);
            dataSource = lookup.dataSource;
            if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
                dataSource = dataSource(options.row || {})
            }
            if (commonUtils.isObject(dataSource) || Array.isArray(dataSource)) {
                dataSource = normalizeDataSourceOptions(dataSource);
                if (isFilterRow) {
                    postProcess = dataSource.postProcess;
                    dataSource.postProcess = function(items) {
                        if (0 === this.pageIndex()) {
                            items = items.slice(0);
                            items.unshift(null)
                        }
                        if (postProcess) {
                            return postProcess.call(this, items)
                        }
                        return items
                    }
                }
            }
            var allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
            options.editorName = "dxSelectBox";
            options.editorOptions = getResultConfig({
                searchEnabled: true,
                value: options.value,
                valueExpr: options.lookup.valueExpr,
                searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
                allowClearing: allowClearing,
                showClearButton: allowClearing,
                displayExpr: function(data) {
                    if (null === data) {
                        return options.showAllText
                    }
                    return displayGetter(data)
                },
                dataSource: dataSource,
                onValueChanged: function(e) {
                    var params = [e.value];
                    !isFilterRow && params.push(e.component.option("text"));
                    options.setValue.apply(this, params)
                }
            }, options)
        }
    };
    var prepareCheckBox = function(options) {
        options.editorName = "dxCheckBox";
        options.editorOptions = getResultConfig({
            value: commonUtils.isDefined(options.value) ? options.value : void 0,
            hoverStateEnabled: !options.readOnly,
            focusStateEnabled: !options.readOnly,
            activeStateEnabled: false,
            onValueChanged: function(e) {
                options.setValue && options.setValue(e.value, e)
            }
        }, options)
    };
    var createEditorCore = function(that, options) {
        if (options.editorName && options.editorOptions && options.editorElement[options.editorName]) {
            if ("dxCheckBox" === options.editorName) {
                if (!options.isOnForm) {
                    options.editorElement.addClass(that.addWidgetPrefix(CHECKBOX_SIZE_CLASS));
                    options.editorElement.parent().addClass(EDITOR_INLINE_BLOCK)
                }
                if (options.command || options.editorOptions.readOnly) {
                    options.editorElement.parent().addClass(CELL_FOCUS_DISABLED_CLASS)
                }
            }
            that._createComponent(options.editorElement, options.editorName, options.editorOptions);
            if ("dxTextBox" === options.editorName) {
                options.editorElement.dxTextBox("instance").registerKeyHandler("enter", commonUtils.noop)
            }
        }
    };
    return {
        _getFocusedElement: function($dataGridElement) {
            return $dataGridElement.find(FOCUSED_ELEMENT_SELECTOR)
        },
        _getFocusCellSelector: function() {
            return ".dx-row > td"
        },
        _updateFocusCore: function() {
            var $focusCell, hideBorders, $focus = this._$focusedElement,
                $dataGridElement = this.component && this.component.element();
            if ($dataGridElement) {
                $focus = this._getFocusedElement($dataGridElement);
                if ($focus.length) {
                    if (!$focus.hasClass(CELL_FOCUS_DISABLED_CLASS)) {
                        $focusCell = $focus.closest(this._getFocusCellSelector() + ", ." + CELL_FOCUS_DISABLED_CLASS);
                        hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(EDITOR_INLINE_BLOCK);
                        $focus = $focusCell
                    }
                    if ($focus.length && !$focus.hasClass(CELL_FOCUS_DISABLED_CLASS)) {
                        this.focus($focus, hideBorders);
                        return
                    }
                }
            }
            this.loseFocus()
        },
        _updateFocus: function(e) {
            var that = this,
                isFocusOverlay = e && e.jQueryEvent && $(e.jQueryEvent.target).hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
            that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
            clearTimeout(that._updateFocusTimeoutID);
            that._updateFocusTimeoutID = setTimeout(function() {
                delete that._updateFocusTimeoutID;
                if (!that._isFocusOverlay) {
                    that._updateFocusCore()
                }
                that._isFocusOverlay = false
            })
        },
        _updateFocusOverlaySize: function($element, position) {
            var location = positionUtils.calculate($element, extend({
                collision: "fit"
            }, position));
            if (location.h.oversize > 0) {
                $element.outerWidth($element.outerWidth() - location.h.oversize)
            }
            if (location.v.oversize > 0) {
                $element.outerHeight($element.outerHeight() - location.v.oversize)
            }
        },
        callbackNames: function() {
            return ["focused"]
        },
        focus: function($element, hideBorder) {
            var that = this;
            if (void 0 === $element) {
                return that._$focusedElement
            } else {
                if ($element) {
                    that._focusTimeoutID = setTimeout(function() {
                        delete that._focusTimeoutID;
                        var focusOverlayPosition, $focusOverlay = that._$focusOverlay = that._$focusOverlay || $("<div>").addClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS) + " " + POINTER_EVENTS_TARGET_CLASS);
                        if (hideBorder) {
                            that._$focusOverlay && that._$focusOverlay.addClass(DX_HIDDEN)
                        } else {
                            var align = browser.msie ? "left bottom" : browser.mozilla ? "right bottom" : "left top",
                                $content = $element.closest("." + that.addWidgetPrefix(CONTENT_CLASS));
                            $focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
                            focusOverlayPosition = {
                                precise: compareVersion($.fn.jquery, [3]) >= 0,
                                my: align,
                                at: align,
                                of: $element,
                                boundary: $content.length && $content
                            };
                            that._updateFocusOverlaySize($focusOverlay, focusOverlayPosition);
                            positionUtils.setup($focusOverlay, focusOverlayPosition);
                            $focusOverlay.css("visibility", "visible")
                        }
                        that._$focusedElement && that._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS);
                        $element.addClass(FOCUSED_ELEMENT_CLASS);
                        that._$focusedElement = $element;
                        that.focused.fire($element)
                    })
                }
            }
        },
        resize: function() {
            var $focusedElement = this._$focusedElement;
            if ($focusedElement) {
                this.focus($focusedElement)
            }
        },
        loseFocus: function() {
            this._$focusedElement && this._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS);
            this._$focusedElement = null;
            this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
        },
        init: function() {
            this.createAction("onEditorPreparing", {
                excludeValidators: ["designMode", "disabled", "readOnly"],
                category: "rendering"
            });
            this.createAction("onEditorPrepared", {
                excludeValidators: ["designMode", "disabled", "readOnly"],
                category: "rendering"
            });
            this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
            $(document).on(UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
            this._attachContainerEventHandlers()
        },
        _attachContainerEventHandlers: function() {
            var that = this,
                $container = that.component && that.component.element(),
                isIE10OrLower = browser.msie && parseInt(browser.version) < 11;
            if ($container) {
                $container.on(addNamespace("keydown", MODULE_NAMESPACE), function(e) {
                    if (e.which === TAB_KEY) {
                        that._updateFocusHandler(e)
                    }
                });
                isIE10OrLower && $container.on([pointerEvents.down, pointerEvents.move, pointerEvents.up, clickEvent.name, contextMenuEvent.name].join(" "), "." + POINTER_EVENTS_TARGET_CLASS, that._focusOverlayEventProxy.bind(that))
            }
        },
        _focusOverlayEventProxy: function(e) {
            var element, $target = $(e.target),
                $currentTarget = $(e.currentTarget),
                needProxy = $target.hasClass(POINTER_EVENTS_TARGET_CLASS) || $target.hasClass(POINTER_EVENTS_NONE_CLASS);
            if (!needProxy || $currentTarget.hasClass(DX_HIDDEN)) {
                return
            }
            $currentTarget.addClass(DX_HIDDEN);
            element = $target.get(0).ownerDocument.elementFromPoint(e.clientX, e.clientY);
            eventUtils.fireEvent({
                originalEvent: e,
                target: element
            });
            e.stopPropagation();
            $currentTarget.removeClass(DX_HIDDEN);
            if (e.type === clickEvent.name && "INPUT" === element.tagName) {
                $(element).focus()
            }
        },
        dispose: function() {
            clearTimeout(this._focusTimeoutID);
            clearTimeout(this._updateFocusTimeoutID);
            $(document).off(UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
        },
        createEditor: function($container, options) {
            options.cancel = false;
            options.editorElement = $container;
            if (!commonUtils.isDefined(options.tabIndex)) {
                options.tabIndex = this.option("tabIndex")
            }
            if (options.lookup) {
                prepareSelectBox(options)
            } else {
                switch (options.dataType) {
                    case "date":
                        prepareDateBox(options);
                        break;
                    case "boolean":
                        prepareBooleanEditor(options);
                        break;
                    case "number":
                        prepareNumberBox(options);
                        break;
                    default:
                        prepareTextBox(options)
                }
            }
            this.executeAction("onEditorPreparing", options);
            if (options.cancel) {
                return
            }
            createEditorCore(this, options);
            this.executeAction("onEditorPrepared", options)
        }
    }
}());
module.exports = {
    defaultOptions: function() {
        return {}
    },
    controllers: {
        editorFactory: EditorFactoryController
    },
    extenders: {
        controllers: {
            columnsResizer: {
                _startResizing: function(args) {
                    this.callBase(args);
                    if (this.isResizing()) {
                        this.getController("editorFactory").loseFocus()
                    }
                }
            }
        }
    }
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.editing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    deepExtendArraySafe = __webpack_require__(84).deepExtendArraySafe,
    extend = __webpack_require__(1).extend,
    modules = __webpack_require__(23),
    clickEvent = __webpack_require__(11),
    gridCoreUtils = __webpack_require__(26),
    getIndexByKey = gridCoreUtils.getIndexByKey,
    eventUtils = __webpack_require__(3),
    addNamespace = eventUtils.addNamespace,
    dialog = __webpack_require__(187),
    messageLocalization = __webpack_require__(8),
    Button = __webpack_require__(25),
    Popup = __webpack_require__(68),
    errors = __webpack_require__(16),
    devices = __webpack_require__(6),
    Form = __webpack_require__(230),
    holdEvent = __webpack_require__(66),
    when = __webpack_require__(10).when;
var EDIT_FORM_CLASS = "edit-form",
    EDIT_FORM_ITEM_CLASS = "edit-form-item",
    FOCUS_OVERLAY_CLASS = "focus-overlay",
    READONLY_CLASS = "readonly",
    EDIT_POPUP_CLASS = "edit-popup",
    FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container",
    ADD_ROW_BUTTON_CLASS = "addrow-button",
    LINK_CLASS = "dx-link",
    EDITOR_CELL_CLASS = "dx-editor-cell",
    ROW_SELECTED = "dx-selection",
    EDIT_ROW = "dx-edit-row",
    EDIT_BUTTON_CLASS = "dx-edit-button",
    BUTTON_CLASS = "dx-button",
    INSERT_INDEX = "__DX_INSERT_INDEX__",
    ROW_CLASS = "dx-row",
    ROW_REMOVED = "dx-row-removed",
    ROW_INSERTED = "dx-row-inserted",
    ROW_MODIFIED = "dx-row-modified",
    CELL_MODIFIED = "dx-cell-modified",
    CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
    EDITING_NAMESPACE = "dxDataGridEditing",
    DATA_ROW_CLASS = "dx-data-row",
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
    EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])",
    FOCUSABLE_ELEMENT_SELECTOR = "[tabindex], " + EDITORS_INPUT_SELECTOR,
    EDIT_MODE_BATCH = "batch",
    EDIT_MODE_ROW = "row",
    EDIT_MODE_CELL = "cell",
    EDIT_MODE_FORM = "form",
    EDIT_MODE_POPUP = "popup",
    DATA_EDIT_DATA_INSERT_TYPE = "insert",
    DATA_EDIT_DATA_UPDATE_TYPE = "update",
    DATA_EDIT_DATA_REMOVE_TYPE = "remove",
    POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
    POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
    EDIT_MODES = [EDIT_MODE_BATCH, EDIT_MODE_ROW, EDIT_MODE_CELL, EDIT_MODE_FORM, EDIT_MODE_POPUP],
    ROW_BASED_MODES = [EDIT_MODE_ROW, EDIT_MODE_FORM, EDIT_MODE_POPUP],
    CELL_BASED_MODES = [EDIT_MODE_BATCH, EDIT_MODE_CELL],
    MODES_WITH_DELAYED_FOCUS = [EDIT_MODE_ROW, EDIT_MODE_FORM];
var getEditMode = function(that) {
    var editMode = that.option("editing.mode");
    if (EDIT_MODES.indexOf(editMode) !== -1) {
        return editMode
    }
    return EDIT_MODE_ROW
};
var isRowEditMode = function(that) {
    var editMode = getEditMode(that);
    return ROW_BASED_MODES.indexOf(editMode) !== -1
};
var EditingController = modules.ViewController.inherit(function() {
    var getDefaultEditorTemplate = function(that) {
        return function(container, options) {
            var $editor = $("<div/>").appendTo(container);
            that.getController("editorFactory").createEditor($editor, extend({}, options.column, {
                value: options.value,
                setValue: options.setValue,
                row: options.row,
                parentType: "dataRow",
                width: null,
                readOnly: !options.setValue,
                isOnForm: options.isOnForm,
                id: options.id,
                updateValueImmediately: isRowEditMode(that)
            }))
        }
    };
    return {
        init: function() {
            var that = this;
            that._editRowIndex = -1;
            that._editData = [];
            that._editColumnIndex = -1;
            that._columnsController = that.getController("columns");
            that._dataController = that.getController("data");
            that._rowsView = that.getView("rowsView");
            if (!that._dataChangedHandler) {
                that._dataChangedHandler = that._handleDataChanged.bind(that);
                that._dataController.changed.add(that._dataChangedHandler)
            }
            if (!that._saveEditorHandler) {
                that.createAction("onInitNewRow", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowInserting", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowInserted", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onEditingStart", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowUpdating", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowUpdated", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowRemoving", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowRemoved", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that._saveEditorHandler = that.createAction(function(e) {
                    var isEditorPopup, isDomElement, isFocusOverlay, isAddRowButton, isCellEditMode, $target, event = e.jQueryEvent;
                    if (!isRowEditMode(that) && !that._editCellInProgress) {
                        $target = $(event.target);
                        isEditorPopup = $target.closest(".dx-dropdowneditor-overlay").length;
                        isDomElement = $target.closest(document).length;
                        isAddRowButton = $target.closest("." + that.addWidgetPrefix(ADD_ROW_BUTTON_CLASS)).length;
                        isFocusOverlay = $target.hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
                        isCellEditMode = getEditMode(that) === EDIT_MODE_CELL;
                        if (!isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && that.isEditing()) && isDomElement) {
                            that._closeEditItem.bind(that)($target)
                        }
                    }
                });
                $(document).on(clickEvent.name, that._saveEditorHandler)
            }
            that._updateEditColumn();
            that._updateEditButtons()
        },
        _closeEditItem: function($targetElement) {
            var isDataRow = $targetElement.closest("." + DATA_ROW_CLASS).length,
                $targetCell = $targetElement.closest("." + ROW_CLASS + "> td"),
                columnIndex = $targetCell[0] && $targetCell[0].cellIndex,
                rowIndex = this.getView("rowsView").getRowIndex($targetCell.parent()),
                visibleColumns = this._columnsController.getVisibleColumns(),
                allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
            if (this.isEditing() && (!isDataRow || isDataRow && !allowEditing && !this.isEditCell(rowIndex, columnIndex))) {
                this.closeEditCell()
            }
        },
        _handleDataChanged: function(args) {
            if ("standard" === this.option("scrolling.mode")) {
                this.resetRowAndPageIndices()
            }
            if ("prepend" === args.changeType) {
                $.each(this._editData, function(_, editData) {
                    editData.rowIndex += args.items.length;
                    if (editData.type === DATA_EDIT_DATA_INSERT_TYPE) {
                        editData.key.rowIndex += args.items.length;
                        editData.key.dataRowIndex += args.items.filter(function(item) {
                            return "data" === item.rowType
                        }).length
                    }
                })
            }
        },
        isRowEditMode: function() {
            return isRowEditMode(this)
        },
        getEditMode: function() {
            return getEditMode(this)
        },
        getFirstEditableColumnIndex: function() {
            var columnIndex, columnsController = this.getController("columns");
            if (getEditMode(this) === EDIT_MODE_FORM && this._firstFormItem) {
                columnIndex = this._firstFormItem.column.index
            } else {
                var visibleColumns = columnsController.getVisibleColumns();
                $.each(visibleColumns, function(index, column) {
                    if (column.allowEditing) {
                        columnIndex = index;
                        return false
                    }
                })
            }
            return columnIndex
        },
        getFirstEditableCellInRow: function(rowIndex) {
            return this.getView("rowsView").getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
        },
        getFocusedCellInRow: function(rowIndex) {
            return this.getFirstEditableCellInRow(rowIndex)
        },
        getIndexByKey: function(key, items) {
            return getIndexByKey(key, items)
        },
        hasChanges: function() {
            var that = this,
                result = false;
            for (var i = 0; i < that._editData.length; i++) {
                if (that._editData[i].type) {
                    result = true;
                    break
                }
            }
            return result
        },
        dispose: function() {
            this.callBase();
            clearTimeout(this._inputFocusTimeoutID);
            $(document).off(clickEvent.name, this._saveEditorHandler)
        },
        optionChanged: function(args) {
            if ("editing" === args.name) {
                this.init();
                args.handled = true
            } else {
                this.callBase(args)
            }
        },
        publicMethods: function() {
            return ["insertRow", "addRow", "removeRow", "deleteRow", "undeleteRow", "editRow", "editCell", "closeEditCell", "saveEditData", "cancelEditData", "hasEditData"]
        },
        refresh: function() {
            if (getEditMode(this) === EDIT_MODE_CELL) {
                return
            }
            if (getEditMode(this) !== EDIT_MODE_BATCH) {
                this.init()
            } else {
                this._editRowIndex = -1;
                this._editColumnIndex = -1
            }
        },
        isEditing: function() {
            return this._editRowIndex > -1
        },
        isEditRow: function(rowIndex) {
            var editMode = getEditMode(this);
            return this._getVisibleEditRowIndex() === rowIndex && ROW_BASED_MODES.indexOf(editMode) !== -1
        },
        getEditRowKey: function() {
            var items = this._dataController.items(),
                item = items[this._getVisibleEditRowIndex()];
            return item && item.key
        },
        getEditFormRowIndex: function() {
            var editMode = getEditMode(this);
            return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP ? this._getVisibleEditRowIndex() : -1
        },
        isEditCell: function(rowIndex, columnIndex) {
            return this._getVisibleEditRowIndex() === rowIndex && this._editColumnIndex === columnIndex
        },
        getPopupContent: function() {
            var editMode = getEditMode(this),
                popupVisible = this._editPopup && this._editPopup.option("visible");
            if (editMode === EDIT_MODE_POPUP && popupVisible) {
                return this._editPopup.content()
            }
        },
        getEditForm: function() {
            return this._editForm
        },
        _needInsertItem: function(editData, changeType) {
            var that = this,
                dataSource = that._dataController.dataSource(),
                scrollingMode = that.option("scrolling.mode"),
                pageIndex = dataSource.pageIndex(),
                beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex,
                endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
            if ("standard" !== scrollingMode) {
                switch (changeType) {
                    case "append":
                        return editData.key.pageIndex === endPageIndex;
                    case "prepend":
                        return editData.key.pageIndex === beginPageIndex;
                    case "refresh":
                        editData.key.rowIndex = 0;
                        editData.key.dataRowIndex = 0;
                        editData.key.pageIndex = 0;
                        break;
                    default:
                        return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex
                }
            }
            return editData.key.pageIndex === pageIndex
        },
        _generateNewItem: function(key) {
            var item = {
                key: key
            };
            if (key && key[INSERT_INDEX]) {
                item[INSERT_INDEX] = key[INSERT_INDEX]
            }
            return item
        },
        processItems: function(items, changeType) {
            var i, key, item, that = this,
                editData = that._editData;
            that.update(changeType);
            for (i = 0; i < editData.length; i++) {
                key = editData[i].key;
                item = that._generateNewItem(key);
                if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && that._needInsertItem(editData[i], changeType, items, item)) {
                    items.splice(key.dataRowIndex, 0, item)
                }
            }
            return items
        },
        processDataItem: function(item, options, generateDataValues) {
            var data, editMode, editData, editIndex, that = this,
                columns = options.visibleColumns,
                key = item.data[INSERT_INDEX] ? item.data.key : item.key;
            editIndex = getIndexByKey(key, that._editData);
            if (editIndex >= 0) {
                editMode = getEditMode(that);
                editData = that._editData[editIndex];
                data = editData.data;
                item.isEditing = options.rowIndex === that._getVisibleEditRowIndex();
                switch (editData.type) {
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        if (editMode === EDIT_MODE_POPUP) {
                            item.visible = false
                        }
                        item.inserted = true;
                        item.key = key;
                        item.data = data;
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        item.modified = true;
                        item.oldData = item.data;
                        item.data = deepExtendArraySafe(deepExtendArraySafe({}, item.data), data);
                        item.modifiedValues = generateDataValues(data, columns);
                        break;
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        if (editMode === EDIT_MODE_BATCH) {
                            item.data = deepExtendArraySafe(deepExtendArraySafe({}, item.data), data)
                        }
                        item.removed = true
                }
            }
        },
        insertRow: function() {
            errors.log("W0002", "dxDataGrid", "insertRow", "15.2", "Use the 'addRow' method instead");
            return this.addRow()
        },
        _initNewRow: function(options, insertKey) {
            this.executeAction("onInitNewRow", options);
            var rows = this._dataController.items(),
                row = rows[insertKey.rowIndex];
            if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
                insertKey.rowIndex++
            }
            insertKey.dataRowIndex = rows.filter(function(row, index) {
                return index < insertKey.rowIndex && "data" === row.rowType
            }).length
        },
        _getInsertIndex: function() {
            var maxInsertIndex = 0;
            this._editData.forEach(function(editItem) {
                if (editItem.type === DATA_EDIT_DATA_INSERT_TYPE && editItem.key[INSERT_INDEX] > maxInsertIndex) {
                    maxInsertIndex = editItem.key[INSERT_INDEX]
                }
            });
            return maxInsertIndex + 1
        },
        addRow: function(parentKey) {
            var $firstCell, that = this,
                dataController = that._dataController,
                store = dataController.store(),
                key = store && store.key(),
                rowsView = that.getView("rowsView"),
                param = {
                    data: {}
                },
                parentRowIndex = dataController.getRowIndexByKey(parentKey),
                insertKey = {
                    pageIndex: dataController.pageIndex(),
                    rowIndex: parentRowIndex >= 0 ? parentRowIndex + 1 : rowsView ? rowsView.getTopVisibleItemIndex() : 0,
                    parentKey: parentKey
                },
                oldEditRowIndex = that._getVisibleEditRowIndex(),
                editMode = getEditMode(that);
            if (editMode === EDIT_MODE_CELL && that.hasChanges()) {
                that.saveEditData()
            }
            that.refresh();
            var insertIndex = that._getInsertIndex();
            if (editMode !== EDIT_MODE_BATCH && insertIndex > 1) {
                return
            }
            if (!key) {
                param.data.__KEY__ = String(new Guid)
            }
            that._initNewRow(param, insertKey);
            if (editMode !== EDIT_MODE_BATCH) {
                that._editRowIndex = insertKey.rowIndex + that._dataController.getRowIndexOffset()
            }
            insertKey[INSERT_INDEX] = insertIndex;
            that._addEditData({
                key: insertKey,
                data: param.data,
                type: DATA_EDIT_DATA_INSERT_TYPE
            });
            dataController.updateItems({
                changeType: "update",
                rowIndices: [oldEditRowIndex, insertKey.rowIndex]
            });
            if (editMode === EDIT_MODE_POPUP) {
                that._showEditPopup(insertKey.rowIndex)
            } else {
                $firstCell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                that._editCellInProgress = true;
                that._delayedInputFocus($firstCell, function() {
                    that._editCellInProgress = false;
                    var $cell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                    $cell && $cell.trigger(clickEvent.name)
                })
            }
            that._afterInsertRow({
                key: insertKey,
                data: param.data
            })
        },
        _isEditingStart: function(options) {
            this.executeAction("onEditingStart", options);
            return options.cancel
        },
        _beforeEditCell: function(rowIndex, columnIndex, item) {
            var that = this;
            if (getEditMode(that) === EDIT_MODE_CELL && !item.inserted && that.hasChanges()) {
                var d = $.Deferred();
                that.saveEditData().always(function() {
                    d.resolve(that.hasChanges())
                });
                return d
            }
        },
        _beforeUpdateItems: function() {},
        _getVisibleEditRowIndex: function() {
            return this._editRowIndex >= 0 ? this._editRowIndex - this._dataController.getRowIndexOffset() : -1
        },
        editRow: function(rowIndex) {
            var $editingCell, that = this,
                dataController = that._dataController,
                items = dataController.items(),
                item = items[rowIndex],
                params = {
                    data: item.data,
                    cancel: false
                },
                oldEditRowIndex = that._getVisibleEditRowIndex();
            if (rowIndex === oldEditRowIndex) {
                return true
            }
            if (!item.inserted) {
                params.key = item.key
            }
            if (that._isEditingStart(params)) {
                return
            }
            that.init();
            that._pageIndex = dataController.pageIndex();
            that._editRowIndex = (items[0].inserted ? rowIndex - 1 : rowIndex) + that._dataController.getRowIndexOffset();
            that._addEditData({
                data: {},
                key: item.key,
                oldData: item.data
            });
            var rowIndices = [oldEditRowIndex, rowIndex],
                editMode = getEditMode(that);
            that._beforeUpdateItems(rowIndices, rowIndex, oldEditRowIndex);
            if (editMode === EDIT_MODE_POPUP) {
                that._showEditPopup(rowIndex)
            } else {
                dataController.updateItems({
                    changeType: "update",
                    rowIndices: rowIndices
                })
            }
            if (MODES_WITH_DELAYED_FOCUS.indexOf(editMode) !== -1) {
                $editingCell = that.getFocusedCellInRow(that._getVisibleEditRowIndex());
                that._delayedInputFocus($editingCell, function() {
                    $editingCell && that.component.focus($editingCell)
                })
            }
        },
        _showEditPopup: function(rowIndex) {
            var that = this,
                isMobileDevice = "desktop" !== devices.current().deviceType,
                popupOptions = extend({
                    showTitle: false,
                    fullScreen: isMobileDevice,
                    toolbarItems: [{
                        toolbar: "bottom",
                        location: "after",
                        widget: "dxButton",
                        options: that._getSaveButtonConfig()
                    }, {
                        toolbar: "bottom",
                        location: "after",
                        widget: "dxButton",
                        options: that._getCancelButtonConfig()
                    }],
                    contentTemplate: that._getPopupEditFormTemplate(rowIndex)
                }, that.option("editing.popup"));
            if (!that._editPopup) {
                var $popupContainer = $("<div>").appendTo(that.component.element()).addClass(that.addWidgetPrefix(EDIT_POPUP_CLASS));
                that._editPopup = that._createComponent($popupContainer, Popup, {});
                that._editPopup.on("hidden", that._getEditPopupHiddenHandler());
                that._editPopup.on("shown", function(e) {
                    e.component.content().find(FOCUSABLE_ELEMENT_SELECTOR).first().focus()
                })
            }
            that._editPopup.option(popupOptions);
            that._editPopup.show()
        },
        _getEditPopupHiddenHandler: function() {
            var that = this;
            return function(e) {
                if (that.isEditing()) {
                    that.cancelEditData()
                }
            }
        },
        _getPopupEditFormTemplate: function(rowIndex) {
            var that = this,
                rowData = that.component.getVisibleRows()[rowIndex],
                templateOptions = {
                    row: rowData,
                    rowType: rowData.rowType,
                    key: rowData.key
                };
            return function($container) {
                var formTemplate = that.getEditFormTemplate();
                formTemplate($container, templateOptions, true)
            }
        },
        _getSaveButtonConfig: function() {
            return {
                text: this.option("editing.texts.saveRowChanges"),
                onClick: this.saveEditData.bind(this)
            }
        },
        _getCancelButtonConfig: function() {
            return {
                text: this.option("editing.texts.cancelRowChanges"),
                onClick: this.cancelEditData.bind(this)
            }
        },
        editCell: function(rowIndex, columnIndex) {
            var that = this,
                columnsController = that._columnsController,
                dataController = that._dataController,
                items = dataController.items(),
                item = items[rowIndex],
                params = {
                    data: item && item.data,
                    cancel: false
                },
                oldEditRowIndex = that._getVisibleEditRowIndex(),
                visibleColumns = columnsController.getVisibleColumns(),
                oldColumn = visibleColumns[that._editColumnIndex];
            if (commonUtils.isString(columnIndex)) {
                columnIndex = columnsController.columnOption(columnIndex, "index");
                columnIndex = columnsController.getVisibleIndex(columnIndex)
            }
            var column = params.column = visibleColumns[columnIndex];
            if (column && item && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && !isRowEditMode(that)) {
                if (that.isEditCell(rowIndex, columnIndex)) {
                    return true
                }
                var editRowIndex = rowIndex + dataController.getRowIndexOffset();
                return when(that._beforeEditCell(rowIndex, columnIndex, item)).done(function(cancel) {
                    if (cancel) {
                        return
                    }
                    if (that._prepareEditCell(params, item, columnIndex, editRowIndex)) {
                        that._repaintEditCell(column, oldColumn, oldEditRowIndex)
                    }
                })
            }
            return false
        },
        _prepareEditCell: function(params, item, editColumnIndex, editRowIndex) {
            var that = this;
            if (!item.inserted) {
                params.key = item.key
            }
            if (that._isEditingStart(params)) {
                return false
            }
            that._editRowIndex = editRowIndex;
            that._editColumnIndex = editColumnIndex;
            that._pageIndex = that._dataController.pageIndex();
            that._addEditData({
                data: {},
                key: item.key,
                oldData: item.data
            });
            return true
        },
        _repaintEditCell: function(column, oldColumn, oldEditRowIndex) {
            var that = this,
                rowsView = that._rowsView;
            if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
                that._editCellInProgress = true;
                that.getController("editorFactory").loseFocus();
                that._dataController.updateItems({
                    changeType: "update",
                    rowIndices: [oldEditRowIndex, that._getVisibleEditRowIndex()]
                })
            }
            var $cell = rowsView && rowsView.getCellElement(that._getVisibleEditRowIndex(), that._editColumnIndex);
            if ($cell && !$cell.find(":focus").length) {
                that._focusEditingCell(function() {
                    that._editCellInProgress = false
                }, $cell, true)
            } else {
                that._editCellInProgress = false
            }
        },
        _delayedInputFocus: function($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
            var that = this;

            function inputFocus() {
                if (beforeFocusCallback) {
                    beforeFocusCallback()
                }
                $cell && $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first().focus();
                that._beforeFocusCallback = null
            }
            if (devices.real().ios || devices.real().android) {
                inputFocus()
            } else {
                if (that._beforeFocusCallback) {
                    that._beforeFocusCallback()
                }
                clearTimeout(that._inputFocusTimeoutID);
                if (callBeforeFocusCallbackAlways) {
                    that._beforeFocusCallback = beforeFocusCallback
                }
                that._inputFocusTimeoutID = setTimeout(inputFocus)
            }
        },
        _focusEditingCell: function(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
            var that = this,
                rowsView = that.getView("rowsView");
            $editCell = $editCell || rowsView && rowsView.getCellElement(that._getVisibleEditRowIndex(), that._editColumnIndex);
            that._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways)
        },
        removeRow: function(rowIndex) {
            errors.log("W0002", "dxDataGrid", "removeRow", "15.2", "Use the 'deleteRow' method instead");
            return this.deleteRow(rowIndex)
        },
        deleteRow: function(rowIndex) {
            var removeByKey, showDialogTitle, that = this,
                editingOptions = that.option("editing"),
                editingTexts = editingOptions && editingOptions.texts,
                confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
                isBatchMode = editingOptions && editingOptions.mode === EDIT_MODE_BATCH,
                confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
                dataController = that._dataController,
                oldEditRowIndex = that._getVisibleEditRowIndex(),
                item = dataController.items()[rowIndex],
                key = item && item.key;
            if (item) {
                removeByKey = function(key) {
                    that.refresh();
                    var editIndex = getIndexByKey(key, that._editData);
                    if (editIndex >= 0) {
                        if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
                            that._editData.splice(editIndex, 1)
                        } else {
                            that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE
                        }
                    } else {
                        that._addEditData({
                            key: key,
                            oldData: item.data,
                            type: DATA_EDIT_DATA_REMOVE_TYPE
                        })
                    }
                    if (isBatchMode) {
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, rowIndex]
                        })
                    } else {
                        that.saveEditData()
                    }
                };
                if (isBatchMode || !confirmDeleteMessage) {
                    removeByKey(key)
                } else {
                    showDialogTitle = commonUtils.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
                    dialog.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
                        if (confirmResult) {
                            removeByKey(key)
                        }
                    })
                }
            }
        },
        undeleteRow: function(rowIndex) {
            var that = this,
                dataController = that._dataController,
                item = dataController.items()[rowIndex],
                oldEditRowIndex = that._getVisibleEditRowIndex(),
                key = item && item.key;
            if (item) {
                var editData, editIndex = getIndexByKey(key, that._editData);
                if (editIndex >= 0) {
                    editData = that._editData[editIndex];
                    if (typeUtils.isEmptyObject(editData.data)) {
                        that._editData.splice(editIndex, 1)
                    } else {
                        editData.type = DATA_EDIT_DATA_UPDATE_TYPE
                    }
                    dataController.updateItems({
                        changeType: "update",
                        rowIndices: [oldEditRowIndex, rowIndex]
                    })
                }
            }
        },
        _saveEditDataCore: function(deferreds, results) {
            var that = this,
                store = that._dataController.store(),
                isDataSaved = true;

            function executeEditingAction(actionName, params, func) {
                var deferred = $.Deferred();
                that.executeAction(actionName, params);

                function createFailureHandler(deferred) {
                    return function(arg) {
                        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
                        deferred.reject(error)
                    }
                }
                when(params.cancel).done(function(cancel) {
                    if (cancel) {
                        deferred.resolve("cancel")
                    } else {
                        func(params).done(deferred.resolve).fail(createFailureHandler(deferred))
                    }
                }).fail(createFailureHandler(deferred));
                return deferred
            }
            $.each(that._editData, function(index, editData) {
                var deferred, doneDeferred, params, data = editData.data,
                    oldData = editData.oldData,
                    type = editData.type;
                if (that._beforeSaveEditData(editData, index)) {
                    return
                }
                switch (type) {
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        params = {
                            data: oldData,
                            key: editData.key,
                            cancel: false
                        };
                        deferred = executeEditingAction("onRowRemoving", params, function() {
                            return store.remove(editData.key)
                        });
                        break;
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        params = {
                            data: data,
                            cancel: false
                        };
                        deferred = executeEditingAction("onRowInserting", params, function() {
                            return store.insert(params.data).done(function(data, key) {
                                editData.key = key
                            })
                        });
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        params = {
                            newData: data,
                            oldData: oldData,
                            key: editData.key,
                            cancel: false
                        };
                        deferred = executeEditingAction("onRowUpdating", params, function() {
                            return store.update(editData.key, params.newData)
                        })
                }
                if (deferred) {
                    doneDeferred = $.Deferred();
                    deferred.always(function(data) {
                        isDataSaved = "cancel" !== data;
                        results.push({
                            key: editData.key,
                            result: data
                        })
                    }).always(doneDeferred.resolve);
                    deferreds.push(doneDeferred.promise())
                }
            });
            return isDataSaved
        },
        _processSaveEditDataResult: function(results) {
            var i, arg, cancel, editData, editIndex, isError, $popupContent, that = this,
                dataController = that._dataController,
                hasSavedData = false,
                editMode = getEditMode(that);
            for (i = 0; i < results.length; i++) {
                arg = results[i].result;
                cancel = "cancel" === arg;
                editIndex = getIndexByKey(results[i].key, that._editData);
                editData = that._editData[editIndex];
                if (editData) {
                    isError = arg && arg instanceof Error;
                    if (isError) {
                        editData.error = arg;
                        $popupContent = that.getPopupContent();
                        dataController.dataErrorOccurred.fire(arg, $popupContent);
                        if (editMode !== EDIT_MODE_BATCH) {
                            break
                        }
                    } else {
                        if (!cancel || editMode !== EDIT_MODE_BATCH && editData.type === DATA_EDIT_DATA_REMOVE_TYPE) {
                            that._editData.splice(editIndex, 1);
                            hasSavedData = !cancel
                        }
                    }
                }
            }
            return hasSavedData
        },
        _fireSaveEditDataEvents: function(editData) {
            var that = this;
            $.each(editData, function(_, itemData) {
                var data = itemData.data,
                    key = itemData.key,
                    type = itemData.type,
                    params = {
                        key: key,
                        data: data
                    };
                if (itemData.error) {
                    params.error = itemData.error
                }
                switch (type) {
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        that.executeAction("onRowRemoved", extend({}, params, {
                            data: itemData.oldData
                        }));
                        break;
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        that.executeAction("onRowInserted", params);
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        that.executeAction("onRowUpdated", params)
                }
            })
        },
        saveEditData: function() {
            var editData, that = this,
                results = [],
                deferreds = [],
                dataController = that._dataController,
                dataSource = dataController.dataSource(),
                editMode = getEditMode(that),
                result = $.Deferred();
            var resetEditIndices = function(that) {
                if (editMode !== EDIT_MODE_CELL) {
                    that._editColumnIndex = -1;
                    that._editRowIndex = -1
                }
            };
            if (that._beforeSaveEditData() || that._saving) {
                that._afterSaveEditData();
                return result.resolve().promise()
            }
            if (!that._saveEditDataCore(deferreds, results) && editMode === EDIT_MODE_CELL) {
                that._focusEditingCell()
            }
            if (deferreds.length) {
                that._saving = true;
                dataSource && dataSource.beginLoading();
                when.apply($, deferreds).done(function() {
                    editData = that._editData.slice(0);
                    if (that._processSaveEditDataResult(results)) {
                        resetEditIndices(that);
                        if (editMode === EDIT_MODE_POPUP && that._editPopup) {
                            that._editPopup.hide()
                        }
                        dataSource && dataSource.endLoading();
                        when(dataController.refresh()).always(function() {
                            that._fireSaveEditDataEvents(editData);
                            that._afterSaveEditData();
                            result.resolve()
                        })
                    } else {
                        dataSource && dataSource.endLoading();
                        result.resolve()
                    }
                }).fail(function() {
                    dataSource && dataSource.endLoading();
                    result.resolve()
                });
                return result.always(function() {
                    that._focusEditingCell();
                    that._saving = false
                }).promise()
            }
            if (isRowEditMode(that)) {
                if (!that.hasChanges()) {
                    that.cancelEditData()
                }
            } else {
                if (CELL_BASED_MODES.indexOf(editMode) !== -1) {
                    resetEditIndices(that);
                    dataController.updateItems()
                } else {
                    that._focusEditingCell()
                }
            }
            that._afterSaveEditData();
            return result.resolve().promise()
        },
        _updateEditColumn: function() {
            var that = this,
                isEditColumnVisible = that._isEditColumnVisible();
            that._columnsController.addCommandColumn({
                command: "edit",
                visible: isEditColumnVisible,
                cssClass: "dx-command-edit",
                width: "auto"
            });
            that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
        },
        _isEditColumnVisible: function() {
            var that = this,
                editingOptions = that.option("editing");
            if (editingOptions) {
                var editMode = getEditMode(that),
                    isVisibleWithCurrentEditMode = false;
                switch (editMode) {
                    case EDIT_MODE_ROW:
                        isVisibleWithCurrentEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
                        break;
                    case EDIT_MODE_FORM:
                    case EDIT_MODE_POPUP:
                        isVisibleWithCurrentEditMode = editingOptions.allowUpdating
                }
                return editingOptions.allowDeleting || isVisibleWithCurrentEditMode
            }
        },
        _updateEditButtons: function() {
            var that = this,
                headerPanel = that.getView("headerPanel"),
                hasChanges = that.hasChanges();
            if (headerPanel) {
                headerPanel.setToolbarItemDisabled("saveButton", !hasChanges);
                headerPanel.setToolbarItemDisabled("revertButton", !hasChanges)
            }
        },
        _applyModified: function($element) {
            $element && $element.addClass(CELL_MODIFIED)
        },
        _beforeCloseEditCellInBatchMode: function() {},
        cancelEditData: function() {
            var that = this,
                editMode = getEditMode(that),
                rowIndex = this._editRowIndex,
                dataController = that._dataController;
            that._beforeCancelEditData();
            that.init();
            if (ROW_BASED_MODES.indexOf(editMode) !== -1 && rowIndex >= 0) {
                dataController.updateItems({
                    changeType: "update",
                    rowIndices: [rowIndex, rowIndex + 1]
                })
            } else {
                dataController.updateItems()
            }
            if (editMode === EDIT_MODE_POPUP) {
                that._hideEditPopup()
            }
        },
        _hideEditPopup: function() {
            this._editPopup && this._editPopup.option("visible", false)
        },
        hasEditData: function() {
            return this.hasChanges()
        },
        closeEditCell: function() {
            var that = this,
                editMode = getEditMode(that),
                oldEditRowIndex = that._getVisibleEditRowIndex(),
                dataController = that._dataController;
            if (!isRowEditMode(that)) {
                setTimeout(function() {
                    if (editMode === EDIT_MODE_CELL && that.hasChanges()) {
                        that.saveEditData().done(function() {
                            if (!that.hasChanges()) {
                                that.closeEditCell()
                            }
                        })
                    } else {
                        if (oldEditRowIndex >= 0) {
                            var rowIndices = [oldEditRowIndex];
                            that._editRowIndex = -1;
                            that._editColumnIndex = -1;
                            that._beforeCloseEditCellInBatchMode(rowIndices);
                            dataController.updateItems({
                                changeType: "update",
                                rowIndices: rowIndices
                            })
                        }
                    }
                })
            }
        },
        update: function(changeType) {
            var that = this,
                dataController = that._dataController;
            if (dataController && that._pageIndex !== dataController.pageIndex()) {
                if ("refresh" === changeType) {
                    that.refresh()
                }
                that._pageIndex = dataController.pageIndex()
            }
            that._updateEditButtons()
        },
        _getRowIndicesForCascadeUpdating: function(row) {
            return [row.rowIndex]
        },
        updateFieldValue: function(options, value, text, forceUpdateRow) {
            var params, that = this,
                data = {},
                rowKey = options.key,
                $cellElement = options.cellElement,
                editMode = getEditMode(that);
            if (void 0 === rowKey) {
                that._dataController.dataErrorOccurred.fire(errors.Error("E1043"))
            }
            if (void 0 !== rowKey && options.column.setCellValue) {
                if (editMode === EDIT_MODE_BATCH) {
                    that._applyModified($cellElement, options)
                }
                options.value = value;
                options.column.setCellValue(data, value, text);
                if (text && options.column.displayValueMap) {
                    options.column.displayValueMap[value] = text
                }
                params = {
                    data: data,
                    key: rowKey,
                    oldData: options.data,
                    type: DATA_EDIT_DATA_UPDATE_TYPE
                };
                that._addEditData(params, options.row);
                that._updateEditButtons();
                if (options.column.showEditorAlways && getEditMode(that) === EDIT_MODE_CELL && options.row && !options.row.inserted) {
                    that.saveEditData()
                } else {
                    if (options.row && (forceUpdateRow || options.column.setCellValue !== options.column.defaultSetCellValue)) {
                        that._updateEditRow(options.row, forceUpdateRow)
                    }
                }
            }
        },
        _updateEditRow: function(row, forceUpdateRow) {
            var that = this,
                editMode = getEditMode(that);
            if (editMode === EDIT_MODE_POPUP) {
                setTimeout(this._updatePopupForm.bind(this, forceUpdateRow))
            } else {
                this._dataController.updateItems({
                    changeType: "update",
                    rowIndices: this._getRowIndicesForCascadeUpdating(row)
                });
                if (!forceUpdateRow) {
                    this._focusEditingCell()
                }
            }
        },
        _updatePopupForm: function(forceUpdateRow) {
            var columnIndex, $focusedItemElement, rowsView = this._rowsView,
                rowIndex = this.getEditFormRowIndex();
            if (rowIndex >= 0 && this._editForm) {
                if (!forceUpdateRow) {
                    $focusedItemElement = this._editForm.element().find(".dx-state-focused");
                    columnIndex = rowsView.getCellIndex($focusedItemElement, rowIndex)
                }
                this._editForm.repaint();
                if (columnIndex >= 0) {
                    $focusedItemElement = rowsView.getCellElement(rowIndex, columnIndex);
                    this._delayedInputFocus($focusedItemElement)
                }
            }
        },
        _addEditData: function(options, row) {
            var that = this,
                editDataIndex = getIndexByKey(options.key, that._editData);
            if (editDataIndex < 0) {
                editDataIndex = that._editData.length;
                that._editData.push(options)
            }
            if (that._editData[editDataIndex]) {
                options.type = that._editData[editDataIndex].type || options.type;
                deepExtendArraySafe(that._editData[editDataIndex], {
                    data: options.data,
                    type: options.type
                });
                if (row) {
                    row.data = deepExtendArraySafe(deepExtendArraySafe({}, row.data), options.data)
                }
            }
            return editDataIndex
        },
        _getFormEditItemTemplate: function(cellOptions, column) {
            return column.editCellTemplate || getDefaultEditorTemplate(this)
        },
        renderFormEditTemplate: function(detailCellOptions, item, form, $container, isReadOnly) {
            var that = this,
                column = item.column,
                rowData = detailCellOptions.row && detailCellOptions.row.data,
                cellOptions = extend({}, detailCellOptions, {
                    cellElement: null,
                    isOnForm: true,
                    item: item,
                    value: column.calculateCellValue(rowData),
                    column: extend({}, column, {
                        editorOptions: item.editorOptions
                    }),
                    id: form.getItemID(item.name || item.dataField),
                    columnIndex: column.index,
                    setValue: !isReadOnly && column.allowEditing && function(value) {
                        that.updateFieldValue(cellOptions, value)
                    }
                }),
                template = that._getFormEditItemTemplate.bind(that)(cellOptions, column);
            if (that._rowsView.renderTemplate($container, template, cellOptions, !!$container.closest(document).length)) {
                that._rowsView._updateCell($container, cellOptions)
            }
        },
        getFormEditorTemplate: function(cellOptions, item) {
            var that = this;
            return function(options, $container) {
                that.renderFormEditTemplate.bind(that)(cellOptions, item, options.component, $container)
            }
        },
        getEditFormTemplate: function() {
            var that = this;
            return function($container, detailOptions, renderFormOnly) {
                var editFormOptions = that.option("editing.form"),
                    items = that.option("editing.form.items"),
                    userCustomizeItem = that.option("editing.form.customizeItem"),
                    editData = that._editData[getIndexByKey(detailOptions.key, that._editData)],
                    editFormItemClass = that.addWidgetPrefix(EDIT_FORM_ITEM_CLASS),
                    isScrollingEnabled = getEditMode(that) === EDIT_MODE_POPUP;
                if (!items) {
                    var columns = that.getController("columns").getColumns();
                    items = [];
                    $.each(columns, function(_, column) {
                        if (!column.isBand) {
                            items.push({
                                column: column,
                                name: column.name,
                                dataField: column.dataField
                            })
                        }
                    })
                }
                that._firstFormItem = void 0;
                that._editForm = that._createComponent($("<div>").appendTo($container), Form, extend({
                    scrollingEnabled: isScrollingEnabled
                }, editFormOptions, {
                    items: items,
                    formID: "dx-" + new Guid,
                    validationGroup: editData,
                    customizeItem: function(item) {
                        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
                        if (column) {
                            item.label = item.label || {};
                            item.label.text = item.label.text || column.caption;
                            item.template = item.template || that.getFormEditorTemplate(detailOptions, item);
                            item.column = column;
                            if (column.formItem) {
                                extend(item, column.formItem)
                            }
                            var itemVisible = commonUtils.isDefined(item.visible) ? item.visible : true;
                            if (!that._firstFormItem && itemVisible) {
                                that._firstFormItem = item
                            }
                        }
                        userCustomizeItem && userCustomizeItem.call(this, item);
                        item.cssClass = commonUtils.isString(item.cssClass) ? item.cssClass + " " + editFormItemClass : editFormItemClass
                    }
                }));
                if (!renderFormOnly) {
                    var $buttonsContainer = $("<div>").addClass(that.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
                    that._createComponent($("<div>").appendTo($buttonsContainer), Button, that._getSaveButtonConfig());
                    that._createComponent($("<div>").appendTo($buttonsContainer), Button, that._getCancelButtonConfig())
                }
            }
        },
        getColumnTemplate: function(options) {
            var template, editingOptions, editingTexts, allowUpdating, editingStartOptions, that = this,
                column = options.column,
                rowIndex = options.row && options.row.rowIndex,
                isRowMode = isRowEditMode(that),
                isRowEditing = that.isEditRow(rowIndex),
                isCellEditing = that.isEditCell(rowIndex, options.columnIndex);
            if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options.rowType || "detailAdaptive" === options.rowType) && !column.command) {
                allowUpdating = that.option("editing.allowUpdating");
                if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {
                    if (column.showEditorAlways && !isRowMode) {
                        editingStartOptions = {
                            cancel: false,
                            key: options.row.inserted ? void 0 : options.row.key,
                            data: options.row.data,
                            column: column
                        };
                        that._isEditingStart(editingStartOptions)
                    }
                    if (!editingStartOptions || !editingStartOptions.cancel) {
                        options.setValue = function(value, text) {
                            that.updateFieldValue(options, value, text)
                        }
                    }
                }
                template = column.editCellTemplate || getDefaultEditorTemplate(that)
            } else {
                if ("edit" === column.command && "data" === options.rowType) {
                    template = function(container, options) {
                        container.css("text-align", "center");
                        options.rtlEnabled = that.option("rtlEnabled");
                        editingOptions = that.option("editing") || {};
                        editingTexts = editingOptions.texts || {};
                        if (options.row && options.row.rowIndex === that._getVisibleEditRowIndex() && isRowMode) {
                            that._createLink(container, editingTexts.saveRowChanges, "saveEditData", options, "dx-link-save");
                            that._createLink(container, editingTexts.cancelRowChanges, "cancelEditData", options, "dx-link-cancel")
                        } else {
                            that._createEditingLinks(container, options, editingOptions, isRowMode)
                        }
                    }
                } else {
                    if ("detail" === column.command && "detail" === options.rowType && isRowEditing) {
                        template = that.getEditFormTemplate(options)
                    }
                }
            }
            return template
        },
        _createLink: function(container, text, methodName, options, linkClass) {
            var that = this,
                $link = $("<a>").addClass(LINK_CLASS).addClass(linkClass).text(text).on(addNamespace(clickEvent.name, EDITING_NAMESPACE), that.createAction(function(params) {
                    var e = params.jQueryEvent;
                    e.stopPropagation();
                    setTimeout(function() {
                        options.row && that[methodName](options.row.rowIndex)
                    })
                }));
            options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
        },
        _createEditingLinks: function(container, options, editingOptions, isRowMode) {
            var editingTexts = editingOptions.texts || {};
            if (editingOptions.allowUpdating && isRowMode) {
                this._createLink(container, editingTexts.editRow, "editRow", options, "dx-link-edit")
            }
            if (editingOptions.allowDeleting) {
                if (options.row.removed) {
                    this._createLink(container, editingTexts.undeleteRow, "undeleteRow", options, "dx-link-undelete")
                } else {
                    this._createLink(container, editingTexts.deleteRow, "deleteRow", options, "dx-link-delete")
                }
            }
        },
        prepareEditButtons: function(headerPanel) {
            var that = this,
                editingOptions = that.option("editing") || {},
                editingTexts = that.option("editing.texts") || {},
                titleButtonTextByClassNames = {
                    revert: editingTexts.cancelAllChanges,
                    save: editingTexts.saveAllChanges,
                    addRow: editingTexts.addRow
                },
                classNameButtonByNames = {
                    revert: "cancel",
                    save: "save",
                    addRow: "addrow"
                },
                buttonItems = [];
            var prepareButtonItem = function(name, methodName, sortIndex) {
                var className = classNameButtonByNames[name],
                    onInitialized = function(e) {
                        e.element.addClass(headerPanel._getToolbarButtonClass(EDIT_BUTTON_CLASS + " " + that.addWidgetPrefix(className) + "-button"))
                    },
                    hintText = titleButtonTextByClassNames[name],
                    isButtonDisabled = ("save" === className || "cancel" === className) && !that.hasChanges();
                return {
                    widget: "dxButton",
                    options: {
                        onInitialized: onInitialized,
                        icon: "edit-button-" + className,
                        disabled: isButtonDisabled,
                        onClick: function() {
                            that[methodName]()
                        },
                        text: hintText,
                        hint: hintText
                    },
                    showText: "inMenu",
                    name: name + "Button",
                    location: "after",
                    locateInMenu: "auto",
                    sortIndex: sortIndex
                }
            };
            if (editingOptions.allowAdding) {
                buttonItems.push(prepareButtonItem("addRow", "addRow", 20))
            }
            if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && getEditMode(that) === EDIT_MODE_BATCH) {
                buttonItems.push(prepareButtonItem("save", "saveEditData", 21));
                buttonItems.push(prepareButtonItem("revert", "cancelEditData", 22))
            }
            return buttonItems
        },
        showHighlighting: function($cell) {
            var $highlight = $cell.find("." + CELL_HIGHLIGHT_OUTLINE);
            if ("TD" === $cell.get(0).tagName && !$highlight.length) {
                $cell.wrapInner($("<div>").addClass(CELL_HIGHLIGHT_OUTLINE + " " + POINTER_EVENTS_TARGET_CLASS))
            }
        },
        resetRowAndPageIndices: function(alwaysRest) {
            var that = this;
            $.each(that._editData, function(_, editData) {
                if (editData.pageIndex !== that._pageIndex || alwaysRest) {
                    delete editData.pageIndex;
                    delete editData.rowIndex
                }
            })
        },
        _afterInsertRow: function() {},
        _beforeSaveEditData: function() {},
        _afterSaveEditData: function() {},
        _beforeCancelEditData: function() {}
    }
}());
module.exports = {
    defaultOptions: function() {
        return {
            editing: {
                mode: "row",
                allowAdding: false,
                allowUpdating: false,
                allowDeleting: false,
                texts: {
                    editRow: messageLocalization.format("dxDataGrid-editingEditRow"),
                    saveAllChanges: messageLocalization.format("dxDataGrid-editingSaveAllChanges"),
                    saveRowChanges: messageLocalization.format("dxDataGrid-editingSaveRowChanges"),
                    cancelAllChanges: messageLocalization.format("dxDataGrid-editingCancelAllChanges"),
                    cancelRowChanges: messageLocalization.format("dxDataGrid-editingCancelRowChanges"),
                    addRow: messageLocalization.format("dxDataGrid-editingAddRow"),
                    deleteRow: messageLocalization.format("dxDataGrid-editingDeleteRow"),
                    undeleteRow: messageLocalization.format("dxDataGrid-editingUndeleteRow"),
                    confirmDeleteMessage: messageLocalization.format("dxDataGrid-editingConfirmDeleteMessage"),
                    confirmDeleteTitle: ""
                },
                form: {
                    colCount: 2
                },
                popup: {}
            }
        }
    },
    controllers: {
        editing: EditingController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    this._editingController = this.getController("editing");
                    this.callBase()
                },
                reload: function(full) {
                    var d, editingController = this.getController("editing");
                    this._editingController.refresh();
                    d = this.callBase(full);
                    return d && d.done(function() {
                        editingController.resetRowAndPageIndices(true)
                    })
                },
                _updateItemsCore: function(change) {
                    this.callBase(change);
                    var editingController = this._editingController,
                        editFormRowIndex = editingController.getEditMode() === EDIT_MODE_FORM && editingController.getEditFormRowIndex(),
                        editFormItem = this.items()[editFormRowIndex];
                    if (editFormItem) {
                        editFormItem.rowType = "detail"
                    }
                },
                _processItems: function(items, changeType) {
                    items = this._editingController.processItems(items, changeType);
                    return this.callBase(items, changeType)
                },
                _processDataItem: function(dataItem, options) {
                    this._editingController.processDataItem(dataItem, options, this.generateDataValues);
                    return this.callBase(dataItem, options)
                },
                _processItem: function(item, options) {
                    item = this.callBase(item, options);
                    if (item.inserted) {
                        options.dataIndex--;
                        delete item.dataIndex
                    }
                    return item
                }
            }
        },
        views: {
            rowsView: {
                init: function() {
                    this.callBase();
                    this._editingController = this.getController("editing")
                },
                getCellElements: function(rowIndex) {
                    var $cellElements = this.callBase(rowIndex),
                        editingController = this._editingController,
                        editForm = editingController.getEditForm(),
                        editFormRowIndex = editingController.getEditFormRowIndex();
                    if (editFormRowIndex === rowIndex && $cellElements && editForm) {
                        return editForm.element().find("." + this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS) + ", ." + BUTTON_CLASS)
                    }
                    return $cellElements
                },
                getCellIndex: function($cell, rowIndex) {
                    if (!$cell.is("td") && rowIndex >= 0) {
                        var $cellElements = this.getCellElements(rowIndex),
                            cellIndex = -1;
                        $.each($cellElements, function(index, cellElement) {
                            if ($(cellElement).find($cell).length) {
                                cellIndex = index;
                                return false
                            }
                        });
                        return cellIndex
                    }
                    return this.callBase.apply(this, arguments)
                },
                _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
                    var item, visibleIndex = this.callBase($cells, rowIndex, columnIdentifier),
                        editFormRowIndex = this._editingController.getEditFormRowIndex();
                    if (editFormRowIndex === rowIndex) {
                        $.each($cells, function(index, cellElement) {
                            item = $(cellElement).find(".dx-field-item-content").data("dx-form-item");
                            if (item && item.column && item.column.visibleIndex === visibleIndex) {
                                visibleIndex = index;
                                return false
                            }
                        })
                    }
                    return visibleIndex
                },
                publicMethods: function() {
                    return this.callBase().concat(["cellValue"])
                },
                _getCellTemplate: function(options) {
                    var that = this,
                        template = that._editingController.getColumnTemplate(options);
                    return template || that.callBase(options)
                },
                _isNativeClick: function() {
                    return (devices.real().ios || devices.real().android) && this.option("editing.allowUpdating")
                },
                _createTable: function() {
                    var that = this,
                        $table = that.callBase.apply(that, arguments);
                    if (!isRowEditMode(that) && that.option("editing.allowUpdating")) {
                        $table.on(addNamespace(holdEvent.name, "dxDataGridRowsView"), "td:not(." + EDITOR_CELL_CLASS + ")", that.createAction(function() {
                            var editingController = that._editingController;
                            if (editingController.isEditing()) {
                                editingController.closeEditCell()
                            }
                        }))
                    }
                    return $table
                },
                _createRow: function(row) {
                    var editingController, isEditRow, isRowRemoved, isRowInserted, isRowModified, $row = this.callBase(row);
                    if (row) {
                        editingController = this._editingController;
                        isEditRow = editingController.isEditRow(row.rowIndex);
                        isRowRemoved = !!row.removed;
                        isRowInserted = !!row.inserted;
                        isRowModified = !!row.modified;
                        if (getEditMode(this) === EDIT_MODE_BATCH) {
                            isRowRemoved && $row.addClass(ROW_REMOVED)
                        } else {
                            isEditRow && $row.addClass(EDIT_ROW)
                        }
                        isRowInserted && $row.addClass(ROW_INSERTED);
                        isRowModified && $row.addClass(ROW_MODIFIED);
                        if (isEditRow || isRowInserted || isRowRemoved) {
                            $row.removeClass(ROW_SELECTED)
                        }
                        if (isEditRow && "detail" === row.rowType) {
                            $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS))
                        }
                    }
                    return $row
                },
                _getColumnIndexByElement: function($element) {
                    var $tableElement = $element.closest("table"),
                        $tableElements = this.getTableElements();
                    while ($tableElement.length && !$tableElements.filter($tableElement).length) {
                        $element = $tableElement.closest("td");
                        $tableElement = $element.closest("table")
                    }
                    return this._getColumnIndexByElementCore($element)
                },
                _getColumnIndexByElementCore: function($element) {
                    var $targetElement = $element.closest("." + ROW_CLASS + "> td:not(.dx-master-detail-cell)");
                    return this.getCellIndex($targetElement)
                },
                _rowClick: function(e) {
                    var that = this,
                        editingController = that._editingController,
                        $targetElement = $(e.jQueryEvent.target),
                        columnIndex = that._getColumnIndexByElement($targetElement),
                        row = that._dataController.items()[e.rowIndex],
                        allowUpdating = that.option("editing.allowUpdating") || row && row.inserted,
                        column = that._columnsController.getVisibleColumns()[columnIndex],
                        allowEditing = column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));
                    if ($targetElement.closest("." + ROW_CLASS + "> td").hasClass(POINTER_EVENTS_NONE_CLASS)) {
                        return
                    }
                    if (!(allowUpdating && allowEditing && editingController.editCell(e.rowIndex, columnIndex)) && !editingController.isEditRow(e.rowIndex)) {
                        that.callBase(e)
                    }
                },
                _cellPrepared: function($cell, parameters) {
                    var columnIndex = parameters.columnIndex,
                        editingController = this._editingController,
                        isCommandCell = !!parameters.column.command,
                        isEditableCell = parameters.setValue,
                        isEditing = parameters.isEditing || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
                    if ("data" === parameters.rowType && !parameters.column.command && (isEditing || parameters.column.showEditorAlways)) {
                        var alignment = parameters.column.alignment;
                        $cell.addClass(EDITOR_CELL_CLASS).toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
                        if (alignment) {
                            $cell.find(EDITORS_INPUT_SELECTOR).first().css("text-align", alignment)
                        }
                    }
                    var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues);
                    if (modifiedValues && void 0 !== modifiedValues[columnIndex] && parameters.column && !isCommandCell && parameters.column.setCellValue) {
                        editingController.showHighlighting($cell);
                        $cell.addClass(CELL_MODIFIED)
                    } else {
                        if (isEditableCell) {
                            editingController.showHighlighting($cell, true)
                        }
                    }
                    this.callBase.apply(this, arguments)
                },
                _formItemPrepared: function() {},
                _isFormItem: function(parameters) {
                    var isDetailRow = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType,
                        isPopupEditing = "data" === parameters.rowType && "popup" === getEditMode(this);
                    return (isDetailRow || isPopupEditing) && parameters.item
                },
                _updateCell: function($cell, parameters) {
                    if (this._isFormItem(parameters)) {
                        this._formItemPrepared(parameters, $cell)
                    } else {
                        this.callBase($cell, parameters)
                    }
                },
                _update: function(change) {
                    this.callBase(change);
                    if ("updateSelection" === change.changeType) {
                        this.getTableElements().children("tbody").children("." + EDIT_ROW).removeClass(ROW_SELECTED)
                    }
                },
                _getCellOptions: function(options) {
                    var cellOptions = this.callBase(options);
                    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
                    return cellOptions
                },
                cellValue: function(rowIndex, columnIdentifier, value, text) {
                    var cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
                    if (cellOptions) {
                        if (void 0 === value) {
                            return cellOptions.value
                        } else {
                            this._editingController.updateFieldValue(cellOptions, value, text, true)
                        }
                    }
                }
            },
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase(),
                        editButtonItems = this.getController("editing").prepareEditButtons(this);
                    return editButtonItems.concat(items)
                },
                optionChanged: function(args) {
                    switch (args.name) {
                        case "editing":
                            this._invalidate();
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                isVisible: function() {
                    var that = this,
                        editingOptions = that.getController("editing").option("editing");
                    return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === EDIT_MODE_BATCH)
                }
            }
        }
    }
};


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/form.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(370);
module.exports.default = module.exports;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.validating.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    equalByValue = commonUtils.equalByValue,
    messageLocalization = __webpack_require__(8),
    Button = __webpack_require__(25),
    pointerEvents = __webpack_require__(17),
    ValidationEngine = __webpack_require__(58),
    Validator = __webpack_require__(129),
    Tooltip = __webpack_require__(208),
    Overlay = __webpack_require__(39);
var INVALIDATE_CLASS = "invalid",
    REVERT_TOOLTIP_CLASS = "revert-tooltip",
    ROWS_VIEW_CLASS = "rowsview",
    INVALID_MESSAGE_CLASS = "dx-invalid-message",
    INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
    REVERT_BUTTON_CLASS = "dx-revert-button",
    CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
    INSERT_INDEX = "__DX_INSERT_INDEX__",
    PADDING_BETWEEN_TOOLTIPS = 2,
    EDIT_MODE_ROW = "row",
    EDIT_MODE_FORM = "form",
    EDIT_MODE_BATCH = "batch",
    EDIT_MODE_CELL = "cell",
    EDIT_MODE_POPUP = "popup",
    FORM_BASED_MODES = [EDIT_MODE_POPUP, EDIT_MODE_FORM];
var ValidatingController = modules.Controller.inherit(function() {
    return {
        init: function() {
            this._editingController = this.getController("editing");
            this.createAction("onRowValidating")
        },
        _rowValidating: function(editData, validate) {
            var that = this,
                brokenRules = validate ? validate.brokenRules || validate.brokenRule && [validate.brokenRule] : [],
                isValid = validate ? validate.isValid : editData.isValid,
                parameters = {
                    brokenRules: brokenRules,
                    isValid: isValid,
                    key: editData.key,
                    newData: editData.data,
                    oldData: editData.oldData,
                    errorText: null
                };
            that.executeAction("onRowValidating", parameters);
            editData.isValid = parameters.isValid;
            editData.errorText = parameters.errorText;
            return parameters
        },
        validate: function(isFull) {
            var that = this,
                isValid = true,
                editingController = that._editingController;
            isFull = isFull || editingController.getEditMode() === EDIT_MODE_ROW;
            if (that._isValidationInProgress) {
                return false
            }
            that._isValidationInProgress = true;
            if (isFull) {
                $.each(editingController._editData, function(index, editData) {
                    var validationResult;
                    if (editData.type && "remove" !== editData.type) {
                        validationResult = that.validateGroup(editData);
                        if (!validationResult.isValid) {
                            $.each(validationResult.brokenRules, function() {
                                var value = this.validator.option("adapter").getValue();
                                if (void 0 === value) {
                                    value = null
                                }
                                if (this.column) {
                                    editingController.updateFieldValue({
                                        key: editData.key,
                                        column: this.column
                                    }, value, null, true)
                                }
                            })
                        }
                        isValid = isValid && validationResult.isValid
                    }
                })
            } else {
                if (that._currentCellValidator) {
                    isValid = that.validateGroup(that._currentCellValidator._findGroup()).isValid
                }
            }
            that._isValidationInProgress = false;
            return isValid
        },
        validateGroup: function(editData) {
            var validationResults, that = this,
                validateGroup = ValidationEngine.getGroupConfig(editData);
            if (validateGroup && validateGroup.validators.length) {
                validationResults = ValidationEngine.validateGroup(editData)
            }
            return that._rowValidating(editData, validationResults)
        },
        updateEditData: function(editData) {
            var editMode = this._editingController.getEditMode();
            if (FORM_BASED_MODES.indexOf(editMode) === -1) {
                this.setDisableApplyValidationResults(true);
                editData.isValid = ValidationEngine.getGroupConfig(editData) ? ValidationEngine.validateGroup(editData).isValid : true;
                this.setDisableApplyValidationResults(false)
            } else {
                editData.isValid = true
            }
        },
        setValidator: function(validator) {
            this._currentCellValidator = validator
        },
        getValidator: function() {
            return this._currentCellValidator
        },
        removeValidators: function(editIndex) {
            var that = this,
                editingController = that._editingController;
            $.each(editingController._editData, function(index, editData) {
                var validateGroup = ValidationEngine.getGroupConfig(editData);
                if (!commonUtils.isDefined(editIndex) || editIndex === index) {
                    if (validateGroup) {
                        for (var i = 0; i < validateGroup.validators.length; i++) {
                            validateGroup.validators[i]._dispose();
                            i--
                        }
                    }
                }
            })
        },
        createValidator: function(parameters, $container) {
            var editData, editIndex, visibleColumns, columnsController, that = this,
                editingController = that._editingController,
                column = parameters.column,
                defaultValidationResult = function(options) {
                    if (options.brokenRule) {
                        options.brokenRule.columnIndex = column.index;
                        options.brokenRule.column = column
                    }
                    if ($container && !that.getDisableApplyValidationResults()) {
                        if (!options.isValid) {
                            var $focus = $container.find(":focus");
                            editingController.showHighlighting($container, true);
                            if (!$focus.is(":focus")) {
                                $focus.focus().trigger(pointerEvents.down)
                            }
                        }
                        $container.toggleClass(that.addWidgetPrefix(INVALIDATE_CLASS), !options.isValid)
                    }
                },
                getValue = function() {
                    var value = column.calculateCellValue(editData.data || {});
                    return void 0 !== value ? value : parameters.value
                },
                showEditorAlways = column.showEditorAlways;
            if (!column.validationRules || !Array.isArray(column.validationRules) || commonUtils.isDefined(column.command)) {
                return
            }
            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData);
            if (editIndex < 0) {
                if (!showEditorAlways) {
                    columnsController = that.getController("columns");
                    visibleColumns = columnsController && columnsController.getVisibleColumns() || [];
                    showEditorAlways = visibleColumns.some(function(column) {
                        return column.showEditorAlways
                    })
                }
                if (showEditorAlways) {
                    editIndex = editingController._addEditData({
                        key: parameters.key,
                        oldData: parameters.data
                    })
                }
            }
            if (editIndex >= 0) {
                editData = editingController._editData[editIndex];
                var useDefaultValidator = $container && $container.hasClass("dx-widget");
                var validator = new Validator($container || {}, {
                    name: column.caption,
                    validationRules: extend(true, [], column.validationRules),
                    validationGroup: editData,
                    adapter: useDefaultValidator ? null : {
                        getValue: getValue,
                        applyValidationResults: defaultValidationResult
                    }
                });
                if (useDefaultValidator) {
                    var adapter = validator.option("adapter");
                    if (adapter) {
                        adapter.getValue = getValue
                    }
                }
                return validator
            }
        },
        setDisableApplyValidationResults: function(flag) {
            this._disableApplyValidationResults = flag
        },
        getDisableApplyValidationResults: function() {
            return this._disableApplyValidationResults
        }
    }
}());
module.exports = {
    defaultOptions: function() {
        return {
            editing: {
                texts: {
                    validationCancelChanges: messageLocalization.format("dxDataGrid-validationCancelChanges")
                }
            }
        }
    },
    controllers: {
        validating: ValidatingController
    },
    extenders: {
        controllers: {
            editing: {
                _addEditData: function(options, row) {
                    var editData, that = this,
                        validatingController = that.getController("validating"),
                        editDataIndex = that.callBase(options, row);
                    if (editDataIndex >= 0) {
                        editData = that._editData[editDataIndex];
                        validatingController.updateEditData(editData)
                    }
                    return editDataIndex
                },
                _updateRowAndPageIndices: function() {
                    var that = this,
                        startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex(),
                        rowIndex = startInsertIndex;
                    $.each(that._editData, function(_, editData) {
                        if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
                            editData.pageIndex = that._pageIndex;
                            if ("insert" === editData.type) {
                                editData.rowIndex = startInsertIndex
                            } else {
                                editData.rowIndex = rowIndex
                            }
                            rowIndex++
                        }
                    })
                },
                _needInsertItem: function(editData) {
                    var result = this.callBase.apply(this, arguments);
                    if (result && !editData.isValid) {
                        result = editData.key.pageIndex === this._pageIndex
                    }
                    return result
                },
                processItems: function(items, changeType) {
                    var i, itemsCount, that = this,
                        insertCount = 0,
                        editData = that._editData,
                        dataController = that.getController("data"),
                        getIndexByEditData = function(editData, items) {
                            var index = -1,
                                isInsert = "insert" === editData.type,
                                key = editData.key;
                            $.each(items, function(i, item) {
                                if (equalByValue(key, isInsert ? item : dataController.keyOf(item))) {
                                    index = i;
                                    return false
                                }
                            });
                            return index
                        },
                        addInValidItem = function(editData) {
                            var rowIndex, data = {
                                    key: editData.key
                                },
                                index = getIndexByEditData(editData, items);
                            if (index >= 0) {
                                return
                            }
                            editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
                            rowIndex = editData.rowIndex;
                            data[INSERT_INDEX] = 1;
                            items.splice(rowIndex, 0, data);
                            insertCount++
                        };
                    items = that.callBase(items, changeType);
                    itemsCount = items.length;
                    if (that.getEditMode() === EDIT_MODE_BATCH && "prepend" !== changeType && "append" !== changeType) {
                        for (i = 0; i < editData.length; i++) {
                            if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex) {
                                addInValidItem(editData[i])
                            }
                        }
                    }
                    return items
                },
                processDataItem: function(item) {
                    var editIndex, editData, that = this,
                        isInserted = item.data[INSERT_INDEX],
                        key = isInserted ? item.data.key : item.key,
                        editMode = that.getEditMode();
                    if (editMode === EDIT_MODE_BATCH && isInserted && key) {
                        editIndex = gridCoreUtils.getIndexByKey(key, that._editData);
                        if (editIndex >= 0) {
                            editData = that._editData[editIndex];
                            if ("insert" !== editData.type) {
                                item.data = extend(true, {}, editData.oldData, editData.data);
                                item.key = key
                            }
                        }
                    }
                    that.callBase.apply(that, arguments)
                },
                _afterInsertRow: function(options) {
                    var validatingController = this.getController("validating"),
                        invisibleColumns = commonUtils.grep(this.getController("columns").getInvisibleColumns(), function(column) {
                            return !column.isBand
                        });
                    if (FORM_BASED_MODES.indexOf(this.getEditMode()) === -1) {
                        $.each(invisibleColumns, function(_, column) {
                            validatingController.createValidator({
                                column: column,
                                key: options.key,
                                value: column.calculateCellValue(options.data)
                            })
                        })
                    }
                    this.callBase(options)
                },
                _beforeSaveEditData: function(editData, editIndex) {
                    var isValid, isFullValid, that = this,
                        result = that.callBase.apply(that, arguments),
                        validatingController = that.getController("validating");
                    if (editData) {
                        isValid = "remove" === editData.type || editData.isValid;
                        if (isValid) {
                            validatingController.removeValidators(editIndex)
                        }
                        result = result || !isValid
                    } else {
                        isFullValid = validatingController.validate(true);
                        that._updateRowAndPageIndices();
                        switch (that.getEditMode()) {
                            case EDIT_MODE_CELL:
                                if (!isFullValid) {
                                    that._focusEditingCell();
                                    result = true
                                }
                                break;
                            case EDIT_MODE_BATCH:
                                if (!isFullValid) {
                                    that._editRowIndex = -1;
                                    that._editColumnIndex = -1;
                                    that.getController("data").updateItems();
                                    result = true
                                }
                                break;
                            case EDIT_MODE_ROW:
                            case EDIT_MODE_POPUP:
                                result = !isFullValid
                        }
                    }
                    return result
                },
                _beforeEditCell: function(rowIndex, columnIndex, item) {
                    var result = this.callBase(rowIndex, columnIndex, item),
                        $cell = this.component.getCellElement(rowIndex, columnIndex),
                        validator = $cell && $cell.data("dxValidator"),
                        value = validator && validator.option("adapter").getValue();
                    if (this.getEditMode(this) === EDIT_MODE_CELL && (!validator || void 0 !== value && validator.validate().isValid)) {
                        return result
                    }
                },
                _afterSaveEditData: function() {
                    var that = this;
                    $.each(that._editData, function(_, editData) {
                        that._showErrorRow(editData)
                    })
                },
                _beforeCancelEditData: function() {
                    var validatingController = this.getController("validating");
                    validatingController.removeValidators();
                    this.callBase()
                },
                _showErrorRow: function(editData) {
                    var $popupContent, errorHandling = this.getController("errorHandling"),
                        items = this.getController("data").items(),
                        rowIndex = this.getIndexByKey(editData.key, items);
                    if (!editData.isValid && editData.errorText && rowIndex >= 0) {
                        $popupContent = this.getPopupContent();
                        errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex, $popupContent)
                    }
                },
                updateFieldValue: function(e) {
                    var that = this,
                        editMode = that.getEditMode();
                    that.callBase.apply(that, arguments);
                    if (editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_BATCH && e.column.showEditorAlways) {
                        var currentValidator = that.getController("validating").getValidator();
                        currentValidator && currentValidator.validate()
                    }
                },
                showHighlighting: function($cell, skipValidation) {
                    var validator, isValid = true;
                    if (!skipValidation) {
                        validator = $cell.data("dxValidator");
                        if (validator) {
                            isValid = validator.validate().isValid
                        }
                    }
                    if (isValid) {
                        this.callBase($cell)
                    }
                },
                getEditDataByKey: function(key) {
                    return this._editData[gridCoreUtils.getIndexByKey(key, this._editData)]
                }
            },
            editorFactory: {
                _showRevertButton: function($container, $targetElement) {
                    var that = this;
                    if ($targetElement && $targetElement.length) {
                        return new Tooltip($("<div>").addClass(that.addWidgetPrefix(REVERT_TOOLTIP_CLASS)).appendTo($container), {
                            animation: null,
                            visible: true,
                            target: $targetElement,
                            container: $container,
                            closeOnOutsideClick: false,
                            closeOnTargetScroll: false,
                            boundary: that._rowsView.element(),
                            contentTemplate: function() {
                                return new Button($("<div>").addClass(REVERT_BUTTON_CLASS), {
                                    icon: "revert",
                                    hint: that.option("editing.texts.validationCancelChanges"),
                                    onClick: function() {
                                        that._editingController.cancelEditData()
                                    }
                                }).element()
                            },
                            position: {
                                my: "left top",
                                at: "right top",
                                of: $targetElement,
                                offset: "1 0",
                                collision: "flip"
                            }
                        })
                    }
                },
                _showValidationMessage: function($cell, message, alignment, revertTooltip) {
                    var needRepaint, that = this,
                        $highlightContainer = $cell.find("." + CELL_HIGHLIGHT_OUTLINE),
                        isOverlayVisible = $cell.find(".dx-dropdowneditor-overlay:visible").length,
                        myPosition = isOverlayVisible ? "top right" : "top " + alignment,
                        atPosition = isOverlayVisible ? "top left" : "bottom " + alignment;
                    new Overlay($("<div/>").addClass(INVALID_MESSAGE_CLASS).addClass(INVALID_MESSAGE_ALWAYS_CLASS).text(message).appendTo($cell), {
                        target: $highlightContainer.length ? $highlightContainer : $cell,
                        container: $cell,
                        shading: false,
                        width: "auto",
                        height: "auto",
                        visible: true,
                        animation: false,
                        closeOnOutsideClick: false,
                        closeOnTargetScroll: false,
                        position: {
                            collision: "flip",
                            boundary: that._rowsView.element(),
                            boundaryOffset: "0 0",
                            my: myPosition,
                            at: atPosition
                        },
                        onPositioned: function(e) {
                            if (!needRepaint) {
                                needRepaint = that._rowsView.updateFreeSpaceRowHeight();
                                if (needRepaint) {
                                    e.component.repaint()
                                }
                            }
                            that._shiftValidationMessageIfNeed(e.component.content(), revertTooltip && revertTooltip.content(), $cell)
                        }
                    })
                },
                _shiftValidationMessageIfNeed: function($content, $revertContent, $cell) {
                    if (!$revertContent) {
                        return
                    }
                    var contentOffset = $content.offset(),
                        revertContentOffset = $revertContent.offset();
                    if (contentOffset.top === revertContentOffset.top && contentOffset.left + $content.width() > revertContentOffset.left) {
                        var left = $revertContent.width() + PADDING_BETWEEN_TOOLTIPS;
                        $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left)
                    }
                },
                _getTooltipsSelector: function() {
                    return ".dx-editor-cell .dx-tooltip, .dx-editor-cell .dx-invalid-message"
                },
                init: function() {
                    this.callBase();
                    this._editingController = this.getController("editing");
                    this._rowsView = this.getView("rowsView")
                },
                loseFocus: function(skipValidator) {
                    if (!skipValidator) {
                        this.getController("validating").setValidator(null)
                    }
                    this.callBase()
                },
                focus: function($element, hideBorder) {
                    var validationResult, revertTooltip, that = this,
                        $focus = $element && $element.closest(that._getFocusCellSelector()),
                        validator = $focus && ($focus.data("dxValidator") || $element.find(".dx-validator").eq(0).data("dxValidator")),
                        rowOptions = $focus && $focus.closest(".dx-row").data("options"),
                        editData = rowOptions ? that.getController("editing").getEditDataByKey(rowOptions.key) : null,
                        $tooltips = $focus && $focus.closest("." + that.addWidgetPrefix(ROWS_VIEW_CLASS)).find(that._getTooltipsSelector()),
                        $cell = $focus && $focus.is("td") ? $focus : null,
                        showValidationMessage = false,
                        column = $cell && that.getController("columns").getVisibleColumns()[$cell.index()];
                    if (!arguments.length) {
                        return that.callBase()
                    }
                    $tooltips && $tooltips.remove();
                    if (validator) {
                        that.getController("validating").setValidator(validator);
                        if (void 0 !== validator.option("adapter").getValue()) {
                            validationResult = validator.validate();
                            if (!validationResult.isValid) {
                                hideBorder = true;
                                showValidationMessage = true
                            }
                        }
                    }
                    if (validationResult && !validationResult.isValid || editData && "update" === editData.type) {
                        if (that._editingController.getEditMode() === EDIT_MODE_CELL) {
                            revertTooltip = that._showRevertButton($focus, $cell ? $focus.find("." + CELL_HIGHLIGHT_OUTLINE).first() : $focus)
                        }
                    }
                    if (showValidationMessage && $cell && column) {
                        that._showValidationMessage($focus, validationResult.brokenRule.message, column.alignment, revertTooltip)
                    }!hideBorder && that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight();
                    return that.callBase($element, hideBorder)
                }
            }
        },
        views: {
            rowsView: {
                updateFreeSpaceRowHeight: function($table) {
                    var $rowElements, $freeSpaceRowElement, $freeSpaceRowElements, that = this,
                        $element = that.element(),
                        $tooltipContent = $element && $element.find(".dx-invalid-message .dx-overlay-content");
                    that.callBase($table);
                    if ($tooltipContent && $tooltipContent.length) {
                        $rowElements = that._getRowElements();
                        $freeSpaceRowElements = that._getFreeSpaceRowElements($table);
                        $freeSpaceRowElement = $freeSpaceRowElements.first();
                        if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                            $freeSpaceRowElements.show();
                            $freeSpaceRowElements.height($tooltipContent.outerHeight());
                            return true
                        }
                    }
                },
                _formItemPrepared: function(cellOptions, $container) {
                    this.callBase.apply(this, arguments);
                    this.getController("validating").createValidator(cellOptions, $container.children(".dx-widget"))
                },
                _cellPrepared: function($cell, parameters) {
                    this.getController("validating").createValidator(parameters, $cell);
                    this.callBase.apply(this, arguments)
                }
            }
        }
    }
};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_scrolling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    virtualScrollingCore = __webpack_require__(374),
    gridCoreUtils = __webpack_require__(26),
    browser = __webpack_require__(21),
    translator = __webpack_require__(19),
    LoadIndicator = __webpack_require__(53);
var TABLE_CLASS = "table",
    BOTTOM_LOAD_PANEL_CLASS = "bottom-load-panel",
    TABLE_CONTENT_CLASS = "table-content",
    GROUP_SPACE_CLASS = "group-space",
    CONTENT_CLASS = "content",
    ROW_CLASS = "dx-row",
    FREESPACE_CLASS = "dx-freespace-row",
    COLUMN_LINES_CLASS = "dx-column-lines",
    SCROLLING_MODE_INFINITE = "infinite",
    SCROLLING_MODE_VIRTUAL = "virtual",
    PIXELS_LIMIT = 25e4;
var isVirtualMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
};
var isAppendMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
};
var VirtualScrollingDataSourceAdapterExtender = function() {
    var updateLoading = function(that) {
        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
        if (isVirtualMode(that)) {
            if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
                if (!that._isLoading) {
                    that._isLoading = true;
                    that.loadingChanged.fire(true)
                }
            } else {
                if (that._isLoading) {
                    that._isLoading = false;
                    that.loadingChanged.fire(false)
                }
            }
        }
    };
    return {
        init: function(dataSource) {
            var that = this;
            that.callBase.apply(that, arguments);
            that._items = [];
            that._isLoaded = true;
            that._virtualScrollController = new virtualScrollingCore.VirtualScrollController(that.component, {
                pageSize: function() {
                    return that.pageSize()
                },
                totalItemsCount: function() {
                    return that.totalItemsCount()
                },
                hasKnownLastPage: function() {
                    return that.hasKnownLastPage()
                },
                pageIndex: function(index) {
                    return dataSource.pageIndex(index)
                },
                isLoading: function() {
                    return dataSource.isLoading()
                },
                pageCount: function() {
                    return that.pageCount()
                },
                load: function() {
                    return dataSource.load()
                },
                updateLoading: function() {
                    updateLoading(that)
                },
                itemsCount: function() {
                    return that.itemsCount(true)
                },
                items: function() {
                    return dataSource.items()
                },
                viewportItems: function(items) {
                    if (items) {
                        that._items = items
                    }
                    return that._items
                },
                onChanged: function(e) {
                    that.changed.fire(e)
                }
            })
        },
        _handleLoadingChanged: function(isLoading) {
            var that = this;
            if (!isVirtualMode(that)) {
                that._isLoading = isLoading;
                that.callBase.apply(that, arguments)
            }
        },
        _handleLoadError: function() {
            var that = this;
            that._isLoading = false;
            that.loadingChanged.fire(false);
            that.callBase.apply(that, arguments)
        },
        _handleDataChanged: function() {
            var callBase = this.callBase.bind(this);
            this._virtualScrollController.handleDataChanged(callBase)
        },
        items: function() {
            return this._items
        },
        itemsCount: function(isBase) {
            if (isBase) {
                return this.callBase()
            }
            return this._virtualScrollController.itemsCount()
        },
        virtualItemsCount: function() {
            return this._virtualScrollController.virtualItemsCount()
        },
        getViewportItemIndex: function() {
            return this._virtualScrollController.getViewportItemIndex()
        },
        setViewportItemIndex: function(itemIndex) {
            return this._virtualScrollController.setViewportItemIndex(itemIndex)
        },
        viewportSize: function(size) {
            return this._virtualScrollController.viewportSize(size)
        },
        pageIndex: function(pageIndex) {
            return this._virtualScrollController.pageIndex(pageIndex)
        },
        beginPageIndex: function() {
            return this._virtualScrollController.beginPageIndex()
        },
        endPageIndex: function() {
            return this._virtualScrollController.endPageIndex()
        },
        load: function(loadOptions) {
            if (loadOptions) {
                return this.callBase(loadOptions)
            }
            return this._virtualScrollController.load()
        },
        loadIfNeed: function() {
            return this._virtualScrollController.loadIfNeed()
        },
        isLoading: function() {
            return this._isLoading
        },
        isLoaded: function() {
            return this._dataSource.isLoaded() && this._isLoaded
        },
        _changeRowExpandCore: function() {
            var result = this.callBase.apply(this, arguments);
            this._virtualScrollController.reset();
            updateLoading(this);
            return result
        },
        reload: function() {
            this._dataSource.pageIndex(this.pageIndex());
            return this.callBase.apply(this, arguments)
        },
        refresh: function(options, isReload, operationTypes) {
            var that = this,
                storeLoadOptions = options.storeLoadOptions,
                dataSource = that._dataSource;
            if (isReload || operationTypes.reload) {
                that._virtualScrollController.reset();
                that._isLoaded = false;
                updateLoading(that);
                that._isLoaded = true;
                if (isAppendMode(that)) {
                    that.pageIndex(0);
                    dataSource.pageIndex(0);
                    storeLoadOptions.pageIndex = 0;
                    storeLoadOptions.skip = 0
                } else {
                    dataSource.pageIndex(that.pageIndex());
                    if (dataSource.paginate()) {
                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
                    }
                }
            }
            return that.callBase.apply(that, arguments)
        }
    }
}();
var VirtualScrollingRowsViewExtender = function() {
    return {
        init: function() {
            var that = this,
                dataController = that.getController("data");
            that.callBase();
            dataController.pageChanged.add(function() {
                that.scrollToPage(dataController.pageIndex())
            })
        },
        scrollToPage: function(pageIndex) {
            var scrollPosition, that = this,
                dataController = that._dataController,
                pageSize = dataController ? dataController.pageSize() : 0;
            if (isVirtualMode(that) || isAppendMode(that)) {
                scrollPosition = pageIndex * that._rowHeight * pageSize
            } else {
                scrollPosition = 0
            }
            that.scrollTo({
                y: scrollPosition,
                x: that._scrollLeft
            })
        },
        _renderCore: function() {
            var that = this,
                startRenderDate = new Date;
            that.callBase.apply(that, arguments);
            that._updateContentPosition();
            that._renderTime = new Date - startRenderDate
        },
        _renderContent: function(contentElement, tableElement) {
            var that = this,
                virtualItemsCount = that._dataController.virtualItemsCount();
            if (virtualItemsCount) {
                tableElement.addClass(that.addWidgetPrefix(TABLE_CONTENT_CLASS));
                if (!contentElement.children().length) {
                    contentElement.append(tableElement)
                } else {
                    contentElement.children().first().replaceWith(tableElement)
                }
                if (1 === contentElement.children("table").length) {
                    contentElement.append(that._createTable());
                    that._contentHeight = 0
                }
                return contentElement
            } else {
                return that.callBase.apply(that, arguments)
            }
        },
        _updateContent: function(tableElement, change) {
            var contentTable, that = this,
                contentElement = that._findContentElement(),
                changeType = change && change.changeType;
            if ("append" === changeType || "prepend" === changeType) {
                contentTable = contentElement.children().first();
                tableElement.children("tbody")["append" === changeType ? "appendTo" : "prependTo"](contentTable);
                tableElement.remove();
                var $rowElements = that._getFreeSpaceRowElements(contentTable);
                for (var i = 0; i < $rowElements.length - 1; i++) {
                    $rowElements.eq(i).remove()
                }
            } else {
                that.callBase.apply(that, arguments)
            }
            that._updateBottomLoading()
        },
        _updateContentPosition: commonUtils.deferUpdater(function() {
            var contentElement, contentHeight, $tables, $contentTable, virtualTable, isRenderVirtualTableContentRequired, that = this,
                rowHeight = that._rowHeight || 20,
                virtualItemsCount = that._dataController.virtualItemsCount();
            if (virtualItemsCount) {
                contentElement = that._findContentElement();
                $tables = contentElement.children();
                $contentTable = $tables.eq(0);
                virtualTable = $tables.eq(1);
                that._contentTableHeight = $contentTable[0].offsetHeight;
                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end + that._dataController.itemsCount()) * that._rowHeight;
                var contentHeightLimit = virtualScrollingCore.getContentHeightLimit(browser);
                if (contentHeight > contentHeightLimit) {
                    that._heightRatio = contentHeightLimit / contentHeight
                } else {
                    that._heightRatio = 1
                }
                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight * that._heightRatio + that._contentTableHeight;
                var top = Math.floor(virtualItemsCount.begin * rowHeight * that._heightRatio);
                commonUtils.deferRender(function() {
                    translator.move($contentTable, {
                        left: 0,
                        top: top
                    });
                    isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || 0 === contentHeight || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
                    if (isRenderVirtualTableContentRequired) {
                        that._contentHeight = contentHeight;
                        that._renderVirtualTableContent(virtualTable, contentHeight)
                    }
                    if (that._scrollTop < top && !that._isScrollByEvent && that._dataController.pageIndex() > 0) {
                        that.scrollTo({
                            top: top,
                            left: that._scrollLeft
                        })
                    }
                })
            }
        }),
        _isTableLinesDisplaysCorrect: function(table) {
            var hasColumnLines = table.find("." + COLUMN_LINES_CLASS).length > 0;
            return hasColumnLines === this.option("showColumnLines")
        },
        _isColumnElementsEqual: function($columns, $virtualColumns) {
            var result = $columns.length === $virtualColumns.length;
            if (result) {
                $.each($columns, function(index, element) {
                    if (element.style.width !== $virtualColumns[index].style.width) {
                        result = false;
                        return result
                    }
                })
            }
            return result
        },
        _renderVirtualTableContent: function(container, height) {
            var i, that = this,
                columns = that._columnsController.getVisibleColumns(),
                html = that._createColGroup(columns).prop("outerHTML"),
                freeSpaceCellsHtml = "",
                columnLinesClass = that.option("showColumnLines") ? COLUMN_LINES_CLASS : "",
                createFreeSpaceRowHtml = function(height) {
                    return "<tr style='height:" + height + "px;' class='" + FREESPACE_CLASS + " " + ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
                };
            for (i = 0; i < columns.length; i++) {
                var classes = that._getCellClasses(columns[i]),
                    classString = classes.length ? " class='" + classes.join(" ") + "'" : "";
                freeSpaceCellsHtml += "<td" + classString + "/>"
            }
            while (height > PIXELS_LIMIT) {
                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                height -= PIXELS_LIMIT
            }
            html += createFreeSpaceRowHtml(height);
            container.addClass(that.addWidgetPrefix(TABLE_CLASS));
            container.html(html)
        },
        _getCellClasses: function(column) {
            var classes = [],
                cssClass = column.cssClass,
                isExpandColumn = "expand" === column.command;
            cssClass && classes.push(cssClass);
            isExpandColumn && classes.push(this.addWidgetPrefix(GROUP_SPACE_CLASS));
            return classes
        },
        _findBottomLoadPanel: function() {
            var $element = this.element();
            var $bottomLoadPanel = $element && $element.find("." + this.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS));
            if ($bottomLoadPanel && $bottomLoadPanel.length) {
                return $bottomLoadPanel
            }
        },
        _updateBottomLoading: function() {
            var that = this,
                scrollingMode = that.option("scrolling.mode"),
                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
                bottomLoadPanelElement = that._findBottomLoadPanel();
            if (showBottomLoading) {
                if (!bottomLoadPanelElement) {
                    $("<div>").addClass(that.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS)).append(that._createComponent($("<div>"), LoadIndicator).element()).appendTo(that._findContentElement())
                }
            } else {
                if (bottomLoadPanelElement) {
                    bottomLoadPanelElement.remove()
                }
            }
        },
        _handleScroll: function(e) {
            var that = this;
            if (that._hasHeight && that._rowHeight) {
                that._setViewportScrollTop(e.scrollOffset.top)
            }
            that.callBase.apply(that, arguments)
        },
        _setViewportScrollTop: function(scrollTop) {
            var that = this,
                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._renderTime || 0);
            clearTimeout(that._scrollTimeoutID);
            if (scrollingTimeout > 0) {
                that._scrollTimeoutID = setTimeout(function() {
                    that._setViewportScrollTopCore(scrollTop)
                }, scrollingTimeout)
            } else {
                that._setViewportScrollTopCore(scrollTop)
            }
        },
        _setViewportScrollTopCore: function(scrollTop) {
            var that = this,
                virtualItemsCount = that._dataController.virtualItemsCount(),
                heightRatio = that._heightRatio || 1,
                rowHeight = that._rowHeight,
                beginHeight = virtualItemsCount ? Math.floor(virtualItemsCount.begin * rowHeight * heightRatio) : 0;
            if (virtualItemsCount && scrollTop >= beginHeight && scrollTop <= beginHeight + that._contentTableHeight) {
                that._dataController.setViewportItemIndex(virtualItemsCount.begin + (scrollTop - beginHeight) / rowHeight)
            } else {
                that._dataController.setViewportItemIndex(scrollTop / (rowHeight * heightRatio))
            }
        },
        _needUpdateRowHeight: function(itemsCount) {
            var that = this;
            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
        },
        _updateRowHeight: function() {
            var viewportHeight, that = this;
            that.callBase.apply(that, arguments);
            if (that._rowHeight) {
                that._updateContentPosition();
                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
                that._dataController.viewportSize(Math.round(viewportHeight / that._rowHeight))
            }
        },
        setLoading: function(isLoading, messageText) {
            var that = this,
                callBase = that.callBase,
                dataController = that._dataController,
                hasBottomLoadPanel = dataController.pageIndex() > 0 && dataController.isLoaded() && !!that._findBottomLoadPanel();
            if (hasBottomLoadPanel) {
                isLoading = false
            }
            callBase.call(that, isLoading, messageText)
        },
        _resizeCore: function() {
            var that = this,
                $element = that.element();
            that.callBase();
            if (that.component.element() && !that._windowScroll && $element.closest(document).length) {
                that._windowScroll = virtualScrollingCore.subscribeToExternalScrollers($element, function(scrollPos) {
                    if (!that._hasHeight && that._rowHeight) {
                        that._setViewportScrollTop(scrollPos)
                    }
                }, that.component.element());
                that.on("disposing", function() {
                    that._windowScroll.dispose()
                })
            }
            var dataSource = that._dataController.dataSource();
            if (dataSource && dataSource.loadIfNeed) {
                dataSource.loadIfNeed()
            }
        },
        setColumnWidths: function(widths) {
            var $content, scrollable = this.getScrollable();
            this.callBase.apply(this, arguments);
            if ("virtual" === this.option("scrolling.mode")) {
                $content = scrollable ? scrollable.content() : this.element();
                this.callBase(widths, $content.children("." + this.addWidgetPrefix(CONTENT_CLASS)).children(":not(." + this.addWidgetPrefix(TABLE_CONTENT_CLASS) + ")"))
            }
        },
        dispose: function() {
            clearTimeout(this._scrollTimeoutID);
            this.callBase()
        }
    }
}();
module.exports = {
    defaultOptions: function() {
        return {
            scrolling: {
                timeout: 300,
                mode: "standard",
                preloadEnabled: false
            }
        }
    },
    extenders: {
        dataSourceAdapter: VirtualScrollingDataSourceAdapterExtender,
        controllers: {
            data: function() {
                var members = {
                    getRowIndexOffset: function() {
                        var offset = 0,
                            dataSource = this.dataSource();
                        if ("virtual" === this.option("scrolling.mode") && dataSource) {
                            offset = dataSource.beginPageIndex() * dataSource.pageSize()
                        }
                        return offset
                    }
                };
                gridCoreUtils.proxyMethod(members, "virtualItemsCount");
                gridCoreUtils.proxyMethod(members, "viewportSize");
                gridCoreUtils.proxyMethod(members, "setViewportItemIndex");
                return members
            }()
        },
        views: {
            rowsView: VirtualScrollingRowsViewExtender
        }
    }
};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_row.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    messageLocalization = __webpack_require__(8),
    Editor = __webpack_require__(33),
    Overlay = __webpack_require__(39),
    Menu = __webpack_require__(234);
var OPERATION_ICONS = {
    "=": "filter-operation-equals",
    "<>": "filter-operation-not-equals",
    "<": "filter-operation-less",
    "<=": "filter-operation-less-equal",
    ">": "filter-operation-greater",
    ">=": "filter-operation-greater-equal",
    "default": "filter-operation-default",
    notcontains: "filter-operation-not-contains",
    contains: "filter-operation-contains",
    startswith: "filter-operation-starts-with",
    endswith: "filter-operation-ends-with",
    between: "filter-operation-between"
};
var OPERATION_DESCRIPTORS = {
    "=": "equal",
    "<>": "notEqual",
    "<": "lessThan",
    "<=": "lessThanOrEqual",
    ">": "greaterThan",
    ">=": "greaterThanOrEqual",
    startswith: "startsWith",
    contains: "contains",
    notcontains: "notContains",
    endswith: "endsWith",
    between: "between"
};
var FILTERING_TIMEOUT = 700,
    CORRECT_FILTER_RANGE_OVERLAY_WIDTH = 1,
    FILTER_ROW_CLASS = "filter-row",
    FILTER_RANGE_OVERLAY_CLASS = "filter-range-overlay",
    FILTER_RANGE_START_CLASS = "filter-range-start",
    FILTER_RANGE_END_CLASS = "filter-range-end",
    MENU_CLASS = "dx-menu",
    EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
    EDITOR_CONTAINER_CLASS = "dx-editor-container",
    EDITOR_CELL_CLASS = "dx-editor-cell",
    FILTER_MENU = "dx-filter-menu",
    APPLY_BUTTON_CLASS = "dx-apply-button",
    HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline",
    FOCUSED_CLASS = "dx-focused",
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
    FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content",
    EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";

function isOnClickApplyFilterMode(that) {
    return "onClick" === that.option("filterRow.applyFilter")
}
var ColumnHeadersViewFilterRowExtender = function() {
    var getEditorInstance = function($editorContainer) {
        var $editor = $editorContainer && $editorContainer.children(),
            componentNames = $editor && $editor.data("dxComponents"),
            editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
        if (editor instanceof Editor) {
            return editor
        }
    };
    var getRangeTextByFilterValue = function(that, column) {
        var result = "",
            rangeEnd = "",
            filterValue = getColumnFilterValue(that, column),
            formatOptions = gridCoreUtils.getFormatOptionsByColumn(column, "filterRow");
        if (Array.isArray(filterValue)) {
            result = gridCoreUtils.formatValue(filterValue[0], formatOptions);
            rangeEnd = gridCoreUtils.formatValue(filterValue[1], formatOptions);
            if ("" !== rangeEnd) {
                result += " - " + rangeEnd
            }
        } else {
            if (commonUtils.isDefined(filterValue)) {
                result = gridCoreUtils.formatValue(filterValue, formatOptions)
            }
        }
        return result
    };
    var getColumnFilterValue = function(that, column) {
        if (column) {
            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue
        }
    };
    var getColumnSelectedFilterOperation = function(that, column) {
        if (column) {
            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation
        }
    };
    var getFilterValue = function(that, columnIndex, $editorContainer) {
        var column = that._columnsController.columnOption(columnIndex),
            filterValue = getColumnFilterValue(that, column),
            isFilterRange = $editorContainer.closest("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).length,
            isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS));
        if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
            if (isRangeStart) {
                return filterValue[0]
            } else {
                return filterValue[1]
            }
        }
        return !isFilterRange && void 0 !== filterValue ? filterValue : null
    };
    var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
        if ("between" === getColumnSelectedFilterOperation(that, column)) {
            var columnFilterValue = getColumnFilterValue(that, column);
            if ($editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
                return [filterValue, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0]
            } else {
                return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue]
            }
        }
        return filterValue
    };
    var updateFilterValue = function(that, options) {
        var value = "" === options.value ? null : options.value,
            $editorContainer = options.container,
            column = that._columnsController.columnOption(options.column.index),
            filterValue = getFilterValue(that, column.index, $editorContainer);
        if (!commonUtils.isDefined(filterValue) && !commonUtils.isDefined(value)) {
            return
        }
        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value);
        that._columnsController.columnOption(column.index, isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue", normalizeFilterValue(that, value, column, $editorContainer), options.notFireEvent)
    };
    return {
        _updateEditorValue: function(column, $editorContainer) {
            var that = this,
                editor = getEditorInstance($editorContainer);
            editor && editor.option("value", getFilterValue(that, column.index, $editorContainer))
        },
        _columnOptionChanged: function(e) {
            var overlayInstance, visibleIndex, column, $cell, $editorContainer, $editorRangeElements, $menu, that = this,
                optionNames = e.optionNames;
            if (gridCoreUtils.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation"]) && void 0 !== e.columnIndex) {
                visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
                column = that._columnsController.columnOption(e.columnIndex);
                $cell = that.getCellElement(that.element().find("." + that.addWidgetPrefix(FILTER_ROW_CLASS)).index(), visibleIndex) || $();
                $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
                if (optionNames.filterValue || optionNames.bufferedFilterValue) {
                    that._updateEditorValue(column, $editorContainer);
                    overlayInstance = $cell.find("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).data("dxOverlay");
                    if (overlayInstance) {
                        $editorRangeElements = overlayInstance.content().find("." + EDITOR_CONTAINER_CLASS);
                        that._updateEditorValue(column, $editorRangeElements.first());
                        that._updateEditorValue(column, $editorRangeElements.last())
                    }
                    if (!overlayInstance || !overlayInstance.option("visible")) {
                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
                    }
                }
                if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
                    if (visibleIndex >= 0 && column) {
                        $menu = $cell.find("." + MENU_CLASS);
                        if ($menu.length) {
                            that._updateFilterOperationChooser($menu, column, $editorContainer);
                            if ("between" === getColumnSelectedFilterOperation(that, column)) {
                                that._renderFilterRangeContent($cell, column)
                            } else {
                                if ($editorContainer.find("." + FILTER_RANGE_CONTENT_CLASS).length) {
                                    that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                    that._hideFilterRange()
                                }
                            }
                        }
                    }
                }
                return
            }
            that.callBase(e)
        },
        _renderCore: function() {
            this._filterRangeOverlayInstance = null;
            this.callBase.apply(this, arguments)
        },
        _resizeCore: function() {
            this.callBase.apply(this, arguments);
            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.repaint()
        },
        isFilterRowVisible: function() {
            return this._isElementVisible(this.option("filterRow"))
        },
        isVisible: function() {
            return this.callBase() || this.isFilterRowVisible()
        },
        init: function() {
            this.callBase();
            this._applyFilterViewController = this.getController("applyFilter")
        },
        _initFilterRangeOverlay: function($cell, column) {
            var that = this,
                sharedData = {},
                $editorContainer = $cell.find(".dx-editor-container"),
                $overlay = $("<div>").addClass(that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).appendTo($cell);
            return that._createComponent($overlay, Overlay, {
                height: "auto",
                shading: false,
                showTitle: false,
                focusStateEnabled: false,
                closeOnTargetScroll: true,
                closeOnOutsideClick: true,
                animation: false,
                position: {
                    my: "top",
                    at: "top",
                    of: $editorContainer.length && $editorContainer || $cell,
                    offset: "0 -1"
                },
                contentTemplate: function(contentElement) {
                    var editorOptions, $editor = $("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_START_CLASS)).appendTo(contentElement);
                    column = that._columnsController.columnOption(column.index);
                    editorOptions = that._getEditorOptions($editor, column);
                    editorOptions.sharedData = sharedData;
                    that._renderEditor($editor, editorOptions);
                    $editor.find(EDITORS_INPUT_SELECTOR).on("keydown", function(e) {
                        var $prevElement = $cell.find("[tabindex]").not(e.target).first();
                        if (9 === e.which && e.shiftKey) {
                            e.preventDefault();
                            that._hideFilterRange();
                            if (!$prevElement.length) {
                                $prevElement = $cell.prev().find("[tabindex]").last()
                            }
                            $prevElement.focus()
                        }
                    });
                    $editor = $("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_END_CLASS)).appendTo(contentElement);
                    editorOptions = that._getEditorOptions($editor, column);
                    editorOptions.sharedData = sharedData;
                    that._renderEditor($editor, editorOptions);
                    $editor.find(EDITORS_INPUT_SELECTOR).on("keydown", function(e) {
                        if (9 === e.which && !e.shiftKey) {
                            e.preventDefault();
                            that._hideFilterRange();
                            $cell.next().find("[tabindex]").first().focus()
                        }
                    });
                    return contentElement.addClass(that.getWidgetContainerClass())
                },
                onShown: function(e) {
                    var $editor = e.component.content().find("." + EDITOR_CONTAINER_CLASS).first();
                    $editor.find(EDITORS_INPUT_SELECTOR).focus()
                },
                onHidden: function() {
                    column = that._columnsController.columnOption(column.index);
                    $cell.find("." + MENU_CLASS).parent().addClass(EDITOR_WITH_MENU_CLASS);
                    if ("between" === getColumnSelectedFilterOperation(that, column)) {
                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
                        that.component.updateDimensions()
                    }
                }
            })
        },
        _updateFilterRangeOverlay: function(options) {
            var overlayInstance = this._filterRangeOverlayInstance;
            overlayInstance && overlayInstance.option(options)
        },
        _showFilterRange: function($cell, column) {
            var that = this,
                $overlay = $cell.children("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)),
                overlayInstance = $overlay.length && $overlay.data("dxOverlay");
            if (!overlayInstance && column) {
                overlayInstance = that._initFilterRangeOverlay($cell, column)
            }
            if (!overlayInstance.option("visible")) {
                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.hide();
                that._filterRangeOverlayInstance = overlayInstance;
                that._updateFilterRangeOverlay({
                    width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
                });
                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.show()
            }
        },
        _hideFilterRange: function() {
            var overlayInstance = this._filterRangeOverlayInstance;
            overlayInstance && overlayInstance.hide()
        },
        getFilterRangeOverlayInstance: function() {
            return this._filterRangeOverlayInstance
        },
        _createRow: function(row) {
            var $row = this.callBase(row);
            if ("filter" === row.rowType) {
                $row.addClass(this.addWidgetPrefix(FILTER_ROW_CLASS))
            }
            return $row
        },
        _getRows: function() {
            var result = this.callBase();
            if (this.isFilterRowVisible()) {
                result.push({
                    rowType: "filter"
                })
            }
            return result
        },
        _renderCellContent: function($cell, options) {
            var $container, $editorContainer, that = this,
                column = options.column;
            if ("filter" === options.rowType) {
                if (column.command) {
                    $cell.html("&nbsp;")
                } else {
                    if (column.allowFiltering) {
                        that.setAria("label", messageLocalization.format("dxDataGrid-ariaColumn") + " " + column.caption + ", " + messageLocalization.format("dxDataGrid-ariaFilterCell"), $cell);
                        $cell.addClass(EDITOR_CELL_CLASS);
                        $container = $("<div>").appendTo($cell);
                        $editorContainer = $("<div>").addClass(EDITOR_CONTAINER_CLASS).appendTo($container);
                        if ("between" === getColumnSelectedFilterOperation(that, column)) {
                            that._renderFilterRangeContent($cell, column)
                        } else {
                            that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column))
                        }
                        if (column.alignment) {
                            $cell.find(EDITORS_INPUT_SELECTOR).first().css("text-align", column.alignment)
                        }
                        if (column.filterOperations && column.filterOperations.length) {
                            that._renderFilterOperationChooser($container, column, $editorContainer)
                        }
                    }
                }
            }
            that.callBase($cell, options)
        },
        _getEditorOptions: function($editorContainer, column) {
            var that = this,
                result = extend({}, column, {
                    value: getFilterValue(that, column.index, $editorContainer),
                    parentType: "filterRow",
                    showAllText: that.option("filterRow.showAllText"),
                    updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : FILTERING_TIMEOUT,
                    width: null,
                    setValue: function(value, notFireEvent) {
                        updateFilterValue(that, {
                            column: column,
                            value: value,
                            container: $editorContainer,
                            notFireEvent: notFireEvent
                        })
                    }
                });
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
                if ($editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
                    result.placeholder = that.option("filterRow.betweenStartText")
                } else {
                    result.placeholder = that.option("filterRow.betweenEndText")
                }
            }
            return result
        },
        _renderEditor: function($editorContainer, options) {
            $editorContainer.empty();
            return this.getController("editorFactory").createEditor($("<div>").appendTo($editorContainer), options)
        },
        _renderFilterRangeContent: function($cell, column) {
            var that = this,
                $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
            $editorContainer.empty();
            $("<div>").addClass(FILTER_RANGE_CONTENT_CLASS).attr("tabindex", this.option("tabIndex")).on("focusin", function() {
                that._showFilterRange($cell, column)
            }).appendTo($editorContainer);
            that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
        },
        _updateFilterRangeContent: function($cell, value) {
            var $filterRangeContent = $cell.find("." + FILTER_RANGE_CONTENT_CLASS);
            if ($filterRangeContent.length) {
                if ("" === value) {
                    $filterRangeContent.html("&nbsp;")
                } else {
                    $filterRangeContent.text(value)
                }
            }
        },
        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
            var isCellWasFocused, that = this;
            that._createComponent($menu, Menu, {
                integrationOptions: {},
                activeStateEnabled: false,
                selectionMode: "single",
                cssClass: that.getWidgetContainerClass() + " " + CELL_FOCUS_DISABLED_CLASS + " " + FILTER_MENU,
                showFirstSubmenuMode: "onHover",
                hideSubmenuOnMouseLeave: true,
                items: [{
                    disabled: column.filterOperations && column.filterOperations.length ? false : true,
                    icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
                    selectable: false,
                    items: that._getFilterOperationMenuItems(column)
                }],
                onItemClick: function(properties) {
                    var selectedFilterOperation = properties.itemData.name,
                        columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column),
                        notFocusEditor = false,
                        isOnClickMode = isOnClickApplyFilterMode(that),
                        options = {};
                    if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
                        return
                    }
                    if (selectedFilterOperation) {
                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
                        if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
                            notFocusEditor = "between" === selectedFilterOperation;
                            options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null
                        }
                    } else {
                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
                        options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null
                    }
                    that._columnsController.columnOption(column.index, options);
                    that._applyFilterViewController.setHighLight($editorContainer, true);
                    if (!selectedFilterOperation) {
                        var editor = getEditorInstance($editorContainer);
                        if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
                            editor.reset();
                            editor.option("isValid", true)
                        }
                    }
                    if (!notFocusEditor) {
                        that._focusEditor($editorContainer)
                    } else {
                        that._showFilterRange($editorContainer.closest("." + EDITOR_CELL_CLASS), column)
                    }
                },
                onSubmenuShown: function() {
                    isCellWasFocused = that._isEditorFocused($editorContainer);
                    that.getController("editorFactory").loseFocus()
                },
                onSubmenuHiding: function() {
                    var menu = Menu.getInstance($menu);
                    $menu.blur();
                    menu && menu.option("focusedElement", null);
                    isCellWasFocused && that._focusEditor($editorContainer)
                },
                rtlEnabled: that.option("rtlEnabled")
            })
        },
        _isEditorFocused: function($container) {
            return $container.hasClass(FOCUSED_CLASS) || $container.parents("." + FOCUSED_CLASS).length
        },
        _focusEditor: function($container) {
            this.getController("editorFactory").focus($container);
            $container.find(EDITORS_INPUT_SELECTOR).focus()
        },
        _renderFilterOperationChooser: function($container, column, $editorContainer) {
            var $menu, that = this;
            if (that.option("filterRow.showOperationChooser")) {
                $container.addClass(EDITOR_WITH_MENU_CLASS);
                $menu = $("<div>").prependTo($container);
                that._updateFilterOperationChooser($menu, column, $editorContainer)
            }
        },
        _getFilterOperationMenuItems: function(column) {
            var that = this,
                result = [{}],
                filterRowOptions = that.option("filterRow"),
                operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
            if (column.filterOperations && column.filterOperations.length) {
                result = $.map(column.filterOperations, function(value) {
                    var descriptionName = OPERATION_DESCRIPTORS[value];
                    return {
                        name: value,
                        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value,
                        text: operationDescriptions[descriptionName],
                        icon: OPERATION_ICONS[value]
                    }
                });
                result.push({
                    name: null,
                    text: filterRowOptions && filterRowOptions.resetOperationText,
                    icon: OPERATION_ICONS.default
                })
            }
            return result
        },
        optionChanged: function(args) {
            var that = this;
            switch (args.name) {
                case "filterRow":
                case "showColumnLines":
                    this._invalidate(true, true);
                    args.handled = true;
                    break;
                default:
                    that.callBase(args)
            }
        }
    }
}();
var DataControllerFilterRowExtender = {
    _calculateAdditionalFilter: function() {
        var that = this,
            filters = [that.callBase()],
            columns = that._columnsController.getVisibleColumns();
        $.each(columns, function() {
            var filter;
            if (this.allowFiltering && this.calculateFilterExpression && commonUtils.isDefined(this.filterValue)) {
                filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
                filters.push(filter)
            }
        });
        return gridCoreUtils.combineFilters(filters)
    }
};
exports.ApplyFilterViewController = modules.ViewController.inherit({
    _getHeaderPanel: function() {
        if (!this._headerPanel) {
            this._headerPanel = this.getView("headerPanel")
        }
        return this._headerPanel
    },
    setHighLight: function($element, value) {
        if (isOnClickApplyFilterMode(this)) {
            $element && $element.toggleClass(HIGHLIGHT_OUTLINE_CLASS, value);
            this._getHeaderPanel().enableApplyButton(value)
        }
    },
    applyFilter: function() {
        var columnsController = this.getController("columns"),
            columns = columnsController.getColumns();
        columnsController.beginUpdate();
        for (var i = 0; i < columns.length; i++) {
            if (void 0 !== columns[i].bufferedFilterValue) {
                columnsController.columnOption(i, "filterValue", columns[i].bufferedFilterValue);
                columns[i].bufferedFilterValue = void 0
            }
            if (void 0 !== columns[i].bufferedSelectedFilterOperation) {
                columnsController.columnOption(i, "selectedFilterOperation", columns[i].bufferedSelectedFilterOperation);
                columns[i].bufferedSelectedFilterOperation = void 0
            }
        }
        columnsController.endUpdate();
        this.removeHighLights()
    },
    removeHighLights: function() {
        if (isOnClickApplyFilterMode(this)) {
            var columnHeadersView = this.getView("columnHeadersView");
            columnHeadersView.element().find("." + this.addWidgetPrefix(FILTER_ROW_CLASS) + " ." + HIGHLIGHT_OUTLINE_CLASS).removeClass(HIGHLIGHT_OUTLINE_CLASS);
            this._getHeaderPanel().enableApplyButton(false)
        }
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            filterRow: {
                visible: false,
                showOperationChooser: true,
                showAllText: messageLocalization.format("dxDataGrid-filterRowShowAllText"),
                resetOperationText: messageLocalization.format("dxDataGrid-filterRowResetOperationText"),
                applyFilter: "auto",
                applyFilterText: messageLocalization.format("dxDataGrid-applyFilterText"),
                operationDescriptions: {
                    equal: messageLocalization.format("dxDataGrid-filterRowOperationEquals"),
                    notEqual: messageLocalization.format("dxDataGrid-filterRowOperationNotEquals"),
                    lessThan: messageLocalization.format("dxDataGrid-filterRowOperationLess"),
                    lessThanOrEqual: messageLocalization.format("dxDataGrid-filterRowOperationLessOrEquals"),
                    greaterThan: messageLocalization.format("dxDataGrid-filterRowOperationGreater"),
                    greaterThanOrEqual: messageLocalization.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
                    startsWith: messageLocalization.format("dxDataGrid-filterRowOperationStartsWith"),
                    contains: messageLocalization.format("dxDataGrid-filterRowOperationContains"),
                    notContains: messageLocalization.format("dxDataGrid-filterRowOperationNotContains"),
                    endsWith: messageLocalization.format("dxDataGrid-filterRowOperationEndsWith"),
                    between: messageLocalization.format("dxDataGrid-filterRowOperationBetween")
                },
                betweenStartText: messageLocalization.format("dxDataGrid-filterRowOperationBetweenStartText"),
                betweenEndText: messageLocalization.format("dxDataGrid-filterRowOperationBetweenEndText")
            }
        }
    },
    controllers: {
        applyFilter: exports.ApplyFilterViewController
    },
    extenders: {
        controllers: {
            data: DataControllerFilterRowExtender,
            columnsResizer: {
                _startResizing: function() {
                    var cellIndex, overlayInstance, that = this;
                    that.callBase.apply(that, arguments);
                    if (that.isResizing()) {
                        overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                        if (overlayInstance) {
                            cellIndex = overlayInstance.element().closest("td").index();
                            if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
                                overlayInstance.content().hide()
                            }
                        }
                    }
                },
                _endResizing: function() {
                    var $cell, overlayInstance, that = this;
                    if (that.isResizing()) {
                        overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                        if (overlayInstance) {
                            $cell = overlayInstance.element().closest("td");
                            that._columnHeadersView._updateFilterRangeOverlay({
                                width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
                            });
                            overlayInstance.content().show()
                        }
                    }
                    that.callBase.apply(that, arguments)
                }
            }
        },
        views: {
            columnHeadersView: ColumnHeadersViewFilterRowExtender,
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase(),
                        filterItem = this._prepareFilterItem(items);
                    return filterItem.concat(items)
                },
                _prepareFilterItem: function() {
                    var that = this,
                        filterItem = [];
                    if (that._isShowApplyFilterButton()) {
                        var hintText = that.option("filterRow.applyFilterText"),
                            columns = that._columnsController.getColumns(),
                            disabled = !columns.filter(function(column) {
                                return void 0 !== column.bufferedFilterValue
                            }).length,
                            onInitialized = function(e) {
                                e.element.addClass(that._getToolbarButtonClass(APPLY_BUTTON_CLASS))
                            },
                            onClickHandler = function() {
                                that._applyFilterViewController.applyFilter()
                            },
                            toolbarItem = {
                                widget: "dxButton",
                                options: {
                                    icon: "apply-filter",
                                    disabled: disabled,
                                    onClick: onClickHandler,
                                    hint: hintText,
                                    text: hintText,
                                    onInitialized: onInitialized
                                },
                                showText: "inMenu",
                                name: "applyFilterButton",
                                location: "after",
                                locateInMenu: "auto",
                                sortIndex: 10
                            };
                        filterItem.push(toolbarItem)
                    }
                    return filterItem
                },
                _isShowApplyFilterButton: function() {
                    var filterRowOptions = this.option("filterRow");
                    return filterRowOptions && filterRowOptions.visible && "onClick" === filterRowOptions.applyFilter
                },
                init: function() {
                    this.callBase();
                    this._dataController = this.getController("data");
                    this._applyFilterViewController = this.getController("applyFilter")
                },
                enableApplyButton: function(value) {
                    this.setToolbarItemDisabled("applyFilterButton", !value)
                },
                isVisible: function() {
                    return this.callBase() || this._isShowApplyFilterButton()
                },
                optionChanged: function(args) {
                    if ("filterRow" === args.name) {
                        this._invalidate();
                        args.handled = true
                    } else {
                        this.callBase(args)
                    }
                }
            }
        }
    }
};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(376);
module.exports.default = module.exports;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_filter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    headerFilterCore = __webpack_require__(379),
    headerFilterMixin = headerFilterCore.headerFilterMixin,
    messageLocalization = __webpack_require__(8),
    allowHeaderFiltering = headerFilterCore.allowHeaderFiltering,
    clickEvent = __webpack_require__(11),
    dataUtils = __webpack_require__(28),
    dataCoreUtils = __webpack_require__(14),
    commonUtils = __webpack_require__(2),
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    extend = __webpack_require__(1).extend,
    normalizeDataSourceOptions = __webpack_require__(51).normalizeDataSourceOptions,
    dateLocalization = __webpack_require__(32),
    isWrapped = __webpack_require__(41).isWrapped;
var DATE_INTERVAL_FORMATS = {
    month: function(value) {
        return dateLocalization.getMonthNames()[value - 1]
    },
    quarter: function(value) {
        return dateLocalization.format(new Date(2e3, 3 * value - 1), "quarter")
    }
};
var HeaderFilterController = modules.ViewController.inherit(function() {
    var getFormatOptions = function(value, column, currentLevel) {
        var groupInterval = gridCoreUtils.getGroupInterval(column),
            result = gridCoreUtils.getFormatOptionsByColumn(column, "headerFilter");
        if (groupInterval) {
            result.groupInterval = groupInterval[currentLevel];
            if ("date" === column.dataType) {
                result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]]
            } else {
                if ("number" === column.dataType) {
                    result.getDisplayFormat = function() {
                        var formatOptions = {
                                format: column.format,
                                precision: column.precision,
                                target: "headerFilter"
                            },
                            firstValueText = gridCoreUtils.formatValue(value, formatOptions),
                            secondValue = value + groupInterval[currentLevel],
                            secondValueText = gridCoreUtils.formatValue(secondValue, formatOptions);
                        return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : ""
                    }
                }
            }
        }
        return result
    };
    return {
        init: function() {
            this._columnsController = this.getController("columns");
            this._dataController = this.getController("data");
            this._headerFilterView = this.getView("headerFilterView")
        },
        _updateSelectedState: function(items, column) {
            var i = items.length,
                isExclude = "exclude" === column.filterType;
            while (i--) {
                var item = items[i];
                if ("items" in items[i]) {
                    this._updateSelectedState(items[i].items, column)
                }
                headerFilterCore.updateHeaderFilterItemSelectionState(item, gridCoreUtils.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude)
            }
        },
        _normalizeGroupItem: function(item, currentLevel, options) {
            var value, displayValue, path = options.path,
                valueSelector = options.valueSelector,
                displaySelector = options.displaySelector,
                column = options.column;
            if (valueSelector && displaySelector) {
                value = valueSelector(item);
                displayValue = displaySelector(item)
            } else {
                value = item.key;
                displayValue = value
            }
            item = commonUtils.isObject(item) ? item : {};
            path.push(value);
            if (1 === path.length) {
                item.value = path[0]
            } else {
                item.value = path.join("/")
            }
            item.text = gridCoreUtils.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
            if (!item.text) {
                item.text = options.headerFilterOptions.texts.emptyValue
            }
            delete item.key;
            return item
        },
        _processGroupItems: function(groupItems, currentLevel, path, options) {
            var displaySelector, valueSelector, that = this,
                column = options.column,
                lookup = column.lookup,
                level = options.level;
            path = path || [];
            currentLevel = currentLevel || 0;
            if (lookup) {
                displaySelector = dataCoreUtils.compileGetter(lookup.displayExpr);
                valueSelector = dataCoreUtils.compileGetter(lookup.valueExpr)
            }
            for (var i = 0; i < groupItems.length; i++) {
                groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
                    column: options.column,
                    headerFilterOptions: options.headerFilterOptions,
                    displaySelector: displaySelector,
                    valueSelector: valueSelector,
                    path: path
                });
                if ("items" in groupItems[i]) {
                    if (currentLevel === level || !commonUtils.isDefined(groupItems[i].value)) {
                        delete groupItems[i].items
                    } else {
                        that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options)
                    }
                }
                path.pop()
            }
        },
        getDataSource: function(column) {
            var filter, cutoffLevel, origPostProcess, that = this,
                dataSource = that._dataController.dataSource(),
                group = gridCoreUtils.getHeaderFilterGroupParameters(column, dataSource && dataSource.remoteOperations().grouping),
                headerFilterDataSource = column.headerFilter && column.headerFilter.dataSource,
                headerFilterOptions = that.option("headerFilter"),
                options = {
                    component: that.component
                };
            if (!dataSource) {
                return
            }
            if (commonUtils.isDefined(headerFilterDataSource) && !commonUtils.isFunction(headerFilterDataSource)) {
                dataSource = normalizeDataSourceOptions(headerFilterDataSource);
                dataSource.postProcess = function(items) {
                    that._updateSelectedState(items, column);
                    return items
                };
                return dataSource
            }
            if (column.lookup) {
                dataSource = column.lookup.dataSource;
                if (commonUtils.isFunction(dataSource) && !isWrapped(dataSource)) {
                    dataSource = dataSource({})
                }
                dataSource = normalizeDataSourceOptions(dataSource);
                dataSource.postProcess = function(items) {
                    if (0 === this.pageIndex()) {
                        items = items.slice(0);
                        items.unshift(null)
                    }
                    that._processGroupItems(items, null, null, {
                        level: 0,
                        column: column,
                        headerFilterOptions: headerFilterOptions
                    });
                    that._updateSelectedState(items, column);
                    return items
                };
                options.dataSource = dataSource
            } else {
                cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
                that._currentColumn = column;
                filter = that._dataController.getCombinedFilter();
                that._currentColumn = null;
                options.dataSource = {
                    filter: filter,
                    group: group,
                    load: function(options) {
                        var d = $.Deferred();
                        options.dataField = column.dataField || column.name;
                        dataSource.load(options).done(function(data) {
                            that._processGroupItems(data, null, null, {
                                level: cutoffLevel,
                                column: column,
                                headerFilterOptions: headerFilterOptions
                            });
                            that._updateSelectedState(data, column);
                            d.resolve(data)
                        }).fail(d.reject);
                        return d
                    }
                }
            }
            if (commonUtils.isFunction(headerFilterDataSource)) {
                headerFilterDataSource.call(column, options);
                origPostProcess = options.dataSource.postProcess;
                options.dataSource.postProcess = function(data) {
                    var items = origPostProcess && origPostProcess.apply(this, arguments) || data;
                    that._updateSelectedState(items, column);
                    return items
                }
            }
            return options.dataSource
        },
        getCurrentColumn: function() {
            return this._currentColumn
        },
        showHeaderFilterMenu: function(columnIndex, isGroupPanel) {
            var that = this,
                column = extend(true, {}, that._columnsController.getColumns()[columnIndex]);
            if (column) {
                var visibleIndex = that._columnsController.getVisibleIndex(columnIndex),
                    view = isGroupPanel ? that.getView("headerPanel") : that.getView("columnHeadersView"),
                    $columnElement = view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex),
                    groupInterval = gridCoreUtils.getGroupInterval(column);
                var options = extend(column, {
                    type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
                    apply: function() {
                        that._columnsController.columnOption(columnIndex, {
                            filterValues: this.filterValues,
                            filterType: this.filterType
                        })
                    },
                    onShowing: function(e) {
                        var dxResizableInstance = e.component.overlayContent().dxResizable("instance");
                        dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
                            var columnsController = that.getController("columns"),
                                headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
                            headerFilterByColumn = headerFilterByColumn || {};
                            headerFilterByColumn.width = e.width;
                            headerFilterByColumn.height = e.height;
                            columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
                        })
                    }
                });
                options.dataSource = that.getDataSource(options);
                that._headerFilterView.showHeaderFilterMenu($columnElement, options)
            }
        },
        hideHeaderFilterMenu: function() {
            this._headerFilterView.hideHeaderFilterMenu()
        }
    }
}());
var ColumnHeadersViewHeaderFilterExtender = extend({}, headerFilterCore.headerFilterMixin, {
    _renderCellContent: function($cell, options) {
        var $headerFilterIndicator, that = this,
            column = options.column;
        if (!column.command && allowHeaderFiltering(column) && that.option("headerFilter.visible") && "header" === options.rowType) {
            $headerFilterIndicator = that._applyColumnState({
                name: "headerFilter",
                rootElement: $cell,
                column: column,
                showColumnLines: that.option("showColumnLines")
            });
            $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
        }
        that.callBase($cell, options)
    },
    _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
        var that = this;
        if ("headerFilter" === indicatorName) {
            $indicator.on(clickEvent.name, that.createAction(function(e) {
                var event = e.jQueryEvent;
                event.stopPropagation();
                that.getController("headerFilter").showHeaderFilterMenu(column.index, false)
            }))
        }
    },
    _updateIndicator: function($cell, column, indicatorName) {
        var $indicator = this.callBase($cell, column, indicatorName);
        $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
    },
    _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (gridCoreUtils.checkChanges(optionNames, ["filterValues", "filterType"])) {
            if (this.option("headerFilter.visible")) {
                this._updateIndicators("headerFilter")
            }
            return
        }
        this.callBase(e)
    }
});
var HeaderPanelHeaderFilterExtender = extend({}, headerFilterMixin, {
    _createGroupPanelItem: function($rootElement, groupColumn) {
        var $headerFilterIndicator, that = this,
            $item = that.callBase.apply(that, arguments);
        if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
            $headerFilterIndicator = that._applyColumnState({
                name: "headerFilter",
                rootElement: $item,
                column: {
                    alignment: getDefaultAlignment(that.option("rtlEnabled")),
                    filterValues: groupColumn.filterValues,
                    allowHeaderFiltering: true
                },
                showColumnLines: true
            });
            $headerFilterIndicator && $headerFilterIndicator.on(clickEvent.name, that.createAction(function(e) {
                var event = e.jQueryEvent;
                event.stopPropagation();
                that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index, true)
            }))
        }
        return $item
    }
});
var INVERTED_BINARY_OPERATIONS = {
    "=": "<>",
    "<>": "=",
    ">": "<=",
    ">=": "<",
    "<": ">=",
    "<=": ">",
    contains: "notcontains",
    notcontains: "contains",
    startswith: "notcontains",
    endswith: "notcontains"
};

function invertFilterExpression(filter) {
    var i, currentGroupOperation, result;
    if (Array.isArray(filter[0])) {
        result = [];
        for (i = 0; i < filter.length; i++) {
            if (Array.isArray(filter[i])) {
                if (currentGroupOperation) {
                    result.push(currentGroupOperation)
                }
                result.push(invertFilterExpression(filter[i]));
                currentGroupOperation = "or"
            } else {
                currentGroupOperation = dataUtils.isConjunctiveOperator(filter[i]) ? "or" : "and"
            }
        }
        return result
    }
    result = dataUtils.normalizeBinaryCriterion(filter);
    result[1] = INVERTED_BINARY_OPERATIONS[result[1]] || result[1];
    return result
}
var DataControllerFilterRowExtender = {
    _calculateAdditionalFilter: function() {
        var that = this,
            filters = [that.callBase()],
            columns = that._columnsController.getVisibleColumns(),
            headerFilterController = that.getController("headerFilter"),
            currentColumn = headerFilterController.getCurrentColumn();
        $.each(columns, function(_, column) {
            var filter;
            if (currentColumn && currentColumn.index === column.index) {
                return
            }
            if (allowHeaderFiltering(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
                var filterValues = [],
                    isExclude = "exclude" === column.filterType;
                $.each(column.filterValues, function(_, filterValue) {
                    if (Array.isArray(filterValue)) {
                        filter = isExclude ? invertFilterExpression(filterValue) : filterValue
                    } else {
                        if (column.deserializeValue && "date" !== column.dataType && "number" !== column.dataType) {
                            filterValue = column.deserializeValue(filterValue)
                        }
                        filter = column.createFilterExpression(filterValue, isExclude ? "<>" : "=", "headerFilter")
                    }
                    if (filter) {
                        filter.columnIndex = column.index
                    }
                    filterValues.push(filter)
                });
                filterValues = gridCoreUtils.combineFilters(filterValues, isExclude ? "and" : "or");
                filters.push(filterValues)
            }
        });
        return gridCoreUtils.combineFilters(filters)
    }
};
module.exports = {
    invertFilterExpression: invertFilterExpression,
    defaultOptions: function() {
        return {
            headerFilter: {
                visible: false,
                width: 252,
                height: 325,
                texts: {
                    emptyValue: messageLocalization.format("dxDataGrid-headerFilterEmptyValue"),
                    ok: messageLocalization.format("dxDataGrid-headerFilterOK"),
                    cancel: messageLocalization.format("dxDataGrid-headerFilterCancel")
                }
            }
        }
    },
    controllers: {
        headerFilter: HeaderFilterController
    },
    views: {
        headerFilterView: headerFilterCore.HeaderFilterView
    },
    extenders: {
        controllers: {
            data: DataControllerFilterRowExtender
        },
        views: {
            columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
            headerPanel: HeaderPanelHeaderFilterExtender
        }
    }
};


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.search.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    compileGetter = __webpack_require__(14).compileGetter,
    gridCoreUtils = __webpack_require__(26),
    messageLocalization = __webpack_require__(8),
    dataQuery = __webpack_require__(35);
var SEARCH_PANEL_CLASS = "search-panel",
    SEARCH_TEXT_CLASS = "search-text",
    FILTERING_TIMEOUT = 700;

function allowSearch(column) {
    return commonUtils.isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
}

function parseValue(column, text) {
    var lookup = column.lookup;
    if (lookup) {
        return column.parseValue.call(lookup, text)
    } else {
        return column.parseValue ? column.parseValue(text) : text
    }
}
module.exports = {
    defaultOptions: function() {
        return {
            searchPanel: {
                visible: false,
                width: 160,
                placeholder: messageLocalization.format("dxDataGrid-searchPanelPlaceholder"),
                highlightSearchText: true,
                highlightCaseSensitive: false,
                text: "",
                searchVisibleColumnsOnly: false
            }
        }
    },
    extenders: {
        controllers: {
            data: function() {
                var calculateSearchFilter = function(that, text) {
                    var i, column, filterValue, lookup, columns = that._columnsController.getColumns(),
                        searchVisibleColumnsOnly = that.option("searchPanel.searchVisibleColumnsOnly"),
                        filters = [];
                    if (!text) {
                        return null
                    }

                    function onQueryDone(items) {
                        var i, value, valueGetter = compileGetter(lookup.valueExpr);
                        for (i = 0; i < items.length; i++) {
                            value = valueGetter(items[i]);
                            filters.push(column.createFilterExpression(value, null, "search"))
                        }
                    }
                    for (i = 0; i < columns.length; i++) {
                        column = columns[i];
                        if (searchVisibleColumnsOnly && !column.visible) {
                            continue
                        }
                        if (allowSearch(column) && column.calculateFilterExpression) {
                            lookup = column.lookup;
                            filterValue = parseValue(column, text);
                            if (lookup && lookup.items) {
                                dataQuery(lookup.items).filter(column.createFilterExpression.call({
                                    dataField: lookup.displayExpr,
                                    dataType: lookup.dataType,
                                    calculateFilterExpression: column.calculateFilterExpression
                                }, filterValue, null, "search")).enumerate().done(onQueryDone)
                            } else {
                                if (void 0 !== filterValue) {
                                    filters.push(column.createFilterExpression(filterValue, null, "search"))
                                }
                            }
                        }
                    }
                    return gridCoreUtils.combineFilters(filters, "or")
                };
                return {
                    publicMethods: function() {
                        return this.callBase().concat(["searchByText"])
                    },
                    _calculateAdditionalFilter: function() {
                        var that = this,
                            filter = that.callBase(),
                            searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                        return gridCoreUtils.combineFilters([filter, searchFilter])
                    },
                    searchByText: function(text) {
                        this.option("searchPanel.text", text)
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.fullName) {
                            case "searchPanel.text":
                            case "searchPanel":
                                that._applyFilter();
                                args.handled = true;
                                break;
                            default:
                                that.callBase(args)
                        }
                    }
                }
            }()
        },
        views: {
            headerPanel: function() {
                var getSearchPanelOptions = function(that) {
                    return that.option("searchPanel")
                };
                return {
                    _getToolbarItems: function() {
                        var items = this.callBase();
                        return this._prepareSearchItem(items)
                    },
                    _prepareSearchItem: function(items) {
                        var that = this,
                            dataController = that.getController("data"),
                            searchPanelOptions = getSearchPanelOptions(that);
                        if (searchPanelOptions && searchPanelOptions.visible) {
                            var toolbarItem = {
                                template: function(data, index, $container) {
                                    var $search = $("<div>").addClass(that.addWidgetPrefix(SEARCH_PANEL_CLASS)).appendTo($container);
                                    that.setAria("label", messageLocalization.format("dxDataGrid-ariaSearchInGrid"), $search);
                                    that.getController("editorFactory").createEditor($search, {
                                        width: searchPanelOptions.width,
                                        placeholder: searchPanelOptions.placeholder,
                                        parentType: "searchPanel",
                                        value: that.option("searchPanel.text"),
                                        updateValueTimeout: FILTERING_TIMEOUT,
                                        setValue: function(value) {
                                            dataController.searchByText(value)
                                        }
                                    });
                                    that.resize()
                                },
                                name: "searchPanel",
                                location: "after",
                                locateInMenu: "never",
                                sortIndex: 40
                            };
                            items.push(toolbarItem)
                        }
                        return items
                    },
                    _getSearchTextEditor: function() {
                        var $searchPanel = this.element().find("." + this.addWidgetPrefix(SEARCH_PANEL_CLASS));
                        if ($searchPanel.length) {
                            return $searchPanel.dxTextBox("instance")
                        }
                        return null
                    },
                    isVisible: function() {
                        var searchPanelOptions = getSearchPanelOptions(this);
                        return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                    },
                    optionChanged: function(args) {
                        if ("searchPanel" === args.name) {
                            if ("searchPanel.text" === args.fullName) {
                                var editor = this._getSearchTextEditor();
                                if (editor) {
                                    editor.option("value", args.value)
                                }
                            } else {
                                this._invalidate()
                            }
                            args.handled = true
                        } else {
                            this.callBase(args)
                        }
                    }
                }
            }(),
            rowsView: {
                init: function() {
                    this.callBase.apply(this, arguments);
                    this._searchParams = []
                },
                _highlightSearchText: function(cellElement, isEquals, column) {
                    var $parent, that = this,
                        searchText = that.option("searchPanel.text");
                    if (searchText && that.option("searchPanel.highlightSearchText")) {
                        var normalizeString = that.option("searchPanel.highlightCaseSensitive") ? function(str) {
                            return str
                        } : function(str) {
                            return str.toLowerCase()
                        };
                        if (isEquals && column) {
                            var value = parseValue(column, searchText),
                                formatOptions = gridCoreUtils.getFormatOptionsByColumn(column, "search");
                            searchText = gridCoreUtils.formatValue(value, formatOptions);
                            if (!searchText) {
                                return
                            }
                        }
                        $parent = cellElement.parent();
                        if (!$parent.length) {
                            $parent = $("<div>").append(cellElement)
                        }
                        var $items = $parent.find("*").filter(function(index, element) {
                            var $contents = $(element).contents();
                            for (var i = 0; i < $contents.length; i++) {
                                var node = $contents.get(i);
                                if (3 === node.nodeType) {
                                    return (node.textContent || node.nodeValue || "").toLowerCase().indexOf(searchText.toLowerCase()) > -1
                                }
                                return false
                            }
                        });
                        $.each($items, function(index, element) {
                            $.each($(element).contents(), function(index, content) {
                                if (3 !== content.nodeType) {
                                    return
                                }
                                var highlightSearchTextInTextNode = function($content, searchText) {
                                    var $searchTextSpan = $("<span />").addClass(that.addWidgetPrefix(SEARCH_TEXT_CLASS)),
                                        text = $content.text(),
                                        index = normalizeString(text).indexOf(normalizeString(searchText));
                                    if (index >= 0) {
                                        if ($content[0].textContent) {
                                            $content[0].textContent = text.substr(0, index)
                                        } else {
                                            $content[0].nodeValue = text.substr(0, index)
                                        }
                                        $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
                                        $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                                        return highlightSearchTextInTextNode($content, searchText)
                                    }
                                };
                                if (isEquals) {
                                    if (normalizeString($(content).text()) === normalizeString(searchText)) {
                                        $(this).replaceWith($("<span />").addClass(that.addWidgetPrefix(SEARCH_TEXT_CLASS)).text($(content).text()))
                                    }
                                } else {
                                    highlightSearchTextInTextNode($(content), searchText)
                                }
                            })
                        })
                    }
                },
                _renderCore: function() {
                    this.callBase.apply(this, arguments);
                    if (this.option("rowTemplate")) {
                        if (this.option("templatesRenderAsynchronously")) {
                            clearTimeout(this._highlightTimer);
                            this._highlightTimer = setTimeout(function() {
                                this._highlightSearchText(this._getTableElement())
                            }.bind(this))
                        } else {
                            this._highlightSearchText(this._getTableElement())
                        }
                    }
                },
                _updateCell: function($cell, parameters) {
                    var column = parameters.column,
                        dataType = column.lookup && column.lookup.dataType || column.dataType,
                        isEquals = "string" !== dataType;
                    if (allowSearch(column)) {
                        if (this.option("templatesRenderAsynchronously")) {
                            if (!this._searchParams.length) {
                                clearTimeout(this._highlightTimer);
                                this._highlightTimer = setTimeout(function() {
                                    this._searchParams.forEach(function(params) {
                                        this._highlightSearchText.apply(this, params)
                                    }.bind(this));
                                    this._searchParams = []
                                }.bind(this))
                            }
                            this._searchParams.push([$cell, isEquals, column])
                        } else {
                            this._highlightSearchText($cell, isEquals, column)
                        }
                    }
                    this.callBase($cell, parameters)
                },
                dispose: function() {
                    clearTimeout(this._highlightTimer);
                    this.callBase()
                }
            }
        }
    }
};


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_resizing_reordering.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    dragEvents = __webpack_require__(76),
    addNamespace = eventUtils.addNamespace,
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    fx = __webpack_require__(22);
var COLUMNS_SEPARATOR_CLASS = "columns-separator",
    COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent",
    DRAGGING_HEADER_CLASS = "drag-header",
    CELL_CONTENT_CLASS = "text-content",
    HEADERS_DRAG_ACTION_CLASS = "drag-action",
    TRACKER_CLASS = "tracker",
    HEADERS_DROP_HIGHLIGHT_CLASS = "drop-highlight",
    BLOCK_SEPARATOR_CLASS = "dx-block-separator",
    HEADER_ROW_CLASS = "dx-header-row",
    WIDGET_CLASS = "dx-widget",
    MODULE_NAMESPACE = "dxDataGridResizingReordering",
    COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
    DRAGGING_DELTA = 5;
var allowResizing = function(that) {
    return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
};
var allowReordering = function(that) {
    return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
};
var TrackerView = modules.View.inherit({
    _renderCore: function() {
        this.callBase();
        this.element().addClass(this.addWidgetPrefix(TRACKER_CLASS));
        this.hide()
    },
    _unsubscribeFromCallback: function() {
        if (this._positionChanged) {
            this._tablePositionController.positionChanged.remove(this._positionChanged)
        }
    },
    _subscribeToCallback: function() {
        var that = this;
        that._positionChanged = function(position) {
            var $element = that.element();
            if ($element && $element.hasClass(that.addWidgetPrefix(TRACKER_CLASS))) {
                $element.css({
                    top: position.top
                });
                $element.height(position.height)
            }
        };
        this._tablePositionController.positionChanged.add(that._positionChanged)
    },
    optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
            this._unsubscribeFromCallback();
            if (args.value) {
                this._subscribeToCallback();
                this._invalidate()
            }
        }
        this.callBase(args)
    },
    init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._subscribeToCallback()
    },
    isVisible: function() {
        return allowResizing(this)
    },
    show: function() {
        this.element().show()
    },
    hide: function() {
        this.element() && this.element().hide()
    },
    setHeight: function(value) {
        this.element().height(value)
    },
    dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase()
    }
});
var SeparatorView = modules.View.inherit({
    _renderSeparator: function() {},
    _renderCore: function(options) {
        this.callBase(options);
        this._isShown = true;
        this._renderSeparator();
        this.hide()
    },
    show: function() {
        this._isShown = true
    },
    hide: function() {
        this._isShown = false
    },
    height: function(value) {
        var $element = this.element();
        if ($element) {
            if (commonUtils.isDefined(value)) {
                $element.height(value)
            } else {
                return $element.height()
            }
        }
    },
    width: function(value) {
        var $element = this.element();
        if ($element) {
            if (commonUtils.isDefined(value)) {
                $element.width(value)
            } else {
                return $element.width()
            }
        }
    }
});
var ColumnsSeparatorView = SeparatorView.inherit({
    _renderSeparator: function() {
        this.callBase();
        var $element = this.element();
        $element.addClass(this.addWidgetPrefix(COLUMNS_SEPARATOR_CLASS))
    },
    _subscribeToCallback: function() {
        var $element, that = this;
        that._positionChanged = function(position) {
            $element = that.element();
            if ($element) {
                $element.css({
                    top: position.top
                });
                $element.height(position.height)
            }
        };
        that._tablePositionController.positionChanged.add(that._positionChanged)
    },
    _unsubscribeFromCallback: function() {
        this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged)
    },
    _init: function() {
        this._isTransparent = allowResizing(this);
        if (this.isVisible()) {
            this._subscribeToCallback()
        }
    },
    isVisible: function() {
        return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
    },
    optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
            if (args.value) {
                this._init();
                this._invalidate();
                this.hide(true)
            } else {
                this._unsubscribeFromCallback();
                this._isTransparent = allowResizing(this);
                this.hide(true)
            }
        }
        this.callBase(args)
    },
    init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._init()
    },
    show: function() {
        var that = this,
            $element = this.element();
        if ($element && !that._isShown) {
            if (that._isTransparent) {
                $element.removeClass(that.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT))
            } else {
                $element.show()
            }
        }
        this.callBase()
    },
    hide: function(force) {
        var $element = this.element(),
            columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
        if ($element && (this._isShown || force)) {
            if (this._isTransparent) {
                $element.addClass(columnsSeparatorTransparent);
                if ("none" === $element.css("display")) {
                    $element.show()
                }
            } else {
                if ($element.hasClass(columnsSeparatorTransparent)) {
                    $element.removeClass(columnsSeparatorTransparent)
                }
                $element.hide()
            }
        }
        this.callBase()
    },
    moveByX: function(outerX) {
        var $element = this.element();
        if ($element) {
            $element.css("left", outerX - this._parentElement().offset().left)
        }
    },
    changeCursor: function(cursorName) {
        cursorName = commonUtils.isDefined(cursorName) ? cursorName : "";
        var $element = this.element();
        if ($element) {
            $element.css("cursor", cursorName)
        }
    },
    dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase()
    }
});
var BlockSeparatorView = SeparatorView.inherit({
    init: function() {
        var that = this;
        this.callBase();
        this.getController("data").loadingChanged.add(function(isLoading) {
            var element = that.element();
            if (!isLoading && element && "none" !== element.css("display")) {
                that.hide()
            }
        })
    },
    _renderSeparator: function() {
        this.callBase();
        this.element().addClass(BLOCK_SEPARATOR_CLASS).html("&nbsp;")
    },
    hide: function() {
        var that = this,
            $parent = this._parentElement(),
            $element = this.element();
        if ($element && this._isShown) {
            $element.hide()
        }
        if ($parent && !$parent.children("." + BLOCK_SEPARATOR_CLASS).length) {
            $parent.prepend(that.element())
        }
        that.callBase()
    },
    isVisible: function() {
        var groupPanelOptions = this.option("groupPanel"),
            columnChooserOptions = this.option("columnChooser");
        return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
    },
    show: function(targetLocation) {
        var that = this,
            $element = this.element(),
            startAnimate = function(toOptions) {
                fx.stop($element, true);
                fx.animate($element, {
                    type: "slide",
                    from: {
                        width: 0,
                        display: toOptions.display
                    },
                    to: toOptions,
                    duration: 300,
                    easing: "swing"
                })
            };
        if ($element && !that._isShown) {
            switch (targetLocation) {
                case "group":
                    startAnimate({
                        width: "50px",
                        display: "inline-block"
                    });
                    break;
                case "columnChooser":
                    startAnimate({
                        width: "100%",
                        display: "block"
                    });
                    break;
                default:
                    $element.show()
            }
        }
        that.callBase()
    }
});
var DraggingHeaderView = modules.View.inherit({
    _isDragging: false,
    _getDraggingPanelByPos: function(pos) {
        var result, that = this;
        $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
            if (draggingPanel) {
                var boundingRect = draggingPanel.getBoundingRect();
                if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
                    result = draggingPanel;
                    return false
                }
            }
        });
        return result
    },
    _renderCore: function() {
        this.element().addClass(this.addWidgetPrefix(DRAGGING_HEADER_CLASS) + " " + this.addWidgetPrefix(CELL_CONTENT_CLASS) + " " + WIDGET_CLASS).css("display", "none")
    },
    _resetTargetColumnOptions: function() {
        var params = this._dropOptions;
        params.targetColumnIndex = -1;
        delete params.targetColumnElement;
        delete params.isLast;
        delete params.posX;
        delete params.posY
    },
    _getVisibleIndexObject: function(rowIndex, visibleIndex) {
        if (commonUtils.isDefined(rowIndex)) {
            return {
                columnIndex: visibleIndex,
                rowIndex: rowIndex
            }
        }
        return visibleIndex
    },
    dispose: function() {
        var element = this.element();
        this._dragOptions = null;
        element && element.parent().find("." + this.addWidgetPrefix(DRAGGING_HEADER_CLASS)).remove()
    },
    isVisible: function() {
        var columnsController = this.getController("columns"),
            commonColumnSettings = columnsController.getCommonSettings();
        return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
    },
    init: function() {
        var that = this;
        this.callBase();
        this._controller = this.getController("draggingHeader");
        this._columnsResizerViewController = this.getController("columnsResizer");
        this.getController("data").loadingChanged.add(function(isLoading) {
            var element = that.element();
            if (!isLoading && element && "none" !== element.css("display")) {
                element.hide()
            }
        })
    },
    dragHeader: function(options) {
        var that = this,
            columnElement = options.columnElement;
        that._isDragging = true;
        that._dragOptions = options;
        that._dropOptions = {
            sourceIndex: options.index,
            sourceColumnIndex: that._getVisibleIndexObject(options.rowIndex, options.columnIndex),
            sourceColumnElement: options.columnElement,
            sourceLocation: options.sourceLocation
        };
        that._onSelectStart = document.onselectstart;
        document.onselectstart = function() {
            return false
        };
        that.element().css({
            textAlign: columnElement && columnElement.css("text-align"),
            height: columnElement && columnElement.height(),
            width: columnElement && columnElement.width(),
            whiteSpace: columnElement && columnElement.css("white-space")
        }).addClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS)).text(options.sourceColumn.caption);
        that.element().appendTo($(document.body))
    },
    moveHeader: function(args) {
        var newLeft, newTop, moveDeltaX, moveDeltaY, e = args.jQueryEvent,
            that = e.data.that,
            eventData = eventUtils.eventData(e),
            isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false,
            dragOptions = that._dragOptions;
        if (that._isDragging && !isResizing) {
            moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
            moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
            if (that.element().is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                that.element().show();
                newLeft = eventData.x - dragOptions.deltaX;
                newTop = eventData.y - dragOptions.deltaY;
                that.element().offset({
                    left: newLeft,
                    top: newTop
                });
                that.dockHeader(eventData)
            }
            e.preventDefault()
        }
    },
    dockHeader: function(eventData) {
        var i, centerPosition, that = this,
            targetDraggingPanel = that._getDraggingPanelByPos(eventData),
            controller = that._controller,
            params = that._dropOptions;
        if (targetDraggingPanel) {
            var rtlEnabled = that.option("rtlEnabled"),
                isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName(),
                axisName = isVerticalOrientation ? "y" : "x",
                targetLocation = targetDraggingPanel.getName(),
                rowIndex = "headers" === targetLocation ? that._dragOptions.rowIndex : void 0,
                sourceColumn = that._dragOptions.sourceColumn,
                columnElements = targetDraggingPanel.getColumnElements(rowIndex, sourceColumn && sourceColumn.ownerBand) || [],
                pointsByColumns = controller._generatePointsByColumns(extend({}, that._dragOptions, {
                    targetDraggingPanel: targetDraggingPanel,
                    columns: targetDraggingPanel.getColumns(rowIndex),
                    columnElements: columnElements,
                    isVerticalOrientation: isVerticalOrientation,
                    startColumnIndex: "headers" === targetLocation && $(columnElements[0]).index()
                }));
            params.targetLocation = targetLocation;
            if (pointsByColumns.length > 0) {
                for (i = 0; i < pointsByColumns.length; i++) {
                    centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                    if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                        params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
                        if (columnElements[i]) {
                            params.targetColumnElement = columnElements.eq(i);
                            params.isLast = false
                        } else {
                            params.targetColumnElement = columnElements.last();
                            params.isLast = true
                        }
                        params.posX = pointsByColumns[i].x;
                        params.posY = pointsByColumns[i].y;
                        controller.dock(params);
                        break
                    }
                }
            } else {
                that._resetTargetColumnOptions();
                controller.dock(params)
            }
        }
    },
    dropHeader: function(args) {
        var e = args.jQueryEvent,
            that = e.data.that,
            controller = that._controller;
        that.element().hide();
        if (controller && that._isDragging) {
            controller.drop(that._dropOptions)
        }
        that.element().appendTo(that._parentElement());
        that._dragOptions = null;
        that._dropOptions = null;
        that._isDragging = false;
        document.onselectstart = that._onSelectStart || null
    }
});
var isNextColumnResizingMode = function(that) {
    return "widget" !== that.option("columnResizingMode")
};
var ColumnsResizerViewController = modules.ViewController.inherit({
    _isHeadersRowArea: function(posY) {
        if (this._columnHeadersView) {
            var headersRowHeight, offsetTop, element = this._columnHeadersView.element();
            if (element) {
                offsetTop = element.offset().top;
                headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
                return posY >= offsetTop && posY <= offsetTop + headersRowHeight
            }
        }
        return false
    },
    _pointCreated: function(point, cellsLength, columns) {
        var currentColumn, nextColumn, isNextColumnMode = isNextColumnResizingMode(this),
            rtlEnabled = this.option("rtlEnabled"),
            firstPointColumnIndex = !isNextColumnMode && rtlEnabled ? 0 : 1;
        if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && !rtlEnabled ? 1 : 0)) {
            point.columnIndex -= firstPointColumnIndex;
            currentColumn = columns[point.columnIndex] || {};
            nextColumn = columns[point.columnIndex + 1] || {};
            return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing)
        }
        return true
    },
    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
        if (pointsByColumns) {
            for (var i = 0; i < pointsByColumns.length; i++) {
                if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
                    continue
                }
                if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
                    return pointsByColumns[i]
                }
            }
        }
        return null
    },
    _moveSeparator: function(args) {
        var e = args.jQueryEvent,
            that = e.data,
            columnsSeparatorWidth = that._columnsSeparatorView.width(),
            columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
            isNextColumnMode = isNextColumnResizingMode(that),
            deltaX = columnsSeparatorWidth / 2,
            parentOffset = that._$parentContainer.offset(),
            parentOffsetLeft = parentOffset.left,
            eventData = eventUtils.eventData(e);
        if (that._isResizing) {
            if (parentOffsetLeft <= eventData.x && (!isNextColumnMode || eventData.x <= parentOffsetLeft + that._$parentContainer.width())) {
                if (that._updateColumnsWidthIfNeeded(eventData.x)) {
                    var $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
                    that._columnsSeparatorView.moveByX($cell.offset().left + (isNextColumnMode && that.option("rtlEnabled") ? 0 : $cell.outerWidth()));
                    that._tablePositionController.update(that._targetPoint.y);
                    e.preventDefault()
                }
            }
        } else {
            if (that._isHeadersRowArea(eventData.y)) {
                if (that._previousParentOffset) {
                    if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
                        that.pointsByColumns(null)
                    }
                }
                that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, columnsSeparatorWidth);
                that._previousParentOffset = parentOffset;
                that._isReadyResizing = false;
                if (that._targetPoint && that._targetPoint.y <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
                    that._columnsSeparatorView.changeCursor("col-resize");
                    that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                    that._tablePositionController.update(that._targetPoint.y);
                    that._isReadyResizing = true;
                    e.preventDefault()
                } else {
                    that._columnsSeparatorView.changeCursor()
                }
            } else {
                that.pointsByColumns(null);
                that._isReadyResizing = false;
                that._columnsSeparatorView.changeCursor()
            }
        }
    },
    _endResizing: function(args) {
        var e = args.jQueryEvent,
            that = e.data;
        if (that._isResizing) {
            that.pointsByColumns(null);
            that._resizingInfo = null;
            that._columnsSeparatorView.hide();
            that._columnsSeparatorView.changeCursor();
            that._trackerView.hide();
            that._isReadyResizing = false;
            that._isResizing = false
        }
    },
    _getNextColumnIndex: function(currentColumnIndex) {
        return currentColumnIndex + 1
    },
    _setupResizingInfo: function(posX) {
        var that = this,
            currentColumnIndex = that._targetPoint.columnIndex,
            nextColumnIndex = that._getNextColumnIndex(currentColumnIndex),
            currentHeader = that._columnHeadersView.getHeaderElement(currentColumnIndex),
            nextHeader = that._columnHeadersView.getHeaderElement(nextColumnIndex);
        that._resizingInfo = {
            startPosX: posX,
            currentColumnIndex: currentColumnIndex,
            currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
            nextColumnIndex: nextColumnIndex,
            nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
        }
    },
    _startResizing: function(args) {
        var e = args.jQueryEvent,
            that = e.data,
            eventData = eventUtils.eventData(e),
            editingController = that.getController("editing"),
            editingMode = that.option("editing.mode"),
            isCellEditing = editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
        if (eventUtils.isTouchEvent(e)) {
            if (that._isHeadersRowArea(eventData.y)) {
                that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                if (that._targetPoint) {
                    that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                    that._isReadyResizing = true
                }
            } else {
                that._isReadyResizing = false
            }
        }
        if (that._isReadyResizing && !isCellEditing) {
            that._setupResizingInfo(eventData.x);
            that._tablePositionController.update(that._targetPoint.y);
            that._columnsSeparatorView.show();
            that._trackerView.show();
            that._isResizing = true;
            e.preventDefault();
            e.stopPropagation()
        }
    },
    _generatePointsByColumns: function() {
        var that = this,
            columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
            cells = that._columnHeadersView.getColumnElements(),
            pointsByColumns = [];
        if (cells && cells.length > 0) {
            pointsByColumns = gridCoreUtils.getPointsByColumns(cells, function(point) {
                return that._pointCreated(point, cells.length, columns)
            })
        }
        that._pointsByColumns = pointsByColumns
    },
    _unsubscribeFromEvents: function() {
        this._moveSeparatorHandler && $(document).off(addNamespace(pointerEvents.move, MODULE_NAMESPACE), this._moveSeparatorHandler);
        this._startResizingHandler && this._$parentContainer.off(addNamespace(pointerEvents.down, MODULE_NAMESPACE), this._startResizingHandler);
        if (this._endResizingHandler) {
            this._columnsSeparatorView.element().off(addNamespace(pointerEvents.up, MODULE_NAMESPACE), this._endResizingHandler);
            $(document).off(addNamespace(pointerEvents.up, MODULE_NAMESPACE), this._endResizingHandler)
        }
    },
    _subscribeToEvents: function() {
        this._moveSeparatorHandler = this.createAction(this._moveSeparator);
        this._startResizingHandler = this.createAction(this._startResizing);
        this._endResizingHandler = this.createAction(this._endResizing);
        $(document).on(addNamespace(pointerEvents.move, MODULE_NAMESPACE), this, this._moveSeparatorHandler);
        this._$parentContainer.on(addNamespace(pointerEvents.down, MODULE_NAMESPACE), this, this._startResizingHandler);
        this._columnsSeparatorView.element().on(addNamespace(pointerEvents.up, MODULE_NAMESPACE), this, this._endResizingHandler);
        $(document).on(addNamespace(pointerEvents.up, MODULE_NAMESPACE), this, this._endResizingHandler)
    },
    _updateColumnsWidthIfNeeded: function(posX) {
        var deltaX, nextCellWidth, column, minWidth, nextColumn, cellWidth, needUpdate = false,
            columnsController = this._columnsController,
            visibleColumns = columnsController.getVisibleColumns(),
            columnsSeparatorWidth = this._columnsSeparatorView.width(),
            contentWidth = this._rowsView.contentWidth(),
            isNextColumnMode = isNextColumnResizingMode(this),
            adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");

        function setColumnWidth(column, columnWidth, contentWidth, adaptColumnWidthByRatio) {
            if (column) {
                var oldColumnWidth = column.width;
                if (oldColumnWidth) {
                    adaptColumnWidthByRatio = commonUtils.isString(oldColumnWidth) && "%" === oldColumnWidth.slice(-1)
                }
                if (adaptColumnWidthByRatio) {
                    column && columnsController.columnOption(column.index, "visibleWidth", columnWidth);
                    column && columnsController.columnOption(column.index, "width", (columnWidth / contentWidth * 100).toFixed(3) + "%")
                } else {
                    column && columnsController.columnOption(column.index, "visibleWidth", void 0);
                    column && columnsController.columnOption(column.index, "width", columnWidth)
                }
            }
        }
        deltaX = posX - this._resizingInfo.startPosX;
        if (isNextColumnMode && this.option("rtlEnabled")) {
            deltaX = -deltaX
        }
        cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
        column = visibleColumns[this._resizingInfo.currentColumnIndex];
        minWidth = column && column.minWidth || columnsSeparatorWidth;
        needUpdate = cellWidth >= minWidth;
        if (isNextColumnMode) {
            nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
            nextColumn = visibleColumns[this._resizingInfo.nextColumnIndex];
            minWidth = nextColumn && nextColumn.minWidth || columnsSeparatorWidth;
            needUpdate = needUpdate && nextCellWidth >= minWidth
        }
        if (needUpdate) {
            columnsController.beginUpdate();
            cellWidth = Math.floor(cellWidth);
            setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
            if (isNextColumnMode) {
                nextCellWidth = Math.floor(nextCellWidth);
                setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio)
            } else {
                var columnWidths = this._columnHeadersView.getColumnWidths();
                for (var i = 0; i < columnWidths.length; i++) {
                    if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
                        columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i])
                    }
                }
            }
            columnsController.endUpdate();
            if (!isNextColumnMode) {
                this.component.updateDimensions()
            }
        }
        return needUpdate
    },
    _subscribeToCallback: function(callback, handler) {
        callback.add(handler);
        this._subscribesToCallbacks.push({
            callback: callback,
            handler: handler
        })
    },
    _unsubscribeFromCallbacks: function() {
        var i, subscribe;
        for (i = 0; i < this._subscribesToCallbacks.length; i++) {
            subscribe = this._subscribesToCallbacks[i];
            subscribe.callback.remove(subscribe.handler)
        }
        this._subscribesToCallbacks = []
    },
    _unsubscribes: function() {
        this._unsubscribeFromEvents();
        this._unsubscribeFromCallbacks()
    },
    _init: function() {
        var that = this,
            generatePointsByColumnsHandler = function() {
                if (!that._isResizing) {
                    that.pointsByColumns(null)
                }
            },
            generatePointsByColumnsScrollHandler = function(offset) {
                if (that._scrollLeft !== offset.left) {
                    that._scrollLeft = offset.left;
                    that.pointsByColumns(null)
                }
            };
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._trackerView = that.getView("trackerView");
        that._rowsView = that.getView("rowsView");
        that._columnsController = that.getController("columns");
        that._tablePositionController = that.getController("tablePosition");
        that._$parentContainer = that._columnsSeparatorView.component.element();
        that._subscribeToCallback(that._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnsSeparatorView.renderCompleted, function() {
            that._unsubscribeFromEvents();
            that._subscribeToEvents()
        });
        that._subscribeToCallback(that._rowsView.renderCompleted, function() {
            that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
            that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
        });
        var previousScrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
        var previousTableHeight = 0;
        that._subscribeToCallback(that.getController("tablePosition").positionChanged, function(e) {
            if (that._isResizing && !that._rowsView.isResizing) {
                var scrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
                if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
                    previousScrollbarVisibility = scrollbarVisibility;
                    previousTableHeight = e.height;
                    that.component.updateDimensions()
                } else {
                    that._rowsView.updateFreeSpaceRowHeight()
                }
            }
            previousTableHeight = e.height
        })
    },
    optionChanged: function(args) {
        this.callBase(args);
        if ("allowColumnResizing" === args.name) {
            if (args.value) {
                this._init();
                this._subscribeToEvents()
            } else {
                this._unsubscribes()
            }
        }
    },
    isResizing: function() {
        return this._isResizing
    },
    init: function() {
        this._subscribesToCallbacks = [];
        if (allowResizing(this)) {
            this._init()
        }
    },
    pointsByColumns: function(value) {
        if (void 0 !== value) {
            this._pointsByColumns = value
        } else {
            if (!this._pointsByColumns) {
                this._generatePointsByColumns()
            }
            return this._pointsByColumns
        }
    },
    dispose: function() {
        this._unsubscribes();
        this.callBase()
    }
});
var TablePositionViewController = modules.ViewController.inherit({
    update: function(top) {
        var that = this,
            $element = that._columnHeadersView.element(),
            offset = $element && $element.offset(),
            offsetTop = offset && offset.top || 0,
            diffOffsetTop = commonUtils.isDefined(top) ? Math.abs(top - offsetTop) : 0,
            columnsHeadersHeight = that._columnHeadersView ? that._columnHeadersView.getHeight() : 0,
            rowsHeight = that._rowsView ? that._rowsView.height() - that._rowsView.getScrollbarWidth(true) : 0;
        that.positionChanged.fire({
            height: columnsHeadersHeight + rowsHeight - diffOffsetTop,
            top: $element && $element.length && $element[0].offsetTop + diffOffsetTop
        })
    },
    init: function() {
        var that = this;
        that.callBase();
        that._columnHeadersView = this.getView("columnHeadersView");
        that._rowsView = this.getView("rowsView");
        that._pagerView = this.getView("pagerView");
        that._rowsView.resizeCompleted.add(function() {
            that.update()
        })
    },
    ctor: function(component) {
        this.callBase(component);
        this.positionChanged = $.Callbacks()
    }
});
var DraggingHeaderViewController = modules.ViewController.inherit({
    _generatePointsByColumns: function(options) {
        var that = this;
        return gridCoreUtils.getPointsByColumns(options.columnElements, function(point) {
            return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
        }, options.isVerticalOrientation, options.startColumnIndex)
    },
    _pointCreated: function(point, columns, location, sourceColumn) {
        var targetColumn = columns[point.columnIndex],
            prevColumn = columns[point.columnIndex - 1];
        switch (location) {
            case "columnChooser":
                return true;
            case "headers":
                return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
            default:
                return 0 === columns.length
        }
    },
    _subscribeToEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        $.each(draggingPanels, function(_, draggingPanel) {
            if (draggingPanel) {
                var i, columns, columnElements, rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1,
                    nameDraggingPanel = draggingPanel.getName(),
                    subscribeToEvents = function(index, columnElement) {
                        var $columnElement = $(columnElement),
                            column = columns[index];
                        if (draggingPanel.allowDragging(columns[index], nameDraggingPanel, draggingPanels)) {
                            $columnElement.addClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS));
                            $columnElement.on(addNamespace(dragEvents.start, MODULE_NAMESPACE), that.createAction(function(args) {
                                var e = args.jQueryEvent,
                                    eventData = eventUtils.eventData(e);
                                draggingHeader.dragHeader({
                                    deltaX: eventData.x - $(e.currentTarget).offset().left,
                                    deltaY: eventData.y - $(e.currentTarget).offset().top,
                                    sourceColumn: column,
                                    index: column.index,
                                    columnIndex: index,
                                    columnElement: $columnElement,
                                    sourceLocation: nameDraggingPanel,
                                    draggingPanels: draggingPanels,
                                    rowIndex: that._columnsController.getRowIndex(column.index, true)
                                })
                            }));
                            $columnElement.on(addNamespace(dragEvents.move, MODULE_NAMESPACE), {
                                that: draggingHeader
                            }, that.createAction(draggingHeader.moveHeader));
                            $columnElement.on(addNamespace(dragEvents.end, MODULE_NAMESPACE), {
                                that: draggingHeader
                            }, that.createAction(draggingHeader.dropHeader))
                        }
                    };
                for (i = 0; i < rowCount; i++) {
                    columnElements = draggingPanel.getColumnElements(i) || [];
                    if (columnElements.length) {
                        columns = draggingPanel.getColumns(i) || [];
                        $.each(columnElements, subscribeToEvents)
                    }
                }
            }
        })
    },
    _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        $.each(draggingPanels, function(_, draggingPanel) {
            if (draggingPanel) {
                var columnElements = draggingPanel.getColumnElements() || [];
                $.each(columnElements, function(index, columnElement) {
                    var $columnElement = $(columnElement);
                    $columnElement.off(addNamespace(dragEvents.start, MODULE_NAMESPACE));
                    $columnElement.off(addNamespace(dragEvents.move, MODULE_NAMESPACE));
                    $columnElement.off(addNamespace(dragEvents.end, MODULE_NAMESPACE));
                    $columnElement.removeClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS))
                })
            }
        })
    },
    _getSeparator: function(targetLocation) {
        return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView
    },
    hideSeparators: function() {
        var blockSeparator = this._blockSeparatorView,
            columnsSeparator = this._columnsSeparatorView;
        this._animationColumnIndex = null;
        blockSeparator && blockSeparator.hide();
        columnsSeparator && columnsSeparator.hide()
    },
    init: function() {
        var subscribeToEvents, that = this;
        that.callBase();
        that._columnsController = that.getController("columns");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._draggingHeaderView = that.getView("draggingHeaderView");
        that._rowsView = that.getView("rowsView");
        that._blockSeparatorView = that.getView("blockSeparatorView");
        that._headerPanelView = that.getView("headerPanel");
        that._columnChooserView = that.getView("columnChooserView");
        subscribeToEvents = function() {
            if (that._draggingHeaderView) {
                var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
                that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
                that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
            }
        };
        that._columnHeadersView.renderCompleted.add(subscribeToEvents);
        that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
        that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
    },
    allowDrop: function(parameters) {
        return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
    },
    dock: function(parameters) {
        var that = this,
            targetColumnIndex = commonUtils.isObject(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex,
            sourceLocation = parameters.sourceLocation,
            sourceIndex = parameters.sourceIndex,
            sourceColumnElement = parameters.sourceColumnElement,
            targetLocation = parameters.targetLocation,
            separator = that._getSeparator(targetLocation),
            hasTargetVisibleIndex = targetColumnIndex >= 0;
        var showSeparator = function() {
            if (that._animationColumnIndex !== targetColumnIndex) {
                that.hideSeparators();
                separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                that._animationColumnIndex = targetColumnIndex;
                separator.show(targetLocation)
            }
        };
        that._columnHeadersView.element().find("." + HEADER_ROW_CLASS).toggleClass(that.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
        if (separator) {
            if (sourceColumnElement) {
                sourceColumnElement.css({
                    opacity: .5
                });
                if ("headers" === sourceLocation) {
                    that._columnHeadersView.setRowsOpacity(sourceIndex, .5);
                    that._rowsView.setRowsOpacity(sourceIndex, .5)
                }
            }
            if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
                if ("group" === targetLocation || "columnChooser" === targetLocation) {
                    showSeparator()
                } else {
                    that.hideSeparators();
                    that.getController("tablePosition").update(parameters.posY);
                    separator.moveByX(parameters.posX - separator.width());
                    separator.show()
                }
            } else {
                that.hideSeparators()
            }
        }
    },
    drop: function(parameters) {
        var sourceColumnElement = parameters.sourceColumnElement;
        if (sourceColumnElement) {
            sourceColumnElement.css({
                opacity: ""
            });
            this._columnHeadersView.setRowsOpacity(parameters.sourceIndex, "");
            this._rowsView.setRowsOpacity(parameters.sourceIndex, "");
            this._columnHeadersView.element().find("." + HEADER_ROW_CLASS).removeClass(this.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS))
        }
        if (this.allowDrop(parameters)) {
            var separator = this._getSeparator(parameters.targetLocation);
            if (separator) {
                separator.hide()
            }
            this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
        }
    },
    dispose: function() {
        if (this._draggingHeaderView) {
            this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
        }
    }
});
module.exports = {
    views: {
        columnsSeparatorView: ColumnsSeparatorView,
        blockSeparatorView: BlockSeparatorView,
        draggingHeaderView: DraggingHeaderView,
        trackerView: TrackerView
    },
    controllers: {
        draggingHeader: DraggingHeaderViewController,
        tablePosition: TablePositionViewController,
        columnsResizer: ColumnsResizerViewController
    }
};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.keyboard_navigation.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    core = __webpack_require__(23),
    commonUtils = __webpack_require__(2),
    inArray = __webpack_require__(7).inArray,
    KeyboardProcessor = __webpack_require__(112),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17);
var ROWS_VIEW_CLASS = "rowsview",
    EDIT_FORM_CLASS = "edit-form",
    GROUP_FOOTER_CLASS = "group-footer",
    ROW_CLASS = "dx-row",
    DATA_ROW_CLASS = "dx-data-row",
    GROUP_ROW_CLASS = "dx-group-row",
    EDIT_FORM_ITEM_CLASS = "edit-form-item",
    MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
    MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
    DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay",
    COMMAND_EXPAND_CLASS = "dx-command-expand",
    INTERACTIVE_ELEMENTS_SELECTOR = "input:not([type='hidden']), textarea, a, [tabindex]",
    VIEWS = ["rowsView"],
    EDIT_MODE_ROW = "row",
    EDIT_MODE_FORM = "form";

function isGroupRow($row) {
    return $row && $row.hasClass(GROUP_ROW_CLASS)
}

function isDetailRow($row) {
    return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS)
}

function isCellElement($element) {
    return $element.length && "TD" === $element[0].tagName
}
var KeyboardNavigationController = core.ViewController.inherit({
    _isRowEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_FORM
    },
    _focusView: function(view, viewIndex) {
        this._focusedViews.viewIndex = viewIndex;
        this._focusedView = view
    },
    _getInteractiveElement: function($cell, isLast) {
        var $focusedElement = $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
        return isLast ? $focusedElement.last() : $focusedElement.first()
    },
    _focusInteractiveElement: function($cell, isLast) {
        if (!$cell) {
            return
        }
        var $focusedElement = this._getInteractiveElement($cell, isLast);
        $focusedElement.focus()
    },
    _updateFocus: function() {
        var that = this,
            $cell = that._getFocusedCell();
        if ($cell && !(that._isMasterDetailCell($cell) && !that._isRowEditMode())) {
            if (that._hasSkipRow($cell.parent())) {
                $cell = that._getNextCell(this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow")
            }
            if ($cell && $cell.length > 0) {
                setTimeout(function() {
                    if ($cell.is("td") || $cell.hasClass(that.addWidgetPrefix(EDIT_FORM_ITEM_CLASS))) {
                        if (that.getController("editorFactory").focus()) {
                            that._focus($cell)
                        }
                        if (that._editingController.isEditing()) {
                            $.proxy(that._focusInteractiveElement, that)($cell)
                        }
                    } else {
                        $cell.focus()
                    }
                })
            }
        }
    },
    _applyTabIndexToElement: function($element) {
        var tabIndex = this.option("tabIndex");
        $element.attr("tabIndex", commonUtils.isDefined(tabIndex) ? tabIndex : 0)
    },
    _clickHandler: function(e) {
        var event = e.jQueryEvent,
            $cell = $(event.currentTarget),
            $grid = $(event.target).closest("." + this.getWidgetContainerClass()).parent(),
            data = event.data;
        if ($grid.is(this.component.element()) && this._isCellValid($cell)) {
            this._focusView(data.view, data.viewIndex);
            this._updateFocusedCellPosition($cell);
            if (!this._editingController.isEditing()) {
                this._applyTabIndexToElement(data.view.element());
                data.view.element().find(".dx-row > td[tabIndex]").attr("tabIndex", null);
                $cell.focus()
            }
        } else {
            this._resetFocusedCell()
        }
    },
    _initFocusedViews: function() {
        var that = this,
            clickAction = that.createAction(that._clickHandler);
        that._focusedViews = [];
        $.each(VIEWS, function(key, viewName) {
            var view = that.getView(viewName);
            if (view && view.isVisible()) {
                that._focusedViews.push(view)
            }
        });
        $.each(that._focusedViews, function(index, view) {
            if (view) {
                view.renderCompleted.add(function() {
                    var $element = view.element();
                    $element.off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), clickAction);
                    $element.on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), "." + ROW_CLASS + " td", {
                        viewIndex: index,
                        view: view
                    }, clickAction);
                    that._initKeyDownProcessor(that, $element, that._keyDownHandler);
                    if (that._focusedView && that._focusedView.name === view.name && that._isNeedFocus) {
                        that._updateFocus()
                    }
                })
            }
        })
    },
    _initKeyDownProcessor: function(context, element, handler) {
        if (this._keyDownProcessor) {
            this._keyDownProcessor.dispose();
            this._keyDownProcessor = null
        }
        this._keyDownProcessor = new KeyboardProcessor({
            element: element,
            context: context,
            handler: handler
        })
    },
    _getCell: function(cellPosition) {
        if (this._focusedView && cellPosition) {
            return this._focusedView.getCell({
                rowIndex: cellPosition.rowIndex - this._dataController.getRowIndexOffset(),
                columnIndex: cellPosition.columnIndex
            })
        }
    },
    _getFocusedCell: function() {
        return this._getCell(this._focusedCellPosition)
    },
    _getRowIndex: function($row) {
        var that = this,
            focusedView = that._focusedView,
            rowIndex = -1;
        if (focusedView) {
            rowIndex = focusedView.getRowIndex($row)
        }
        if (rowIndex >= 0) {
            rowIndex += that._dataController.getRowIndexOffset()
        }
        return rowIndex
    },
    _updateFocusedCellPosition: function($cell, direction) {
        var rowIndex, columnIndex, that = this,
            $rowElement = $cell.closest("tr");
        if ($rowElement.length > 0 && that._focusedView) {
            rowIndex = $rowElement.length > 0 && that._getRowIndex($rowElement);
            columnIndex = that._focusedView.getCellIndex($cell, rowIndex);
            if (direction) {
                columnIndex = "previous" === direction ? columnIndex - 1 : columnIndex + 1;
                columnIndex = that._applyColumnIndexBoundaries(columnIndex)
            }
            this._focusedCellPosition = {
                columnIndex: columnIndex,
                rowIndex: rowIndex
            }
        }
    },
    _applyColumnIndexBoundaries: function(columnIndex) {
        var visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < 0) {
            columnIndex = 0
        } else {
            if (columnIndex >= visibleColumnsCount) {
                columnIndex = visibleColumnsCount - 1
            }
        }
        return columnIndex
    },
    _isCellValid: function($cell) {
        if (commonUtils.isDefined($cell)) {
            var rowsView = this.getView("rowsView"),
                visibleColumns = this._columnsController.getVisibleColumns(),
                visibleRowIndex = rowsView.getRowIndex($cell.parent()),
                columnIndex = rowsView.getCellIndex($cell),
                column = visibleColumns[columnIndex],
                visibleColumnCount = this._getVisibleColumnCount(),
                editingController = this._editingController,
                editMode = editingController && editingController.getEditMode(),
                isEditingCurrentRow = editingController && (editMode === EDIT_MODE_ROW ? editingController.isEditRow(visibleRowIndex) : editingController.isEditing()),
                isMasterDetailRow = isDetailRow($cell.parent()),
                isValidGroupSpaceColumn = function() {
                    return !isMasterDetailRow && column && !commonUtils.isDefined(column.groupIndex) || parseInt($cell.attr("colspan")) > 1
                };
            if (this._isMasterDetailCell($cell)) {
                return true
            }
            if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
                var isExpandColumn = "expand" === column.command;
                return column && !column.command && (!isEditingCurrentRow || column.allowEditing) || !isEditingCurrentRow && isExpandColumn
            }
        }
    },
    _isCellByPositionValid: function(cellPosition) {
        var $cell = this._getCell(cellPosition);
        return this._isCellValid($cell)
    },
    _focus: function($cell) {
        var $focusElement, $row = $cell.parent(),
            $focusedCell = this._getFocusedCell(),
            focusedView = this._focusedView;
        $focusedCell && $focusedCell.is("td") && $focusedCell.attr("tabIndex", null);
        if (isGroupRow($row)) {
            $focusElement = $row;
            if (focusedView) {
                this._focusedCellPosition.rowIndex = this._getRowIndex($row)
            }
        } else {
            if (isCellElement($cell)) {
                $focusElement = $cell;
                this._updateFocusedCellPosition($cell)
            }
        }
        focusedView && focusedView.element().attr("tabIndex", null);
        if ($focusElement) {
            this._applyTabIndexToElement($focusElement);
            $focusElement.focus()
        }
        this.getController("editorFactory").focus($focusElement)
    },
    _hasSkipRow: function($row) {
        return $row && ("none" === $row.css("display") || $row.hasClass(this.addWidgetPrefix(GROUP_FOOTER_CLASS)) || isDetailRow($row) && !$row.hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS)))
    },
    _enterKeyHandler: function(eventArgs, isEditing) {
        var $cell = this._getFocusedCell(),
            editingOptions = this.option("editing"),
            rowIndex = this._getFocusedRowIndex(),
            $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (this.option("grouping.allowCollapsing") && isGroupRow($row) || this.option("masterDetail.enabled") && $cell && $cell.hasClass(COMMAND_EXPAND_CLASS)) {
            var key = this._dataController.getKeyByRowIndex(rowIndex),
                item = this._dataController.items()[rowIndex];
            if (void 0 !== key && item && item.data && !item.data.isContinuation) {
                this._dataController.changeRowExpand(key)
            }
        } else {
            if (isEditing) {
                $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
                this._updateFocusedCellPosition($cell);
                if (this._isRowEditMode()) {
                    this._focusEditFormCell($cell);
                    setTimeout(this._editingController.saveEditData.bind(this._editingController))
                } else {
                    $(eventArgs.originalEvent.target).blur().focus();
                    this._editingController.closeEditCell()
                }
                eventArgs.originalEvent.preventDefault()
            } else {
                var column = this._columnsController.getVisibleColumns()[this._focusedCellPosition.columnIndex];
                if (editingOptions.allowUpdating && column && column.allowEditing) {
                    if (this._isRowEditMode()) {
                        this._editingController.editRow(rowIndex)
                    } else {
                        this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
                    }
                }
            }
        }
    },
    _getFocusedRowIndex: function() {
        if (this._focusedCellPosition) {
            return this._focusedCellPosition.rowIndex - this._dataController.getRowIndexOffset()
        }
        return null
    },
    _leftRightKeysHandler: function(eventArgs, isEditing) {
        var key, directionCode, $cell, rowIndex = this._getFocusedRowIndex(),
            $row = this._focusedView && this._focusedView.getRow(rowIndex),
            dataController = this._dataController;
        if (eventArgs.ctrl) {
            directionCode = this._getDirectionCodeByKey(eventArgs.key);
            key = dataController.getKeyByRowIndex(rowIndex);
            if ("nextInRow" === directionCode) {
                dataController.expandRow(key)
            } else {
                dataController.collapseRow(key)
            }
        } else {
            if (!isEditing && $row && !isGroupRow($row) && !isDetailRow($row)) {
                directionCode = this._getDirectionCodeByKey(eventArgs.key);
                $cell = this._getNextCell(directionCode);
                if ($cell && this._isCellValid($cell)) {
                    this._focus($cell)
                }
                eventArgs.originalEvent.preventDefault()
            }
        }
    },
    _getDirectionCodeByKey: function(key) {
        var directionCode;
        if (this.option("rtlEnabled")) {
            directionCode = "leftArrow" === key ? "nextInRow" : "previousInRow"
        } else {
            directionCode = "leftArrow" === key ? "previousInRow" : "nextInRow"
        }
        return directionCode
    },
    _upDownKeysHandler: function(eventArgs, isEditing) {
        var $cell, rowIndex = this._getFocusedRowIndex(),
            $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (!isEditing && !isDetailRow($row)) {
            $cell = this._getNextCell(eventArgs.key);
            if ($cell && this._isCellValid($cell)) {
                this._focus($cell)
            }
            eventArgs.originalEvent.preventDefault()
        }
    },
    _isVirtualScrolling: function() {
        var scrollingMode = this.option("scrolling.mode");
        return "virtual" === scrollingMode || "infinite" === scrollingMode
    },
    _scrollBy: function(top) {
        var that = this,
            scrollable = this.getView("rowsView").getScrollable();
        if (that._focusedCellPosition) {
            var scrollHandler = function() {
                scrollable.off(scrollHandler);
                setTimeout(function() {
                    var columnIndex = that._focusedCellPosition.columnIndex;
                    var rowIndex = that.getView("rowsView").getTopVisibleItemIndex() + that._dataController.getRowIndexOffset();
                    that.getController("editorFactory").loseFocus();
                    var $rowsView = that.getView("rowsView").element();
                    that._applyTabIndexToElement($rowsView);
                    $rowsView.focus();
                    that._focusedCellPosition.rowIndex = rowIndex;
                    that._focusedCellPosition.columnIndex = columnIndex
                })
            };
            scrollable.on("scroll", scrollHandler)
        }
        scrollable.scrollBy({
            left: 0,
            top: top
        })
    },
    _pageUpDownKeyHandler: function(eventArgs) {
        var pageIndex = this._dataController.pageIndex(),
            pageCount = this._dataController.pageCount(),
            pagingEnabled = this.option("paging.enabled"),
            isPageUp = "pageUp" === eventArgs.key,
            pageStep = isPageUp ? -1 : 1,
            scrollable = this.getView("rowsView").getScrollable();
        if (pagingEnabled && !this._isVirtualScrolling()) {
            if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
                this._dataController.pageIndex(pageIndex + pageStep);
                eventArgs.originalEvent.preventDefault()
            }
        } else {
            if (scrollable && scrollable._container().height() < scrollable.content().height()) {
                this._scrollBy(scrollable._container().height() * pageStep);
                eventArgs.originalEvent.preventDefault()
            }
        }
    },
    _spaceKeyHandler: function(eventArgs, isEditing) {
        var rowIndex = this._getFocusedRowIndex(),
            $target = $(eventArgs.originalEvent && eventArgs.originalEvent.target);
        if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing && ($target.parent().hasClass(DATA_ROW_CLASS) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS)))) {
            this._selectionController.changeItemSelection(rowIndex, {
                shift: eventArgs.shift,
                control: eventArgs.ctrl
            });
            eventArgs.originalEvent.preventDefault()
        }
    },
    _ctrlAKeyHandler: function(eventArgs, isEditing) {
        if (!isEditing && eventArgs.ctrl && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
            this._selectionController.selectAll();
            eventArgs.originalEvent.preventDefault()
        }
    },
    _isInsideEditForm: function(element) {
        return $(element).closest("." + this.addWidgetPrefix(EDIT_FORM_CLASS)).length > 0
    },
    _isMasterDetailCell: function(element) {
        var $masterDetailCell = $(element).closest("." + MASTER_DETAIL_CELL_CLASS),
            $masterDetailGrid = $masterDetailCell.closest("." + this.getWidgetContainerClass()).parent();
        return $masterDetailCell.length && $masterDetailGrid.is(this.component.element())
    },
    _processNextCellInMasterDetail: function($nextCell) {
        if (!this._isInsideEditForm($nextCell) && $nextCell) {
            this._applyTabIndexToElement($nextCell)
        }
    },
    _handleTabKeyOnMasterDetailCell: function(target, direction) {
        if (this._isMasterDetailCell(target)) {
            this._updateFocusedCellPosition($(target), direction);
            var $nextCell = this._getNextCell(direction, "row");
            this._processNextCellInMasterDetail($nextCell);
            return true
        }
        return false
    },
    _tabKeyHandler: function(eventArgs, isEditing) {
        var $cell, editingOptions = this.option("editing"),
            direction = eventArgs.shift ? "previous" : "next",
            isOriginalHandlerRequired = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition),
            eventTarget = eventArgs.originalEvent.target;
        if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
            return
        }
        if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
            if ($(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
                this._resetFocusedCell()
            }
            if (isEditing) {
                var column, row, isEditingAllowed;
                this._updateFocusedCellPosition(this._getCellElementFromTarget(eventTarget));
                $cell = this._getNextCell(direction);
                if (this._handleTabKeyOnMasterDetailCell($cell, direction)) {
                    return
                }
                column = this._columnsController.getVisibleColumns()[this.getView("rowsView").getCellIndex($cell)];
                row = this._dataController.items()[this._getRowIndex($cell && $cell.parent())];
                isEditingAllowed = (editingOptions.allowUpdating || row && row.inserted) && column.allowEditing;
                if (!isEditingAllowed) {
                    this._editingController.closeEditCell()
                }
                if (this._focusCell($cell)) {
                    if (!this._isRowEditMode() && isEditingAllowed) {
                        this._editingController.editCell(this._getFocusedRowIndex(), this._focusedCellPosition.columnIndex)
                    } else {
                        this._focusInteractiveElement($cell, eventArgs.shift)
                    }
                }
            } else {
                $cell = $(eventTarget).closest(".dx-row > td");
                var $lastInteractiveElement = this._getInteractiveElement($cell, !eventArgs.shift);
                if ($lastInteractiveElement.length && eventTarget !== $lastInteractiveElement.get(0)) {
                    isOriginalHandlerRequired = true
                } else {
                    $cell = this._getNextCell(direction, this._getElementType(eventTarget));
                    this._focusCell($cell);
                    this._focusInteractiveElement($cell, eventArgs.shift)
                }
            }
        }
        if (isOriginalHandlerRequired) {
            this.getController("editorFactory").loseFocus();
            if (this._editingController.isEditing() && !this._isRowEditMode()) {
                this._resetFocusedCell();
                this._editingController.closeEditCell()
            }
        } else {
            eventArgs.originalEvent.preventDefault()
        }
    },
    _focusCell: function($cell) {
        if (this._isCellValid($cell)) {
            this._focus($cell);
            return true
        }
    },
    _getElementType: function(target) {
        return $(target).is("tr") ? "row" : "cell"
    },
    _focusEditFormCell: function($cell) {
        if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS)) {
            this.getController("editorFactory").focus($cell, true)
        }
    },
    _escapeKeyHandler: function(eventArgs, isEditing) {
        if (isEditing) {
            var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
            this._updateFocusedCellPosition($cell);
            if (!this._isRowEditMode()) {
                if ("cell" === this._editingController.getEditMode()) {
                    this._editingController.cancelEditData()
                } else {
                    this._editingController.closeEditCell()
                }
            } else {
                this._focusEditFormCell($cell);
                this._editingController.cancelEditData()
            }
            eventArgs.originalEvent.preventDefault()
        }
    },
    _ctrlFKeyHandler: function(eventArgs) {
        if (eventArgs.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
            this._headerPanel.focus();
            eventArgs.originalEvent.preventDefault()
        }
    },
    _keyDownHandler: function(e) {
        var isEditing = this._editingController.isEditing(),
            needStopPropagation = true,
            args = {
                handled: false,
                jQueryEvent: e.originalEvent
            };
        this.executeAction("onKeyDown", args);
        if (e.originalEvent.isDefaultPrevented()) {
            return
        }
        this._isNeedFocus = true;
        this._isNeedScroll = true;
        this._updateFocusedCellPosition(this._getCellElementFromTarget(args.jQueryEvent.target));
        if (!args.handled) {
            switch (e.key) {
                case "leftArrow":
                case "rightArrow":
                    this._leftRightKeysHandler(e, isEditing);
                    break;
                case "upArrow":
                case "downArrow":
                    this._upDownKeysHandler(e, isEditing);
                    break;
                case "pageUp":
                case "pageDown":
                    this._pageUpDownKeyHandler(e);
                    break;
                case "space":
                    this._spaceKeyHandler(e, isEditing);
                    break;
                case "A":
                    this._ctrlAKeyHandler(e, isEditing);
                    break;
                case "tab":
                    this._tabKeyHandler(e, isEditing);
                    break;
                case "enter":
                    this._enterKeyHandler(e, isEditing);
                    break;
                case "escape":
                    this._escapeKeyHandler(e, isEditing);
                    break;
                case "F":
                    this._ctrlFKeyHandler(e);
                    break;
                default:
                    this._isNeedFocus = false;
                    this._isNeedScroll = false;
                    needStopPropagation = false
            }
            if (needStopPropagation) {
                e.originalEvent.stopPropagation()
            }
        }
    },
    _isLastRow: function(rowIndex) {
        if (this._isVirtualScrolling()) {
            return rowIndex >= this._dataController.totalItemsCount() - 1
        }
        return rowIndex === this.getController("data").items().length - 1
    },
    _getNextCell: function(keyCode, elementType, cellPosition) {
        var rowIndex, newFocusedCellPosition, $cell, $row, focusedCellPosition = cellPosition || this._focusedCellPosition,
            includeCommandCells = inArray(keyCode, ["next", "previous"]) > -1,
            isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(focusedCellPosition) : this._isLastValidCell(focusedCellPosition);
        if (this._focusedView && focusedCellPosition) {
            newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
            $cell = this._getCell(newFocusedCellPosition);
            if (!this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
                $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition)
            }
            $row = $cell && $cell.parent();
            if (this._hasSkipRow($row)) {
                rowIndex = this._getRowIndex($row);
                if (!this._isLastRow(rowIndex)) {
                    $cell = this._getNextCell(keyCode, "row", {
                        columnIndex: focusedCellPosition.columnIndex,
                        rowIndex: rowIndex
                    })
                } else {
                    return null
                }
            }
            return $cell
        }
        return null
    },
    _getNewPositionByCode: function(cellPosition, elementType, code) {
        var visibleColumnsCount, columnIndex = cellPosition.columnIndex,
            rowIndex = cellPosition.rowIndex;
        if (void 0 === cellPosition.rowIndex && "next" === code) {
            return {
                columnIndex: 0,
                rowIndex: 0
            }
        }
        switch (code) {
            case "nextInRow":
            case "next":
                visibleColumnsCount = this._getVisibleColumnCount();
                if (columnIndex < visibleColumnsCount - 1 && !this._isLastValidCell({
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    }) && "row" !== elementType) {
                    columnIndex++
                } else {
                    if (!this._isLastRow(rowIndex) && "next" === code) {
                        columnIndex = 0;
                        rowIndex++
                    }
                }
                break;
            case "previousInRow":
            case "previous":
                if (columnIndex > 0 && !this._isFirstValidCell({
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    }) && "row" !== elementType) {
                    columnIndex--
                } else {
                    if (rowIndex > 0 && "previous" === code) {
                        rowIndex--;
                        visibleColumnsCount = this._getVisibleColumnCount();
                        columnIndex = visibleColumnsCount - 1
                    }
                }
                break;
            case "upArrow":
                rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                break;
            case "downArrow":
                rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex
        }
        return {
            columnIndex: columnIndex,
            rowIndex: rowIndex
        }
    },
    _isFirstValidCell: function(cellPosition) {
        var isFirstValidCell = false;
        if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
            isFirstValidCell = isFirstValidCell || !this._haveValidCellBeforePosition(cellPosition)
        }
        return isFirstValidCell
    },
    _haveValidCellBeforePosition: function(cellPosition) {
        var columnIndex = cellPosition.columnIndex,
            hasValidCells = false;
        while (columnIndex > 0 && !hasValidCells) {
            var checkingPosition = {
                columnIndex: --columnIndex,
                rowIndex: cellPosition.rowIndex
            };
            hasValidCells = this._isCellByPositionValid(checkingPosition)
        }
        return hasValidCells
    },
    _isLastValidCell: function(cellPosition) {
        var checkingPosition = {
                columnIndex: cellPosition.columnIndex + 1,
                rowIndex: cellPosition.rowIndex
            },
            visibleColumnsCount = this._getVisibleColumnCount(),
            isCheckingCellValid = this._isCellByPositionValid(checkingPosition);
        if (!this._isLastRow(cellPosition.rowIndex)) {
            return false
        }
        if (cellPosition.columnIndex === visibleColumnsCount - 1) {
            return true
        }
        if (isCheckingCellValid) {
            return false
        }
        return this._isLastValidCell(checkingPosition)
    },
    _getVisibleColumnCount: function() {
        return this.getController("columns").getVisibleColumns().length
    },
    _isCellInRow: function(cellPosition, includeCommandCells) {
        var columnIndex = cellPosition.columnIndex,
            visibleColumnsCount = this._getVisibleColumnCount();
        return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
    },
    _resetFocusedCell: function() {
        var that = this,
            $cell = that._getFocusedCell();
        $cell && $cell.attr("tabIndex", null);
        that._focusedView && that._focusedView.renderFocusState && that._focusedView.renderFocusState();
        that._isNeedFocus = false;
        that._isNeedScroll = false;
        that._focusedCellPosition = {}
    },
    _getCellElementFromTarget: function(target) {
        return $(target).closest("." + ROW_CLASS + "> td")
    },
    init: function() {
        var that = this;
        if (that.option("useKeyboard")) {
            that._dataController = that.getController("data");
            that._selectionController = that.getController("selection");
            that._editingController = that.getController("editing");
            that._headerPanel = that.getView("headerPanel");
            that._columnsController = that.getController("columns");
            that.getController("editorFactory").focused.add(function($element) {
                that.setupFocusedView();
                if (that._isNeedScroll) {
                    if ($element.is(":visible") && that._focusedView && that._focusedView.getScrollable) {
                        that._scrollToElement($element);
                        that._isNeedScroll = false
                    }
                }
            });
            that._focusedCellPosition = {};
            that._initFocusedViews();
            that._documentClickHandler = that.createAction(function(e) {
                var $target = $(e.jQueryEvent.target);
                if (!$target.closest("." + that.addWidgetPrefix(ROWS_VIEW_CLASS)).length && !$target.closest("." + DROPDOWN_EDITOR_OVERLAY_CLASS).length) {
                    that._resetFocusedCell()
                }
            });
            that.createAction("onKeyDown");
            $(document).on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), that._documentClickHandler)
        }
    },
    _scrollToElement: function($element, offset) {
        var scrollable = this._focusedView.getScrollable();
        scrollable && scrollable.scrollToElement($element, offset)
    },
    focus: function($element) {
        var focusView = this._getFocusedViewByElement($element);
        if (focusView) {
            this._focusView(focusView.view, focusView.viewIndex);
            this._isNeedFocus = true;
            this._isNeedScroll = true;
            this._focus($element);
            this._focusInteractiveElement($element)
        }
    },
    getFocusedView: function() {
        return this._focusedView
    },
    _getFocusedViewByElement: function($element) {
        var condition = function(view) {
            return $element.closest(view._$element).length
        };
        return this._getFocusedViewByCondition(condition)
    },
    _getFocusedViewByCondition: function(conditionFunction) {
        var focusView;
        $.each(this._focusedViews, function(index, view) {
            if (conditionFunction(view)) {
                focusView = {
                    viewIndex: index,
                    view: view
                };
                return false
            }
        });
        return focusView
    },
    focusViewByName: function(viewName) {
        var view = this._getFocusedViewByName(viewName);
        this._focusView(view.view, view.viewIndex)
    },
    setupFocusedView: function() {
        if (this.option("useKeyboard") && !commonUtils.isDefined(this._focusedView)) {
            this.focusViewByName("rowsView")
        }
    },
    _getFocusedViewByName: function(viewName) {
        var condition = function(view) {
            return view.name === viewName
        };
        return this._getFocusedViewByCondition(condition)
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "useKeyboard":
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    },
    dispose: function() {
        this.callBase();
        this._focusedView = null;
        this._focusedViews = null;
        this._keyDownProcessor && this._keyDownProcessor.dispose();
        $(document).off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler)
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            useKeyboard: true
        }
    },
    controllers: {
        keyboardNavigation: KeyboardNavigationController
    },
    extenders: {
        views: {
            rowsView: {
                renderFocusState: function() {
                    var $row, $cell, that = this,
                        cellElements = that.getCellElements(0),
                        keyboardNavigation = that.getController("keyboardNavigation"),
                        tabIndex = that.option("tabIndex"),
                        oldFocusedView = keyboardNavigation._focusedView,
                        $element = that.element();
                    if ($element && !$element.is(":focus")) {
                        $element.attr("tabIndex", null)
                    }
                    if (that.option("useKeyboard") && cellElements) {
                        $row = cellElements.eq(0).parent();
                        if (isGroupRow($row)) {
                            $row.attr("tabIndex", tabIndex)
                        } else {
                            keyboardNavigation._focusedView = that;
                            for (var i = 0; i < cellElements.length; i++) {
                                $cell = cellElements.eq(i);
                                if (keyboardNavigation._isCellValid($cell)) {
                                    if (isCellElement($cell)) {
                                        $cell.attr("tabIndex", tabIndex)
                                    }
                                    break
                                }
                            }
                            keyboardNavigation._focusedView = oldFocusedView
                        }
                    }
                },
                renderDelayedTemplates: function() {
                    this.callBase.apply(this, arguments);
                    this.renderFocusState()
                },
                _renderCore: function(change) {
                    this.callBase(change);
                    this.renderFocusState()
                }
            }
        },
        controllers: {
            editing: {
                editCell: function(rowIndex, columnIndex) {
                    var isCellEditing = this.callBase(rowIndex, columnIndex),
                        keyboardNavigationController = this.getController("keyboardNavigation");
                    if (isCellEditing) {
                        keyboardNavigationController.setupFocusedView()
                    }
                    return isCellEditing
                },
                addRow: function(parentKey) {
                    this.getController("keyboardNavigation").setupFocusedView();
                    this.callBase.apply(this, arguments)
                },
                getFocusedCellInRow: function(rowIndex) {
                    var keyboardNavigationController = this.getController("keyboardNavigation"),
                        $cell = this.callBase(rowIndex);
                    if (this.option("useKeyboard") && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex) {
                        $cell = keyboardNavigationController._getFocusedCell() || $cell
                    }
                    return $cell
                }
            }
        }
    }
};


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_fixing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    browser = __webpack_require__(21),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    wheelEvent = __webpack_require__(137),
    messageLocalization = __webpack_require__(8),
    gridCoreUtils = __webpack_require__(26);
var CONTENT_CLASS = "content",
    CONTENT_FIXED_CLASS = "content-fixed",
    MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
    FIRST_CELL_CLASS = "dx-first-cell",
    LAST_CELL_CLASS = "dx-last-cell",
    HOVER_STATE_CLASS = "dx-state-hover",
    FIXED_COL_CLASS = "dx-col-fixed",
    POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
    POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
    getTransparentColumnIndex = function(fixedColumns) {
        var transparentColumnIndex = -1;
        $.each(fixedColumns, function(index, column) {
            if ("transparent" === column.command) {
                transparentColumnIndex = index;
                return false
            }
        });
        return transparentColumnIndex
    },
    normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
        var i, fixedColumnIndex = 0;
        if (fixedColumns && widths && fixedWidths) {
            for (i = 0; i < fixedColumns.length; i++) {
                if ("transparent" === fixedColumns[i].command) {
                    fixedColumnIndex += fixedColumns[i].colspan
                } else {
                    if (widths[fixedColumnIndex] < fixedWidths[i]) {
                        widths[fixedColumnIndex] = fixedWidths[i]
                    }
                    fixedColumnIndex++
                }
            }
        }
        return widths
    };
var baseFixedColumns = {
    init: function() {
        this.callBase();
        this._isFixedTableRendering = false;
        this._isFixedColumns = false
    },
    _createCol: function(column) {
        return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && "transparent" !== column.command)))
    },
    _renderTable: function(options) {
        var $fixedTable, $table, that = this,
            fixedColumns = that.getFixedColumns();
        that._isFixedColumns = !!fixedColumns.length;
        $table = that.callBase(options);
        if (that._isFixedColumns) {
            that._isFixedTableRendering = true;
            $fixedTable = that._createTable(fixedColumns);
            that._renderRows($fixedTable, extend({}, options, {
                columns: fixedColumns
            }));
            that._updateContent($fixedTable, options && options.change);
            that._isFixedTableRendering = false
        } else {
            that._fixedTableElement && that._fixedTableElement.remove();
            that._fixedTableElement = null
        }
        return $table
    },
    _createCell: function(options) {
        var fixedColumns, prevFixedColumn, transparentColumnIndex, that = this,
            column = options.column,
            columnCommand = column && column.command,
            rowType = options.rowType,
            $cell = that.callBase.apply(that, arguments);
        if (that._isFixedTableRendering || "filter" === rowType) {
            fixedColumns = that.getFixedColumns();
            transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
            prevFixedColumn = fixedColumns[transparentColumnIndex - 1]
        }
        if (that._isFixedTableRendering) {
            if ("transparent" === columnCommand) {
                $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1).html("freeSpace" !== rowType ? "&nbsp;" : "")
            }
        } else {
            if ("filter" === rowType) {
                $cell.toggleClass(FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex)
            }
        }
        return $cell
    },
    _wrapTableInScrollContainer: function() {
        var $scrollContainer = this.callBase.apply(this, arguments);
        if (this._isFixedTableRendering) {
            $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS) + " " + POINTER_EVENTS_TARGET_CLASS)
        }
        return $scrollContainer
    },
    _renderCellContent: function($cell, options) {
        var columns, isEmptyCell, transparentColumnIndex, alignByFixedColumnCellCount, that = this,
            column = options.column;
        if (!that._isFixedTableRendering && that._isFixedColumns) {
            isEmptyCell = column.fixed || column.command;
            if ("group" === options.rowType && commonUtils.isDefined(column.groupIndex)) {
                isEmptyCell = false;
                if (options.row.summaryCells && options.row.summaryCells.length) {
                    columns = that._columnsController.getVisibleColumns();
                    alignByFixedColumnCellCount = that._getAlignByColumnCellCount ? that._getAlignByColumnCellCount(column.colspan, {
                        columns: columns,
                        row: options.row,
                        isFixed: true
                    }) : 0;
                    if (alignByFixedColumnCellCount > 0) {
                        transparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
                        isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex
                    }
                }
            }
            if (isEmptyCell) {
                $cell.html("&nbsp;").addClass(column.cssClass);
                return
            }
        }
        if ("transparent" !== column.command) {
            that.callBase($cell, options)
        }
    },
    _getCellElementsCore: function(rowIndex) {
        var fixedColumns, fixedColumnIndex, fixedCellElements, that = this,
            cellElements = that.callBase(rowIndex),
            index = "columnHeadersView" === that.name ? rowIndex : void 0;
        if (that._fixedTableElement && cellElements) {
            fixedColumns = that.getFixedColumns(index);
            fixedCellElements = that._getRowElements(that._fixedTableElement).eq(rowIndex).children("td");
            $.each(fixedColumns, function(columnIndex, column) {
                if ("transparent" === column.command) {
                    if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS)) {
                        cellElements[columnIndex] = fixedCellElements.get(columnIndex) || cellElements[columnIndex]
                    }
                } else {
                    fixedColumnIndex = that._columnsController.getVisibleIndex(column.index, index);
                    cellElements[fixedColumnIndex] = fixedCellElements.get(columnIndex) || cellElements[fixedColumnIndex]
                }
            })
        }
        return cellElements
    },
    getColumnWidths: function() {
        var fixedWidths, that = this,
            result = that.callBase(),
            fixedColumns = that.getFixedColumns();
        if (that._fixedTableElement && result.length) {
            fixedWidths = that.callBase(that._fixedTableElement)
        }
        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
    },
    _getTableElement: function() {
        var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
        return tableElement
    },
    _setTableElement: function(tableElement) {
        if (this._isFixedTableRendering) {
            this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS)
        } else {
            this.callBase(tableElement)
        }
    },
    getColumns: function(rowIndex, $tableElement) {
        $tableElement = $tableElement || this._getTableElement();
        if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).length) {
            return this.getFixedColumns(rowIndex)
        }
        return this.callBase(rowIndex, $tableElement)
    },
    getRowIndex: function($row) {
        var $fixedTable = this._fixedTableElement;
        if ($fixedTable && $fixedTable.find($row).length) {
            return this._getRowElements($fixedTable).index($row)
        }
        return this.callBase($row)
    },
    getTableElements: function() {
        var result = this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
            result = result.add(this._fixedTableElement)
        }
        return result
    },
    getFixedColumns: function(rowIndex) {
        return this._columnsController.getFixedColumns(rowIndex)
    },
    getFixedColumnsOffset: function() {
        var $transparentColumn, positionTransparentColumn, offset = {
            left: 0,
            right: 0
        };
        if (this._fixedTableElement) {
            $transparentColumn = this.getTransparentColumnElement();
            positionTransparentColumn = $transparentColumn.position();
            offset = {
                left: positionTransparentColumn.left,
                right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
            }
        }
        return offset
    },
    getTransparentColumnElement: function() {
        return this._fixedTableElement && this._fixedTableElement.find("." + POINTER_EVENTS_NONE_CLASS).first()
    },
    getFixedTableElement: function() {
        return this._fixedTableElement
    },
    isFixedColumns: function() {
        return this._isFixedColumns
    },
    _resizeCore: function() {
        this.callBase();
        this.synchronizeRows()
    },
    setColumnWidths: function(widths) {
        var columns;
        this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
            if (widths && widths.length && !this.isScrollbarVisible(true)) {
                columns = this._columnsController.getVisibleColumns()
            }
            this.callBase(widths, this._fixedTableElement, columns)
        }
        this.synchronizeRows()
    },
    _getClientHeight: function(element) {
        var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();
        return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
    },
    synchronizeRows: function() {
        var rowHeight, fixedRowHeight, rowIndex, heightTable, heightFixedTable, $rowElements, $fixedRowElements, that = this,
            rowHeights = [],
            fixedRowHeights = [];
        if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
            heightTable = that._getClientHeight(that._tableElement.get(0));
            heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
            $rowElements = that._getRowElements(that._tableElement);
            $fixedRowElements = that._getRowElements(that._fixedTableElement);
            if (heightTable !== heightFixedTable) {
                $rowElements.css("height", "");
                $fixedRowElements.css("height", "");
                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                    rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));
                    fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)))
                }
                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                    rowHeight = rowHeights[rowIndex];
                    fixedRowHeight = fixedRowHeights[rowIndex];
                    if (rowHeight > fixedRowHeight) {
                        $fixedRowElements.eq(rowIndex).css("height", rowHeight)
                    } else {
                        if (rowHeight < fixedRowHeight) {
                            $rowElements.eq(rowIndex).css("height", fixedRowHeight)
                        }
                    }
                }
            }
        }
    }
};
var ColumnHeadersViewFixedColumnsExtender = extend({}, baseFixedColumns, {
    _getRowVisibleColumns: function(rowIndex) {
        if (this._isFixedTableRendering) {
            return this.getFixedColumns(rowIndex)
        }
        return this.callBase(rowIndex)
    },
    getContextMenuItems: function(options) {
        var onItemClick, that = this,
            column = options.column,
            columnFixingOptions = that.option("columnFixing"),
            items = that.callBase(options);
        if (options.row && "header" === options.row.rowType) {
            if (column && column.allowFixing) {
                onItemClick = function(params) {
                    switch (params.itemData.value) {
                        case "none":
                            that._columnsController.columnOption(column.index, "fixed", false);
                            break;
                        case "left":
                            that._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "left"
                            });
                            break;
                        case "right":
                            that._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "right"
                            })
                    }
                };
                items = items || [];
                items.push({
                    text: columnFixingOptions.texts.fix,
                    beginGroup: true,
                    items: [{
                        text: columnFixingOptions.texts.leftPosition,
                        value: "left",
                        disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
                        onItemClick: onItemClick
                    }, {
                        text: columnFixingOptions.texts.rightPosition,
                        value: "right",
                        disabled: column.fixed && "right" === column.fixedPosition,
                        onItemClick: onItemClick
                    }]
                }, {
                    text: columnFixingOptions.texts.unfix,
                    value: "none",
                    disabled: !column.fixed,
                    onItemClick: onItemClick
                })
            }
        }
        return items
    },
    setScrollerSpacing: function(width) {
        var that = this,
            rtlEnabled = that.option("rtlEnabled");
        that.callBase(width);
        that.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).css(rtlEnabled ? {
            paddingLeft: width
        } : {
            paddingRight: width
        })
    },
    getFixedColumnElements: function(rowIndex) {
        var columnElements, transparentColumnIndex, $transparentColumnElement, that = this;
        if (commonUtils.isDefined(rowIndex)) {
            return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children()
        }
        columnElements = that.getColumnElements();
        $transparentColumnElement = that.getTransparentColumnElement();
        if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
            transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
            columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0))
        }
        return columnElements
    },
    getColumnWidths: function() {
        var fixedWidths, that = this,
            result = that.callBase(),
            $fixedColumnElements = that.getFixedColumnElements(),
            fixedColumns = that.getFixedColumns();
        if (that._fixedTableElement) {
            if ($fixedColumnElements && $fixedColumnElements.length) {
                fixedWidths = that._getWidths($fixedColumnElements)
            } else {
                fixedWidths = that.callBase(that._fixedTableElement)
            }
        }
        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
    }
});
var RowsViewFixedColumnsExtender = extend({}, baseFixedColumns, {
    _detachHoverEvents: function() {
        this._fixedTableElement && this._fixedTableElement.off("mouseover mouseout", ".dx-data-row");
        this._tableElement && this._tableElement.off("mouseover mouseout", ".dx-data-row")
    },
    _attachHoverEvents: function() {
        var that = this,
            attachHoverEvent = function($table) {
                $table.on("mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
                    var event = args.jQueryEvent,
                        rowIndex = that.getRowIndex($(event.target).closest(".dx-row")),
                        isHover = "mouseover" === event.type;
                    if (rowIndex >= 0) {
                        that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);
                        that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover)
                    }
                }))
            };
        if (that._fixedTableElement && that._tableElement) {
            attachHoverEvent(that._fixedTableElement);
            attachHoverEvent(that._tableElement)
        }
    },
    _findContentElement: function() {
        var $content, scrollable, scrollTop, that = this,
            contentClass = that.addWidgetPrefix(CONTENT_CLASS),
            element = that.element();
        if (element && that._isFixedTableRendering) {
            $content = element.children("." + contentClass);
            scrollable = that.getScrollable();
            if (!$content.length && scrollable) {
                $content = $("<div/>").addClass(contentClass).on("scroll", function(e) {
                    scrollTop = $(e.target).scrollTop();
                    if (scrollTop) {
                        $(e.target).scrollTop(0);
                        scrollable.scrollTo({
                            y: that._scrollTop + scrollTop
                        })
                    }
                }).on(wheelEvent.name, function(e) {
                    if (scrollable) {
                        scrollTop = scrollable.scrollTop();
                        scrollable.scrollTo({
                            y: scrollTop - e.delta
                        });
                        if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {
                            return false
                        }
                    }
                }).appendTo(element)
            }
            return $content
        }
        return that.callBase()
    },
    _updateBottomLoading: function() {
        if (!this._isFixedTableRendering) {
            this.callBase()
        }
    },
    _updateScrollable: function() {
        this.callBase();
        var scrollable = this.getScrollable(),
            scrollTop = scrollable && scrollable.scrollOffset().top;
        this._updateFixedTablePosition(-scrollTop)
    },
    _renderContent: function(contentElement, tableElement) {
        if (this._isFixedTableRendering) {
            return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS) + " " + this.addWidgetPrefix(CONTENT_FIXED_CLASS) + " " + POINTER_EVENTS_TARGET_CLASS).append(tableElement)
        }
        return this.callBase(contentElement, tableElement)
    },
    _getGroupCellOptions: function(options) {
        if (this._isFixedTableRendering) {
            return this.callBase(extend({}, options, {
                columns: this._columnsController.getVisibleColumns()
            }))
        }
        return this.callBase(options)
    },
    _renderGroupSummaryCells: function($row, options) {
        if (this._isFixedTableRendering) {
            this.callBase($row, extend({}, options, {
                columns: this._columnsController.getVisibleColumns()
            }))
        } else {
            this.callBase($row, options)
        }
    },
    _hasAlignByColumnSummaryItems: function(columnIndex, options) {
        var result = this.callBase.apply(this, arguments),
            column = options.columns[columnIndex];
        if (options.isFixed) {
            return column.fixed && (result || "right" === column.fixedPosition) || "edit" === column.command
        }
        return result && !column.fixed
    },
    _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
        var startColumnIndex, transparentColumnIndex, alignByFixedColumnCellCount;
        if (this._isFixedTableRendering) {
            options.isFixed = true;
            alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
            options.isFixed = false;
            startColumnIndex = options.columns.length - alignByFixedColumnCellCount;
            options = extend({}, options, {
                columns: this.getFixedColumns()
            });
            transparentColumnIndex = getTransparentColumnIndex(options.columns);
            if (startColumnIndex < transparentColumnIndex) {
                alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;
                groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0
            } else {
                if (alignByColumnCellCount > 0) {
                    if (browser.mozilla) {
                        $groupCell.css("display", "none")
                    } else {
                        $groupCell.css("visibility", "hidden")
                    }
                }
            }
            alignByColumnCellCount = alignByFixedColumnCellCount
        }
        this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
    },
    _getSummaryCellIndex: function(columnIndex, columns) {
        var transparentColumnIndex;
        if (this._isFixedTableRendering) {
            transparentColumnIndex = getTransparentColumnIndex(columns);
            if (columnIndex > transparentColumnIndex) {
                columnIndex += columns[transparentColumnIndex].colspan - 1
            }
            return columnIndex
        }
        return this.callBase.apply(this, arguments)
    },
    _renderCore: function(change) {
        this._detachHoverEvents();
        this.callBase(change);
        if (this.option("hoverStateEnabled") && this._isFixedColumns) {
            this._attachHoverEvents()
        }
    },
    optionChanged: function(args) {
        var that = this;
        that.callBase(args);
        if ("hoverStateEnabled" === args.name && that._isFixedColumns) {
            args.value ? this._attachHoverEvents() : this._detachHoverEvents()
        }
    },
    getCellIndex: function($cell) {
        var columns, $fixedTable = this._fixedTableElement,
            cellIndex = 0;
        if ($fixedTable && $fixedTable.find($cell).length) {
            columns = this.getFixedColumns();
            $.each(columns, function(index, column) {
                if (index === $cell[0].cellIndex) {
                    return false
                }
                if (column.colspan) {
                    cellIndex += column.colspan;
                    return
                }
                cellIndex++
            });
            return cellIndex
        }
        return this.callBase.apply(this, arguments)
    },
    _updateFixedTablePosition: function(scrollTop) {
        if (this._fixedTableElement && this._tableElement) {
            var editorFactory = this.getController("editorFactory"),
                $focusedElement = editorFactory.focus();
            this._fixedTableElement.css("top", scrollTop + this._tableElement.position().top);
            if ($focusedElement) {
                editorFactory.focus($focusedElement)
            }
        }
    },
    setScrollerSpacing: function(vWidth, hWidth) {
        var styles, that = this;
        var $fixedContent = that.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS));
        if ($fixedContent.length) {
            styles = that.option("rtlEnabled") ? {
                marginLeft: vWidth
            } : {
                marginRight: vWidth
            };
            styles.marginBottom = hWidth;
            $fixedContent.css(styles)
        }
    },
    _handleScroll: function(e) {
        this._updateFixedTablePosition(-e.scrollOffset.top);
        this.callBase(e)
    },
    _updateContentPosition: function() {
        var isUpdated = this.callBase();
        if (isUpdated) {
            this._updateFixedTablePosition(-this._scrollTop)
        }
        return isUpdated
    },
    _afterRowPrepared: function(e) {
        if (this._isFixedTableRendering) {
            return
        }
        this.callBase(e)
    }
});
var FooterViewFixedColumnsExtender = baseFixedColumns;
module.exports = {
    defaultOptions: function() {
        return {
            columnFixing: {
                enabled: false,
                texts: {
                    fix: messageLocalization.format("dxDataGrid-columnFixingFix"),
                    unfix: messageLocalization.format("dxDataGrid-columnFixingUnfix"),
                    leftPosition: messageLocalization.format("dxDataGrid-columnFixingLeftPosition"),
                    rightPosition: messageLocalization.format("dxDataGrid-columnFixingRightPosition")
                }
            }
        }
    },
    extenders: {
        views: {
            columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
            rowsView: RowsViewFixedColumnsExtender,
            footerView: FooterViewFixedColumnsExtender
        },
        controllers: function() {
            var normalizeColumnIndicesByPoints = function(columns, fixedColumns, pointsByColumns) {
                var transparentColumnIndex = getTransparentColumnIndex(fixedColumns),
                    correctIndex = columns.length - fixedColumns.length;
                $.each(pointsByColumns, function(_, point) {
                    if (point.index > transparentColumnIndex) {
                        point.columnIndex += correctIndex;
                        point.index += correctIndex
                    }
                });
                return pointsByColumns
            };
            return {
                draggingHeader: {
                    _generatePointsByColumns: function(options) {
                        var pointsByColumns, visibleColumns = options.columns,
                            targetDraggingPanel = options.targetDraggingPanel;
                        if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
                            if (options.sourceColumn.fixed) {
                                if (!options.rowIndex) {
                                    options.columnElements = targetDraggingPanel.getFixedColumnElements(0)
                                }
                                options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);
                                pointsByColumns = this.callBase(options);
                                normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);
                                return pointsByColumns
                            }
                        }
                        return this.callBase(options)
                    },
                    _pointCreated: function(point, columns, location, sourceColumn) {
                        var boundingRect, result = this.callBase.apply(this, arguments),
                            $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                        if (!result && "headers" === location && $transparentColumn && $transparentColumn.length) {
                            boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                            if (sourceColumn && sourceColumn.fixed) {
                                return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left
                            } else {
                                return point.x < boundingRect.left || point.x > boundingRect.right
                            }
                        }
                        return result
                    }
                },
                columnsResizer: {
                    _generatePointsByColumns: function() {
                        var that = this,
                            columnsController = that._columnsController,
                            columns = columnsController && that._columnsController.getVisibleColumns(),
                            fixedColumns = columnsController && that._columnsController.getFixedColumns(),
                            cells = that._columnHeadersView.getFixedColumnElements(),
                            pointsByFixedColumns = [];
                        that.callBase();
                        if (cells && cells.length > 0) {
                            pointsByFixedColumns = gridCoreUtils.getPointsByColumns(cells, function(point) {
                                return that._pointCreated(point, cells.length, fixedColumns)
                            });
                            that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns)
                        }
                    },
                    _pointCreated: function(point, cellsLength, columns) {
                        var currentColumn, nextColumn;
                        if (point.index > 0 && point.index < cellsLength) {
                            currentColumn = columns[point.columnIndex - 1] || {};
                            nextColumn = columns[point.columnIndex] || {};
                            if (currentColumn.fixed || nextColumn.fixed) {
                                point.columnIndex -= 1;
                                return !((currentColumn.allowResizing || "transparent" === currentColumn.command) && (nextColumn.allowResizing || "transparent" === nextColumn.command))
                            }
                        }
                        return this.callBase.apply(this, arguments)
                    },
                    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                        var boundingRect, $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                        if ($transparentColumn && $transparentColumn.length) {
                            boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                            if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
                                return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
                            }
                        }
                        return this.callBase(pointsByColumns, currentX, deltaX)
                    }
                },
                keyboardNavigation: {
                    _scrollToElement: function($element) {
                        var focusedView = this.getFocusedView();
                        this.callBase($element, focusedView && focusedView.getFixedColumnsOffset())
                    }
                }
            }
        }()
    }
};


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.adaptivity.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    eventUtils = __webpack_require__(3),
    clickEvent = __webpack_require__(11),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    equalByValue = commonUtils.equalByValue,
    Guid = __webpack_require__(34),
    modules = __webpack_require__(23),
    Form = __webpack_require__(230),
    gridCoreUtils = __webpack_require__(26),
    COLUMN_HEADERS_VIEW = "columnHeadersView",
    ROWS_VIEW = "rowsView",
    FOOTER_VIEW = "footerView",
    COLUMN_VIEWS = [COLUMN_HEADERS_VIEW, ROWS_VIEW, FOOTER_VIEW],
    ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity",
    HIDDEN_COLUMNS_WIDTH = "adaptiveHidden",
    ADAPTIVE_ROW_TYPE = "detailAdaptive",
    FORM_ITEM_CONTENT_CLASS = "dx-field-item-content",
    FORM_ITEM_MODIFIED = "dx-item-modified",
    HIDDEN_COLUMN_CLASS = "hidden-column",
    ADAPTIVE_COLUMN_BUTTON_CLASS = "adaptive-more",
    ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive",
    COMMAND_ADAPTIVE_HIDDEN_CLASS = "dx-command-adaptive-hidden",
    ADAPTIVE_DETAIL_ROW_CLASS = "dx-adaptive-detail-row",
    ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text",
    MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
    ADAPTIVE_COLUMN_NAME = "adaptive",
    EDIT_MODE_BATCH = "batch",
    EDIT_MODE_ROW = "row",
    EDIT_MODE_FORM = "form",
    EDIT_MODE_POPUP = "popup";

function getColumnId(column) {
    return column.command ? "command:" + column.command : column.index
}
var AdaptiveColumnsController = modules.ViewController.inherit({
    _isRowEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_ROW
    },
    _isItemModified: function(item, cellOptions) {
        var columnIndex = this._columnsController.getVisibleIndex(item.column.index),
            rowIndex = this._dataController.getRowIndexByKey(cellOptions.key),
            row = this._dataController.items()[rowIndex + 1];
        return row && row.modifiedValues && commonUtils.isDefined(row.modifiedValues[columnIndex])
    },
    _renderFormViewTemplate: function(item, cellOptions, $container) {
        var cellText, that = this,
            column = item.column,
            cellValue = column.calculateCellValue(cellOptions.data),
            focusAction = that.createAction(function() {
                $container.trigger(clickEvent.name)
            });
        cellValue = gridCoreUtils.getDisplayValue(column, cellValue, cellOptions.data, cellOptions.rowType);
        cellText = gridCoreUtils.formatValue(cellValue, column);
        if (column.allowEditing && that.option("useKeyboard")) {
            $container.attr("tabIndex", that.option("tabIndex")).off("focus", focusAction).on("focus", focusAction)
        }
        if (column.cellTemplate) {
            var templateOptions = extend({}, cellOptions, {
                value: cellValue,
                text: cellText,
                column: column
            });
            that._rowsView.renderTemplate($container, column.cellTemplate, templateOptions, !!$container.closest(document).length)
        } else {
            var container = $container.get(0);
            if (column.encodeHtml) {
                container.textContent = cellText
            } else {
                container.innerHTML = cellText
            }
            $container.addClass(ADAPTIVE_ITEM_TEXT_CLASS);
            if (!commonUtils.isDefined(cellText) || "" === cellText) {
                $container.html("&nbsp;")
            }
            if (!that._isRowEditMode()) {
                if (that._isItemModified(item, cellOptions)) {
                    $container.addClass(FORM_ITEM_MODIFIED)
                }
            }
        }
    },
    _getTemplate: function(item, cellOptions) {
        var that = this,
            column = item.column,
            editingController = this.getController("editing");
        return function(options, $container) {
            var isItemEdited = that._isItemEdited(item),
                columnIndex = that._columnsController.getVisibleIndex(column.visibleIndex),
                templateOptions = extend({}, cellOptions);
            templateOptions.value = cellOptions.row.values[columnIndex];
            if (isItemEdited || column.showEditorAlways) {
                editingController.renderFormEditTemplate(templateOptions, item, options.component, $container, !isItemEdited)
            } else {
                templateOptions.column = column;
                templateOptions.columnIndex = columnIndex;
                that._renderFormViewTemplate(item, templateOptions, $container);
                that.getView("rowsView")._cellPrepared($container, templateOptions)
            }
        }
    },
    _isVisibleColumnsValid: function(visibleColumns) {
        var getCommandColumnsCount = function() {
            var j, visibleColumn, result = 0;
            for (j = 0; j < visibleColumns.length; j++) {
                visibleColumn = visibleColumns[j];
                if (visibleColumn.command) {
                    result++
                }
            }
            return result
        };
        if (visibleColumns < 2) {
            return false
        }
        if (visibleColumns.length - getCommandColumnsCount() <= 1) {
            return false
        }
        return true
    },
    _calculatePercentWidths: function(widths, visibleColumns) {
        var that = this,
            percentWidths = 0;
        visibleColumns.forEach(function(item, index) {
            if (widths[index] !== HIDDEN_COLUMNS_WIDTH) {
                percentWidths += that._getItemPercentWidth(item)
            }
        });
        return percentWidths
    },
    _isPercentWidth: function(width) {
        return commonUtils.isString(width) && "%" === width.slice(-1)
    },
    _isColumnHidden: function(column) {
        return this._hiddenColumns.filter(function(hiddenColumn) {
            return hiddenColumn.index === column.index
        }).length > 0
    },
    _getAverageColumnsWidth: function(containerWidth, columns, columnsCanFit) {
        var that = this,
            fixedColumnsWidth = 0,
            columnsWithoutFixedWidthCount = 0;
        columns.forEach(function(column) {
            if (!that._isColumnHidden(column)) {
                var width = column.width;
                if (commonUtils.isDefined(width) && !isNaN(parseFloat(width))) {
                    fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
                        visibleIndex: column.visibleIndex,
                        columnsCount: columns.length,
                        columnsCanFit: columnsCanFit,
                        bestFitWidth: column.bestFitWidth,
                        columnWidth: width,
                        containerWidth: containerWidth
                    }) : parseFloat(width)
                } else {
                    columnsWithoutFixedWidthCount++
                }
            }
        });
        return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount
    },
    _calculatePercentWidth: function(options) {
        var columnFitted = options.visibleIndex < options.columnsCount - 1 && options.columnsCanFit,
            partialWidth = options.containerWidth * parseFloat(options.columnWidth) / 100,
            resultWidth = options.columnsCanFit && partialWidth < options.bestFitWidth ? options.bestFitWidth : partialWidth;
        return columnFitted ? this.component.element().width() * parseFloat(options.columnWidth) / 100 : resultWidth
    },
    _getNotTruncatedColumnWidth: function(column, containerWidth, contentColumns, columnsCanFit) {
        var colWidth, columnId = getColumnId(column),
            widthOption = this._columnsController.columnOption(columnId, "width"),
            bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth"),
            columnsCount = contentColumns.length;
        if (widthOption && "auto" !== widthOption) {
            if (this._isPercentWidth(widthOption)) {
                colWidth = this._calculatePercentWidth({
                    visibleIndex: column.visibleIndex,
                    columnsCount: columnsCount,
                    columnsCanFit: columnsCanFit,
                    bestFitWidth: bestFitWidth,
                    columnWidth: widthOption,
                    containerWidth: containerWidth
                })
            } else {
                return widthOption
            }
        } else {
            var columnAutoWidth = this.option("columnAutoWidth");
            colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit)
        }
        var isTruncated = colWidth < bestFitWidth;
        return isTruncated ? null : colWidth
    },
    _getItemPercentWidth: function(item) {
        var result = 0;
        if (item.width && this._isPercentWidth(item.width)) {
            result = parseFloat(item.width)
        }
        return result
    },
    _getCommandColumnsWidth: function() {
        var that = this,
            columns = that._columnsController.getVisibleColumns(),
            colWidth = 0;
        $.each(columns, function(index, column) {
            if (column.index < 0 || column.command) {
                colWidth += that._columnsController.columnOption(getColumnId(column), "bestFitWidth") || 0
            }
        });
        return colWidth
    },
    _isItemEdited: function(item) {
        if (this.isFormEditMode()) {
            return false
        }
        if (this._isRowEditMode()) {
            var editRowKey = this._editingController.getEditRowKey();
            if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
                return true
            }
        } else {
            var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,
                columnIndex = this._columnsController.getVisibleIndex(item.column.index);
            return this._editingController.isEditCell(rowIndex, columnIndex)
        }
    },
    _getFormItemsByHiddenColumns: function(hiddenColumns) {
        var items = [];
        $.each(hiddenColumns, function(_, column) {
            items.push({
                column: column,
                name: column.name,
                dataField: column.dataField,
                visibleIndex: column.visibleIndex
            })
        });
        return items
    },
    _getAdaptiveColumnVisibleIndex: function(visibleColumns) {
        var i, column;
        for (i = 0; i < visibleColumns.length; i++) {
            column = visibleColumns[i];
            if (column.command === ADAPTIVE_COLUMN_NAME) {
                return i
            }
        }
    },
    _hideAdaptiveColumn: function(resultWidths, visibleColumns) {
        var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
        if (commonUtils.isDefined(visibleIndex)) {
            resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;
            this._addCssClassToColumn(COMMAND_ADAPTIVE_HIDDEN_CLASS, visibleIndex)
        }
    },
    _removeCssClassFromColumn: function(cssClassName) {
        var i, view, $cells;
        for (i = 0; i < COLUMN_VIEWS.length; i++) {
            view = this.getView(COLUMN_VIEWS[i]);
            if (view && view.isVisible() && view.element()) {
                $cells = view.element().find("." + cssClassName);
                $cells.removeClass(cssClassName)
            }
        }
    },
    _removeCssClassesFromColumns: function() {
        this._removeCssClassFromColumn(COMMAND_ADAPTIVE_HIDDEN_CLASS);
        this._removeCssClassFromColumn(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS))
    },
    _isCellValid: function($cell) {
        return !$cell.hasClass(MASTER_DETAIL_CELL_CLASS)
    },
    _addCssClassToColumn: function(cssClassName, visibleIndex) {
        var that = this;
        COLUMN_VIEWS.forEach(function(viewName) {
            var view = that.getView(viewName);
            view && that._addCssClassToViewColumn(view, cssClassName, visibleIndex)
        })
    },
    _addCssClassToViewColumn: function(view, cssClassName, visibleIndex) {
        var rowsCount, rowIndex, $cellElement, currentVisibleIndex, viewName = view.name,
            column = this._columnsController.getVisibleColumns()[visibleIndex],
            editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
        if (view && view.isVisible() && column) {
            rowsCount = view.getRowsCount();
            for (rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
                if (rowIndex !== editFormRowIndex || viewName !== ROWS_VIEW) {
                    currentVisibleIndex = viewName === COLUMN_HEADERS_VIEW ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
                    if (currentVisibleIndex >= 0) {
                        $cellElement = view.getCellElements(rowIndex).eq(currentVisibleIndex);
                        this._isCellValid($cellElement) && $cellElement.addClass(cssClassName)
                    }
                }
            }
        }
    },
    applyStylesForHiddenColumns: function(view) {
        var that = this;
        this._hiddenColumns.forEach(function(column) {
            var visibleIndex = that._columnsController.getVisibleIndex(column.index);
            that._addCssClassToViewColumn(view, that.addWidgetPrefix(HIDDEN_COLUMN_CLASS), visibleIndex)
        })
    },
    isFormEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP
    },
    hideRedundantColumns: function(resultWidths, visibleColumns, hiddenQueue) {
        var visibleColumn, that = this;
        this._hiddenColumns = [];
        if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
            var percentWidths, columnsCanFit, i, needHideColumn, totalWidth = 0,
                $rootElement = that.component.element(),
                rootElementWidth = $rootElement.width() - that._getCommandColumnsWidth(),
                contentColumns = visibleColumns.filter(function(item) {
                    return !item.command
                }),
                contentColumnCount = contentColumns.length;
            do {
                needHideColumn = false;
                totalWidth = 0;
                percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
                columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
                for (i = 0; i < visibleColumns.length; i++) {
                    visibleColumn = visibleColumns[i];
                    var columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, contentColumns, columnsCanFit),
                        columnId = getColumnId(visibleColumn),
                        widthOption = that._columnsController.columnOption(columnId, "width"),
                        columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
                    if (resultWidths[i] === HIDDEN_COLUMNS_WIDTH) {
                        continue
                    }
                    if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
                        needHideColumn = true;
                        break
                    }
                    if (widthOption && "auto" !== widthOption) {
                        totalWidth += columnWidth
                    } else {
                        totalWidth += columnBestFitWidth || 0
                    }
                }
                needHideColumn = needHideColumn || totalWidth > $rootElement.width();
                if (needHideColumn) {
                    var column = hiddenQueue.pop(),
                        visibleIndex = that._columnsController.getVisibleIndex(column.index);
                    that._addCssClassToColumn(that.addWidgetPrefix(HIDDEN_COLUMN_CLASS), visibleIndex);
                    resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;
                    contentColumnCount--;
                    this._hiddenColumns.push(column)
                }
            } while (needHideColumn && contentColumnCount > 1 && hiddenQueue.length);
            if (contentColumnCount === contentColumns.length) {
                that._hideAdaptiveColumn(resultWidths, visibleColumns)
            }
        } else {
            that._hideAdaptiveColumn(resultWidths, visibleColumns)
        }
    },
    getItemContentByColumnIndex: function(visibleColumnIndex) {
        var $itemContent, i, item;
        for (i = 0; i < this._$itemContents.length; i++) {
            $itemContent = this._$itemContents.eq(i);
            item = $itemContent.data("dx-form-item");
            if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
                return $itemContent
            }
        }
    },
    toggleExpandAdaptiveDetailRow: function(key) {
        if (!(this.isFormEditMode() && this._editingController.isEditing())) {
            this.getController("data").toggleExpandAdaptiveDetailRow(key)
        }
    },
    createFormByHiddenColumns: function($container, options) {
        var that = this,
            userFormOptions = {
                items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
                formID: "dx-" + new Guid
            };
        this.executeAction("onAdaptiveDetailRowPreparing", {
            formOptions: userFormOptions
        });
        that._$itemContents = null;
        that._form = that._createComponent($("<div>").appendTo($container), Form, extend({}, userFormOptions, {
            customizeItem: function(item) {
                var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
                if (column) {
                    item.label = item.label || {};
                    item.label.text = item.label.text || column.caption;
                    item.column = column;
                    item.template = that._getTemplate(item, options, that.updateForm.bind(that))
                }
                userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item)
            },
            onContentReady: function(e) {
                userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
                that._$itemContents = $container.find("." + FORM_ITEM_CONTENT_CLASS)
            }
        }))
    },
    hasAdaptiveDetailRowExpanded: function() {
        return commonUtils.isDefined(this._dataController.adaptiveExpandedKey())
    },
    updateForm: function(hiddenColumns) {
        if (this.hasAdaptiveDetailRowExpanded()) {
            if (this._form && commonUtils.isDefined(this._form._contentReadyAction)) {
                if (hiddenColumns && hiddenColumns.length) {
                    this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns))
                } else {
                    this._form.repaint()
                }
            }
        }
    },
    updateHidingQueue: function(columns) {
        var columnsHasHidingPriority, i, that = this,
            hideableColumns = columns.filter(function(column) {
                return column.visible && !column.fixed && !(commonUtils.isDefined(column.groupIndex) && column.groupIndex >= 0)
            });
        that._hidingColumnsQueue = [];
        if (that.option("allowColumnResizing") && "widget" === that.option("columnResizingMode")) {
            return that._hidingColumnsQueue
        }
        for (i = 0; i < hideableColumns.length; i++) {
            if (commonUtils.isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
                columnsHasHidingPriority = true;
                that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i]
            }
        }
        if (columnsHasHidingPriority) {
            that._hidingColumnsQueue.reverse()
        } else {
            if (that.option("columnHidingEnabled")) {
                for (i = 0; i < hideableColumns.length; i++) {
                    var visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);
                    that._hidingColumnsQueue[visibleIndex] = hideableColumns[i]
                }
            }
        }
        that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
        return that._hidingColumnsQueue
    },
    getHiddenColumns: function() {
        return this._hiddenColumns
    },
    hasHiddenColumns: function() {
        return this._hiddenColumns.length > 0
    },
    getHidingColumnsQueue: function() {
        return this._hidingColumnsQueue
    },
    init: function() {
        var that = this;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._rowsView = that.getView("rowsView");
        that._columnsController.addCommandColumn({
            command: ADAPTIVE_COLUMN_NAME,
            visible: true,
            adaptiveHidden: true,
            cssClass: ADAPTIVE_COLUMN_NAME_CLASS,
            width: "auto"
        });
        that._columnsController.columnsChanged.add(function() {
            var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;
            that._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true)
        });
        that._editingController = that.getController("editing");
        that._hidingColumnsQueue = [];
        that._hiddenColumns = [];
        that.createAction("onAdaptiveDetailRowPreparing");
        that.callBase()
    },
    optionChanged: function(args) {
        if ("columnHidingEnabled" === args.name) {
            this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value)
        }
        this.callBase(args)
    },
    publicMethods: function() {
        return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"]
    },
    isAdaptiveDetailRowExpanded: function(key) {
        return this._dataController.adaptiveExpandedKey() && commonUtils.equalByValue(this._dataController.adaptiveExpandedKey(), key)
    },
    expandAdaptiveDetailRow: function(key) {
        if (!this.hasAdaptiveDetailRowExpanded()) {
            this.toggleExpandAdaptiveDetailRow(key)
        }
    },
    collapseAdaptiveDetailRow: function() {
        if (this.hasAdaptiveDetailRowExpanded()) {
            this.toggleExpandAdaptiveDetailRow()
        }
    }
});
module.exports = {
    defaultOptions: function() {
        return {
            columnHidingEnabled: false,
            onAdaptiveDetailRowPreparing: null
        }
    },
    controllers: {
        adaptiveColumns: AdaptiveColumnsController
    },
    extenders: {
        views: {
            rowsView: {
                _getCellTemplate: function(options) {
                    var that = this,
                        column = options.column;
                    if (column.command === ADAPTIVE_COLUMN_NAME && "groupFooter" !== options.rowType) {
                        return function(container) {
                            $("<span/>").addClass(that.addWidgetPrefix(ADAPTIVE_COLUMN_BUTTON_CLASS)).on(eventUtils.addNamespace(clickEvent.name, ADAPTIVE_NAMESPACE), that.createAction(function() {
                                that._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key)
                            })).appendTo(container)
                        }
                    }
                    if (options.rowType === ADAPTIVE_ROW_TYPE && "detail" === column.command) {
                        return function(container, options) {
                            that._adaptiveColumnsController.createFormByHiddenColumns(container, options)
                        }
                    }
                    return that.callBase(options)
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row && row.rowType === ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {
                        $row.addClass(ADAPTIVE_DETAIL_ROW_CLASS)
                    }
                    return $row
                },
                _getColumnIndexByElementCore: function($element) {
                    var $itemContent = $element.closest("." + FORM_ITEM_CONTENT_CLASS);
                    if ($itemContent.length && $itemContent.closest(this.component.element()).length) {
                        var formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
                        return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index)
                    } else {
                        return this.callBase($element)
                    }
                },
                _cellPrepared: function() {
                    this.callBase.apply(this, arguments);
                    this._adaptiveColumnsController.applyStylesForHiddenColumns(this)
                },
                getCellElement: function(rowIndex, columnIdentifier) {
                    var item = this._dataController.items()[rowIndex];
                    if (item && item.rowType === ADAPTIVE_ROW_TYPE) {
                        return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier)
                    } else {
                        return this.callBase(rowIndex, columnIdentifier)
                    }
                },
                isClickableElement: function($target) {
                    var isClickable = this.callBase ? this.callBase($target) : false;
                    return isClickable || !!$target.closest("." + ADAPTIVE_COLUMN_NAME_CLASS).length
                },
                init: function() {
                    this.callBase();
                    this._adaptiveColumnsController = this.getController("adaptiveColumns")
                }
            }
        },
        controllers: {
            "export": {
                _updateColumnWidth: function(column, width) {
                    this.callBase(column, column.visibleWidth === HIDDEN_COLUMNS_WIDTH ? column.bestFitWidth : width)
                }
            },
            columnsResizer: {
                _pointCreated: function(point, cellsLength, columns) {
                    var result = this.callBase(point, cellsLength, columns),
                        currentColumn = columns[point.columnIndex] || {},
                        nextColumnIndex = this._getNextColumnIndex(point.columnIndex),
                        nextColumn = columns[nextColumnIndex] || {},
                        hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command,
                        hasAdaptiveHiddenWidth = currentColumn.visibleWidth === HIDDEN_COLUMNS_WIDTH || hasHiddenColumnsOnly;
                    return result || hasAdaptiveHiddenWidth
                },
                _getNextColumnIndex: function(currentColumnIndex) {
                    var visibleColumns = this._columnsController.getVisibleColumns(),
                        index = this.callBase(currentColumnIndex);
                    while (visibleColumns[index] && visibleColumns[index].visibleWidth === HIDDEN_COLUMNS_WIDTH) {
                        index++
                    }
                    return index
                }
            },
            draggingHeader: {
                _pointCreated: function(point, columns, location, sourceColumn) {
                    var result = this.callBase(point, columns, location, sourceColumn),
                        column = columns[point.columnIndex] || {},
                        hasAdaptiveHiddenWidth = column.visibleWidth === HIDDEN_COLUMNS_WIDTH;
                    return result || hasAdaptiveHiddenWidth
                }
            },
            editing: {
                _getFormEditItemTemplate: function(cellOptions, column) {
                    if (this.getEditMode() !== EDIT_MODE_ROW && "detailAdaptive" === cellOptions.rowType) {
                        cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
                        return this.getColumnTemplate(cellOptions)
                    }
                    return this.callBase(cellOptions, column)
                },
                _closeEditItem: function($targetElement) {
                    var $itemContents = $targetElement.closest("." + FORM_ITEM_CONTENT_CLASS),
                        rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,
                        formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null,
                        columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
                    if (!this.isEditCell(rowIndex, columnIndex)) {
                        this.callBase($targetElement)
                    }
                },
                _beforeUpdateItems: function(rowIndices, rowIndex) {
                    if (!this._adaptiveController.isFormEditMode() && this._adaptiveController.hasHiddenColumns()) {
                        var items = this._dataController.items(),
                            item = items[rowIndex],
                            oldExpandRowIndex = gridCoreUtils.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
                        this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();
                        if (oldExpandRowIndex >= 0 && rowIndex > oldExpandRowIndex) {
                            this._editRowIndex--
                        }
                        if (oldExpandRowIndex >= 0) {
                            rowIndices.push(oldExpandRowIndex + 1)
                        }
                        rowIndices.push(rowIndex + 1);
                        this._dataController.adaptiveExpandedKey(item.key)
                    }
                },
                _afterInsertRow: function(options) {
                    this.callBase(options);
                    if (this._adaptiveController.hasHiddenColumns()) {
                        this._adaptiveController.expandAdaptiveDetailRow(options.key);
                        this._isForceRowAdaptiveExpand = true
                    }
                },
                _collapseAdaptiveDetailRow: function() {
                    if (this.getEditMode() === EDIT_MODE_ROW && this._isForceRowAdaptiveExpand) {
                        this._adaptiveController.collapseAdaptiveDetailRow();
                        this._isForceRowAdaptiveExpand = false
                    }
                },
                _cancelEditAdaptiveDetailRow: function() {
                    if (this._adaptiveController.hasHiddenColumns()) {
                        this._collapseAdaptiveDetailRow()
                    }
                },
                _afterSaveEditData: function() {
                    this.callBase();
                    if (this.getController("validating").validate(true)) {
                        this._cancelEditAdaptiveDetailRow()
                    }
                },
                _beforeCancelEditData: function() {
                    this.callBase();
                    this._cancelEditAdaptiveDetailRow()
                },
                _getRowIndicesForCascadeUpdating: function(row) {
                    var rowIndices = this.callBase.apply(this, arguments);
                    if (this._adaptiveController.isAdaptiveDetailRowExpanded(row.key)) {
                        rowIndices.push(row.rowType === ADAPTIVE_ROW_TYPE ? row.rowIndex - 1 : row.rowIndex + 1)
                    }
                    return rowIndices
                },
                _beforeCloseEditCellInBatchMode: function(rowIndices) {
                    var rowIndex, expandedKey = this._dataController._adaptiveExpandedKey;
                    if (expandedKey) {
                        rowIndex = gridCoreUtils.getIndexByKey(expandedKey, this._dataController.items());
                        if (rowIndex > -1) {
                            rowIndices.unshift(rowIndex)
                        }
                    }
                },
                editRow: function(rowIndex) {
                    if (this._adaptiveController.isFormEditMode()) {
                        this._adaptiveController.collapseAdaptiveDetailRow()
                    }
                    this.callBase(rowIndex)
                },
                deleteRow: function(rowIndex) {
                    var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
                    if (this.getEditMode() === EDIT_MODE_BATCH && this._adaptiveController.isAdaptiveDetailRowExpanded(rowKey)) {
                        this._adaptiveController.collapseAdaptiveDetailRow()
                    }
                    this.callBase(rowIndex)
                },
                init: function() {
                    this.callBase();
                    this._adaptiveController = this.getController("adaptiveColumns")
                }
            },
            resizing: {
                _needBestFit: function() {
                    return this.callBase() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length
                },
                _correctColumnWidths: function(resultWidths, visibleColumns) {
                    var hiddenColumns, adaptiveController = this._adaptiveColumnsController,
                        oldHiddenColumns = adaptiveController.getHiddenColumns(),
                        hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
                    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
                    hiddenColumns = adaptiveController.getHiddenColumns();
                    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
                        if (oldHiddenColumns.length !== hiddenColumns.length) {
                            adaptiveController.updateForm(hiddenColumns)
                        }
                    }!hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
                    return this.callBase(resultWidths, visibleColumns)
                },
                _toggleBestFitMode: function(isBestFit) {
                    isBestFit && this._adaptiveColumnsController._removeCssClassesFromColumns();
                    this.callBase(isBestFit)
                },
                init: function() {
                    this._adaptiveColumnsController = this.getController("adaptiveColumns");
                    this.callBase()
                }
            },
            data: {
                _processItems: function(items, changeType) {
                    var item, expandRowIndex, that = this;
                    items = that.callBase.apply(that, arguments);
                    if ("loadingAll" === changeType || !commonUtils.isDefined(that._adaptiveExpandedKey)) {
                        return items
                    }
                    expandRowIndex = gridCoreUtils.getIndexByKey(that._adaptiveExpandedKey, items);
                    if (expandRowIndex >= 0) {
                        item = items[expandRowIndex];
                        items.splice(expandRowIndex + 1, 0, {
                            visible: true,
                            rowType: ADAPTIVE_ROW_TYPE,
                            key: item.key,
                            data: item.data,
                            modifiedValues: item.modifiedValues,
                            inserted: item.inserted,
                            values: item.values
                        })
                    } else {
                        that._adaptiveExpandedKey = void 0
                    }
                    return items
                },
                _getRowIndicesForExpand: function(key) {
                    var lastRowIndex, rowIndices = this.callBase.apply(this, arguments);
                    if (this.getController("adaptiveColumns").isAdaptiveDetailRowExpanded(key)) {
                        lastRowIndex = rowIndices[rowIndices.length - 1];
                        rowIndices.push(lastRowIndex + 1)
                    }
                    return rowIndices
                },
                adaptiveExpandedKey: function(value) {
                    if (commonUtils.isDefined(value)) {
                        this._adaptiveExpandedKey = value
                    } else {
                        return this._adaptiveExpandedKey
                    }
                },
                toggleExpandAdaptiveDetailRow: function(key) {
                    var that = this;
                    var oldExpandRowIndex = gridCoreUtils.getIndexByKey(that._adaptiveExpandedKey, that._items);
                    var newExpandRowIndex = gridCoreUtils.getIndexByKey(key, that._items);
                    if (oldExpandRowIndex >= 0 && oldExpandRowIndex === newExpandRowIndex) {
                        key = void 0;
                        newExpandRowIndex = -1
                    }
                    that._adaptiveExpandedKey = key;
                    if (oldExpandRowIndex >= 0) {
                        oldExpandRowIndex++
                    }
                    if (newExpandRowIndex >= 0) {
                        newExpandRowIndex++
                    }
                    that.updateItems({
                        changeType: "update",
                        rowIndices: [oldExpandRowIndex, newExpandRowIndex]
                    })
                },
                init: function() {
                    this.callBase();
                    this._adaptiveExpandedKey = void 0
                }
            },
            editorFactory: {
                _getFocusCellSelector: function() {
                    return this.callBase() + ", .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content"
                },
                _getTooltipsSelector: function() {
                    return this.callBase() + ", .dx-field-item-content .dx-tooltip"
                }
            },
            columns: {
                _isColumnVisible: function(column) {
                    return this.callBase(column) && !column.adaptiveHidden
                }
            },
            keyboardNavigation: {
                _isCellValid: function($cell) {
                    return this.callBase($cell) && !$cell.hasClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS))
                },
                _processNextCellInMasterDetail: function($nextCell) {
                    this.callBase($nextCell);
                    if (!this._isInsideEditForm($nextCell) && $nextCell) {
                        var focusHandler = function() {
                            $nextCell.off("focus", focusHandler);
                            $nextCell.trigger("dxclick")
                        };
                        $nextCell.on("focus", focusHandler)
                    }
                }
            }
        }
    }
};


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.data_source_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    commonUtils = __webpack_require__(2),
    dataCoreUtils = __webpack_require__(14),
    extend = __webpack_require__(1).extend,
    gridCoreUtils = __webpack_require__(26),
    ArrayStore = __webpack_require__(67),
    query = __webpack_require__(35),
    DataSourceAdapter = __webpack_require__(216);
var DEFAULT_KEY_EXPRESSION = "id";
DataSourceAdapter = DataSourceAdapter.inherit(function() {
    return {
        _createKeyGetter: function() {
            var keyExpr = this.getKeyExpr();
            return dataCoreUtils.compileGetter(keyExpr)
        },
        _createKeySetter: function() {
            var keyExpr = this.getKeyExpr();
            return dataCoreUtils.compileSetter(keyExpr)
        },
        _createParentIdGetter: function() {
            return dataCoreUtils.compileGetter(this.option("parentIdExpr"))
        },
        createParentIdSetter: function() {
            return dataCoreUtils.compileSetter(this.option("parentIdExpr"))
        },
        _createItemsGetter: function() {
            return dataCoreUtils.compileGetter(this.option("itemsExpr"))
        },
        _createHasItemsGetter: function() {
            var hasItemsExpr = this.option("hasItemsExpr");
            return hasItemsExpr && dataCoreUtils.compileGetter(hasItemsExpr)
        },
        _updateIndexByKeyObject: function(items) {
            var that = this;
            that._indexByKey = {};
            $.each(items, function(index, item) {
                that._indexByKey[item.key] = index
            })
        },
        _calculateHasItems: function(node, options) {
            var hasItems, that = this;
            if (that._hasItemsGetter) {
                hasItems = that._hasItemsGetter(node.data)
            }
            if (void 0 === hasItems) {
                var hasItemsByMap = that._hasItemsMap[node.key];
                if (void 0 !== hasItemsByMap) {
                    hasItems = hasItemsByMap
                } else {
                    if (options.remoteOperations.filtering && options.storeLoadOptions.parentIds) {
                        hasItems = true
                    } else {
                        hasItems = node.hasChildren
                    }
                }
            }
            return !!hasItems
        },
        _createVisibleItemsByNodes: function(nodes, options) {
            var that = this,
                result = [];
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].visible) {
                    result.push(nodes[i])
                }
                if ((that.isRowExpanded(nodes[i].key) || !nodes[i].visible) && nodes[i].hasChildren && nodes[i].children.length) {
                    result = result.concat(that._createVisibleItemsByNodes(nodes[i].children, options))
                }
            }
            return result
        },
        _convertItemToNode: function(item, rootValue, nodeByKey) {
            var parentNode, node, key = this._keyGetter(item),
                parentId = this._parentIdGetter(item);
            parentId = commonUtils.isDefined(parentId) ? parentId : rootValue;
            parentNode = nodeByKey[parentId] = nodeByKey[parentId] || {
                key: parentId,
                children: []
            };
            node = nodeByKey[key] = nodeByKey[key] || {
                key: key,
                children: []
            };
            node.data = item;
            node.parent = parentNode;
            return node
        },
        _createNodesByItems: function(items, visibleItems) {
            var i, that = this,
                rootValue = that.option("rootValue"),
                visibleByKey = {},
                nodeByKey = that._nodeByKey = {};
            if (visibleItems) {
                for (i = 0; i < visibleItems.length; i++) {
                    visibleByKey[this._keyGetter(visibleItems[i])] = true
                }
            }
            for (i = 0; i < items.length; i++) {
                var node = that._convertItemToNode(items[i], rootValue, nodeByKey);
                if (void 0 === node.key) {
                    return
                }
                node.visible = !visibleItems || !!visibleByKey[node.key];
                if (node.parent) {
                    node.parent.children.push(node)
                }
            }
            var rootNode = nodeByKey[rootValue] || {
                key: rootValue,
                children: []
            };
            rootNode.level = -1;
            return rootNode
        },
        _convertDataToPlainStructure: function(data, parentId, result) {
            var key, item, itemsExpr, childItems;
            if (this._itemsGetter) {
                result = result || [];
                for (var i = 0; i < data.length; i++) {
                    item = extend({}, data[i]);
                    key = this._keyGetter(item);
                    if (void 0 === key) {
                        key = result.length + 1;
                        this._keySetter(item, key)
                    }
                    if (void 0 === this._parentIdGetter(item)) {
                        this._parentIdSetter(item, void 0 === parentId ? this.option("rootValue") : parentId)
                    }
                    result.push(item);
                    childItems = this._itemsGetter(item);
                    if (childItems && childItems.length) {
                        this._convertDataToPlainStructure(childItems, key, result);
                        itemsExpr = this.option("itemsExpr");
                        if (!commonUtils.isFunction(itemsExpr)) {
                            delete item[itemsExpr]
                        }
                    }
                }
                return result
            }
            return data
        },
        _createIdFilter: function(field, keys) {
            var parentIdFilters = [];
            for (var i = 0; i < keys.length; i++) {
                parentIdFilters.push([field, "=", keys[i]])
            }
            return gridCoreUtils.combineFilters(parentIdFilters, "or")
        },
        _customizeRemoteOperations: function(options, isReload, operationTypes) {
            this.callBase.apply(this, arguments);
            options.remoteOperations.paging = false;
            var expandVisibleNodes = false;
            if (this.option("autoExpandAll")) {
                options.remoteOperations.sorting = false;
                options.remoteOperations.filtering = false;
                if (isReload && !this._lastLoadOptions && !options.isCustomLoading) {
                    expandVisibleNodes = true
                }
            }
            this._isReload = this._isReload || isReload || operationTypes.reload;
            if (!options.isCustomLoading) {
                if (!options.cachedStoreData) {
                    this._hasItemsMap = {}
                }
                if (this.option("expandNodesOnFiltering") && (isReload || operationTypes.filtering)) {
                    if (options.storeLoadOptions.filter || operationTypes.filtering && this.option("autoExpandAll")) {
                        expandVisibleNodes = true
                    }
                }
            }
            options.expandVisibleNodes = expandVisibleNodes
        },
        _getParentIdsToLoad: function(parentIds) {
            var parentIdsToLoad = [];
            for (var i = 0; i < parentIds.length; i++) {
                if (!this._hasItemsMap[parentIds[i]]) {
                    parentIdsToLoad.push(parentIds[i])
                }
            }
            return parentIdsToLoad
        },
        _handleDataLoading: function(options) {
            var combinedParentIdFilter, rootValue = this.option("rootValue"),
                parentIdExpr = this.option("parentIdExpr"),
                expandedRowKeys = this.option("expandedRowKeys"),
                filterMode = this.option("filterMode");
            this.callBase.apply(this, arguments);
            if (options.remoteOperations.filtering && !options.isCustomLoading) {
                if ("standard" === filterMode || !options.storeLoadOptions.filter) {
                    var parentIds = [rootValue].concat(expandedRowKeys),
                        parentIdsToLoad = options.data ? this._getParentIdsToLoad(parentIds) : parentIds;
                    if (parentIdsToLoad.length) {
                        options.cachedPagingData = void 0;
                        options.data = void 0;
                        options.mergeStoreLoadData = true
                    }
                    options.storeLoadOptions.parentIds = parentIdsToLoad;
                    combinedParentIdFilter = this._createIdFilter(parentIdExpr, parentIdsToLoad);
                    options.storeLoadOptions.filter = gridCoreUtils.combineFilters([combinedParentIdFilter, options.storeLoadOptions.filter])
                }
            }
        },
        _generateParentInfoToLoad: function(data) {
            var i, that = this,
                keyMap = {},
                parentIdMap = {},
                parentIds = [],
                rootValue = that.option("rootValue");
            for (i = 0; i < data.length; i++) {
                keyMap[that._keyGetter(data[i])] = true
            }
            for (i = 0; i < data.length; i++) {
                var parentId = that._parentIdGetter(data[i]);
                if (!parentIdMap[parentId] && !keyMap[parentId] && parentId !== rootValue) {
                    parentIdMap[parentId] = true;
                    parentIds.push(parentId)
                }
            }
            return {
                parentIdMap: parentIdMap,
                parentIds: parentIds
            }
        },
        _loadParents: function(data, options) {
            var store, filter, filterLength, needLocalFiltering, that = this,
                parentInfo = that._generateParentInfoToLoad(data),
                parentIds = parentInfo.parentIds,
                parentIdMap = parentInfo.parentIdMap,
                d = $.Deferred(),
                isRemoteFiltering = options.remoteOperations.filtering,
                maxFilterLengthInRequest = that.option("maxFilterLengthInRequest"),
                loadOptions = isRemoteFiltering ? options.storeLoadOptions : options.loadOptions;
            if (!parentIds.length) {
                return d.resolve(data)
            }
            filter = that._createIdFilter(that.getKeyExpr(), parentIds);
            filterLength = encodeURI(JSON.stringify(filter)).length;
            if (filterLength > maxFilterLengthInRequest) {
                filter = function(itemData) {
                    return parentIdMap[that._keyGetter(itemData)]
                };
                needLocalFiltering = isRemoteFiltering
            }
            loadOptions = extend({}, loadOptions, {
                filter: !needLocalFiltering ? filter : null
            });
            store = options.fullData ? new ArrayStore(options.fullData) : that._dataSource.store();
            store.load(loadOptions).done(function(loadedData) {
                if (loadedData.length) {
                    if (needLocalFiltering) {
                        loadedData = query(loadedData).filter(filter).toArray()
                    }
                    that._loadParents(data.concat(loadedData), options).done(d.resolve).fail(d.reject)
                } else {
                    d.resolve(data)
                }
            }).fail(d.reject);
            return d
        },
        _updateHasItemsMap: function(options) {
            var data = options.data,
                parentIds = options.storeLoadOptions.parentIds;
            if (parentIds) {
                for (var i = 0; i < parentIds.length; i++) {
                    for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {
                        var parentId = this._parentIdGetter(data[dataIndex]);
                        if (parentId === parentIds[i]) {
                            this._hasItemsMap[parentIds[i]] = true;
                            break
                        }
                    }
                    if (dataIndex === data.length) {
                        this._hasItemsMap[parentIds[i]] = false
                    }
                }
            }
        },
        _handleDataLoaded: function(options) {
            options.data = this._convertDataToPlainStructure(options.data);
            if (!options.remoteOperations.filtering) {
                options.fullData = options.data
            }
            this._updateHasItemsMap(options);
            this.callBase(options)
        },
        _fillNodes: function(nodes, options, expandedRowKeys, level) {
            level = level || 0;
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                this._fillNodes(nodes[i].children, options, expandedRowKeys, level + 1);
                node.level = level;
                node.hasChildren = this._calculateHasItems(node, options);
                if (node.visible && node.hasChildren && options.expandVisibleNodes) {
                    expandedRowKeys.push(node.key)
                }
                if (node.visible || node.hasChildren) {
                    node.parent.hasChildren = true
                }
            }
        },
        _processTreeStructure: function(options, visibleItems) {
            var data = options.data,
                expandedRowKeys = [];
            if (!options.fullData || this._isReload) {
                if (options.fullData && options.fullData.length > options.data.length) {
                    data = options.fullData;
                    visibleItems = visibleItems || options.data
                }
                this._rootNode = this._createNodesByItems(data, visibleItems);
                if (!this._rootNode) {
                    options.data = $.Deferred().reject(errors.Error("E1046", this.getKeyExpr()));
                    return
                }
                this._fillNodes(this._rootNode.children, options, expandedRowKeys);
                this._isNodesInitializing = true;
                if (expandedRowKeys.length) {
                    this.option("expandedRowKeys", expandedRowKeys)
                }
                this.executeAction("onNodesInitialized", {
                    root: this._rootNode
                });
                this._isNodesInitializing = false;
                this._isReload = false
            }
            data = this._createVisibleItemsByNodes(this._rootNode.children, options);
            options.data = data;
            this._totalItemsCount = data.length
        },
        _handleDataLoadedCore: function(options) {
            var visibleItems, that = this,
                data = options.data,
                callBase = that.callBase,
                filter = options.storeLoadOptions.filter || options.loadOptions.filter,
                filterMode = that.option("filterMode");
            if (!options.isCustomLoading) {
                if (filter && !options.storeLoadOptions.parentIds && "standard" !== filterMode) {
                    var d = options.data = $.Deferred();
                    if ("smart" === filterMode) {
                        visibleItems = data
                    }
                    return that._loadParents(data, options).done(function(data) {
                        options.data = data;
                        that._processTreeStructure(options, visibleItems);
                        callBase.call(that, options);
                        d.resolve(options.data)
                    }).fail(d.reject)
                } else {
                    that._processTreeStructure(options)
                }
            }
            that.callBase(options)
        },
        init: function(dataSource, remoteOperations) {
            this.callBase.apply(this, arguments);
            var dataStructure = this.option("dataStructure");
            this._keyGetter = this._createKeyGetter();
            this._parentIdGetter = this._createParentIdGetter();
            this._hasItemsGetter = this._createHasItemsGetter();
            if ("tree" === dataStructure) {
                this._itemsGetter = this._createItemsGetter();
                this._keySetter = this._createKeySetter();
                this._parentIdSetter = this.createParentIdSetter()
            }
            this._nodeByKey = {};
            this._hasItemsMap = {};
            this._totalItemsCount = 0;
            this.createAction("onNodesInitialized")
        },
        getKeyExpr: function() {
            var store = this.store(),
                key = store && store.key(),
                keyExpr = this.option("keyExpr");
            if (commonUtils.isDefined(key) && commonUtils.isDefined(keyExpr)) {
                if (!commonUtils.equalByValue(key, keyExpr)) {
                    throw errors.Error("E1044")
                }
            }
            return key || keyExpr || DEFAULT_KEY_EXPRESSION
        },
        keyOf: function(data) {
            return this._keyGetter && this._keyGetter(data)
        },
        getRootNode: function() {
            return this._rootNode
        },
        totalItemsCount: function() {
            return this._totalItemsCount
        },
        isRowExpanded: function(key) {
            var indexExpandedNodeKey = gridCoreUtils.getIndexByKey(key, this.option("expandedRowKeys"), null);
            return indexExpandedNodeKey >= 0
        },
        _changeRowExpandCore: function(key) {
            var expandedRowKeys = this.option("expandedRowKeys"),
                indexExpandedNodeKey = gridCoreUtils.getIndexByKey(key, expandedRowKeys, null);
            if (indexExpandedNodeKey < 0) {
                expandedRowKeys.push(key)
            } else {
                expandedRowKeys.splice(indexExpandedNodeKey, 1)
            }
            this.option("expandedRowKeys", expandedRowKeys)
        },
        changeRowExpand: function(key) {
            this._changeRowExpandCore(key);
            return this._isNodesInitializing ? $.Deferred().resolve() : this.load()
        },
        getNodeByKey: function(key) {
            if (this._nodeByKey) {
                return this._nodeByKey[key]
            }
        }
    }
}());
module.exports = {
    extend: function(extender) {
        DataSourceAdapter = DataSourceAdapter.inherit(extender)
    },
    create: function(component) {
        return new DataSourceAdapter(component)
    }
};


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (viz/export.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(418);


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Comment lines below for the widgets you don't require and run "devextreme-bundler" in this directory, then include dx.custom.js in your project */

/* Core (dx.module-core.js) */

var DevExpress = __webpack_require__(82);

/* Framework (dx.module-framework.js) */

DevExpress.framework = __webpack_require__(255);

/* Integrations (dx.module-core.js) */

//require("devextreme/integration/angular");
__webpack_require__(90);

__webpack_require__(95);
__webpack_require__(264);
__webpack_require__(145);
__webpack_require__(265);
__webpack_require__(266);

/* Events (dx.module-core.js) */

__webpack_require__(11);
__webpack_require__(146);
__webpack_require__(182);
__webpack_require__(76);
__webpack_require__(66);
__webpack_require__(113);
__webpack_require__(17);
__webpack_require__(118);
__webpack_require__(267);


/* Data (dx.module-core.js) */

var data = DevExpress.data = __webpack_require__(183);

data.odata = __webpack_require__(272);


/* UI core (dx.module-core.js) */

var ui = DevExpress.ui = __webpack_require__(274);

ui.themes = __webpack_require__(20);

ui.setTemplateEngine = __webpack_require__(275);

ui.dialog = __webpack_require__(187);
ui.notify = __webpack_require__(280);

/* Base widgets (dx.module-widgets-base.js) */

//ui.dxActionSheet = require("devextreme/ui/action_sheet");
ui.dxAutocomplete = __webpack_require__(281);
//ui.dxBox = require("devextreme/ui/box");
ui.dxButton = __webpack_require__(25);
//ui.dxCalendar = require("devextreme/ui/calendar");
ui.dxCheckBox = __webpack_require__(99);
ui.dxColorBox = __webpack_require__(304);
ui.dxDateBox = __webpack_require__(153);
ui.dxDeferRendering = __webpack_require__(323);
ui.dxDropDownBox = __webpack_require__(324);
ui.dxDropDownMenu = __webpack_require__(155);
ui.dxFileUploader = __webpack_require__(325);
//ui.dxForm = require("devextreme/ui/form");
//ui.dxGallery = require("devextreme/ui/gallery");
ui.dxList = __webpack_require__(79);
ui.dxLoadIndicator = __webpack_require__(53);
ui.dxLoadPanel = __webpack_require__(151);
ui.dxLookup = __webpack_require__(327);
//ui.dxMap = require("devextreme/ui/map");
//ui.dxMultiView = require("devextreme/ui/multi_view");
//ui.dxNavBar = require("devextreme/ui/nav_bar");
ui.dxNumberBox = __webpack_require__(81);
ui.dxOverlay = __webpack_require__(39);
ui.dxPopover = __webpack_require__(98);
//ui.dxPopup = require("devextreme/ui/popup");
ui.dxProgressBar = __webpack_require__(202);
ui.dxRadioGroup = __webpack_require__(328);
//ui.dxRangeSlider = require("devextreme/ui/range_slider");
ui.dxResizable = __webpack_require__(174);
ui.dxResponsiveBox = __webpack_require__(203);
ui.dxScrollView = __webpack_require__(197);
ui.dxSelectBox = __webpack_require__(128);
//ui.dxSlider = require("devextreme/ui/slider");
ui.dxSwitch = __webpack_require__(330);
ui.dxTabPanel = __webpack_require__(204);
ui.dxTabs = __webpack_require__(205);
ui.dxTagBox = __webpack_require__(333);
ui.dxTextArea = __webpack_require__(334);
ui.dxTextBox = __webpack_require__(69);
//ui.dxTileView = require("devextreme/ui/tile_view");
ui.dxToast = __webpack_require__(191);
ui.dxToolbar = __webpack_require__(206);
ui.dxTooltip = __webpack_require__(208);
//ui.dxTrackBar = require("devextreme/ui/track_bar");

/* Validation (dx.module-widgets-base.js) */

DevExpress.validationEngine = __webpack_require__(58);
ui.dxValidationSummary = __webpack_require__(157);
ui.dxValidationGroup = __webpack_require__(211);
ui.dxValidator = __webpack_require__(129);


/* Mobile widgets (dx.module-widgets-mobile.js) */

//ui.dxPanorama = require("devextreme/ui/panorama");
//ui.dxPivot = require("devextreme/ui/pivot");
//ui.dxSlideOut = require("devextreme/ui/slide_out");
//ui.dxSlideOutView = require("devextreme/ui/slide_out_view");


/* Web widgets (dx.module-widgets-web.js) */

ui.dxAccordion = __webpack_require__(341);
ui.dxContextMenu = __webpack_require__(130);
ui.dxDataGrid = __webpack_require__(346);
ui.dxTreeList = __webpack_require__(391);
ui.dxMenu = __webpack_require__(234);
//ui.dxPivotGrid = require("devextreme/ui/pivot_grid");
//ui.dxPivotGridFieldChooser = require("devextreme/ui/pivot_grid_field_chooser");
//data.PivotGridDataSource = require("devextreme/ui/pivot_grid/data_source");
//data.XmlaStore = require("devextreme/ui/pivot_grid/xmla_store");
//ui.dxScheduler = require("devextreme/ui/scheduler");
ui.dxTreeView = __webpack_require__(132);


/* Viz core (dx.module-viz-core.js) */

var viz = DevExpress.viz = __webpack_require__(417);
viz.currentTheme = __webpack_require__(158).currentTheme;
viz.registerTheme = __webpack_require__(158).registerTheme;
viz.exportFromMarkup = __webpack_require__(242).exportFromMarkup;
viz.getMarkup = __webpack_require__(242).getMarkup;
viz.currentPalette = __webpack_require__(160).currentPalette;
viz.getPalette = __webpack_require__(160).getPalette;
viz.registerPalette = __webpack_require__(160).registerPalette;
viz.refreshTheme = __webpack_require__(158).refreshTheme;

/* Charts (dx.module-viz-charts.js) */
//viz.dxChart = require("devextreme/viz/chart");
//viz.dxPieChart = require("devextreme/viz/pie_chart");
//viz.dxPolarChart = require("devextreme/viz/polar_chart");

/* Gauges (dx.module-viz-gauges.js) */
//viz.dxLinearGauge = require("devextreme/viz/linear_gauge");
//viz.dxCircularGauge = require("devextreme/viz/circular_gauge");
//viz.dxBarGauge = require("devextreme/viz/bar_gauge");

/* Range selector (dx.module-viz-rangeselector.js) */
//viz.dxRangeSelector = require("devextreme/viz/range_selector");

/* Vector map (dx.module-viz-vectormap.js) */
//viz.dxVectorMap = require("devextreme/viz/vector_map");
//viz.map = {};
//viz.map.sources = {};
//viz.map.projection = require("devextreme/viz/vector_map/projection").projection;

/* Sparklines (dx.module-viz-sparklines.js) */
//viz.dxSparkline = require("devextreme/viz/sparkline");
//viz.dxBullet = require("devextreme/viz/bullet");

/* Treemap */
//viz.dxTreeMap = require("devextreme/viz/tree_map");


/* Utilities for integration with ASP.NET */
/* DevExpress.aspnet = require("devextreme/aspnet"); */


/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = window.JSZip;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/language_codes.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var locale = __webpack_require__(60).locale,
    LANGUAGE_CODES = {
        ar: 1,
        bg: 2,
        ca: 3,
        "zh-Hans": 4,
        cs: 5,
        da: 6,
        de: 7,
        el: 8,
        en: 9,
        es: 10,
        fi: 11,
        fr: 12,
        he: 13,
        hu: 14,
        is: 15,
        it: 16,
        ja: 17,
        ko: 18,
        nl: 19,
        no: 20,
        pl: 21,
        pt: 22,
        rm: 23,
        ro: 24,
        ru: 25,
        hr: 26,
        sk: 27,
        sq: 28,
        sv: 29,
        th: 30,
        tr: 31,
        ur: 32,
        id: 33,
        uk: 34,
        be: 35,
        sl: 36,
        et: 37,
        lv: 38,
        lt: 39,
        tg: 40,
        fa: 41,
        vi: 42,
        hy: 43,
        az: 44,
        eu: 45,
        hsb: 46,
        mk: 47,
        tn: 50,
        xh: 52,
        zu: 53,
        af: 54,
        ka: 55,
        fo: 56,
        hi: 57,
        mt: 58,
        se: 59,
        ga: 60,
        ms: 62,
        kk: 63,
        ky: 64,
        sw: 65,
        tk: 66,
        uz: 67,
        tt: 68,
        bn: 69,
        pa: 70,
        gu: 71,
        or: 72,
        ta: 73,
        te: 74,
        kn: 75,
        ml: 76,
        as: 77,
        mr: 78,
        sa: 79,
        mn: 80,
        bo: 81,
        cy: 82,
        km: 83,
        lo: 84,
        gl: 86,
        kok: 87,
        syr: 90,
        si: 91,
        iu: 93,
        am: 94,
        tzm: 95,
        ne: 97,
        fy: 98,
        ps: 99,
        fil: 100,
        dv: 101,
        ha: 104,
        yo: 106,
        quz: 107,
        nso: 108,
        ba: 109,
        lb: 110,
        kl: 111,
        ig: 112,
        ii: 120,
        arn: 122,
        moh: 124,
        br: 126,
        ug: 128,
        mi: 129,
        oc: 130,
        co: 131,
        gsw: 132,
        sah: 133,
        qut: 134,
        rw: 135,
        wo: 136,
        prs: 140,
        gd: 145,
        "ar-SA": 1025,
        "bg-BG": 1026,
        "ca-ES": 1027,
        "zh-TW": 1028,
        "cs-CZ": 1029,
        "da-DK": 1030,
        "de-DE": 1031,
        "el-GR": 1032,
        "en-US": 1033,
        "fi-FI": 1035,
        "fr-FR": 1036,
        "he-IL": 1037,
        "hu-HU": 1038,
        "is-IS": 1039,
        "it-IT": 1040,
        "ja-JP": 1041,
        "ko-KR": 1042,
        "nl-NL": 1043,
        "nb-NO": 1044,
        "pl-PL": 1045,
        "pt-BR": 1046,
        "rm-CH": 1047,
        "ro-RO": 1048,
        "ru-RU": 1049,
        "hr-HR": 1050,
        "sk-SK": 1051,
        "sq-AL": 1052,
        "sv-SE": 1053,
        "th-TH": 1054,
        "tr-TR": 1055,
        "ur-PK": 1056,
        "id-ID": 1057,
        "uk-UA": 1058,
        "be-BY": 1059,
        "sl-SI": 1060,
        "et-EE": 1061,
        "lv-LV": 1062,
        "lt-LT": 1063,
        "tg-Cyrl-TJ": 1064,
        "fa-IR": 1065,
        "vi-VN": 1066,
        "hy-AM": 1067,
        "az-Latn-AZ": 1068,
        "eu-ES": 1069,
        "hsb-DE": 1070,
        "mk-MK": 1071,
        "tn-ZA": 1074,
        "xh-ZA": 1076,
        "zu-ZA": 1077,
        "af-ZA": 1078,
        "ka-GE": 1079,
        "fo-FO": 1080,
        "hi-IN": 1081,
        "mt-MT": 1082,
        "se-NO": 1083,
        "ms-MY": 1086,
        "kk-KZ": 1087,
        "ky-KG": 1088,
        "sw-KE": 1089,
        "tk-TM": 1090,
        "uz-Latn-UZ": 1091,
        "tt-RU": 1092,
        "bn-IN": 1093,
        "pa-IN": 1094,
        "gu-IN": 1095,
        "or-IN": 1096,
        "ta-IN": 1097,
        "te-IN": 1098,
        "kn-IN": 1099,
        "ml-IN": 1100,
        "as-IN": 1101,
        "mr-IN": 1102,
        "sa-IN": 1103,
        "mn-MN": 1104,
        "bo-CN": 1105,
        "cy-GB": 1106,
        "km-KH": 1107,
        "lo-LA": 1108,
        "gl-ES": 1110,
        "kok-IN": 1111,
        "syr-SY": 1114,
        "si-LK": 1115,
        "iu-Cans-CA": 1117,
        "am-ET": 1118,
        "ne-NP": 1121,
        "fy-NL": 1122,
        "ps-AF": 1123,
        "fil-PH": 1124,
        "dv-MV": 1125,
        "ha-Latn-NG": 1128,
        "yo-NG": 1130,
        "quz-BO": 1131,
        "nso-ZA": 1132,
        "ba-RU": 1133,
        "lb-LU": 1134,
        "kl-GL": 1135,
        "ig-NG": 1136,
        "ii-CN": 1144,
        "arn-CL": 1146,
        "moh-CA": 1148,
        "br-FR": 1150,
        "ug-CN": 1152,
        "mi-NZ": 1153,
        "oc-FR": 1154,
        "co-FR": 1155,
        "gsw-FR": 1156,
        "sah-RU": 1157,
        "qut-GT": 1158,
        "rw-RW": 1159,
        "wo-SN": 1160,
        "prs-AF": 1164,
        "gd-GB": 1169,
        "ar-IQ": 2049,
        "zh-CN": 2052,
        "de-CH": 2055,
        "en-GB": 2057,
        "es-MX": 2058,
        "fr-BE": 2060,
        "it-CH": 2064,
        "nl-BE": 2067,
        "nn-NO": 2068,
        "pt-PT": 2070,
        "sr-Latn-CS": 2074,
        "sv-FI": 2077,
        "az-Cyrl-AZ": 2092,
        "dsb-DE": 2094,
        "se-SE": 2107,
        "ga-IE": 2108,
        "ms-BN": 2110,
        "uz-Cyrl-UZ": 2115,
        "bn-BD": 2117,
        "mn-Mong-CN": 2128,
        "iu-Latn-CA": 2141,
        "tzm-Latn-DZ": 2143,
        "quz-EC": 2155,
        "ar-EG": 3073,
        "zh-HK": 3076,
        "de-AT": 3079,
        "en-AU": 3081,
        "es-ES": 3082,
        "fr-CA": 3084,
        "sr-Cyrl-CS": 3098,
        "se-FI": 3131,
        "quz-PE": 3179,
        "ar-LY": 4097,
        "zh-SG": 4100,
        "de-LU": 4103,
        "en-CA": 4105,
        "es-GT": 4106,
        "fr-CH": 4108,
        "hr-BA": 4122,
        "smj-NO": 4155,
        "ar-DZ": 5121,
        "zh-MO": 5124,
        "de-LI": 5127,
        "en-NZ": 5129,
        "es-CR": 5130,
        "fr-LU": 5132,
        "bs-Latn-BA": 5146,
        "smj-SE": 5179,
        "ar-MA": 6145,
        "en-IE": 6153,
        "es-PA": 6154,
        "fr-MC": 6156,
        "sr-Latn-BA": 6170,
        "sma-NO": 6203,
        "ar-TN": 7169,
        "en-ZA": 7177,
        "es-DO": 7178,
        "sr-Cyrl-BA": 7194,
        "sma-SE": 7227,
        "ar-OM": 8193,
        "en-JM": 8201,
        "es-VE": 8202,
        "bs-Cyrl-BA": 8218,
        "sms-FI": 8251,
        "ar-YE": 9217,
        "en-029": 9225,
        "es-CO": 9226,
        "sr-Latn-RS": 9242,
        "smn-FI": 9275,
        "ar-SY": 10241,
        "en-BZ": 10249,
        "es-PE": 10250,
        "sr-Cyrl-RS": 10266,
        "ar-JO": 11265,
        "en-TT": 11273,
        "es-AR": 11274,
        "sr-Latn-ME": 11290,
        "ar-LB": 12289,
        "en-ZW": 12297,
        "es-EC": 12298,
        "sr-Cyrl-ME": 12314,
        "ar-KW": 13313,
        "en-PH": 13321,
        "es-CL": 13322,
        "ar-AE": 14337,
        "es-UY": 14346,
        "ar-BH": 15361,
        "es-PY": 15370,
        "ar-QA": 16385,
        "en-IN": 16393,
        "es-BO": 16394,
        "en-MY": 17417,
        "es-SV": 17418,
        "en-SG": 18441,
        "es-HN": 18442,
        "es-NI": 19466,
        "es-PR": 20490,
        "es-US": 21514,
        "bs-Cyrl": 25626,
        "bs-Latn": 26650,
        "sr-Cyrl": 27674,
        "sr-Latn": 28698,
        smn: 28731,
        "az-Cyrl": 29740,
        sms: 29755,
        zh: 30724,
        nn: 30740,
        bs: 30746,
        "az-Latn": 30764,
        sma: 30779,
        "uz-Cyrl": 30787,
        "mn-Cyrl": 30800,
        "iu-Cans": 30813,
        "zh-Hant": 31748,
        nb: 31764,
        sr: 31770,
        "tg-Cyrl": 31784,
        dsb: 31790,
        smj: 31803,
        "uz-Latn": 31811,
        "mn-Mong": 31824,
        "iu-Latn": 31837,
        "tzm-Latn": 31839,
        "ha-Latn": 31848
    };
exports.getLanguageId = function() {
    return LANGUAGE_CODES[locale()]
};


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (client_exporter/pdf_creator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    VERSION = __webpack_require__(104),
    imageCreator = __webpack_require__(134).imageCreator,
    isFunction = __webpack_require__(2).isFunction,
    extend = __webpack_require__(1).extend,
    when = __webpack_require__(10).when,
    mainPageTemplate = "%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n",
    contentTemplate = "3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n",
    infoTemplate = "6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n",
    imageStartTemplate = "5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n",
    imageEndTemplate = "\r\nendstream\r\nendobj\r\n",
    trailerTemplate = "trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF",
    xrefTemplate = "xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n",
    DEFAULT_MARGIN_X = 60,
    DEFAULT_MARGIN_Y = 40;
var pad = function(str, len) {
    return str.length < len ? pad("0" + str, len) : str
};
var composePdfString = function(imageString, options, curDate) {
    var width = options.width + DEFAULT_MARGIN_X,
        height = options.height + DEFAULT_MARGIN_Y,
        widthPt = (.75 * width).toFixed(2),
        heightPt = (.75 * height).toFixed(2);
    var mainPage = mainPageTemplate.replace("_width_", widthPt).replace("_height_", heightPt),
        content = contentTemplate.replace("_width_", widthPt).replace("_height_", heightPt),
        info = infoTemplate.replace("_date_", curDate).replace("_version_", VERSION),
        image = imageStartTemplate.replace("_width_", width).replace("_height_", height).replace("_length_", imageString.length) + imageString + imageEndTemplate,
        xref = getXref(mainPage.length, content.length, info.length);
    var mainContent = mainPage + content + info + image,
        trailer = trailerTemplate.replace("_length_", mainContent.length);
    return mainContent + xref + trailer
};
var getXref = function(mainPageLength, contentLength, infoLength) {
    return xrefTemplate.replace("_main_", pad(mainPageLength + "", 10)).replace("_info_", pad(mainPageLength + contentLength + "", 10)).replace("_image_", pad(mainPageLength + contentLength + infoLength + "", 10))
};
var getCurDate = function() {
    return new Date
};
var getBlob = function(binaryData) {
    var i = 0,
        dataArray = new Uint8Array(binaryData.length);
    for (; i < binaryData.length; i++) {
        dataArray[i] = binaryData.charCodeAt(i)
    }
    return new Blob([dataArray.buffer], {
        type: "application/pdf"
    })
};
var getBase64 = function(binaryData) {
    return window.btoa(binaryData)
};
exports.getData = function(data, options, callback) {
    var imageData = imageCreator.getImageData(data, extend({}, options, {
            format: "jpeg"
        })),
        blob = $.Deferred();
    blob.done(callback);
    when(imageData).done(function(imageString) {
        var binaryData = composePdfString(imageString, options, getCurDate()),
            pdfData = isFunction(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
        blob.resolve(pdfData)
    })
};


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/svg.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function getMarkup(element) {
    var temp = document.createElement("div");
    temp.appendChild(element.cloneNode(true));
    return temp.innerHTML
}

function fixIENamespaces(markup) {
    var first = true;
    markup = markup.replace(/xmlns="[\s\S]*?"/gi, function(match) {
        if (!first) {
            return ""
        }
        first = false;
        return match
    });
    return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, "").replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"')
}

function decodeHtmlEntities(markup) {
    return markup.replace(/&quot;/gi, "&#34;").replace(/&amp;/gi, "&#38;").replace(/&apos;/gi, "&#39;").replace(/&lt;/gi, "&#60;").replace(/&gt;/gi, "&#62;").replace(/&nbsp;/gi, "&#160;").replace(/&shy;/gi, "&#173;")
}
exports.getSvgMarkup = function(element) {
    return fixIENamespaces(decodeHtmlEntities(getMarkup(element)))
};


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/polyfills/weak_map.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var inArray = __webpack_require__(7).inArray,
    WeakMap = window.WeakMap;
if (!WeakMap) {
    WeakMap = function() {
        var keys = [],
            values = [];
        this.set = function(key, value) {
            var index = inArray(key, keys);
            if (index === -1) {
                keys.push(key);
                values.push(value)
            } else {
                values[index] = value
            }
        };
        this.get = function(key) {
            var index = inArray(key, keys);
            if (index === -1) {
                return
            }
            return values[index]
        };
        this.has = function(key) {
            var index = inArray(key, keys);
            if (index === -1) {
                return false
            }
            return true
        }
    }
}
module.exports = WeakMap;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/events_strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    isFunction = __webpack_require__(2).isFunction,
    Class = __webpack_require__(5);
module.exports = Class.inherit({
    ctor: function(owner) {
        this._events = {};
        this._owner = owner
    },
    hasEvent: function(eventName) {
        var callbacks = this._events[eventName];
        if (callbacks) {
            return callbacks.has()
        }
        return false
    },
    fireEvent: function(eventName, eventArgs) {
        var callbacks = this._events[eventName];
        if (callbacks) {
            callbacks.fireWith(this._owner, eventArgs)
        }
    },
    on: function(eventName, eventHandler) {
        var addFn, callbacks = this._events[eventName];
        if (!callbacks) {
            callbacks = $.Callbacks();
            this._events[eventName] = callbacks
        }
        addFn = callbacks.originalAdd || callbacks.add;
        addFn.call(callbacks, eventHandler)
    },
    off: function(eventName, eventHandler) {
        var callbacks = this._events[eventName];
        if (callbacks) {
            if (isFunction(eventHandler)) {
                callbacks.remove(eventHandler)
            } else {
                callbacks.empty()
            }
        }
    },
    dispose: function() {
        $.each(this._events, function() {
            this.empty()
        })
    }
});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/core/hooks.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    compareVersion = __webpack_require__(37).compare,
    isNumeric = __webpack_require__(2).isNumeric,
    registerEvent = __webpack_require__(47);
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name, event) {
    if (event[name] || !event.touches) {
        return event[name]
    }
    var touches = event.touches.length ? event.touches : event.changedTouches;
    if (!touches.length) {
        return
    }
    return touches[0][name]
};
if (compareVersion($.fn.jquery, [3]) < 0) {
    var POINTER_TYPE_MAP = {
        2: "touch",
        3: "pen",
        4: "mouse"
    };
    $.each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
        $.event.fixHooks[this] = {
            filter: function(event, originalEvent) {
                var pointerType = originalEvent.pointerType;
                if (isNumeric(pointerType)) {
                    event.pointerType = POINTER_TYPE_MAP[pointerType]
                }
                return event
            },
            props: $.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
        }
    });
    $.each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
        $.event.fixHooks[this] = {
            filter: function(event, originalEvent) {
                $.each(touchPropsToHook, function(_, name) {
                    event[name] = touchPropHook(name, originalEvent)
                });
                return event
            },
            props: $.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
        }
    });
    $.event.fixHooks.wheel = $.event.mouseHooks;
    var DX_EVENT_HOOKS = {
        props: $.event.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])
    };
    registerEvent.callbacks.add(function(name) {
        $.event.fixHooks[name] = DX_EVENT_HOOKS
    });
    var fix = function(event, originalEvent) {
        var fixHook = $.event.fixHooks[originalEvent.type] || $.event.mouseHooks;
        var props = fixHook.props ? $.event.props.concat(fixHook.props) : $.event.props,
            propIndex = props.length;
        while (propIndex--) {
            var prop = props[propIndex];
            event[prop] = originalEvent[prop]
        }
        return fixHook.filter ? fixHook.filter(event, originalEvent) : event
    };
    exports.copy = function(originalEvent) {
        return fix($.Event(originalEvent.type, originalEvent), originalEvent)
    }
} else {
    $.each(touchPropsToHook, function(_, name) {
        $.event.addProp(name, function(event) {
            return touchPropHook(name, event)
        })
    });
    exports.copy = function(originalEvent) {
        return $.Event(originalEvent, originalEvent)
    }
}


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/mspointer.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var BaseStrategy = __webpack_require__(110),
    Observer = __webpack_require__(170),
    extend = __webpack_require__(1).extend,
    onlyMSPointerSupport = !window.PointerEvent && window.MSPointerEvent;
var eventMap = {
    dxpointerdown: onlyMSPointerSupport ? "MSPointerDown" : "pointerdown",
    dxpointermove: onlyMSPointerSupport ? "MSPointerMove" : "pointermove",
    dxpointerup: onlyMSPointerSupport ? "MSPointerUp" : "pointerup",
    dxpointercancel: onlyMSPointerSupport ? "MSPointerCancel" : "pointercancel",
    dxpointerover: onlyMSPointerSupport ? "MSPointerOver" : "pointerover",
    dxpointerout: onlyMSPointerSupport ? "MSPointerOut" : "pointerout",
    dxpointerenter: onlyMSPointerSupport ? "mouseenter" : "pointerenter",
    dxpointerleave: onlyMSPointerSupport ? "mouseleave" : "pointerleave"
};
var observer;
var activated = false;
var activateStrategy = function() {
    if (activated) {
        return
    }
    observer = new Observer(eventMap, function(a, b) {
        return a.pointerId === b.pointerId
    }, function(e) {
        if (e.isPrimary) {
            observer.reset()
        }
    });
    activated = true
};
var MsPointerStrategy = BaseStrategy.inherit({
    ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy()
    },
    _fireEvent: function(args) {
        return this.callBase(extend({
            pointers: observer.pointers(),
            pointerId: args.originalEvent.pointerId
        }, args))
    }
});
MsPointerStrategy.map = eventMap;
MsPointerStrategy.resetObserver = function() {
    observer.reset()
};
module.exports = MsPointerStrategy;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/pointer/mouse_and_touch.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    BaseStrategy = __webpack_require__(110),
    MouseStrategy = __webpack_require__(171),
    TouchStrategy = __webpack_require__(169),
    eventUtils = __webpack_require__(3);
var eventMap = {
    dxpointerdown: "touchstart mousedown",
    dxpointermove: "touchmove mousemove",
    dxpointerup: "touchend mouseup",
    dxpointercancel: "touchcancel",
    dxpointerover: "mouseover",
    dxpointerout: "mouseout",
    dxpointerenter: "mouseenter",
    dxpointerleave: "mouseleave"
};
var activated = false;
var activateStrategy = function() {
    if (activated) {
        return
    }
    MouseStrategy.activate();
    activated = true
};
var MouseAndTouchStrategy = BaseStrategy.inherit({
    EVENT_LOCK_TIMEOUT: 100,
    ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy()
    },
    _handler: function(e) {
        var isMouseEvent = eventUtils.isMouseEvent(e);
        if (!isMouseEvent) {
            this._skipNextEvents = true
        }
        if (isMouseEvent && this._mouseLocked) {
            return
        }
        if (isMouseEvent && this._skipNextEvents) {
            this._skipNextEvents = false;
            this._mouseLocked = true;
            clearTimeout(this._unlockMouseTimer);
            var that = this;
            this._unlockMouseTimer = setTimeout(function() {
                that._mouseLocked = false
            }, this.EVENT_LOCK_TIMEOUT);
            return
        }
        return this.callBase(e)
    },
    _fireEvent: function(args) {
        var isMouseEvent = eventUtils.isMouseEvent(args.originalEvent),
            normalizer = isMouseEvent ? MouseStrategy.normalize : TouchStrategy.normalize;
        return this.callBase(extend(normalizer(args.originalEvent), args))
    },
    dispose: function() {
        this.callBase();
        this._skipNextEvents = false;
        this._mouseLocked = false;
        clearTimeout(this._unlockMouseTimer)
    }
});
MouseAndTouchStrategy.map = eventMap;
MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
module.exports = MouseAndTouchStrategy;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.locale = __webpack_require__(60).locale;
exports.loadMessages = __webpack_require__(8).load;
exports.message = __webpack_require__(8);
exports.number = __webpack_require__(44);
exports.date = __webpack_require__(32);
exports.currency = __webpack_require__(105);


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/default_messages.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = {
    en: {
        Yes: "Yes",
        No: "No",
        Cancel: "Cancel",
        Clear: "Clear",
        Done: "Done",
        Loading: "Loading...",
        Select: "Select...",
        Search: "Search",
        Back: "Back",
        OK: "OK",
        "dxCollectionWidget-noDataText": "No data to display",
        "validation-required": "Required",
        "validation-required-formatted": "{0} is required",
        "validation-numeric": "Value must be a number",
        "validation-numeric-formatted": "{0} must be a number",
        "validation-range": "Value is out of range",
        "validation-range-formatted": "{0} is out of range",
        "validation-stringLength": "The length of the value is not correct",
        "validation-stringLength-formatted": "The length of {0} is not correct",
        "validation-custom": "Value is invalid",
        "validation-custom-formatted": "{0} is invalid",
        "validation-compare": "Values do not match",
        "validation-compare-formatted": "{0} does not match",
        "validation-pattern": "Value does not match pattern",
        "validation-pattern-formatted": "{0} does not match pattern",
        "validation-email": "Email is invalid",
        "validation-email-formatted": "{0} is invalid",
        "validation-mask": "Value is invalid",
        "dxLookup-searchPlaceholder": "Minimum character number: {0}",
        "dxList-pullingDownText": "Pull down to refresh...",
        "dxList-pulledDownText": "Release to refresh...",
        "dxList-refreshingText": "Refreshing...",
        "dxList-pageLoadingText": "Loading...",
        "dxList-nextButtonText": "More",
        "dxList-selectAll": "Select All",
        "dxListEditDecorator-delete": "Delete",
        "dxListEditDecorator-more": "More",
        "dxScrollView-pullingDownText": "Pull down to refresh...",
        "dxScrollView-pulledDownText": "Release to refresh...",
        "dxScrollView-refreshingText": "Refreshing...",
        "dxScrollView-reachBottomText": "Loading...",
        "dxDateBox-simulatedDataPickerTitleTime": "Select time",
        "dxDateBox-simulatedDataPickerTitleDate": "Select date",
        "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
        "dxDateBox-validation-datetime": "Value must be a date or time",
        "dxFileUploader-selectFile": "Select file",
        "dxFileUploader-dropFile": "or Drop file here",
        "dxFileUploader-bytes": "bytes",
        "dxFileUploader-kb": "kb",
        "dxFileUploader-Mb": "Mb",
        "dxFileUploader-Gb": "Gb",
        "dxFileUploader-upload": "Upload",
        "dxFileUploader-uploaded": "Uploaded",
        "dxFileUploader-readyToUpload": "Ready to upload",
        "dxFileUploader-uploadFailedMessage": "Upload failed",
        "dxRangeSlider-ariaFrom": "From",
        "dxRangeSlider-ariaTill": "Till",
        "dxSwitch-onText": "ON",
        "dxSwitch-offText": "OFF",
        "dxForm-optionalMark": "optional",
        "dxForm-requiredMessage": "{0} is required",
        "dxNumberBox-invalidValueMessage": "Value must be a number",
        "dxDataGrid-columnChooserTitle": "Column Chooser",
        "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
        "dxDataGrid-groupContinuesMessage": "Continues on the next page",
        "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
        "dxDataGrid-groupHeaderText": "Group by This Column",
        "dxDataGrid-ungroupHeaderText": "Ungroup",
        "dxDataGrid-ungroupAllText": "Ungroup All",
        "dxDataGrid-editingEditRow": "Edit",
        "dxDataGrid-editingSaveRowChanges": "Save",
        "dxDataGrid-editingCancelRowChanges": "Cancel",
        "dxDataGrid-editingDeleteRow": "Delete",
        "dxDataGrid-editingUndeleteRow": "Undelete",
        "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
        "dxDataGrid-validationCancelChanges": "Cancel changes",
        "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
        "dxDataGrid-noDataText": "No data",
        "dxDataGrid-searchPanelPlaceholder": "Search...",
        "dxDataGrid-filterRowShowAllText": "(All)",
        "dxDataGrid-filterRowResetOperationText": "Reset",
        "dxDataGrid-filterRowOperationEquals": "Equals",
        "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
        "dxDataGrid-filterRowOperationLess": "Less than",
        "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
        "dxDataGrid-filterRowOperationGreater": "Greater than",
        "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
        "dxDataGrid-filterRowOperationStartsWith": "Starts with",
        "dxDataGrid-filterRowOperationContains": "Contains",
        "dxDataGrid-filterRowOperationNotContains": "Does not contain",
        "dxDataGrid-filterRowOperationEndsWith": "Ends with",
        "dxDataGrid-filterRowOperationBetween": "Between",
        "dxDataGrid-filterRowOperationBetweenStartText": "Start",
        "dxDataGrid-filterRowOperationBetweenEndText": "End",
        "dxDataGrid-applyFilterText": "Apply filter",
        "dxDataGrid-trueText": "true",
        "dxDataGrid-falseText": "false",
        "dxDataGrid-sortingAscendingText": "Sort Ascending",
        "dxDataGrid-sortingDescendingText": "Sort Descending",
        "dxDataGrid-sortingClearText": "Clear Sorting",
        "dxDataGrid-editingSaveAllChanges": "Save changes",
        "dxDataGrid-editingCancelAllChanges": "Discard changes",
        "dxDataGrid-editingAddRow": "Add a row",
        "dxDataGrid-summaryMin": "Min: {0}",
        "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
        "dxDataGrid-summaryMax": "Max: {0}",
        "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
        "dxDataGrid-summaryAvg": "Avg: {0}",
        "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
        "dxDataGrid-summarySum": "Sum: {0}",
        "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
        "dxDataGrid-summaryCount": "Count: {0}",
        "dxDataGrid-columnFixingFix": "Fix",
        "dxDataGrid-columnFixingUnfix": "Unfix",
        "dxDataGrid-columnFixingLeftPosition": "To the left",
        "dxDataGrid-columnFixingRightPosition": "To the right",
        "dxDataGrid-exportTo": "Export",
        "dxDataGrid-exportToExcel": "Export to Excel file",
        "dxDataGrid-excelFormat": "Excel file",
        "dxDataGrid-selectedRows": "Selected rows",
        "dxDataGrid-exportSelectedRows": "Export selected rows",
        "dxDataGrid-exportAll": "Export all data",
        "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
        "dxDataGrid-headerFilterOK": "OK",
        "dxDataGrid-headerFilterCancel": "Cancel",
        "dxDataGrid-ariaColumn": "Column",
        "dxDataGrid-ariaValue": "Value",
        "dxDataGrid-ariaFilterCell": "Filter cell",
        "dxDataGrid-ariaCollapse": "Collapse",
        "dxDataGrid-ariaExpand": "Expand",
        "dxDataGrid-ariaDataGrid": "Data grid",
        "dxDataGrid-ariaSearchInGrid": "Search in data grid",
        "dxDataGrid-ariaSelectAll": "Select all",
        "dxDataGrid-ariaSelectRow": "Select row",
        "dxTreeList-ariaTreeList": "Tree list",
        "dxTreeList-editingAddRowToNode": "Add",
        "dxPager-infoText": "Page {0} of {1} ({2} items)",
        "dxPager-pagesCountText": "of",
        "dxPivotGrid-grandTotal": "Grand Total",
        "dxPivotGrid-total": "{0} Total",
        "dxPivotGrid-fieldChooserTitle": "Field Chooser",
        "dxPivotGrid-showFieldChooser": "Show Field Chooser",
        "dxPivotGrid-expandAll": "Expand All",
        "dxPivotGrid-collapseAll": "Collapse All",
        "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
        "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
        "dxPivotGrid-removeAllSorting": "Remove All Sorting",
        "dxPivotGrid-dataNotAvailable": "N/A",
        "dxPivotGrid-rowFields": "Row Fields",
        "dxPivotGrid-columnFields": "Column Fields",
        "dxPivotGrid-dataFields": "Data Fields",
        "dxPivotGrid-filterFields": "Filter Fields",
        "dxPivotGrid-allFields": "All Fields",
        "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
        "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
        "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
        "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
        "dxScheduler-editorLabelTitle": "Subject",
        "dxScheduler-editorLabelStartDate": "Start Date",
        "dxScheduler-editorLabelEndDate": "End Date",
        "dxScheduler-editorLabelDescription": "Description",
        "dxScheduler-editorLabelRecurrence": "Repeat",
        "dxScheduler-openAppointment": "Open appointment",
        "dxScheduler-recurrenceNever": "Never",
        "dxScheduler-recurrenceDaily": "Daily",
        "dxScheduler-recurrenceWeekly": "Weekly",
        "dxScheduler-recurrenceMonthly": "Monthly",
        "dxScheduler-recurrenceYearly": "Yearly",
        "dxScheduler-recurrenceEvery": "Every",
        "dxScheduler-recurrenceEnd": "End repeat",
        "dxScheduler-recurrenceAfter": "After",
        "dxScheduler-recurrenceOn": "On",
        "dxScheduler-recurrenceRepeatDaily": "day(s)",
        "dxScheduler-recurrenceRepeatWeekly": "week(s)",
        "dxScheduler-recurrenceRepeatMonthly": "month(s)",
        "dxScheduler-recurrenceRepeatYearly": "year(s)",
        "dxScheduler-switcherDay": "Day",
        "dxScheduler-switcherWeek": "Week",
        "dxScheduler-switcherWorkWeek": "Work Week",
        "dxScheduler-switcherMonth": "Month",
        "dxScheduler-switcherAgenda": "Agenda",
        "dxScheduler-switcherTimelineDay": "Timeline Day",
        "dxScheduler-switcherTimelineWeek": "Timeline Week",
        "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
        "dxScheduler-switcherTimelineMonth": "Timeline Month",
        "dxScheduler-recurrenceRepeatOnDate": "on date",
        "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
        "dxScheduler-allDay": "All day",
        "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
        "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
        "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
        "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
        "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
        "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
        "dxScheduler-noTimezoneTitle": "No timezone",
        "dxCalendar-todayButtonText": "Today",
        "dxCalendar-ariaWidgetName": "Calendar",
        "dxColorView-ariaRed": "Red",
        "dxColorView-ariaGreen": "Green",
        "dxColorView-ariaBlue": "Blue",
        "dxColorView-ariaAlpha": "Transparency",
        "dxColorView-ariaHex": "Color code",
        "vizExport-printingButtonText": "Print",
        "vizExport-titleMenuText": "Exporting/Printing",
        "vizExport-exportButtonText": "{0} file"
    }
};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/framework.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(82);
__webpack_require__(90);
module.exports = DevExpress.framework = {};
DevExpress.framework.dxCommand = __webpack_require__(139);
DevExpress.framework.Router = __webpack_require__(115);
DevExpress.framework.StateManager = __webpack_require__(140);
DevExpress.framework.ViewCache = __webpack_require__(65);
DevExpress.framework.NullViewCache = __webpack_require__(65).NullViewCache;
DevExpress.framework.ConditionalViewCacheDecorator = __webpack_require__(65).ConditionalViewCacheDecorator;
DevExpress.framework.CapacityViewCacheDecorator = __webpack_require__(65).CapacityViewCacheDecorator;
DevExpress.framework.HistoryDependentViewCacheDecorator = __webpack_require__(65).HistoryDependentViewCacheDecorator;
DevExpress.framework.dxCommandContainer = __webpack_require__(141);
DevExpress.framework.dxView = __webpack_require__(49).dxView;
DevExpress.framework.dxLayout = __webpack_require__(49).dxLayout;
DevExpress.framework.dxViewPlaceholder = __webpack_require__(49).dxViewPlaceholder;
DevExpress.framework.dxContentPlaceholder = __webpack_require__(49).dxContentPlaceholder;
DevExpress.framework.dxTransition = __webpack_require__(49).dxTransition;
DevExpress.framework.dxContent = __webpack_require__(49).dxContent;
DevExpress.framework.html = {};
DevExpress.framework.html.HtmlApplication = __webpack_require__(175);
DevExpress.framework.Route = __webpack_require__(115).Route;
DevExpress.framework.MemoryKeyValueStorage = __webpack_require__(140).MemoryKeyValueStorage;
DevExpress.framework.NavigationDevices = __webpack_require__(116);
DevExpress.framework.NavigationManager = __webpack_require__(94);
DevExpress.framework.createActionExecutors = __webpack_require__(177).createActionExecutors;
DevExpress.framework.Application = __webpack_require__(176).Application;
var browserAdapters = __webpack_require__(178);
DevExpress.framework.DefaultBrowserAdapter = browserAdapters.DefaultBrowserAdapter;
DevExpress.framework.OldBrowserAdapter = browserAdapters.OldBrowserAdapter;
DevExpress.framework.BuggyAndroidBrowserAdapter = browserAdapters.BuggyAndroidBrowserAdapter;
DevExpress.framework.HistorylessBrowserAdapter = browserAdapters.HistorylessBrowserAdapter;
DevExpress.framework.BuggyCordovaWP81BrowserAdapter = browserAdapters.BuggyCordovaWP81BrowserAdapter;
DevExpress.framework.CommandMapping = __webpack_require__(143);
DevExpress.framework.HistoryBasedNavigationDevice = __webpack_require__(116).HistoryBasedNavigationDevice;
DevExpress.framework.StackBasedNavigationDevice = __webpack_require__(116).StackBasedNavigationDevice;
DevExpress.framework.HistoryBasedNavigationManager = __webpack_require__(94).HistoryBasedNavigationManager;
DevExpress.framework.StackBasedNavigationManager = __webpack_require__(94).StackBasedNavigationManager;
DevExpress.framework.NavigationStack = __webpack_require__(94).NavigationStack;
DevExpress.framework.utils = __webpack_require__(93).utils;
DevExpress.framework.templateProvider = __webpack_require__(93).templateProvider;
DevExpress.framework.html.CommandManager = __webpack_require__(179);
DevExpress.framework.html.HtmlApplication = __webpack_require__(175);
DevExpress.framework.html.layoutSets = __webpack_require__(117).layoutSets;
DevExpress.framework.html.animationSets = __webpack_require__(117).animationSets;
DevExpress.framework.html.DefaultLayoutController = __webpack_require__(144).DefaultLayoutController;
DevExpress.framework.html.layoutSets = __webpack_require__(144).layoutSets;
DevExpress.framework.html.MarkupComponent = __webpack_require__(142).MarkupComponent;
DevExpress.framework.html.ViewEngine = __webpack_require__(181).ViewEngine;
DevExpress.framework.html.ViewEngineComponents = __webpack_require__(49);
var widgetCommandAdaptersModule = __webpack_require__(180);
DevExpress.framework.html.commandToDXWidgetAdapters = {
    dxToolbar: widgetCommandAdaptersModule.dxToolbar,
    dxList: widgetCommandAdaptersModule.dxList,
    dxNavBar: widgetCommandAdaptersModule.dxNavBar,
    dxPivot: widgetCommandAdaptersModule.dxPivot,
    dxSlideOut: widgetCommandAdaptersModule.dxSlideOut
};


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/component_registrator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ko = __webpack_require__(42),
    errors = __webpack_require__(13),
    inflector = __webpack_require__(36),
    isPlainObject = __webpack_require__(9).isPlainObject,
    registerComponent = __webpack_require__(4),
    Widget = __webpack_require__(27),
    KoTemplate = __webpack_require__(173),
    Editor = __webpack_require__(33),
    Locker = __webpack_require__(257),
    config = __webpack_require__(31);
var LOCKS_DATA_KEY = "dxKoLocks",
    CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
var editorsBindingHandlers = [];
var registerComponentKoBinding = function(componentName, componentClass) {
    if (componentClass.subclassOf(Editor)) {
        editorsBindingHandlers.push(componentName)
    }
    ko.bindingHandlers[componentName] = {
        init: function(domNode, valueAccessor) {
            var component, isBindingPropertyPredicate, $element = $(domNode),
                optionChangedCallbacks = $.Callbacks(),
                optionsByReference = {},
                knockoutConfig = config().knockout,
                isBindingPropertyPredicateName = knockoutConfig && knockoutConfig.isBindingPropertyPredicateName,
                ctorOptions = {
                    onInitializing: function() {
                        optionsByReference = this._getOptionsByReference();
                        ko.computed(function() {
                            var model = ko.unwrap(valueAccessor());
                            if (component) {
                                component.beginUpdate()
                            }
                            isBindingPropertyPredicate = isBindingPropertyPredicateName && model && model[isBindingPropertyPredicateName];
                            unwrapModel(model);
                            if (component) {
                                component.endUpdate()
                            }
                        }, null, {
                            disposeWhenNodeIsRemoved: domNode
                        });
                        component = this
                    },
                    modelByElement: function($element) {
                        if ($element.length) {
                            return ko.dataFor($element.get(0))
                        }
                    },
                    nestedComponentOptions: function(component) {
                        return {
                            modelByElement: component.option("modelByElement"),
                            nestedComponentOptions: component.option("nestedComponentOptions")
                        }
                    },
                    _optionChangedCallbacks: optionChangedCallbacks,
                    integrationOptions: {
                        watchMethod: function(fn, callback, options) {
                            options = options || {};
                            var skipCallback = options.skipImmediate;
                            var watcher = ko.computed(function() {
                                var newValue = ko.unwrap(fn());
                                if (!skipCallback) {
                                    callback(newValue)
                                }
                                skipCallback = false
                            });
                            return function() {
                                watcher.dispose()
                            }
                        },
                        templates: {
                            "dx-polymorph-widget": {
                                render: function(options) {
                                    var widgetName = ko.utils.unwrapObservable(options.model.widget);
                                    if (!widgetName) {
                                        return
                                    }
                                    if ("button" === widgetName || "tabs" === widgetName || "dropDownMenu" === widgetName) {
                                        var deprecatedName = widgetName;
                                        widgetName = inflector.camelize("dx-" + widgetName);
                                        errors.log("W0001", "dxToolbar - 'widget' item field", deprecatedName, "16.1", "Use: '" + widgetName + "' instead")
                                    }
                                    var markup = $('<div data-bind="' + widgetName + ': options">').get(0);
                                    options.container.append(markup);
                                    ko.applyBindings(options.model, markup)
                                }
                            }
                        },
                        createTemplate: function(element) {
                            return new KoTemplate(element)
                        }
                    }
                },
                optionNameToModelMap = {};
            var applyModelValueToOption = function(optionName, modelValue, unwrap) {
                var locks = $element.data(LOCKS_DATA_KEY),
                    optionValue = unwrap ? ko.unwrap(modelValue) : modelValue;
                if (ko.isWriteableObservable(modelValue)) {
                    optionNameToModelMap[optionName] = modelValue
                }
                if (component) {
                    if (locks.locked(optionName)) {
                        return
                    }
                    locks.obtain(optionName);
                    try {
                        if (ko.ignoreDependencies) {
                            ko.ignoreDependencies(component.option, component, [optionName, optionValue])
                        } else {
                            component.option(optionName, optionValue)
                        }
                    } finally {
                        locks.release(optionName)
                    }
                } else {
                    ctorOptions[optionName] = optionValue
                }
            };
            var handleOptionChanged = function(args) {
                var optionName = args.fullName,
                    optionValue = args.value;
                if (!(optionName in optionNameToModelMap)) {
                    return
                }
                var $element = this._$element,
                    locks = $element.data(LOCKS_DATA_KEY);
                if (locks.locked(optionName)) {
                    return
                }
                locks.obtain(optionName);
                try {
                    optionNameToModelMap[optionName](optionValue)
                } finally {
                    locks.release(optionName)
                }
            };
            var createComponent = function() {
                optionChangedCallbacks.add(handleOptionChanged);
                $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new Locker)[componentName](ctorOptions);
                ctorOptions = null
            };
            var unwrapModelValue = function(currentModel, propertyName, propertyPath) {
                if (propertyPath === isBindingPropertyPredicateName) {
                    return
                }
                if (!isBindingPropertyPredicate || isBindingPropertyPredicate(propertyPath, propertyName, currentModel)) {
                    var unwrappedPropertyValue;
                    ko.computed(function() {
                        var propertyValue = currentModel[propertyName];
                        applyModelValueToOption(propertyPath, propertyValue, true);
                        unwrappedPropertyValue = ko.unwrap(propertyValue)
                    }, null, {
                        disposeWhenNodeIsRemoved: domNode
                    });
                    if (isPlainObject(unwrappedPropertyValue)) {
                        if (!optionsByReference[propertyPath]) {
                            unwrapModel(unwrappedPropertyValue, propertyPath)
                        }
                    }
                } else {
                    applyModelValueToOption(propertyPath, currentModel[propertyName], false)
                }
            };
            var unwrapModel = function(model, propertyPath) {
                for (var propertyName in model) {
                    if (model.hasOwnProperty(propertyName)) {
                        unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join(".") : propertyName)
                    }
                }
            };
            createComponent();
            return {
                controlsDescendantBindings: componentClass.subclassOf(Widget)
            }
        }
    };
    if ("dxValidator" === componentName) {
        ko.bindingHandlers.dxValidator.after = editorsBindingHandlers
    }
};
registerComponent.callbacks.add(function(name, componentClass) {
    registerComponentKoBinding(name, componentClass)
});


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (core/utils/locker.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errors = __webpack_require__(13);
var Locker = function() {
    var info = {};
    var currentCount = function(lockName) {
        return info[lockName] || 0
    };
    return {
        obtain: function(lockName) {
            info[lockName] = currentCount(lockName) + 1
        },
        release: function(lockName) {
            var count = currentCount(lockName);
            if (count < 1) {
                throw errors.Error("E0014")
            }
            if (1 === count) {
                delete info[lockName]
            } else {
                info[lockName] = count - 1
            }
        },
        locked: function(lockName) {
            return currentCount(lockName) > 0
        }
    }
};
module.exports = Locker;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/event_registrator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ko = __webpack_require__(42),
    isPlainObject = __webpack_require__(9).isPlainObject,
    eventRegistrator = __webpack_require__(47),
    eventUtils = __webpack_require__(3);
eventRegistrator.callbacks.add(function(name) {
    var koBindingEventName = eventUtils.addNamespace(name, name + "Binding");
    ko.bindingHandlers[name] = {
        update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
            var $element = $(element),
                unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
            $element.off(koBindingEventName).on(koBindingEventName, isPlainObject(unwrappedValue) ? unwrappedValue : {}, function(e) {
                eventSource.call(viewModel, viewModel, e)
            })
        }
    }
});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/components.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Action = __webpack_require__(62),
    compileGetter = __webpack_require__(14).compileGetter,
    extend = __webpack_require__(1).extend,
    ko = __webpack_require__(42),
    iconUtils = __webpack_require__(77),
    clickEvent = __webpack_require__(11);
ko.bindingHandlers.dxAction = {
    update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
        var $element = $(element);
        var unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
            actionSource = unwrappedValue,
            actionOptions = {
                context: element
            };
        if (unwrappedValue.execute) {
            actionSource = unwrappedValue.execute;
            extend(actionOptions, unwrappedValue)
        }
        var action = new Action(actionSource, actionOptions);
        $element.off(".dxActionBinding").on(clickEvent.name + ".dxActionBinding", function(e) {
            action.execute({
                element: $element,
                model: viewModel,
                evaluate: function(expression) {
                    var context = viewModel;
                    if (expression.length > 0 && "$" === expression[0]) {
                        context = ko.contextFor(element)
                    }
                    var getter = compileGetter(expression);
                    return getter(context)
                },
                jQueryEvent: e
            });
            if (!actionOptions.bubbling) {
                e.stopPropagation()
            }
        })
    }
};
ko.bindingHandlers.dxControlsDescendantBindings = {
    init: function(_, valueAccessor) {
        return {
            controlsDescendantBindings: ko.unwrap(valueAccessor())
        }
    }
};
ko.bindingHandlers.dxIcon = {
    init: function(element, valueAccessor) {
        var options = ko.utils.unwrapObservable(valueAccessor()) || {},
            iconElement = iconUtils.getImageContainer(options);
        ko.virtualElements.emptyNode(element);
        if (iconElement) {
            ko.virtualElements.prepend(element, iconElement.get(0))
        }
    },
    update: function(element, valueAccessor) {
        var options = ko.utils.unwrapObservable(valueAccessor()) || {},
            iconElement = iconUtils.getImageContainer(options);
        ko.virtualElements.emptyNode(element);
        if (iconElement) {
            ko.virtualElements.prepend(element, iconElement.get(0))
        }
    }
};
ko.virtualElements.allowedBindings.dxIcon = true;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/validation.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    EventsMixin = __webpack_require__(38),
    ValidationEngine = __webpack_require__(58),
    ko = __webpack_require__(42);
var koDxValidator = Class.inherit({
    ctor: function(target, option) {
        var that = this;
        that.target = target;
        that.validationRules = option.validationRules;
        that.name = option.name;
        that.isValid = ko.observable(true);
        that.validationError = ko.observable();
        $.each(this.validationRules, function(_, rule) {
            rule.validator = that
        })
    },
    validate: function() {
        var result = ValidationEngine.validate(this.target(), this.validationRules, this.name);
        this._applyValidationResult(result);
        return result
    },
    reset: function() {
        this.target(null);
        var result = {
            isValid: true,
            brokenRule: null
        };
        this._applyValidationResult(result);
        return result
    },
    _applyValidationResult: function(result) {
        result.validator = this;
        this.target.dxValidator.isValid(result.isValid);
        this.target.dxValidator.validationError(result.brokenRule);
        this.fireEvent("validated", [result])
    }
}).include(EventsMixin);
ko.extenders.dxValidator = function(target, option) {
    target.dxValidator = new koDxValidator(target, option);
    target.subscribe(target.dxValidator.validate.bind(target.dxValidator));
    return target
};
ValidationEngine.registerModelForValidation = function(model) {
    $.each(model, function(name, member) {
        if (ko.isObservable(member) && member.dxValidator) {
            ValidationEngine.registerValidatorInGroup(model, member.dxValidator)
        }
    })
};
ValidationEngine.unregisterModelForValidation = function(model) {
    $.each(model, function(name, member) {
        if (ko.isObservable(member) && member.dxValidator) {
            ValidationEngine.removeRegisteredValidator(model, member.dxValidator)
        }
    })
};
ValidationEngine.validateModel = ValidationEngine.validateGroup;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/variable_wrapper_utils.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ko = __webpack_require__(42),
    variableWrapper = __webpack_require__(41);
variableWrapper.inject({
    isWrapped: ko.isObservable,
    isWritableWrapped: ko.isWritableObservable,
    wrap: ko.observable,
    unwrap: function(value) {
        if (ko.isObservable(value)) {
            return ko.utils.unwrapObservable(value)
        }
        return this.callBase(value)
    },
    assign: function(variable, value) {
        if (ko.isObservable(variable)) {
            variable(value)
        } else {
            this.callBase(variable, value)
        }
    }
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/clean_node.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(103),
    ko = __webpack_require__(42),
    cleanData = $.cleanData,
    compareVersion = __webpack_require__(37).compare;
if (compareVersion($.fn.jquery, [2, 0]) >= 0) {
    $.cleanData = function(nodes) {
        var result = cleanData(nodes);
        for (var i = 0; i < nodes.length; i++) {
            nodes[i].cleanedByJquery = true
        }
        for (i = 0; i < nodes.length; i++) {
            if (!nodes[i].cleanedByKo) {
                ko.cleanNode(nodes[i])
            }
            delete nodes[i].cleanedByKo
        }
        for (i = 0; i < nodes.length; i++) {
            delete nodes[i].cleanedByJquery
        }
        return result
    };
    ko.utils.domNodeDisposal.cleanExternalData = function(node) {
        node.cleanedByKo = true;
        if (!node.cleanedByJquery) {
            $.cleanData([node])
        }
    }
}


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (integration/knockout/clean_node_old.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ko = __webpack_require__(42),
    compareVersion = __webpack_require__(37).compare;
if (compareVersion($.fn.jquery, [2, 0]) < 0) {
    var cleanKoData = function(element, andSelf) {
        var cleanNode = function() {
            ko.cleanNode(this)
        };
        if (andSelf) {
            element.each(cleanNode)
        } else {
            element.find("*").each(cleanNode)
        }
    };
    var originalEmpty = $.fn.empty;
    $.fn.empty = function() {
        cleanKoData(this, false);
        return originalEmpty.apply(this, arguments)
    };
    var originalRemove = $.fn.remove;
    $.fn.remove = function(selector, keepData) {
        if (!keepData) {
            var subject = this;
            if (selector) {
                subject = subject.filter(selector)
            }
            cleanKoData(subject, true)
        }
        return originalRemove.call(this, selector, keepData)
    };
    var originalHtml = $.fn.html;
    $.fn.html = function(value) {
        if ("string" === typeof value) {
            cleanKoData(this, false)
        }
        return originalHtml.apply(this, arguments)
    };
    var originalReplaceWith = $.fn.replaceWith;
    $.fn.replaceWith = function() {
        var result = originalReplaceWith.apply(this, arguments);
        if (!this.parent().length) {
            cleanKoData(this, true)
        }
        return result
    }
}


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/globalize/message.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(95);
var Globalize = __webpack_require__(50),
    messageLocalization = __webpack_require__(8),
    coreLocalization = __webpack_require__(60);
__webpack_require__(50);
if (Globalize && Globalize.formatMessage) {
    var DEFAULT_LOCALE = "en";
    var originalLoadMessages = Globalize.loadMessages;
    Globalize.loadMessages = function(messages) {
        messageLocalization.load(messages)
    };
    var globalizeMessageLocalization = {
        ctor: function() {
            this.load(this._dictionary)
        },
        load: function(messages) {
            this.callBase(messages);
            originalLoadMessages(messages)
        },
        getMessagesByLocales: function() {
            return Globalize.cldr.get("globalize-messages")
        },
        getFormatter: function(key, locale) {
            var currentLocale = locale || coreLocalization.locale(),
                formatter = this._getFormatterBase(key, locale);
            if (!formatter) {
                formatter = this._formatterByGlobalize(key, locale)
            }
            if (!formatter && currentLocale !== DEFAULT_LOCALE) {
                formatter = this.getFormatter(key, DEFAULT_LOCALE)
            }
            return formatter
        },
        _formatterByGlobalize: function(key, locale) {
            var result, currentGlobalize = !locale || locale === coreLocalization.locale() ? Globalize : new Globalize(locale);
            if (this._messageLoaded(key, locale)) {
                result = currentGlobalize.messageFormatter(key)
            }
            return result
        },
        _messageLoaded: function(key, locale) {
            var currentCldr = locale ? new Globalize(locale).cldr : Globalize.locale(),
                value = currentCldr.get(["globalize-messages/{bundle}", key]);
            return void 0 !== value
        },
        _loadSingle: function(key, value, locale) {
            var data = {};
            data[locale] = {};
            data[locale][key] = value;
            this.load(data)
        }
    };
    messageLocalization.inject(globalizeMessageLocalization)
}


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/globalize/date.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(95);
__webpack_require__(145);
__webpack_require__(50);
var timeData = {
    supplemental: {
        version: {
            _cldrVersion: "28",
            _unicodeVersion: "8.0.0",
            _number: "$Revision: 11969 $"
        },
        timeData: {
            "001": {
                _allowed: "H h",
                _preferred: "H"
            },
            DE: {
                _allowed: "H",
                _preferred: "H"
            },
            JP: {
                _allowed: "H K h",
                _preferred: "H"
            },
            RU: {
                _allowed: "H",
                _preferred: "H"
            },
            US: {
                _allowed: "H h",
                _preferred: "h"
            }
        }
    }
};
var enCaGregorian = {
    main: {
        en: {
            identity: {
                version: {
                    _cldrVersion: "28",
                    _number: "$Revision: 11972 $"
                },
                language: "en"
            },
            dates: {
                calendars: {
                    gregorian: {
                        months: {
                            format: {
                                abbreviated: {
                                    1: "Jan",
                                    2: "Feb",
                                    3: "Mar",
                                    4: "Apr",
                                    5: "May",
                                    6: "Jun",
                                    7: "Jul",
                                    8: "Aug",
                                    9: "Sep",
                                    10: "Oct",
                                    11: "Nov",
                                    12: "Dec"
                                },
                                narrow: {
                                    1: "J",
                                    2: "F",
                                    3: "M",
                                    4: "A",
                                    5: "M",
                                    6: "J",
                                    7: "J",
                                    8: "A",
                                    9: "S",
                                    10: "O",
                                    11: "N",
                                    12: "D"
                                },
                                wide: {
                                    1: "January",
                                    2: "February",
                                    3: "March",
                                    4: "April",
                                    5: "May",
                                    6: "June",
                                    7: "July",
                                    8: "August",
                                    9: "September",
                                    10: "October",
                                    11: "November",
                                    12: "December"
                                }
                            },
                            "stand-alone": {
                                abbreviated: {
                                    1: "Jan",
                                    2: "Feb",
                                    3: "Mar",
                                    4: "Apr",
                                    5: "May",
                                    6: "Jun",
                                    7: "Jul",
                                    8: "Aug",
                                    9: "Sep",
                                    10: "Oct",
                                    11: "Nov",
                                    12: "Dec"
                                },
                                narrow: {
                                    1: "J",
                                    2: "F",
                                    3: "M",
                                    4: "A",
                                    5: "M",
                                    6: "J",
                                    7: "J",
                                    8: "A",
                                    9: "S",
                                    10: "O",
                                    11: "N",
                                    12: "D"
                                },
                                wide: {
                                    1: "January",
                                    2: "February",
                                    3: "March",
                                    4: "April",
                                    5: "May",
                                    6: "June",
                                    7: "July",
                                    8: "August",
                                    9: "September",
                                    10: "October",
                                    11: "November",
                                    12: "December"
                                }
                            }
                        },
                        days: {
                            format: {
                                abbreviated: {
                                    sun: "Sun",
                                    mon: "Mon",
                                    tue: "Tue",
                                    wed: "Wed",
                                    thu: "Thu",
                                    fri: "Fri",
                                    sat: "Sat"
                                },
                                narrow: {
                                    sun: "S",
                                    mon: "M",
                                    tue: "T",
                                    wed: "W",
                                    thu: "T",
                                    fri: "F",
                                    sat: "S"
                                },
                                "short": {
                                    sun: "Su",
                                    mon: "Mo",
                                    tue: "Tu",
                                    wed: "We",
                                    thu: "Th",
                                    fri: "Fr",
                                    sat: "Sa"
                                },
                                wide: {
                                    sun: "Sunday",
                                    mon: "Monday",
                                    tue: "Tuesday",
                                    wed: "Wednesday",
                                    thu: "Thursday",
                                    fri: "Friday",
                                    sat: "Saturday"
                                }
                            },
                            "stand-alone": {
                                abbreviated: {
                                    sun: "Sun",
                                    mon: "Mon",
                                    tue: "Tue",
                                    wed: "Wed",
                                    thu: "Thu",
                                    fri: "Fri",
                                    sat: "Sat"
                                },
                                narrow: {
                                    sun: "S",
                                    mon: "M",
                                    tue: "T",
                                    wed: "W",
                                    thu: "T",
                                    fri: "F",
                                    sat: "S"
                                },
                                "short": {
                                    sun: "Su",
                                    mon: "Mo",
                                    tue: "Tu",
                                    wed: "We",
                                    thu: "Th",
                                    fri: "Fr",
                                    sat: "Sa"
                                },
                                wide: {
                                    sun: "Sunday",
                                    mon: "Monday",
                                    tue: "Tuesday",
                                    wed: "Wednesday",
                                    thu: "Thursday",
                                    fri: "Friday",
                                    sat: "Saturday"
                                }
                            }
                        },
                        quarters: {
                            format: {
                                abbreviated: {
                                    1: "Q1",
                                    2: "Q2",
                                    3: "Q3",
                                    4: "Q4"
                                },
                                narrow: {
                                    1: "1",
                                    2: "2",
                                    3: "3",
                                    4: "4"
                                },
                                wide: {
                                    1: "1st quarter",
                                    2: "2nd quarter",
                                    3: "3rd quarter",
                                    4: "4th quarter"
                                }
                            },
                            "stand-alone": {
                                abbreviated: {
                                    1: "Q1",
                                    2: "Q2",
                                    3: "Q3",
                                    4: "Q4"
                                },
                                narrow: {
                                    1: "1",
                                    2: "2",
                                    3: "3",
                                    4: "4"
                                },
                                wide: {
                                    1: "1st quarter",
                                    2: "2nd quarter",
                                    3: "3rd quarter",
                                    4: "4th quarter"
                                }
                            }
                        },
                        dayPeriods: {
                            format: {
                                abbreviated: {
                                    midnight: "midnight",
                                    am: "AM",
                                    "am-alt-variant": "am",
                                    noon: "noon",
                                    pm: "PM",
                                    "pm-alt-variant": "pm",
                                    morning1: "in the morning",
                                    afternoon1: "in the afternoon",
                                    evening1: "in the evening",
                                    night1: "at night"
                                },
                                narrow: {
                                    midnight: "mi",
                                    am: "a",
                                    "am-alt-variant": "am",
                                    noon: "n",
                                    pm: "p",
                                    "pm-alt-variant": "pm",
                                    morning1: "in the morning",
                                    afternoon1: "in the afternoon",
                                    evening1: "in the evening",
                                    night1: "at night"
                                },
                                wide: {
                                    midnight: "midnight",
                                    am: "AM",
                                    "am-alt-variant": "am",
                                    noon: "noon",
                                    pm: "PM",
                                    "pm-alt-variant": "pm",
                                    morning1: "in the morning",
                                    afternoon1: "in the afternoon",
                                    evening1: "in the evening",
                                    night1: "at night"
                                }
                            },
                            "stand-alone": {
                                abbreviated: {
                                    midnight: "midnight",
                                    am: "AM",
                                    "am-alt-variant": "am",
                                    noon: "noon",
                                    pm: "PM",
                                    "pm-alt-variant": "pm",
                                    morning1: "in the morning",
                                    afternoon1: "in the afternoon",
                                    evening1: "in the evening",
                                    night1: "at night"
                                },
                                narrow: {
                                    midnight: "midnight",
                                    am: "AM",
                                    "am-alt-variant": "am",
                                    noon: "noon",
                                    pm: "PM",
                                    "pm-alt-variant": "pm",
                                    morning1: "in the morning",
                                    afternoon1: "in the afternoon",
                                    evening1: "in the evening",
                                    night1: "at night"
                                },
                                wide: {
                                    midnight: "midnight",
                                    am: "AM",
                                    "am-alt-variant": "am",
                                    noon: "noon",
                                    pm: "PM",
                                    "pm-alt-variant": "pm",
                                    morning1: "morning",
                                    afternoon1: "afternoon",
                                    evening1: "evening",
                                    night1: "night"
                                }
                            }
                        },
                        eras: {
                            eraNames: {
                                0: "Before Christ",
                                "0-alt-variant": "Before Common Era",
                                1: "Anno Domini",
                                "1-alt-variant": "Common Era"
                            },
                            eraAbbr: {
                                0: "BC",
                                "0-alt-variant": "BCE",
                                1: "AD",
                                "1-alt-variant": "CE"
                            },
                            eraNarrow: {
                                0: "B",
                                "0-alt-variant": "BCE",
                                1: "A",
                                "1-alt-variant": "CE"
                            }
                        },
                        dateFormats: {
                            full: "EEEE, MMMM d, y",
                            "long": "MMMM d, y",
                            medium: "MMM d, y",
                            "short": "M/d/yy"
                        },
                        timeFormats: {
                            full: "h:mm:ss a zzzz",
                            "long": "h:mm:ss a z",
                            medium: "h:mm:ss a",
                            "short": "h:mm a"
                        },
                        dateTimeFormats: {
                            full: "{1} 'at' {0}",
                            "long": "{1} 'at' {0}",
                            medium: "{1}, {0}",
                            "short": "{1}, {0}",
                            availableFormats: {
                                d: "d",
                                E: "ccc",
                                Ed: "d E",
                                Ehm: "E h:mm a",
                                EHm: "E HH:mm",
                                Ehms: "E h:mm:ss a",
                                EHms: "E HH:mm:ss",
                                Gy: "y G",
                                GyMMM: "MMM y G",
                                GyMMMd: "MMM d, y G",
                                GyMMMEd: "E, MMM d, y G",
                                h: "h a",
                                H: "HH",
                                hm: "h:mm a",
                                Hm: "HH:mm",
                                hms: "h:mm:ss a",
                                Hms: "HH:mm:ss",
                                hmsv: "h:mm:ss a v",
                                Hmsv: "HH:mm:ss v",
                                hmv: "h:mm a v",
                                Hmv: "HH:mm v",
                                M: "L",
                                Md: "M/d",
                                MEd: "E, M/d",
                                MMM: "LLL",
                                MMMd: "MMM d",
                                MMMEd: "E, MMM d",
                                MMMMd: "MMMM d",
                                ms: "mm:ss",
                                y: "y",
                                yM: "M/y",
                                yMd: "M/d/y",
                                yMEd: "E, M/d/y",
                                yMMM: "MMM y",
                                yMMMd: "MMM d, y",
                                yMMMEd: "E, MMM d, y",
                                yMMMM: "MMMM y",
                                yQQQ: "QQQ y",
                                yQQQQ: "QQQQ y"
                            },
                            appendItems: {
                                Day: "{0} ({2}: {1})",
                                "Day-Of-Week": "{0} {1}",
                                Era: "{0} {1}",
                                Hour: "{0} ({2}: {1})",
                                Minute: "{0} ({2}: {1})",
                                Month: "{0} ({2}: {1})",
                                Quarter: "{0} ({2}: {1})",
                                Second: "{0} ({2}: {1})",
                                Timezone: "{0} {1}",
                                Week: "{0} ({2}: {1})",
                                Year: "{0} {1}"
                            },
                            intervalFormats: {
                                intervalFormatFallback: "{0}  {1}",
                                d: {
                                    d: "d  d"
                                },
                                h: {
                                    a: "h a  h a",
                                    h: "h  h a"
                                },
                                H: {
                                    H: "HH  HH"
                                },
                                hm: {
                                    a: "h:mm a  h:mm a",
                                    h: "h:mm  h:mm a",
                                    m: "h:mm  h:mm a"
                                },
                                Hm: {
                                    H: "HH:mm  HH:mm",
                                    m: "HH:mm  HH:mm"
                                },
                                hmv: {
                                    a: "h:mm a  h:mm a v",
                                    h: "h:mm  h:mm a v",
                                    m: "h:mm  h:mm a v"
                                },
                                Hmv: {
                                    H: "HH:mm  HH:mm v",
                                    m: "HH:mm  HH:mm v"
                                },
                                hv: {
                                    a: "h a  h a v",
                                    h: "h  h a v"
                                },
                                Hv: {
                                    H: "HH  HH v"
                                },
                                M: {
                                    M: "M  M"
                                },
                                Md: {
                                    d: "M/d  M/d",
                                    M: "M/d  M/d"
                                },
                                MEd: {
                                    d: "E, M/d  E, M/d",
                                    M: "E, M/d  E, M/d"
                                },
                                MMM: {
                                    M: "MMM  MMM"
                                },
                                MMMd: {
                                    d: "MMM d  d",
                                    M: "MMM d  MMM d"
                                },
                                MMMEd: {
                                    d: "E, MMM d  E, MMM d",
                                    M: "E, MMM d  E, MMM d"
                                },
                                y: {
                                    y: "y  y"
                                },
                                yM: {
                                    M: "M/y  M/y",
                                    y: "M/y  M/y"
                                },
                                yMd: {
                                    d: "M/d/y  M/d/y",
                                    M: "M/d/y  M/d/y",
                                    y: "M/d/y  M/d/y"
                                },
                                yMEd: {
                                    d: "E, M/d/y  E, M/d/y",
                                    M: "E, M/d/y  E, M/d/y",
                                    y: "E, M/d/y  E, M/d/y"
                                },
                                yMMM: {
                                    M: "MMM  MMM y",
                                    y: "MMM y  MMM y"
                                },
                                yMMMd: {
                                    d: "MMM d  d, y",
                                    M: "MMM d  MMM d, y",
                                    y: "MMM d, y  MMM d, y"
                                },
                                yMMMEd: {
                                    d: "E, MMM d  E, MMM d, y",
                                    M: "E, MMM d  E, MMM d, y",
                                    y: "E, MMM d, y  E, MMM d, y"
                                },
                                yMMMM: {
                                    M: "MMMM  MMMM y",
                                    y: "MMMM y  MMMM y"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
var weekData = {
    supplemental: {
        version: {
            _cldrVersion: "28",
            _unicodeVersion: "8.0.0",
            _number: "$Revision: 11969 $"
        },
        weekData: {
            minDays: {
                "001": "1",
                US: "1",
                DE: "4"
            },
            firstDay: {
                "001": "mon",
                DE: "mon",
                RU: "mon",
                JP: "sun",
                US: "sun"
            },
            weekendStart: {
                "001": "sat"
            },
            weekendEnd: {
                "001": "sun"
            }
        }
    }
};
var ACCEPTABLE_JSON_FORMAT_PROPERTIES = ["skeleton", "date", "time", "datetime", "raw"];
var $ = __webpack_require__(0),
    Globalize = __webpack_require__(50),
    dateLocalization = __webpack_require__(32),
    isObject = __webpack_require__(2).isObject,
    inArray = __webpack_require__(7).inArray,
    errors = __webpack_require__(13);
if (Globalize && Globalize.formatDate) {
    if ("en" === Globalize.locale().locale) {
        Globalize.load(weekData, timeData, enCaGregorian);
        Globalize.locale("en")
    }
    var formattersCache = {};
    var FORMATS_TO_GLOBALIZE_MAP = {
        shortdate: {
            path: "dateTimeFormats/availableFormats/yMd"
        },
        shorttime: {
            path: "timeFormats/short"
        },
        longdate: {
            path: "dateFormats/full"
        },
        longtime: {
            path: "timeFormats/medium"
        },
        monthandday: {
            path: "dateTimeFormats/availableFormats/MMMMd"
        },
        monthandyear: {
            path: "dateTimeFormats/availableFormats/yMMMM"
        },
        quarterandyear: {
            path: "dateTimeFormats/availableFormats/yQQQ"
        },
        day: {
            path: "dateTimeFormats/availableFormats/d"
        },
        year: {
            path: "dateTimeFormats/availableFormats/y"
        },
        shortdateshorttime: {
            path: "dateTimeFormats/short",
            parts: ["shorttime", "shortdate"]
        },
        mediumdatemediumtime: {
            path: "dateTimeFormats/medium",
            parts: ["shorttime", "monthandday"]
        },
        longdatelongtime: {
            path: "dateTimeFormats/medium",
            parts: ["longtime", "longdate"]
        },
        month: {
            pattern: "LLLL"
        },
        shortyear: {
            pattern: "yy"
        },
        dayofweek: {
            pattern: "EEEE"
        },
        quarter: {
            pattern: "QQQ"
        },
        millisecond: {
            pattern: "SSS"
        },
        hour: {
            pattern: "HH"
        },
        minute: {
            pattern: "mm"
        },
        second: {
            pattern: "ss"
        }
    };
    var globalizeDateLocalization = {
        _getPatternByFormat: function(format) {
            var that = this,
                lowerFormat = format.toLowerCase(),
                globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];
            if ("datetime-local" === lowerFormat) {
                return "yyyy-MM-ddTHH':'mm':'ss"
            }
            if (!globalizeFormat) {
                return
            }
            var result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;
            if (globalizeFormat.parts) {
                $.each(globalizeFormat.parts, function(index, part) {
                    result = result.replace("{" + index + "}", that._getPatternByFormat(part))
                })
            }
            return result
        },
        _getFormatStringByPath: function(path) {
            return Globalize.locale().main("dates/calendars/gregorian/" + path)
        },
        getMonthNames: function(format) {
            var months = Globalize.locale().main("dates/calendars/gregorian/months/stand-alone/" + (format || "wide"));
            return $.map(months, function(month) {
                return month
            })
        },
        getDayNames: function(format) {
            var days = Globalize.locale().main("dates/calendars/gregorian/days/stand-alone/" + (format || "wide"));
            return $.map(days, function(day) {
                return day
            })
        },
        getTimeSeparator: function() {
            return Globalize.locale().main("numbers/symbols-numberSystem-latn/timeSeparator")
        },
        format: function(date, format) {
            if (!date) {
                return
            }
            if (!format) {
                return date
            }
            var formatter, formatCacheKey;
            if ("function" === typeof format) {
                return format(date)
            }
            if (format.formatter) {
                return format.formatter(date)
            }
            format = format.type || format;
            if ("string" === typeof format) {
                formatCacheKey = Globalize.locale().locale + ":" + format;
                formatter = formattersCache[formatCacheKey];
                if (!formatter) {
                    format = {
                        raw: this._getPatternByFormat(format) || format
                    };
                    formatter = formattersCache[formatCacheKey] = Globalize.dateFormatter(format)
                }
            } else {
                formatter = Globalize.dateFormatter(format)
            }
            return formatter(date)
        },
        parse: function(text, format) {
            if (!text) {
                return
            }
            if (!format || "function" === typeof format || isObject(format) && !this._isAcceptableFormat(format)) {
                if (format) {
                    errors.log("W0012")
                }
                return Globalize.parseDate(text)
            }
            if (format.parser) {
                return format.parser(text)
            }
            if ("string" === typeof format) {
                format = {
                    raw: this._getPatternByFormat(format) || format
                }
            }
            return Globalize.parseDate(text, format)
        },
        _isAcceptableFormat: function(format) {
            if (format.parser) {
                return true
            }
            for (var i = 0; i < ACCEPTABLE_JSON_FORMAT_PROPERTIES.length; i++) {
                if (format.hasOwnProperty(ACCEPTABLE_JSON_FORMAT_PROPERTIES[i])) {
                    return true
                }
            }
        },
        firstDayOfWeekIndex: function() {
            var firstDay = Globalize.locale().supplemental.weekData.firstDay();
            return inArray(firstDay, this._getDayKeys())
        },
        _getDayKeys: function() {
            var days = Globalize.locale().main("dates/calendars/gregorian/days/format/short");
            return $.map(days, function(day, key) {
                return key
            })
        }
    };
    dateLocalization.inject(globalizeDateLocalization)
}


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (localization/globalize/currency.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(95);
__webpack_require__(145);
__webpack_require__(105);
__webpack_require__(50);
var enCurrencyUSD = {
    main: {
        en: {
            identity: {
                version: {
                    _cldrVersion: "28",
                    _number: "$Revision: 11972 $"
                },
                language: "en"
            },
            numbers: {
                currencies: {
                    USD: {
                        displayName: "US Dollar",
                        "displayName-count-one": "US dollar",
                        "displayName-count-other": "US dollars",
                        symbol: "$",
                        "symbol-alt-narrow": "$"
                    }
                }
            }
        }
    }
};
var currencyData = {
    supplemental: {
        version: {
            _cldrVersion: "28",
            _unicodeVersion: "8.0.0",
            _number: "$Revision: 11969 $"
        },
        currencyData: {
            fractions: {
                DEFAULT: {
                    _rounding: "0",
                    _digits: "2"
                }
            }
        }
    }
};
var Globalize = __webpack_require__(50),
    config = __webpack_require__(31),
    numberLocalization = __webpack_require__(44);
if (Globalize && Globalize.formatCurrency) {
    if ("en" === Globalize.locale().locale) {
        Globalize.load(enCurrencyUSD, currencyData);
        Globalize.locale("en")
    }
    var formattersCache = {};
    var getFormatter = function(currency, format) {
        var formatter, formatCacheKey;
        if ("object" === typeof format) {
            formatCacheKey = Globalize.locale().locale + ":" + currency + ":" + JSON.stringify(format)
        } else {
            formatCacheKey = Globalize.locale().locale + ":" + currency + ":" + format
        }
        formatter = formattersCache[formatCacheKey];
        if (!formatter) {
            formatter = formattersCache[formatCacheKey] = Globalize.currencyFormatter(currency, format)
        }
        return formatter
    };
    var globalizeCurrencyLocalization = {
        _formatNumberCore: function(value, format, formatConfig) {
            if ("currency" === format) {
                var currency = formatConfig && formatConfig.currency || config().defaultCurrency;
                return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value)
            }
            return this.callBase.apply(this, arguments)
        },
        _normalizeFormatConfig: function(format, formatConfig, value) {
            var config = this.callBase(format, formatConfig, value);
            if ("currency" === format) {
                config.style = "accounting"
            }
            return config
        },
        format: function(value, format) {
            if ("number" !== typeof value) {
                return value
            }
            format = this._normalizeFormat(format);
            if (format) {
                if ("default" === format.currency) {
                    format.currency = config().defaultCurrency
                }
                if ("currency" === format.type) {
                    return this._formatNumber(value, this._parseNumberFormatString("currency"), format)
                } else {
                    if (!format.type && format.currency) {
                        return getFormatter(format.currency, format)(value)
                    }
                }
            }
            return this.callBase.apply(this, arguments)
        },
        getCurrencySymbol: function(currency) {
            if (!currency) {
                currency = config().defaultCurrency
            }
            return Globalize.cldr.main("numbers/currencies/" + currency)
        },
        getOpenXmlCurrencyFormat: function(currency) {
            var i, result, symbol, encodeSymbols, currencySymbol = this.getCurrencySymbol(currency).symbol,
                currencyFormat = Globalize.cldr.main("numbers/currencyFormats-numberSystem-latn");
            if (currencyFormat.accounting) {
                encodeSymbols = {
                    ".00": "{0}",
                    "'": "\\'",
                    "\\(": "\\(",
                    "\\)": "\\)",
                    " ": "\\ ",
                    '"': "&quot;",
                    "\\": currencySymbol
                };
                result = currencyFormat.accounting.split(";");
                for (i = 0; i < result.length; i++) {
                    for (symbol in encodeSymbols) {
                        if (encodeSymbols.hasOwnProperty(symbol)) {
                            result[i] = result[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol])
                        }
                    }
                }
                return 2 === result.length ? result[0] + "_);" + result[1] : result[0]
            }
        }
    };
    numberLocalization.inject(globalizeCurrencyLocalization)
}


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (events/transform.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    mathUtils = __webpack_require__(56),
    errors = __webpack_require__(13),
    eventUtils = __webpack_require__(3),
    Emitter = __webpack_require__(89),
    registerEmitter = __webpack_require__(63);
var DX_PREFIX = "dx",
    TRANSFORM = "transform",
    TRANSLATE = "translate",
    ZOOM = "zoom",
    PINCH = "pinch",
    ROTATE = "rotate",
    START_POSTFIX = "start",
    UPDATE_POSTFIX = "",
    END_POSTFIX = "end";
var eventAliases = [];
var addAlias = function(eventName, eventArgs) {
    eventAliases.push({
        name: eventName,
        args: eventArgs
    })
};
addAlias(TRANSFORM, {
    scale: true,
    deltaScale: true,
    rotation: true,
    deltaRotation: true,
    translation: true,
    deltaTranslation: true
});
addAlias(TRANSLATE, {
    translation: true,
    deltaTranslation: true
});
addAlias(ZOOM, {
    scale: true,
    deltaScale: true
});
addAlias(PINCH, {
    scale: true,
    deltaScale: true
});
addAlias(ROTATE, {
    rotation: true,
    deltaRotation: true
});
var getVector = function(first, second) {
    return {
        x: second.pageX - first.pageX,
        y: -second.pageY + first.pageY,
        centerX: .5 * (second.pageX + first.pageX),
        centerY: .5 * (second.pageY + first.pageY)
    }
};
var getEventVector = function(e) {
    var pointers = e.pointers;
    return getVector(pointers[0], pointers[1])
};
var getDistance = function(vector) {
    return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
};
var getScale = function(firstVector, secondVector) {
    return getDistance(firstVector) / getDistance(secondVector)
};
var getRotation = function(firstVector, secondVector) {
    var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
    var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
    if (0 === distanceProduct) {
        return 0
    }
    var sign = mathUtils.sign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
    var angle = Math.acos(mathUtils.fitIntoRange(scalarProduct / distanceProduct, -1, 1));
    return sign * angle
};
var getTranslation = function(firstVector, secondVector) {
    return {
        x: firstVector.centerX - secondVector.centerX,
        y: firstVector.centerY - secondVector.centerY
    }
};
var TransformEmitter = Emitter.inherit({
    configure: function(data, eventName) {
        if (eventName.indexOf(ZOOM) > -1) {
            errors.log("W0005", eventName, "15.1", "Use '" + eventName.replace(ZOOM, PINCH) + "' event instead")
        }
        this.callBase(data)
    },
    validatePointers: function(e) {
        return eventUtils.hasTouches(e) > 1
    },
    start: function(e) {
        this._accept(e);
        var startVector = getEventVector(e);
        this._startVector = startVector;
        this._prevVector = startVector;
        this._fireEventAliases(START_POSTFIX, e)
    },
    move: function(e) {
        var currentVector = getEventVector(e),
            eventArgs = this._getEventArgs(currentVector);
        this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
        this._prevVector = currentVector
    },
    end: function(e) {
        var eventArgs = this._getEventArgs(this._prevVector);
        this._fireEventAliases(END_POSTFIX, e, eventArgs)
    },
    _getEventArgs: function(vector) {
        return {
            scale: getScale(vector, this._startVector),
            deltaScale: getScale(vector, this._prevVector),
            rotation: getRotation(vector, this._startVector),
            deltaRotation: getRotation(vector, this._prevVector),
            translation: getTranslation(vector, this._startVector),
            deltaTranslation: getTranslation(vector, this._prevVector)
        }
    },
    _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {
        eventArgs = eventArgs || {};
        $.each(eventAliases, function(_, eventAlias) {
            var args = {};
            $.each(eventAlias.args, function(name) {
                if (name in eventArgs) {
                    args[name] = eventArgs[name]
                }
            });
            this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)
        }.bind(this))
    }
});
var eventNames = $.map(eventAliases, function(eventAlias) {
    var eventNames = [];
    $.each([START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX], function(_, eventPostfix) {
        eventNames.push(DX_PREFIX + eventAlias.name + eventPostfix)
    });
    return eventNames
});
registerEmitter({
    emitter: TransformEmitter,
    events: eventNames
});
$.each(eventNames, function(_, eventName) {
    exports[eventName.substring(DX_PREFIX.length)] = eventName
});


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/data_source.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(51).DataSource;
module.exports.default = module.exports;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/remote_query.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    queryAdapters = __webpack_require__(147),
    errorsModule = __webpack_require__(29),
    isFunction = __webpack_require__(2).isFunction,
    arrayQueryImpl = __webpack_require__(119);
var remoteQueryImpl = function(url, queryOptions, tasks) {
    tasks = tasks || [];
    queryOptions = queryOptions || {};
    var createTask = function(name, args) {
        return {
            name: name,
            args: args
        }
    };
    var exec = function(executorTask) {
        var _adapterFactory, _adapter, _taskQueue, _currentTask, _mergedSortArgs, d = $.Deferred();
        var rejectWithNotify = function(error) {
            var handler = queryOptions.errorHandler;
            if (handler) {
                handler(error)
            }
            errorsModule._errorHandler(error);
            d.reject(error)
        };

        function mergeSortTask(task) {
            switch (task.name) {
                case "sortBy":
                    _mergedSortArgs = [task.args];
                    return true;
                case "thenBy":
                    if (!_mergedSortArgs) {
                        throw errorsModule.errors.Error("E4004")
                    }
                    _mergedSortArgs.push(task.args);
                    return true
            }
            return false
        }

        function unmergeSortTasks() {
            var head = _taskQueue[0],
                unmergedTasks = [];
            if (head && "multiSort" === head.name) {
                _taskQueue.shift();
                $.each(head.args[0], function() {
                    unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
                })
            }
            _taskQueue = unmergedTasks.concat(_taskQueue)
        }
        try {
            _adapterFactory = queryOptions.adapter;
            if (!isFunction(_adapterFactory)) {
                _adapterFactory = queryAdapters[_adapterFactory]
            }
            _adapter = _adapterFactory(queryOptions);
            _taskQueue = [].concat(tasks).concat(executorTask);
            while (_taskQueue.length) {
                _currentTask = _taskQueue[0];
                if (!mergeSortTask(_currentTask)) {
                    if (_mergedSortArgs) {
                        _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                        _mergedSortArgs = null;
                        continue
                    }
                    if ("enumerate" !== String(_currentTask.name)) {
                        if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
                            break
                        }
                    }
                }
                _taskQueue.shift()
            }
            unmergeSortTasks();
            _adapter.exec(url).done(function(result, extra) {
                if (!_taskQueue.length) {
                    d.resolve(result, extra)
                } else {
                    var clientChain = arrayQueryImpl(result, {
                        errorHandler: queryOptions.errorHandler
                    });
                    $.each(_taskQueue, function() {
                        clientChain = clientChain[this.name].apply(clientChain, this.args)
                    });
                    clientChain.done(d.resolve).fail(d.reject)
                }
            }).fail(rejectWithNotify)
        } catch (x) {
            rejectWithNotify(x)
        }
        return d.promise()
    };
    var query = {};
    $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
        var name = String(this);
        query[name] = function() {
            return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)))
        }
    });
    $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
        var name = String(this);
        query[name] = function() {
            return exec.call(this, createTask(name, arguments))
        }
    });
    return query
};
module.exports = remoteQueryImpl;


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/local_store.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    abstract = Class.abstract,
    errors = __webpack_require__(29).errors,
    ArrayStore = __webpack_require__(67);
var LocalStoreBackend = Class.inherit({
    ctor: function(store, storeOptions) {
        this._store = store;
        this._dirty = !!storeOptions.data;
        this.save();
        var immediate = this._immediate = storeOptions.immediate;
        var flushInterval = Math.max(100, storeOptions.flushInterval || 1e4);
        if (!immediate) {
            var saveProxy = this.save.bind(this);
            setInterval(saveProxy, flushInterval);
            $(window).on("beforeunload", saveProxy);
            if (window.cordova) {
                document.addEventListener("pause", saveProxy, false)
            }
        }
    },
    notifyChanged: function() {
        this._dirty = true;
        if (this._immediate) {
            this.save()
        }
    },
    load: function() {
        this._store._array = this._loadImpl();
        this._dirty = false
    },
    save: function() {
        if (!this._dirty) {
            return
        }
        this._saveImpl(this._store._array);
        this._dirty = false
    },
    _loadImpl: abstract,
    _saveImpl: abstract
});
var DomLocalStoreBackend = LocalStoreBackend.inherit({
    ctor: function(store, storeOptions) {
        var name = storeOptions.name;
        if (!name) {
            throw errors.Error("E4013")
        }
        this._key = "dx-data-localStore-" + name;
        this.callBase(store, storeOptions)
    },
    _loadImpl: function() {
        var raw = localStorage.getItem(this._key);
        if (raw) {
            return JSON.parse(raw)
        }
        return []
    },
    _saveImpl: function(array) {
        if (!array.length) {
            localStorage.removeItem(this._key)
        } else {
            localStorage.setItem(this._key, JSON.stringify(array))
        }
    }
});
var localStoreBackends = {
    dom: DomLocalStoreBackend
};
var LocalStore = ArrayStore.inherit({
    ctor: function(options) {
        if ("string" === typeof options) {
            options = {
                name: options
            }
        } else {
            options = options || {}
        }
        this.callBase(options);
        this._backend = new localStoreBackends[options.backend || "dom"](this, options);
        this._backend.load()
    },
    clear: function() {
        this.callBase();
        this._backend.notifyChanged()
    },
    _insertImpl: function(values) {
        var b = this._backend;
        return this.callBase(values).done(b.notifyChanged.bind(b))
    },
    _updateImpl: function(key, values) {
        var b = this._backend;
        return this.callBase(key, values).done(b.notifyChanged.bind(b))
    },
    _removeImpl: function(key) {
        var b = this._backend;
        return this.callBase(key).done(b.notifyChanged.bind(b))
    }
}, "local");
module.exports = LocalStore;
module.exports.default = module.exports;


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/endpoint_selector.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var errors = __webpack_require__(13),
    proxyUrlFormatter = __webpack_require__(184);
var location = window.location,
    IS_WINJS_ORIGIN = "ms-appx:" === location.protocol,
    IS_LOCAL_ORIGIN = isLocalHostName(location.hostname);

function isLocalHostName(url) {
    return /^(localhost$|127\.)/i.test(url)
}
var EndpointSelector = function(config) {
    this.config = config
};
EndpointSelector.prototype = {
    urlFor: function(key) {
        var bag = this.config[key];
        if (!bag) {
            throw errors.Error("E0006")
        }
        if (proxyUrlFormatter.isProxyUsed()) {
            return proxyUrlFormatter.formatProxyUrl(bag.local)
        }
        if (bag.production) {
            if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
                return bag.production
            }
        }
        return bag.local
    }
};
module.exports = EndpointSelector;
module.exports.default = module.exports;


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/data.odata.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(183);
DevExpress.data.ODataStore = __webpack_require__(185);
DevExpress.data.ODataContext = __webpack_require__(273);
DevExpress.data.utils = DevExpress.data.utils || {};
DevExpress.data.utils.odata = {};
DevExpress.data.utils.odata.keyConverters = __webpack_require__(78).keyConverters;
DevExpress.data.EdmLiteral = __webpack_require__(78).EdmLiteral;
var ODataUtilsModule = __webpack_require__(78);
DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
DevExpress.data.queryAdapters.odata = __webpack_require__(120).odata;


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (data/odata/context.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    errorsModule = __webpack_require__(29),
    ODataStore = __webpack_require__(185),
    mixins = __webpack_require__(186),
    when = __webpack_require__(10).when;
__webpack_require__(120);
var ODataContext = Class.inherit({
    ctor: function(options) {
        var that = this;
        that._extractServiceOptions(options);
        that._errorHandler = options.errorHandler;
        $.each(options.entities || [], function(entityAlias, entityOptions) {
            that[entityAlias] = new ODataStore(extend({}, options, {
                url: that._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)
            }, entityOptions))
        })
    },
    get: function(operationName, params) {
        return this.invoke(operationName, params, "GET")
    },
    invoke: function(operationName, params, httpMethod) {
        params = params || {};
        httpMethod = (httpMethod || "POST").toLowerCase();
        var payload, d = $.Deferred(),
            url = this._url + "/" + encodeURIComponent(operationName);
        if (4 === this.version()) {
            if ("get" === httpMethod) {
                url = mixins.formatFunctionInvocationUrl(url, mixins.escapeServiceOperationParams(params, this.version()));
                params = null
            } else {
                if ("post" === httpMethod) {
                    payload = params;
                    params = null
                }
            }
        }
        when(this._sendRequest(url, httpMethod, mixins.escapeServiceOperationParams(params, this.version()), payload)).done(function(r) {
            if (typeUtils.isPlainObject(r) && operationName in r) {
                r = r[operationName]
            }
            d.resolve(r)
        }).fail([this._errorHandler, errorsModule._errorHandler, d.reject]);
        return d.promise()
    },
    objectLink: function(entityAlias, key) {
        var store = this[entityAlias];
        if (!store) {
            throw errorsModule.errors.Error("E4015", entityAlias)
        }
        if (!commonUtils.isDefined(key)) {
            return null
        }
        return {
            __metadata: {
                uri: store._byKeyUrl(key, true)
            }
        }
    }
}).include(mixins.SharedMethods);
module.exports = ODataContext;
module.exports.default = module.exports;


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/ui.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(82);
module.exports = DevExpress.ui = {};
DevExpress.ui.templateRendered = __webpack_require__(64).renderedCallbacks;


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/set_template_engine.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(172).setTemplateEngine;
module.exports.default = module.exports;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/collection/ui.collection_widget.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    isPlainObject = __webpack_require__(9).isPlainObject,
    when = __webpack_require__(10).when,
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    Action = __webpack_require__(62),
    Guid = __webpack_require__(34),
    domUtils = __webpack_require__(15),
    dataUtils = __webpack_require__(14),
    Widget = __webpack_require__(27),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    DataHelperMixin = __webpack_require__(121),
    CollectionWidgetItem = __webpack_require__(122),
    selectors = __webpack_require__(92),
    messageLocalization = __webpack_require__(8),
    holdEvent = __webpack_require__(66),
    clickEvent = __webpack_require__(11),
    contextMenuEvent = __webpack_require__(146),
    BindableTemplate = __webpack_require__(52);
var COLLECTION_CLASS = "dx-collection",
    ITEM_CLASS = "dx-item",
    CONTENT_CLASS_POSTFIX = "-content",
    ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder",
    ITEM_DATA_KEY = "dxItemData",
    ITEM_INDEX_KEY = "dxItemIndex",
    ITEM_TEMPLATE_ID_PREFIX = "tmpl-",
    ITEMS_SELECTOR = "[data-options*='dxItem']",
    SELECTED_ITEM_CLASS = "dx-item-selected",
    ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait",
    EMPTY_COLLECTION = "dx-empty-collection",
    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
    ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w\.]+)$/;
var FOCUS_UP = "up",
    FOCUS_DOWN = "down",
    FOCUS_LEFT = "left",
    FOCUS_RIGHT = "right",
    FOCUS_PAGE_UP = "pageup",
    FOCUS_PAGE_DOWN = "pagedown",
    FOCUS_LAST = "last",
    FOCUS_FIRST = "first";
var CollectionWidget = Widget.inherit({
    _activeStateUnit: "." + ITEM_CLASS,
    _supportedKeys: function() {
        var enter = function(e) {
                var $itemElement = this.option("focusedElement");
                if (!$itemElement) {
                    return
                }
                e.target = $itemElement;
                e.currentTarget = $itemElement;
                this._itemClickHandler(e)
            },
            space = function(e) {
                e.preventDefault();
                enter.call(this, e)
            },
            move = function(location, e) {
                e.preventDefault();
                e.stopPropagation();
                this._moveFocus(location, e)
            };
        return extend(this.callBase(), {
            space: space,
            enter: enter,
            leftArrow: move.bind(this, FOCUS_LEFT),
            rightArrow: move.bind(this, FOCUS_RIGHT),
            upArrow: move.bind(this, FOCUS_UP),
            downArrow: move.bind(this, FOCUS_DOWN),
            pageUp: move.bind(this, FOCUS_UP),
            pageDown: move.bind(this, FOCUS_DOWN),
            home: move.bind(this, FOCUS_FIRST),
            end: move.bind(this, FOCUS_LAST)
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            selectOnFocus: false,
            loopItemFocus: true,
            items: [],
            itemTemplate: "item",
            onItemRendered: null,
            onItemClick: null,
            onItemHold: null,
            itemHoldTimeout: 750,
            onItemContextMenu: null,
            onFocusedItemChanged: null,
            noDataText: messageLocalization.format("dxCollectionWidget-noDataText"),
            dataSource: null,
            _itemAttributes: {},
            itemTemplateProperty: "template",
            focusOnSelectedItem: true,
            focusedElement: null,
            disabledExpr: function(data) {
                return data ? data.disabled : void 0
            },
            visibleExpr: function(data) {
                return data ? data.visible : void 0
            }
        })
    },
    _getAnonymousTemplateName: function() {
        return "item"
    },
    _init: function() {
        this.callBase();
        this._cleanRenderedItems();
        this._refreshDataSource()
    },
    _initTemplates: function() {
        this._initItemsFromMarkup();
        this.callBase();
        this._defaultTemplates.item = new BindableTemplate(function($container, data) {
            if (isPlainObject(data)) {
                if (data.text) {
                    $container.text(data.text)
                }
                if (data.html) {
                    $container.html(data.html)
                }
            } else {
                $container.text(String(data))
            }
        }, ["text", "html"], this.option("integrationOptions.watchMethod"))
    },
    _initItemsFromMarkup: function() {
        var $items = this.element().contents().filter(ITEMS_SELECTOR);
        if (!$items.length || this.option("items").length) {
            return
        }
        var items = $.map($items, function(item) {
            var $item = $(item);
            var result = domUtils.getElementOptions(item).dxItem;
            var isTemplateRequired = $.trim($item.html()) && !result.template;
            if (isTemplateRequired) {
                result.template = this._prepareItemTemplate($item)
            } else {
                $item.remove()
            }
            return result
        }.bind(this));
        this.option("items", items)
    },
    _prepareItemTemplate: function($item) {
        var templateId = ITEM_TEMPLATE_ID_PREFIX + new Guid;
        var templateOptions = 'dxTemplate: { name: "' + templateId + '" }';
        $item.detach().clone().attr("data-options", templateOptions).data("options", templateOptions).appendTo(this.element());
        return templateId
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _cleanRenderedItems: function() {
        this._renderedItemsCount = 0
    },
    _focusTarget: function() {
        return this.element()
    },
    _focusInHandler: function(e) {
        this.callBase.apply(this, arguments);
        if (inArray(e.target, this._focusTarget()) === -1) {
            return
        }
        var $focusedElement = this.option("focusedElement");
        if ($focusedElement && $focusedElement.length) {
            this._setFocusedItem($focusedElement)
        } else {
            var $activeItem = this._getActiveItem();
            if ($activeItem.length) {
                this.option("focusedElement", $activeItem)
            }
        }
    },
    _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        var $target = this.option("focusedElement");
        if ($target) {
            this._toggleFocusClass(false, $target)
        }
    },
    _getActiveItem: function(last) {
        var $focusedElement = this.option("focusedElement");
        if ($focusedElement && $focusedElement.length) {
            return $focusedElement
        }
        var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0,
            activeElements = this._getActiveElement(),
            lastIndex = activeElements.length - 1;
        if (index < 0) {
            index = last ? lastIndex : 0
        }
        return activeElements.eq(index)
    },
    _renderFocusTarget: function() {
        this.callBase.apply(this, arguments);
        this._refreshActiveDescendant()
    },
    _moveFocus: function(location) {
        var $newTarget, $items = this._getAvailableItems();
        switch (location) {
            case FOCUS_PAGE_UP:
            case FOCUS_UP:
                $newTarget = this._prevItem($items);
                break;
            case FOCUS_PAGE_DOWN:
            case FOCUS_DOWN:
                $newTarget = this._nextItem($items);
                break;
            case FOCUS_RIGHT:
                $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                break;
            case FOCUS_LEFT:
                $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                break;
            case FOCUS_FIRST:
                $newTarget = $items.first();
                break;
            case FOCUS_LAST:
                $newTarget = $items.last();
                break;
            default:
                return false
        }
        if (0 !== $newTarget.length) {
            this.option("focusedElement", $newTarget)
        }
    },
    _getAvailableItems: function($itemElements) {
        $itemElements = $itemElements || this._itemElements();
        return $itemElements.filter(":visible").not(".dx-state-disabled")
    },
    _prevItem: function($items) {
        var $target = this._getActiveItem(),
            targetIndex = $items.index($target),
            $last = $items.last(),
            $item = $($items[targetIndex - 1]),
            loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
            $item = $last
        }
        return $item
    },
    _nextItem: function($items) {
        var $target = this._getActiveItem(true),
            targetIndex = $items.index($target),
            $first = $items.first(),
            $item = $($items[targetIndex + 1]),
            loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
            $item = $first
        }
        return $item
    },
    _selectFocusedItem: function($target) {
        this.selectItem($target)
    },
    _removeFocusedItem: function($target) {
        if ($target && $target.length) {
            this._toggleFocusClass(false, $target);
            $target.removeAttr("id")
        }
    },
    _refreshActiveDescendant: function() {
        this.setAria("activedescendant", "");
        this.setAria("activedescendant", this.getFocusedItemId())
    },
    _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
            return
        }
        $target.attr("id", this.getFocusedItemId());
        this._toggleFocusClass(true, $target);
        this.onFocusedItemChanged(this.getFocusedItemId());
        this._refreshActiveDescendant();
        if (this.option("selectOnFocus")) {
            this._selectFocusedItem($target)
        }
    },
    _findItemElementByItem: function(item) {
        var result = $(),
            that = this;
        this.itemElements().each(function() {
            var $item = $(this);
            if ($item.data(that._itemDataKey()) === item) {
                result = $item;
                return false
            }
        });
        return result
    },
    _getIndexByItem: function(item) {
        return this.option("items").indexOf(item)
    },
    _itemOptionChanged: function(item, property, value, oldValue) {
        var $item = this._findItemElementByItem(item);
        if (!$item.length) {
            return
        }
        if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
            var itemData = this._getItemData($item),
                index = $item.data(this._itemIndexKey());
            this._renderItem(index, itemData, null, $item)
        }
    },
    _optionChanged: function(args) {
        if ("items" === args.name) {
            var matches = args.fullName.match(ITEM_PATH_REGEX);
            if (matches && matches.length) {
                var property = matches[matches.length - 1],
                    itemPath = args.fullName.replace("." + property, ""),
                    item = this.option(itemPath);
                this._itemOptionChanged(item, property, args.value, args.previousValue);
                return
            }
        }
        switch (args.name) {
            case "items":
            case "_itemAttributes":
            case "itemTemplateProperty":
                this._cleanRenderedItems();
                this._invalidate();
                break;
            case "dataSource":
                this.option("items", []);
                this._refreshDataSource();
                this._renderEmptyMessage();
                break;
            case "noDataText":
                this._renderEmptyMessage();
                break;
            case "itemTemplate":
                this._invalidate();
                break;
            case "onItemRendered":
                this._createItemRenderAction();
                break;
            case "onItemClick":
                break;
            case "onItemHold":
            case "itemHoldTimeout":
                this._attachHoldEvent();
                break;
            case "onItemContextMenu":
                this._attachContextMenuEvent();
                break;
            case "onFocusedItemChanged":
                this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                break;
            case "selectOnFocus":
            case "loopItemFocus":
            case "focusOnSelectedItem":
                break;
            case "focusedElement":
                this._removeFocusedItem(args.previousValue);
                this._setFocusedItem(args.value);
                break;
            case "visibleExpr":
            case "disabledExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _loadNextPage: function() {
        var dataSource = this._dataSource;
        this._expectNextPageLoading();
        dataSource.pageIndex(1 + dataSource.pageIndex());
        return dataSource.load()
    },
    _expectNextPageLoading: function() {
        this._startIndexForAppendedItems = 0
    },
    _expectLastItemLoading: function() {
        this._startIndexForAppendedItems = -1
    },
    _forgetNextPageLoading: function() {
        this._startIndexForAppendedItems = null
    },
    _dataSourceChangedHandler: function(newItems) {
        var items = this.option("items");
        if (this._initialized && items && this._shouldAppendItems()) {
            this._renderedItemsCount = items.length;
            if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
                this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems))
            }
            this._forgetNextPageLoading();
            this._renderContent();
            this._renderFocusTarget()
        } else {
            this.option("items", newItems)
        }
    },
    _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        this.option("items", this.option("items"))
    },
    _shouldAppendItems: function() {
        return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend()
    },
    _allowDynamicItemsAppend: function() {
        return false
    },
    _clean: function() {
        this._cleanFocusState();
        this._cleanItemContainer()
    },
    _cleanItemContainer: function() {
        this._itemContainer().empty()
    },
    _dispose: function() {
        this.callBase();
        clearTimeout(this._itemFocusTimeout)
    },
    _refresh: function() {
        this._cleanRenderedItems();
        this.callBase.apply(this, arguments)
    },
    _itemContainer: function() {
        return this.element()
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemContentClass: function() {
        return this._itemClass() + CONTENT_CLASS_POSTFIX
    },
    _selectedItemClass: function() {
        return SELECTED_ITEM_CLASS
    },
    _itemResponseWaitClass: function() {
        return ITEM_RESPONSE_WAIT_CLASS
    },
    _itemSelector: function() {
        return "." + this._itemClass()
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _itemIndexKey: function() {
        return ITEM_INDEX_KEY
    },
    _itemElements: function() {
        return this._itemContainer().find(this._itemSelector())
    },
    _render: function() {
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        this.callBase();
        this.element().addClass(COLLECTION_CLASS);
        this._attachClickEvent();
        this._attachHoldEvent();
        this._attachContextMenuEvent()
    },
    _attachClickEvent: function() {
        var itemSelector = this._itemSelector(),
            clickEventNamespace = eventUtils.addNamespace(clickEvent.name, this.NAME),
            pointerDownEventNamespace = eventUtils.addNamespace(pointerEvents.down, this.NAME),
            that = this;
        var pointerDownAction = new Action(function(args) {
            var event = args.event;
            that._itemPointerDownHandler(event)
        });
        this._itemContainer().off(clickEventNamespace, itemSelector).off(pointerDownEventNamespace, itemSelector).on(clickEventNamespace, itemSelector, function(e) {
            this._itemClickHandler(e)
        }.bind(this)).on(pointerDownEventNamespace, itemSelector, function(e) {
            pointerDownAction.execute({
                element: $(e.target),
                event: e
            })
        })
    },
    _itemClickHandler: function(e, args, config) {
        this._itemJQueryEventHandler(e, "onItemClick", args, config)
    },
    _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        this._itemFocusHandler = function() {
            clearTimeout(this._itemFocusTimeout);
            this._itemFocusHandler = null;
            if (e.isDefaultPrevented()) {
                return
            }
            var $target = $(e.target),
                $closestItem = $target.closest(this._itemElements()),
                $closestFocusable = this._closestFocusable($target);
            if ($closestItem.length && inArray($closestFocusable.get(0), this._focusTarget()) !== -1) {
                this.option("focusedElement", $closestItem)
            }
        }.bind(this);
        this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this))
    },
    _closestFocusable: function($target) {
        if ($target.is(selectors.focusable)) {
            return $target
        } else {
            $target = $target.parent();
            while ($target.length) {
                if ($target.is(selectors.focusable)) {
                    return $target
                }
                $target = $target.parent()
            }
        }
    },
    _forcePointerDownFocus: function() {
        this._itemFocusHandler && this._itemFocusHandler()
    },
    _updateFocusState: function() {
        this.callBase.apply(this, arguments);
        this._forcePointerDownFocus()
    },
    _attachHoldEvent: function() {
        var $itemContainer = this._itemContainer(),
            itemSelector = this._itemSelector(),
            eventName = eventUtils.addNamespace(holdEvent.name, this.NAME);
        $itemContainer.off(eventName, itemSelector);
        $itemContainer.on(eventName, itemSelector, {
            timeout: this._getHoldTimeout()
        }, this._itemHoldHandler.bind(this))
    },
    _getHoldTimeout: function() {
        return this.option("itemHoldTimeout")
    },
    _shouldFireHoldEvent: function() {
        return this.hasActionSubscription("onItemHold")
    },
    _itemHoldHandler: function(e) {
        if (this._shouldFireHoldEvent()) {
            this._itemJQueryEventHandler(e, "onItemHold")
        } else {
            e.cancel = true
        }
    },
    _attachContextMenuEvent: function() {
        var $itemContainer = this._itemContainer(),
            itemSelector = this._itemSelector(),
            eventName = eventUtils.addNamespace(contextMenuEvent.name, this.NAME);
        $itemContainer.off(eventName, itemSelector);
        $itemContainer.on(eventName, itemSelector, this._itemContextMenuHandler.bind(this))
    },
    _shouldFireContextMenuEvent: function() {
        return this.hasActionSubscription("onItemContextMenu")
    },
    _itemContextMenuHandler: function(e) {
        if (this._shouldFireContextMenuEvent()) {
            this._itemJQueryEventHandler(e, "onItemContextMenu")
        } else {
            e.cancel = true
        }
    },
    _renderContentImpl: function() {
        var items = this.option("items") || [];
        if (this._renderedItemsCount) {
            this._renderItems(items.slice(this._renderedItemsCount))
        } else {
            this._renderItems(items)
        }
    },
    _renderItems: function(items) {
        if (items.length) {
            $.each(items, this._renderItem.bind(this))
        }
        this._renderEmptyMessage()
    },
    _renderItem: function(index, itemData, $container, $itemToReplace) {
        $container = $container || this._itemContainer();
        var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);
        this._setElementData($itemFrame, itemData, index);
        $itemFrame.attr(this.option("_itemAttributes"));
        this._attachItemClickEvent(itemData, $itemFrame);
        var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
        $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
        var renderContentPromise = this._renderItemContent({
            index: index,
            itemData: itemData,
            container: $itemContent,
            contentClass: this._itemContentClass(),
            defaultTemplateName: this.option("itemTemplate")
        });
        var that = this;
        when(renderContentPromise).done(function($itemContent) {
            that._postprocessRenderItem({
                itemElement: $itemFrame,
                itemContent: $itemContent,
                itemData: itemData,
                itemIndex: index
            });
            that._executeItemRenderAction(index, itemData, $itemFrame)
        });
        return $itemFrame
    },
    _attachItemClickEvent: function(itemData, $itemElement) {
        if (!itemData || !itemData.onClick) {
            return
        }
        $itemElement.on(clickEvent.name, function(e) {
            this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
                jQueryEvent: e
            })
        }.bind(this))
    },
    _renderItemContent: function(args) {
        var itemTemplateName = this._getItemTemplateName(args);
        var itemTemplate = this._getTemplate(itemTemplateName);
        this._addItemContentClasses(args);
        var $templateResult = this._createItemByTemplate(itemTemplate, args);
        if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
            return args.container
        }
        return this._renderItemContentByNode(args, $templateResult)
    },
    _renderItemContentByNode: function(args, $node) {
        args.container.replaceWith($node);
        args.container = $node;
        this._addItemContentClasses(args);
        return $node
    },
    _addItemContentClasses: function(args) {
        var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
        args.container.addClass(classes.join(" "))
    },
    _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
        var $itemFrame = $("<div>");
        new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
        if ($itemToReplace && $itemToReplace.length) {
            $itemToReplace.replaceWith($itemFrame)
        } else {
            $itemFrame.appendTo($container)
        }
        return $itemFrame
    },
    _itemOptions: function() {
        var that = this;
        return {
            watchMethod: function() {
                return that.option("integrationOptions.watchMethod")
            },
            fieldGetter: function(field) {
                var expr = that.option(field + "Expr"),
                    getter = dataUtils.compileGetter(expr);
                return getter
            }
        }
    },
    _postprocessRenderItem: commonUtils.noop,
    _executeItemRenderAction: function(index, itemData, itemElement) {
        this._getItemRenderAction()({
            itemElement: itemElement,
            itemIndex: index,
            itemData: itemData
        })
    },
    _setElementData: function(element, data, index) {
        element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
    },
    _createItemRenderAction: function() {
        return this._itemRenderAction = this._createActionByOption("onItemRendered", {
            element: this.element(),
            excludeValidators: ["designMode", "disabled", "readOnly"],
            category: "rendering"
        })
    },
    _getItemRenderAction: function() {
        return this._itemRenderAction || this._createItemRenderAction()
    },
    _getItemTemplateName: function(args) {
        var data = args.itemData,
            templateProperty = args.templateProperty || this.option("itemTemplateProperty"),
            template = data && data[templateProperty];
        return template || args.defaultTemplateName
    },
    _createItemByTemplate: function(itemTemplate, renderArgs) {
        return itemTemplate.render({
            model: renderArgs.itemData,
            container: renderArgs.container,
            index: renderArgs.index
        })
    },
    _emptyMessageContainer: function() {
        return this._itemContainer()
    },
    _renderEmptyMessage: function() {
        var noDataText = this.option("noDataText"),
            items = this.option("items"),
            hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
        if (hideNoData && this._$noData) {
            this._$noData.remove();
            this._$noData = null;
            this.setAria("label", void 0)
        }
        if (!hideNoData) {
            this._$noData = this._$noData || $("<div>").addClass("dx-empty-message");
            this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
            this.setAria("label", noDataText)
        }
        this.element().toggleClass(EMPTY_COLLECTION, !hideNoData)
    },
    _itemJQueryEventHandler: function(jQueryEvent, handlerOptionName, actionArgs, actionConfig) {
        this._itemEventHandler(jQueryEvent.target, handlerOptionName, extend(actionArgs, {
            jQueryEvent: jQueryEvent
        }), actionConfig)
    },
    _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
        var action = this._createActionByOption(handlerOptionName, extend({
            validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs)
    },
    _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
        var action = this._createAction(handler, extend({
            validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs)
    },
    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = this._closestItemElement($(initiator)),
            args = extend({}, actionArgs);
        return action(extend(actionArgs, this._extendActionArgs($itemElement), args))
    },
    _extendActionArgs: function($itemElement) {
        return {
            itemElement: $itemElement,
            itemIndex: this._itemElements().index($itemElement),
            itemData: this._getItemData($itemElement)
        }
    },
    _closestItemElement: function($element) {
        return $($element).closest(this._itemSelector())
    },
    _getItemData: function(itemElement) {
        return $(itemElement).data(this._itemDataKey())
    },
    getFocusedItemId: function() {
        if (!this._focusedItemId) {
            this._focusedItemId = "dx-" + new Guid
        }
        return this._focusedItemId
    },
    itemElements: function() {
        return this._itemElements()
    },
    itemsContainer: function() {
        return this._itemContainer()
    }
}).include(DataHelperMixin);
CollectionWidget.ItemClass = CollectionWidgetItem;
module.exports = CollectionWidget;


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    abstract = Class.abstract;
var EditStrategy = Class.inherit({
    ctor: function(collectionWidget) {
        this._collectionWidget = collectionWidget
    },
    getIndexByItemData: abstract,
    getItemDataByIndex: abstract,
    getKeysByItems: abstract,
    getItemsByKeys: abstract,
    itemsGetter: abstract,
    getKeyByIndex: function(index) {
        var resultIndex = this._denormalizeItemIndex(index);
        return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0]
    },
    _equalKeys: function(key1, key2) {
        if (this._collectionWidget._isKeySpecified()) {
            return commonUtils.equalByValue(key1, key2)
        } else {
            return key1 === key2
        }
    },
    getIndexByKey: abstract,
    getNormalizedIndex: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return value
        }
        if (this._isItemIndex(value)) {
            return this._normalizeItemIndex(value)
        }
        if (this._isDOMNode(value)) {
            return this._getNormalizedItemIndex(value)
        }
        return this._normalizeItemIndex(this.getIndexByItemData(value))
    },
    getIndex: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return this._denormalizeItemIndex(value)
        }
        if (this._isItemIndex(value)) {
            return value
        }
        if (this._isDOMNode(value)) {
            return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
        }
        return this.getIndexByItemData(value)
    },
    getItemElement: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return this._getItemByNormalizedIndex(value)
        }
        if (this._isItemIndex(value)) {
            return this._getItemByNormalizedIndex(this._normalizeItemIndex(value))
        }
        if (this._isDOMNode(value)) {
            return $(value)
        }
        return this._getItemByNormalizedIndex(this.getIndexByItemData(value))
    },
    deleteItemAtIndex: abstract,
    itemPlacementFunc: function(movingIndex, destinationIndex) {
        return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
    },
    moveItemAtIndexToIndex: abstract,
    _isNormalizedItemIndex: function(index) {
        return "number" === typeof index && Math.round(index) === index
    },
    _isDOMNode: function(value) {
        var $value;
        try {
            $value = $(value)
        } catch (error) {
            return false
        }
        return $value && $value.length && $value.get(0).nodeType
    },
    _isItemIndex: abstract,
    _getNormalizedItemIndex: abstract,
    _normalizeItemIndex: abstract,
    _denormalizeItemIndex: abstract,
    _getItemByNormalizedIndex: abstract,
    _itemsFromSameParent: abstract
});
module.exports = EditStrategy;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/selection/selection.strategy.deferred.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    SelectionStrategy = __webpack_require__(190),
    errors = __webpack_require__(16),
    dataQuery = __webpack_require__(35);
module.exports = SelectionStrategy.inherit({
    getSelectedItems: function() {
        return this._loadFilteredData(this.options.selectionFilter)
    },
    getSelectedItemKeys: function() {
        var d = $.Deferred(),
            that = this,
            key = this.options.key(),
            select = commonUtils.isString(key) ? [key] : key;
        this._loadFilteredData(this.options.selectionFilter, null, select).done(function(items) {
            var keys = items.map(function(item) {
                return that.options.keyOf(item)
            });
            d.resolve(keys)
        }).fail(d.reject);
        return d.promise()
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
        if (isSelectAll) {
            var filter = this.options.filter();
            if (!filter) {
                this._setOption("selectionFilter", isDeselect ? [] : null)
            } else {
                this._addSelectionFilter(isDeselect, filter, false)
            }
        } else {
            if (!preserve) {
                this._setOption("selectionFilter", [])
            }
            for (var i = 0; i < keys.length; i++) {
                if (isDeselect) {
                    this.removeSelectedItem(keys[i])
                } else {
                    this.addSelectedItem(keys[i])
                }
            }
        }
        this.onSelectionChanged();
        return $.Deferred().resolve()
    },
    setSelectedItems: function(keys) {
        this._setOption("selectionFilter", null);
        for (var i = 0; i < keys.length; i++) {
            this.addSelectedItem(keys[i])
        }
    },
    isItemDataSelected: function(itemData) {
        return this.isItemKeySelected(itemData)
    },
    isItemKeySelected: function(itemData) {
        var selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
            return true
        }
        return !!dataQuery([itemData]).filter(selectionFilter).toArray().length
    },
    _processSelectedItem: function(key) {
        var keyField = this.options.key(),
            filter = [keyField, "=", key];
        if (Array.isArray(keyField)) {
            filter = [];
            for (var i = 0; i < keyField.length; i++) {
                filter.push([keyField[i], "=", key[keyField[i]]]);
                if (i !== keyField.length - 1) {
                    filter.push("and")
                }
            }
        }
        return filter
    },
    addSelectedItem: function(key) {
        var filter = this._processSelectedItem(key);
        this._addSelectionFilter(false, filter, true)
    },
    removeSelectedItem: function(key) {
        var filter = this._processSelectedItem(key);
        this._addSelectionFilter(true, filter, true)
    },
    validate: function() {
        var key = this.options.key;
        if (key && void 0 === key()) {
            throw errors.Error("E1042")
        }
    },
    _findSubFilter: function(selectionFilter, filter) {
        if (!selectionFilter) {
            return -1
        }
        var filterString = JSON.stringify(filter);
        for (var index = 0; index < selectionFilter.length; index++) {
            var subFilter = selectionFilter[index];
            if (subFilter && JSON.stringify(subFilter) === filterString) {
                return index
            }
        }
        return -1
    },
    _isLastSubFilter: function(selectionFilter, filter) {
        if (selectionFilter && filter) {
            return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter)
        }
        return false
    },
    _addFilterOperator: function(selectionFilter, filterOperator) {
        if (selectionFilter.length > 1 && commonUtils.isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
            selectionFilter = [selectionFilter]
        }
        if (selectionFilter.length) {
            selectionFilter.push(filterOperator)
        }
        return selectionFilter
    },
    _denormalizeFilter: function(filter) {
        if (filter && commonUtils.isString(filter[0])) {
            filter = [filter]
        }
        return filter
    },
    _addSelectionFilter: function(isDeselect, filter, isUnique) {
        var that = this,
            needAddFilter = true,
            currentFilter = isDeselect ? ["!", filter] : filter,
            selectionFilter = that.options.selectionFilter || [];
        selectionFilter = that._denormalizeFilter(selectionFilter);
        if (selectionFilter && selectionFilter.length) {
            that._removeSameFilter(selectionFilter, filter, isDeselect, true);
            if (that._removeSameFilter(selectionFilter, filter, !isDeselect, !isUnique)) {
                needAddFilter = selectionFilter.length && !isUnique
            }
            if (needAddFilter) {
                selectionFilter = that._addFilterOperator(selectionFilter, isDeselect ? "and" : "or")
            }
        }
        if (needAddFilter) {
            selectionFilter.push(currentFilter)
        }
        selectionFilter = that._normalizeFilter(selectionFilter);
        that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter)
    },
    _normalizeFilter: function(filter) {
        if (filter && 1 === filter.length) {
            filter = filter[0]
        }
        return filter
    },
    _removeSameFilter: function(selectionFilter, filter, inverted, forceRemove) {
        filter = inverted ? ["!", filter] : filter;
        var filterIndex = this._findSubFilter(selectionFilter, filter);
        if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
            selectionFilter.splice(0, selectionFilter.length);
            return true
        }
        var isLastItem = filterIndex === selectionFilter.length - 1;
        if (filterIndex >= 0 && (forceRemove || isLastItem)) {
            if (filterIndex > 0) {
                selectionFilter.splice(filterIndex - 1, 2)
            } else {
                selectionFilter.splice(filterIndex, 2)
            }
            return true
        }
        return false
    },
    getSelectAllState: function() {
        var filter = this.options.filter(),
            selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
            return true
        }
        if (!selectionFilter.length) {
            return false
        }
        if (!filter || !filter.length) {
            return
        }
        selectionFilter = this._denormalizeFilter(selectionFilter);
        if (this._isLastSubFilter(selectionFilter, filter)) {
            return true
        }
        if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
            return false
        }
        return
    }
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/selection/selection.strategy.standard.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    getKeyHash = commonUtils.getKeyHash,
    dataQuery = __webpack_require__(35),
    when = __webpack_require__(10).when,
    errors = __webpack_require__(16),
    SelectionStrategy = __webpack_require__(190);

function SelectionFilterCreator(keyExpr, selectedItemKeys, isSelectAll, equalKeys, keyOf, equalByReference) {
    this.getLocalFilter = function() {
        return functionFilter
    };
    this.getExpr = function() {
        if (!keyExpr) {
            return
        }
        var filterExpr;
        for (var i = 0, length = selectedItemKeys.length; i < length; i++) {
            filterExpr = filterExpr || [];
            var filterExprPart, itemKeyValue = selectedItemKeys[i];
            if (i > 0) {
                filterExpr.push(isSelectAll ? "and" : "or")
            }
            if (commonUtils.isString(keyExpr)) {
                filterExprPart = getFilterForPlainKey(itemKeyValue)
            } else {
                filterExprPart = getFilterForCompositeKey(itemKeyValue)
            }
            filterExpr.push(filterExprPart)
        }
        if (filterExpr && 1 === filterExpr.length) {
            filterExpr = filterExpr[0]
        }
        this._filter = filterExpr;
        return filterExpr
    };
    this.getCombinedFilter = function(dataSourceFilter) {
        var filterExpr = this.getExpr(),
            combinedFilter = filterExpr;
        if (isSelectAll && dataSourceFilter) {
            if (filterExpr) {
                combinedFilter = [];
                combinedFilter.push(filterExpr);
                combinedFilter.push(dataSourceFilter)
            } else {
                combinedFilter = dataSourceFilter
            }
        }
        return combinedFilter
    };
    var selectedItemKeyHashesMap;
    var getSelectedItemKeyHashesMap = function(selectedItemKeys) {
        if (!selectedItemKeyHashesMap) {
            selectedItemKeyHashesMap = {};
            for (var i = 0; i < selectedItemKeys.length; i++) {
                selectedItemKeyHashesMap[getKeyHash(selectedItemKeys[i])] = true
            }
        }
        return selectedItemKeyHashesMap
    };
    var functionFilter = function(item) {
        var keyHash, i, key = keyOf(item);
        if (!equalByReference) {
            keyHash = getKeyHash(key);
            if (!commonUtils.isObject(keyHash)) {
                var selectedKeyHashesMap = getSelectedItemKeyHashesMap(selectedItemKeys);
                if (selectedKeyHashesMap[keyHash]) {
                    return !isSelectAll
                }
                return !!isSelectAll
            }
        }
        for (i = 0; i < selectedItemKeys.length; i++) {
            if (equalKeys(selectedItemKeys[i], key)) {
                return !isSelectAll
            }
        }
        return !!isSelectAll
    };
    var getFilterForPlainKey = function(keyValue, key) {
        return [key || keyExpr, isSelectAll ? "<>" : "=", keyValue]
    };
    var getFilterForCompositeKey = function(itemKeyValue) {
        var filterExpr = [];
        for (var i = 0, length = keyExpr.length; i < length; i++) {
            if (i > 0) {
                filterExpr.push(isSelectAll ? "or" : "and")
            }
            var currentKeyExpr = keyExpr[i],
                currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr],
                filterExprPart = getFilterForPlainKey(currentKeyValue, currentKeyExpr);
            filterExpr.push(filterExprPart)
        }
        return filterExpr
    }
}
module.exports = SelectionStrategy.inherit({
    ctor: function(options) {
        this.callBase(options);
        this._initSelectedItemKeyHash()
    },
    _initSelectedItemKeyHash: function() {
        this._setOption("keyHashIndices", this.options.equalByReference ? null : {})
    },
    getSelectedItemKeys: function() {
        return this.options.selectedItemKeys.slice(0)
    },
    getSelectedItems: function() {
        return this.options.selectedItems.slice(0)
    },
    _preserveSelectionUpdate: function(items, isDeselect) {
        var keyIndicesToRemoveMap, keyIndex, i, keyOf = this.options.keyOf;
        if (!keyOf) {
            return
        }
        var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
        if (isBatchDeselect) {
            keyIndicesToRemoveMap = {}
        }
        for (i = 0; i < items.length; i++) {
            var item = items[i],
                key = keyOf(item);
            if (isDeselect) {
                keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap);
                if (keyIndicesToRemoveMap && keyIndex >= 0) {
                    keyIndicesToRemoveMap[keyIndex] = true
                }
            } else {
                this.addSelectedItem(key, item)
            }
        }
        if (isBatchDeselect) {
            this._batchRemoveSelectedItems(keyIndicesToRemoveMap)
        }
    },
    _batchRemoveSelectedItems: function(keyIndicesToRemoveMap) {
        var selectedItemKeys = this.options.selectedItemKeys.slice(0);
        var selectedItems = this.options.selectedItems.slice(0);
        this.options.selectedItemKeys.length = 0;
        this.options.selectedItems.length = 0;
        for (var i = 0; i < selectedItemKeys.length; i++) {
            if (!keyIndicesToRemoveMap[i]) {
                this.options.selectedItemKeys.push(selectedItemKeys[i]);
                this.options.selectedItems.push(selectedItems[i])
            }
        }
        this._initSelectedItemKeyHash();
        this.updateSelectedItemKeyHash(this.options.selectedItemKeys)
    },
    _loadSelectedItemsCore: function(keys, isDeselect, isSelectAll) {
        var deferred = $.Deferred(),
            key = this.options.key;
        if (!keys.length && !isSelectAll) {
            deferred.resolve([]);
            return deferred
        }
        var filter = this.options.filter();
        if (isSelectAll && isDeselect && !filter) {
            deferred.resolve(this.getSelectedItems());
            return deferred
        }
        var selectionFilterCreator = new SelectionFilterCreator(key(), keys, isSelectAll, this.equalKeys.bind(this), this.options.keyOf, this.options.equalByReference),
            combinedFilter = selectionFilterCreator.getCombinedFilter(filter);
        var deselectedItems = [];
        if (isDeselect) {
            deselectedItems = combinedFilter ? dataQuery(this.options.selectedItems).filter(combinedFilter).toArray() : this.options.selectedItems.slice(0)
        }
        var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems().filter(this.options.isSelectableItem).map(this.options.getItemData);
        var localFilter = selectionFilterCreator.getLocalFilter();
        filteredItems = filteredItems.filter(localFilter);
        if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
            deferred.resolve(filteredItems)
        } else {
            deferred = this._loadFilteredData(combinedFilter, localFilter)
        }
        return deferred
    },
    _replaceSelectionUpdate: function(items) {
        var internalKeys = [],
            keyOf = this.options.keyOf;
        if (!keyOf) {
            return
        }
        for (var i = 0; i < items.length; i++) {
            var item = items[i],
                key = keyOf(item);
            internalKeys.push(key)
        }
        this.setSelectedItems(internalKeys, items)
    },
    _warnOnIncorrectKeys: function(keys) {
        for (var i = 0; i < keys.length; i++) {
            if (!this.isItemKeySelected(keys[i])) {
                errors.log("W1002", keys[i])
            }
        }
    },
    _loadSelectedItems: function(keys, isDeselect, isSelectAll) {
        var that = this,
            deferred = $.Deferred();
        when(that._lastLoadDeferred).always(function() {
            that._loadSelectedItemsCore(keys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject)
        });
        that._lastLoadDeferred = deferred;
        return deferred
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
        var that = this,
            deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll);
        deferred.done(function(items) {
            if (preserve) {
                that._preserveSelectionUpdate(items, isDeselect)
            } else {
                that._replaceSelectionUpdate(items)
            }
            that.onSelectionChanged()
        });
        return deferred
    },
    addSelectedItem: function(key, itemData) {
        var keyHash = this._getKeyHash(key);
        if (this._indexOfSelectedItemKey(keyHash) === -1) {
            if (!commonUtils.isObject(keyHash) && this.options.keyHashIndices) {
                this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length]
            }
            this.options.selectedItemKeys.push(key);
            this.options.addedItemKeys.push(key);
            this.options.addedItems.push(itemData);
            this.options.selectedItems.push(itemData)
        }
    },
    _getSelectedIndexByKey: function(key, ignoreIndicesMap) {
        var selectedItemKeys = this.options.selectedItemKeys;
        for (var index = 0; index < selectedItemKeys.length; index++) {
            if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
                return index
            }
        }
        return -1
    },
    _getSelectedIndexByHash: function(key, ignoreIndicesMap) {
        var indices = this.options.keyHashIndices[key];
        if (indices && indices.length > 1 && ignoreIndicesMap) {
            indices = indices.filter(function(index) {
                return !ignoreIndicesMap[index]
            })
        }
        return indices && indices[0] >= 0 ? indices[0] : -1
    },
    _indexOfSelectedItemKey: function(key, ignoreIndicesMap) {
        var selectedIndex;
        if (this.options.equalByReference) {
            selectedIndex = this.options.selectedItemKeys.indexOf(key)
        } else {
            if (commonUtils.isObject(key)) {
                selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap)
            } else {
                selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap)
            }
        }
        return selectedIndex
    },
    _shiftSelectedKeyIndices: function(keyIndex) {
        for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
            var currentKey = this.options.selectedItemKeys[currentKeyIndex],
                currentKeyHash = getKeyHash(currentKey),
                currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
            if (!currentKeyIndices) {
                continue
            }
            for (var i = 0; i < currentKeyIndices.length; i++) {
                if (currentKeyIndices[i] > keyIndex) {
                    currentKeyIndices[i]--
                }
            }
        }
    },
    removeSelectedItem: function(key, keyIndicesToRemoveMap) {
        var keyHash = this._getKeyHash(key),
            isBatchDeselect = !!keyIndicesToRemoveMap,
            keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
        if (keyIndex < 0) {
            return keyIndex
        }
        this.options.removedItemKeys.push(key);
        this.options.removedItems.push(this.options.selectedItems[keyIndex]);
        if (isBatchDeselect) {
            return keyIndex
        }
        this.options.selectedItemKeys.splice(keyIndex, 1);
        this.options.selectedItems.splice(keyIndex, 1);
        if (commonUtils.isObject(keyHash) || !this.options.keyHashIndices) {
            return keyIndex
        }
        var keyIndices = this.options.keyHashIndices[keyHash];
        if (!keyIndices) {
            return keyIndex
        }
        keyIndices.shift();
        if (!keyIndices.length) {
            delete this.options.keyHashIndices[keyHash]
        }
        this._shiftSelectedKeyIndices(keyIndex);
        return keyIndex
    },
    _needRemoveItemKey: function(keys, key) {
        var hashIndices = this.options.keyHashIndices;
        if (!hashIndices) {
            return keys.indexOf(key) < 0
        }
        var hash = this._getKeyHash(key);
        for (var i = 0; i < keys.length; i++) {
            var keyHash = this._getKeyHash(keys[i]);
            if (this.equalKeys(hash, keyHash)) {
                return false
            }
        }
        return true
    },
    _updateAddedItemKeys: function(keys, items) {
        for (var i = 0; i < keys.length; i++) {
            if (this._indexOfSelectedItemKey(keys[i]) < 0) {
                this.options.addedItemKeys.push(keys[i]);
                this.options.addedItems.push(items[i])
            }
        }
    },
    _updateRemovedItemKeys: function(keys) {
        var oldSelectedKeys = this.options.selectedItemKeys,
            oldSelectedItems = this.options.selectedItems;
        for (var i = 0; i < oldSelectedKeys.length; i++) {
            if (this._needRemoveItemKey(keys, oldSelectedKeys[i])) {
                this.options.removedItemKeys.push(oldSelectedKeys[i]);
                this.options.removedItems.push(oldSelectedItems[i])
            }
        }
    },
    _getKeyHash: function(key) {
        return this.options.equalByReference ? key : getKeyHash(key)
    },
    setSelectedItems: function(keys, items) {
        this._updateRemovedItemKeys(keys, items);
        this._updateAddedItemKeys(keys, items);
        if (!this.options.equalByReference) {
            this._initSelectedItemKeyHash();
            this.updateSelectedItemKeyHash(keys)
        }
        this._setOption("selectedItemKeys", keys);
        this._setOption("selectedItems", items)
    },
    isItemDataSelected: function(itemData) {
        var key = this.options.keyOf(itemData);
        return this.isItemKeySelected(key)
    },
    isItemKeySelected: function(key) {
        var keyHash = this._getKeyHash(key);
        var index = this._indexOfSelectedItemKey(keyHash);
        return index !== -1
    },
    getSelectAllState: function(visibleOnly) {
        if (visibleOnly) {
            return this._getVisibleSelectAllState()
        } else {
            return this._getFullSelectAllState()
        }
    }
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/notify.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Action = __webpack_require__(62),
    viewPortUtils = __webpack_require__(54),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    Toast = __webpack_require__(191);
var $notify = null;
var notify = function(message, type, displayTime) {
    var options = isPlainObject(message) ? message : {
        message: message
    };
    var userHiddenAction = options.onHidden;
    extend(options, {
        type: type,
        displayTime: displayTime,
        onHidden: function(args) {
            args.element.remove();
            new Action(userHiddenAction, {
                context: args.model
            }).execute(arguments)
        }
    });
    $notify = $("<div>").appendTo(viewPortUtils.value());
    new Toast($notify, options).show()
};
module.exports = notify;
module.exports.default = module.exports;


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/autocomplete.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    DropDownList = __webpack_require__(150),
    themes = __webpack_require__(20);
var AUTOCOMPLETE_CLASS = "dx-autocomplete",
    AUTOCOMPLETE_POPUP_WRAPPER_CLASS = "dx-autocomplete-popup-wrapper";
var Autocomplete = DropDownList.inherit({
    _supportedKeys: function() {
        var item = this._list ? this._list.option("focusedElement") : null,
            parent = this.callBase();
        return extend({}, parent, {
            upArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (item && !item.prev().length) {
                    this._clearFocusedItem();
                    return false
                }
                return true
            },
            downArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (item && !item.next().length) {
                    this._clearFocusedItem();
                    return false
                }
                return true
            },
            enter: function() {
                if (!item) {
                    this.close()
                }
                parent.enter.apply(this, arguments);
                return this.option("opened")
            }
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            displayExpr: {
                since: "15.2",
                alias: "valueExpr"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            minSearchLength: 1,
            maxItemCount: 10,
            noDataText: "",
            showDropDownButton: false,
            searchEnabled: true
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                popupPosition: {
                    offset: {
                        h: -16,
                        v: -8
                    }
                }
            }
        }])
    },
    _render: function() {
        this.callBase();
        this.element().addClass(AUTOCOMPLETE_CLASS);
        this.setAria("autocomplete", "inline")
    },
    _loadValue: function() {
        return $.Deferred().resolve(this.option("value"))
    },
    _displayGetterExpr: function() {
        return this.option("valueExpr")
    },
    _setSelectedItem: function(item) {
        this.callBase(item);
        this.option("displayValue", this.option("value"))
    },
    _popupConfig: function() {
        return extend(this.callBase(), {
            closeOnOutsideClick: function(e) {
                return !$(e.target).closest(this.element()).length
            }.bind(this)
        })
    },
    _renderDimensions: function() {
        this.callBase();
        this._setPopupOption("width")
    },
    _popupWrapperClass: function() {
        return this.callBase() + " " + AUTOCOMPLETE_POPUP_WRAPPER_CLASS
    },
    _listConfig: function() {
        return extend(this.callBase(), {
            pageLoadMode: "none",
            indicateLoading: false
        })
    },
    _listItemClickHandler: function(e) {
        var value = this._displayGetter(e.itemData);
        this.option("value", value);
        this.close()
    },
    _setListDataSource: function() {
        if (!this._list) {
            return
        }
        this._list.option("selectedItems", []);
        this.callBase()
    },
    _refreshSelected: noop,
    _searchCanceled: function() {
        this.callBase();
        this.close()
    },
    _dataSourceOptions: function() {
        return {
            paginate: true
        }
    },
    _searchDataSource: function() {
        this._dataSource.pageSize(this.option("maxItemCount"));
        this.callBase();
        this._clearFocusedItem()
    },
    _clearFocusedItem: function() {
        if (this._list) {
            this._list.option("focusedElement", null);
            this._list.option("selectedIndex", -1)
        }
    },
    _renderValueEventName: function() {
        return "input keyup"
    },
    _searchHandler: function(e) {
        if (this._isControlKey(e.key)) {
            return
        }
        this.callBase(e)
    },
    _optionChanged: function(args) {
        if ("maxItemCount" === args.name) {
            this._searchDataSource()
        } else {
            this.callBase(args)
        }
    },
    reset: function() {
        this.callBase();
        this.close()
    }
});
registerComponent("dxAutocomplete", Autocomplete);
module.exports = Autocomplete;
module.exports.default = module.exports;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/text_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    registerComponent = __webpack_require__(4),
    TextEditor = __webpack_require__(192),
    eventUtils = __webpack_require__(3);
var ua = window.navigator.userAgent,
    ignoreCode = [8, 9, 13, 33, 34, 35, 36, 37, 38, 39, 40, 46],
    TEXTBOX_CLASS = "dx-textbox",
    SEARCHBOX_CLASS = "dx-searchbox",
    ICON_CLASS = "dx-icon",
    SEARCH_ICON_CLASS = "dx-icon-search";
var TextBox = TextEditor.inherit({
    ctor: function(element, options) {
        if (options) {
            this._showClearButton = options.showClearButton
        }
        this.callBase.apply(this, arguments)
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            mode: "text",
            maxLength: null
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass(TEXTBOX_CLASS);
        this.setAria("role", "textbox");
        this._renderMaxLengthHandlers()
    },
    _renderInputType: function() {
        this.callBase();
        this._renderSearchMode()
    },
    _renderMaxLengthHandlers: function() {
        if (this._isAndroid()) {
            this._input().on(eventUtils.addNamespace("keydown", this.NAME), this._onKeyDownAndroidHandler.bind(this)).on(eventUtils.addNamespace("change", this.NAME), this._onChangeAndroidHandler.bind(this))
        }
    },
    _renderProps: function() {
        this.callBase();
        this._toggleMaxLengthProp()
    },
    _toggleMaxLengthProp: function() {
        if (this._isAndroid()) {
            return
        }
        var maxLength = this.option("maxLength");
        if (maxLength > 0) {
            this._input().attr("maxLength", maxLength)
        } else {
            this._input().removeAttr("maxLength")
        }
    },
    _renderSearchMode: function() {
        var $element = this._$element;
        if ("search" === this.option("mode")) {
            $element.addClass(SEARCHBOX_CLASS);
            this._renderSearchIcon();
            if (void 0 === this._showClearButton) {
                this._showClearButton = this.option("showClearButton");
                this.option("showClearButton", true)
            }
        } else {
            $element.removeClass(SEARCHBOX_CLASS);
            this._$searchIcon && this._$searchIcon.remove();
            this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
            delete this._showClearButton
        }
    },
    _renderSearchIcon: function() {
        var $searchIcon = $("<div>").addClass(ICON_CLASS).addClass(SEARCH_ICON_CLASS);
        $searchIcon.prependTo(this._input().parent());
        this._$searchIcon = $searchIcon
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "maxLength":
                this._toggleMaxLengthProp();
                this._renderMaxLengthHandlers();
                break;
            default:
                this.callBase(args)
        }
    },
    _onKeyDownAndroidHandler: function(e) {
        var maxLength = this.option("maxLength");
        if (maxLength) {
            var $input = $(e.target),
                code = e.keyCode;
            this._cutOffExtraChar($input);
            return $input.val().length < maxLength || inArray(code, ignoreCode) !== -1 || "" !== window.getSelection().toString()
        } else {
            return true
        }
    },
    _onChangeAndroidHandler: function(e) {
        var $input = $(e.target);
        if (this.option("maxLength")) {
            this._cutOffExtraChar($input)
        }
    },
    _cutOffExtraChar: function($input) {
        var maxLength = this.option("maxLength"),
            textInput = $input.val();
        if (textInput.length > maxLength) {
            $input.val(textInput.substr(0, maxLength))
        }
    },
    _isAndroid: function() {
        var realDevice = devices.real();
        var version = realDevice.version.join(".");
        return "android" === realDevice.platform && version && /^(2\.|4\.1)/.test(version) && !/chrome/i.test(ua)
    }
});
registerComponent("dxTextBox", TextBox);
module.exports = TextBox;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    caret = __webpack_require__(193),
    domUtils = __webpack_require__(15),
    commonUtils = __webpack_require__(2),
    stringUtils = __webpack_require__(30),
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8),
    TextEditorBase = __webpack_require__(284),
    MaskRules = __webpack_require__(285),
    eventUtils = __webpack_require__(3);
var stubCaret = function() {
    return {}
};
var EMPTY_CHAR = " ";
var EMPTY_CHAR_CODE = 32;
var ESCAPED_CHAR = "\\";
var TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
var MASK_EVENT_NAMESPACE = "dxMask";
var FORWARD_DIRECTION = "forward";
var BACKWARD_DIRECTION = "backward";
var BLUR_EVENT = "blur beforedeactivate";
var buildInMaskRules = {
    0: /[0-9]/,
    9: /[0-9\s]/,
    "#": /[-+0-9\s]/,
    L: function(char) {
        return isLiteralChar(char)
    },
    l: function(char) {
        return isLiteralChar(char) || isSpaceChar(char)
    },
    C: /\S/,
    c: /./,
    A: function(char) {
        return isLiteralChar(char) || isNumericChar(char)
    },
    a: function(char) {
        return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
    }
};
var isNumericChar = function(char) {
    return /[0-9]/.test(char)
};
var isLiteralChar = function(char) {
    var code = char.charCodeAt();
    return 64 < code && code < 91 || 96 < code && code < 123 || code > 127
};
var isSpaceChar = function(char) {
    return " " === char
};
var TextEditorMask = TextEditorBase.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            mask: "",
            maskChar: "_",
            maskRules: {},
            maskInvalidMessage: messageLocalization.format("validation-mask"),
            useMaskedValue: false
        })
    },
    _supportedKeys: function() {
        var that = this;
        var keyHandlerMap = {
            backspace: that._maskBackspaceHandler,
            del: that._maskDelHandler,
            enter: that._changeHandler
        };
        var result = that.callBase();
        $.each(keyHandlerMap, function(key, callback) {
            var parentHandler = result[key];
            result[key] = function(e) {
                that.option("mask") && callback.call(that, e);
                parentHandler && parentHandler(e)
            }
        });
        return result
    },
    _getSubmitElement: function() {
        return !this.option("mask") ? this.callBase() : this._$hiddenElement
    },
    _render: function() {
        this._renderHiddenElement();
        this.callBase();
        this._renderMask()
    },
    _renderHiddenElement: function() {
        if (this.option("mask")) {
            this._$hiddenElement = $("<input>").attr("type", "hidden").appendTo(this._inputWrapper())
        }
    },
    _removeHiddenElement: function() {
        this._$hiddenElement && this._$hiddenElement.remove()
    },
    _renderMask: function() {
        this.element().removeClass(TEXTEDITOR_MASKED_CLASS);
        this._maskRulesChain = null;
        this._detachMaskEventHandlers();
        if (!this.option("mask")) {
            return
        }
        this.element().addClass(TEXTEDITOR_MASKED_CLASS);
        this._attachMaskEventHandlers();
        this._parseMask();
        this._renderMaskedValue();
        this._changedValue = this._input().val()
    },
    _attachMaskEventHandlers: function() {
        this._input().on(eventUtils.addNamespace("focus", MASK_EVENT_NAMESPACE), this._maskFocusHandler.bind(this)).on(eventUtils.addNamespace("keydown", MASK_EVENT_NAMESPACE), this._maskKeyDownHandler.bind(this)).on(eventUtils.addNamespace("keypress", MASK_EVENT_NAMESPACE), this._maskKeyPressHandler.bind(this)).on(eventUtils.addNamespace("input", MASK_EVENT_NAMESPACE), this._maskInputHandler.bind(this)).on(eventUtils.addNamespace("paste", MASK_EVENT_NAMESPACE), this._maskPasteHandler.bind(this)).on(eventUtils.addNamespace("cut", MASK_EVENT_NAMESPACE), this._maskCutHandler.bind(this)).on(eventUtils.addNamespace("drop", MASK_EVENT_NAMESPACE), this._maskDragHandler.bind(this));
        this._attachChangeEventHandlers()
    },
    _detachMaskEventHandlers: function() {
        this._input().off("." + MASK_EVENT_NAMESPACE)
    },
    _attachChangeEventHandlers: function() {
        if (inArray("change", this.option("valueChangeEvent").split(" ")) === -1) {
            return
        }
        this._input().on(eventUtils.addNamespace(BLUR_EVENT, MASK_EVENT_NAMESPACE), function(e) {
            this._suppressCaretChanging(this._changeHandler, [e]);
            this._changeHandler(e)
        }.bind(this))
    },
    _suppressCaretChanging: function(callback, args) {
        var originalCaret = caret;
        caret = stubCaret;
        try {
            callback.apply(this, args)
        } finally {
            caret = originalCaret
        }
    },
    _changeHandler: function(e) {
        var $input = this._input(),
            inputValue = $input.val();
        if (inputValue === this._changedValue) {
            return
        }
        this._changedValue = inputValue;
        var changeEvent = eventUtils.createEvent(e, {
            type: "change"
        });
        $input.trigger(changeEvent)
    },
    _parseMask: function() {
        this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
        this._maskRulesChain = this._parseMaskRule(0)
    },
    _parseMaskRule: function(index) {
        var mask = this.option("mask");
        if (index >= mask.length) {
            return new MaskRules.EmptyMaskRule
        }
        var currentMaskChar = mask[index];
        var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
        var result = isEscapedChar ? new MaskRules.StubMaskRule({
            maskChar: mask[index + 1]
        }) : this._getMaskRule(currentMaskChar);
        result.next(this._parseMaskRule(index + 1 + isEscapedChar));
        return result
    },
    _getMaskRule: function(pattern) {
        var ruleConfig;
        $.each(this._maskRules, function(rulePattern, allowedChars) {
            if (rulePattern === pattern) {
                ruleConfig = {
                    pattern: rulePattern,
                    allowedChars: allowedChars
                };
                return false
            }
        });
        return commonUtils.isDefined(ruleConfig) ? new MaskRules.MaskRule(extend({
            maskChar: this.option("maskChar")
        }, ruleConfig)) : new MaskRules.StubMaskRule({
            maskChar: pattern
        })
    },
    _renderMaskedValue: function() {
        if (!this._maskRulesChain) {
            return
        }
        var value = this.option("value") || "";
        this._maskRulesChain.clear(this._normalizeChainArguments());
        var chainArgs = {
            length: value.length
        };
        chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value;
        this._handleChain(chainArgs);
        this._displayMask()
    },
    _isMaskedValueMode: function() {
        return this.option("useMaskedValue")
    },
    _displayMask: function(caret) {
        caret = caret || this._caret();
        this._renderValue();
        this._caret(caret)
    },
    _renderValue: function() {
        if (this._maskRulesChain) {
            var text = this._maskRulesChain.text();
            this.option("text", text);
            if (this._$hiddenElement) {
                var value = this._maskRulesChain.value(),
                    hiddenElementValue = this._isMaskedValueMode() ? text : value;
                this._$hiddenElement.val(!stringUtils.isEmpty(value) ? hiddenElementValue : "")
            }
        }
        this.callBase()
    },
    _valueChangeEventHandler: function(e) {
        if (!this._maskRulesChain) {
            this.callBase.apply(this, arguments);
            return
        }
        this._saveValueChangeEvent(e);
        var value = this._isMaskedValueMode() ? (this._textValue || "").replace(new RegExp("[" + this.option("maskChar") + "]", "g"), " ").replace(/\s+$/, "") : (this._value || "").replace(/\s+$/, "");
        this.option("value", value)
    },
    _maskFocusHandler: function() {
        this._direction(FORWARD_DIRECTION);
        this._adjustCaret()
    },
    _maskKeyDownHandler: function() {
        this._keyPressHandled = false
    },
    _maskKeyPressHandler: function(e) {
        if (this._keyPressHandled) {
            return
        }
        this._keyPressHandled = true;
        if (this._isControlKeyFired(e)) {
            return
        }
        this._maskKeyHandler(e, function() {
            this._handleKey(e.which);
            return true
        })
    },
    _maskInputHandler: function(e) {
        if (this._keyPressHandled) {
            return
        }
        this._keyPressHandled = true;
        var inputValue = this._input().val();
        var caret = this._caret();
        if (!caret.end) {
            return
        }
        caret.start = caret.end - 1;
        var oldValue = inputValue.substring(0, caret.start) + inputValue.substring(caret.end);
        var char = inputValue[caret.start];
        this._input().val(oldValue);
        this._inputHandlerTimer = setTimeout(function() {
            this._caret({
                start: caret.start,
                end: caret.start
            });
            this._maskKeyHandler(e, function() {
                this._handleKey(char.charCodeAt());
                return true
            })
        }.bind(this))
    },
    _isControlKeyFired: function(e) {
        return this._isControlKey(e.key) || e.ctrlKey || e.metaKey
    },
    _maskBackspaceHandler: function(e) {
        var that = this;
        that._keyPressHandled = true;
        var afterBackspaceHandler = function(needAdjustCaret, callBack) {
            if (needAdjustCaret) {
                that._direction(FORWARD_DIRECTION);
                that._adjustCaret()
            }
            var currentCaret = that._caret();
            clearTimeout(that._backspaceHandlerTimeout);
            that._backspaceHandlerTimeout = setTimeout(function() {
                callBack(currentCaret)
            })
        };
        that._maskKeyHandler(e, function() {
            if (that._hasSelection()) {
                afterBackspaceHandler(true, function(currentCaret) {
                    that._displayMask(currentCaret);
                    that._maskRulesChain.reset()
                });
                return
            }
            if (that._tryMoveCaretBackward()) {
                afterBackspaceHandler(false, function(currentCaret) {
                    that._caret(currentCaret)
                });
                return
            }
            that._handleKey(EMPTY_CHAR_CODE, BACKWARD_DIRECTION);
            afterBackspaceHandler(true, function(currentCaret) {
                that._displayMask(currentCaret);
                that._maskRulesChain.reset()
            })
        })
    },
    _maskDelHandler: function(e) {
        this._keyPressHandled = true;
        this._maskKeyHandler(e, function() {
            !this._hasSelection() && this._handleKey(EMPTY_CHAR_CODE);
            return true
        })
    },
    _maskPasteHandler: function(e) {
        this._keyPressHandled = true;
        var caret = this._caret();
        this._maskKeyHandler(e, function() {
            var pastingText = domUtils.clipboardText(e);
            var restText = this._maskRulesChain.text().substring(caret.end);
            var accepted = this._handleChain({
                text: pastingText,
                start: caret.start,
                length: pastingText.length
            });
            var newCaret = caret.start + accepted;
            this._handleChain({
                text: restText,
                start: newCaret,
                length: restText.length
            });
            this._caret({
                start: newCaret,
                end: newCaret
            });
            return true
        })
    },
    _handleChain: function(args) {
        var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
        this._value = this._maskRulesChain.value();
        this._textValue = this._maskRulesChain.text();
        return handledCount
    },
    _normalizeChainArguments: function(args) {
        args = args || {};
        args.index = 0;
        args.fullText = this._maskRulesChain.text();
        return args
    },
    _maskCutHandler: function(e) {
        var caret = this._caret();
        var selectedText = this._input().val().substring(caret.start, caret.end);
        this._maskKeyHandler(e, function() {
            domUtils.clipboardText(e, selectedText);
            return true
        })
    },
    _maskDragHandler: function() {
        this._clearDragTimer();
        this._dragTimer = setTimeout(function() {
            this.option("value", this._convertToValue(this._input().val()))
        }.bind(this))
    },
    _convertToValue: function(text) {
        return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR)
    },
    _maskKeyHandler: function(e, tryHandleKeyCallback) {
        if (this.option("readOnly")) {
            return
        }
        this._direction(FORWARD_DIRECTION);
        e.preventDefault();
        this._handleSelection();
        if (!tryHandleKeyCallback.call(this)) {
            return
        }
        this._direction(FORWARD_DIRECTION);
        this._adjustCaret();
        this._displayMask();
        this._maskRulesChain.reset()
    },
    _handleKey: function(keyCode, direction) {
        var char = String.fromCharCode(keyCode);
        this._direction(direction || FORWARD_DIRECTION);
        this._adjustCaret(char);
        this._handleKeyChain(char);
        this._moveCaret()
    },
    _handleSelection: function() {
        if (!this._hasSelection()) {
            return
        }
        var caret = this._caret();
        var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);
        this._handleKeyChain(emptyChars)
    },
    _handleKeyChain: function(chars) {
        var caret = this._caret();
        var start = this._isForwardDirection() ? caret.start : caret.start - 1;
        var end = this._isForwardDirection() ? caret.end : caret.end - 1;
        var length = start === end ? 1 : end - start;
        this._handleChain({
            text: chars,
            start: start,
            length: length
        })
    },
    _tryMoveCaretBackward: function() {
        this._direction(BACKWARD_DIRECTION);
        var currentCaret = this._caret().start;
        this._adjustCaret();
        return !currentCaret || currentCaret !== this._caret().start
    },
    _adjustCaret: function(char) {
        var caret = this._maskRulesChain.adjustedCaret(this._caret().start, this._isForwardDirection(), char);
        this._caret({
            start: caret,
            end: caret
        })
    },
    _moveCaret: function() {
        var currentCaret = this._caret().start;
        var maskRuleIndex = currentCaret + (this._isForwardDirection() ? 0 : -1);
        var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this._isForwardDirection() ? 1 : -1) : currentCaret;
        this._caret({
            start: caret,
            end: caret
        })
    },
    _caret: function(position) {
        if (!arguments.length) {
            return caret(this._input())
        }
        caret(this._input(), position)
    },
    _hasSelection: function() {
        var caret = this._caret();
        return caret.start !== caret.end
    },
    _direction: function(direction) {
        if (!arguments.length) {
            return this._typingDirection
        }
        this._typingDirection = direction
    },
    _isForwardDirection: function() {
        return this._direction() === FORWARD_DIRECTION
    },
    _clearDragTimer: function() {
        clearTimeout(this._dragTimer)
    },
    _clean: function() {
        this._clearDragTimer();
        this.callBase()
    },
    _validateMask: function() {
        if (!this._maskRulesChain) {
            return
        }
        var isValid = this._maskRulesChain.isValid(this._normalizeChainArguments());
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: this.option("maskInvalidMessage")
            }
        })
    },
    _dispose: function() {
        clearTimeout(this._inputHandlerTimer);
        clearTimeout(this._backspaceHandlerTimeout);
        this.callBase()
    },
    _updateHiddenElement: function() {
        this._removeHiddenElement();
        if (this.option("mask")) {
            this._input().attr("name", null);
            this._renderHiddenElement()
        }
        this._setSubmitElementName(this.option("name"))
    },
    _updateMaskOption: function() {
        this._updateHiddenElement();
        this._renderMask();
        this._validateMask()
    },
    _processEmptyMask: function(mask) {
        if (mask) {
            return
        }
        var value = this.option("value");
        this.option({
            text: value,
            isValid: true
        });
        this.validationRequest.fire({
            value: value,
            editor: this
        });
        this._renderValue()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "mask":
                this._updateMaskOption();
                this._processEmptyMask(args.value);
                break;
            case "maskChar":
            case "maskRules":
            case "useMaskedValue":
                this._updateMaskOption();
                break;
            case "value":
                this._renderMaskedValue();
                this._validateMask();
                this.callBase(args);
                break;
            case "maskInvalidMessage":
                break;
            default:
                this.callBase(args)
        }
    }
});
module.exports = TextEditorMask;


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/ui.text_editor.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    domUtils = __webpack_require__(15),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    themes = __webpack_require__(20),
    Editor = __webpack_require__(33),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    clickEvent = __webpack_require__(11);
var TEXTEDITOR_CLASS = "dx-texteditor",
    TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input",
    TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS,
    TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container",
    TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container",
    TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder",
    TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button",
    TEXTEDITOR_ICON_CLASS = "dx-icon",
    TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear",
    TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area",
    TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty";
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["Tab", "Enter", "Shift", "Control", "Alt", "Escape", "PageUp", "PageDown", "End", "Home", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "Esc", "Left", "Up", "Right", "Down"];
var TextEditorBase = Editor.inherit({
    _supportedKeys: function() {
        var stop = function(e) {
            e.stopPropagation()
        };
        return {
            space: stop,
            enter: stop,
            leftArrow: stop,
            rightArrow: stop
        }
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            attr: {
                since: "16.2",
                alias: "inputAttr"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: "",
            spellcheck: false,
            showClearButton: false,
            valueChangeEvent: "change",
            placeholder: "",
            inputAttr: {},
            onFocusIn: null,
            onFocusOut: null,
            onKeyDown: null,
            onKeyPress: null,
            onKeyUp: null,
            onChange: null,
            onInput: null,
            onCut: null,
            onCopy: null,
            onPaste: null,
            onEnterKey: null,
            mode: "text",
            hoverStateEnabled: true,
            focusStateEnabled: true,
            text: void 0,
            valueFormat: function(value) {
                return value
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var currentTheme = (themes.current() || "").split(".")[0];
                return "android5" === currentTheme
            },
            options: {
                validationMessageOffset: {
                    v: -8
                }
            }
        }])
    },
    _input: function() {
        return this.element().find(TEXTEDITOR_INPUT_SELECTOR).first()
    },
    _inputWrapper: function() {
        return this.element()
    },
    _buttonsContainer: function() {
        return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS)
    },
    _isControlKey: function(key) {
        return CONTROL_KEYS.indexOf(key) !== -1
    },
    _render: function() {
        this.element().addClass(TEXTEDITOR_CLASS);
        this._renderInput();
        this._renderInputType();
        this._renderValue();
        this._renderProps();
        this._renderPlaceholder();
        this.callBase();
        this._refreshValueChangeEvent();
        this._renderEvents();
        this._renderEnterKeyAction();
        this._renderEmptinessEvent()
    },
    _renderInput: function() {
        $("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).append(this._createInput()).append($("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS)).appendTo(this.element())
    },
    _createInput: function() {
        var $input = $("<input>");
        this._applyInputAttributes($input, this.option("inputAttr"));
        return $input
    },
    _applyInputAttributes: function($input, customAttributes) {
        $input.attr("autocomplete", "off").attr(customAttributes).addClass(TEXTEDITOR_INPUT_CLASS).css("min-height", this.option("height") ? "0" : "")
    },
    _renderValue: function() {
        this._renderInputValue();
        this._renderInputAddons()
    },
    _renderInputValue: function(value) {
        value = value || this.option("value");
        var text = this.option("text"),
            displayValue = this.option("displayValue"),
            valueFormat = this.option("valueFormat");
        if (void 0 !== displayValue && null !== value) {
            text = valueFormat(displayValue)
        } else {
            if (!commonUtils.isDefined(text)) {
                text = valueFormat(value)
            }
        }
        this.option("text", text);
        if (this._input().val() !== (commonUtils.isDefined(text) ? text : "")) {
            this._renderDisplayText(text)
        } else {
            this._toggleEmptinessEventHandler()
        }
    },
    _renderDisplayText: function(text) {
        this._input().val(text);
        this._toggleEmptinessEventHandler()
    },
    _isValueValid: function() {
        if (this._input().length) {
            var validity = this._input().get(0).validity;
            if (validity) {
                return validity.valid
            }
        }
        return true
    },
    _toggleEmptiness: function(isEmpty) {
        this.element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty);
        this._togglePlaceholder(isEmpty)
    },
    _togglePlaceholder: function(isEmpty) {
        if (!this._$placeholder) {
            return
        }
        this._$placeholder.toggleClass("dx-state-invisible", !isEmpty)
    },
    _renderProps: function() {
        this._toggleReadOnlyState();
        this._toggleSpellcheckState();
        this._toggleTabIndex()
    },
    _toggleDisabledState: function(value) {
        this.callBase.apply(this, arguments);
        var $input = this._input();
        if (value) {
            $input.attr("disabled", true)
        } else {
            $input.removeAttr("disabled")
        }
    },
    _toggleTabIndex: function() {
        var $input = this._input(),
            disabled = this.option("disabled"),
            focusStateEnabled = this.option("focusStateEnabled");
        if (disabled || !focusStateEnabled) {
            $input.attr("tabIndex", -1)
        } else {
            $input.removeAttr("tabIndex")
        }
    },
    _toggleReadOnlyState: function() {
        this._input().prop("readOnly", this._readOnlyPropValue());
        this.callBase()
    },
    _readOnlyPropValue: function() {
        return this.option("readOnly")
    },
    _toggleSpellcheckState: function() {
        this._input().prop("spellcheck", this.option("spellcheck"))
    },
    _renderPlaceholder: function() {
        if (this._$placeholder) {
            this._$placeholder.remove();
            this._$placeholder = null
        }
        var that = this,
            $input = that._input(),
            placeholderText = that.option("placeholder"),
            $placeholder = this._$placeholder = $("<div>").attr("data-dx_placeholder", placeholderText),
            startEvent = eventUtils.addNamespace(pointerEvents.up, this.NAME);
        $placeholder.on(startEvent, function() {
            $input.focus()
        });
        $placeholder.insertAfter($input);
        $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS);
        this._toggleEmptinessEventHandler()
    },
    _placeholder: function() {
        return this._$placeholder || $()
    },
    _renderInputAddons: function() {
        this._renderClearButton()
    },
    _renderClearButton: function() {
        var clearButtonVisibility = this._clearButtonVisibility();
        this.element().toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, clearButtonVisibility);
        if (clearButtonVisibility) {
            if (!this._$clearButton || this._$clearButton && !this._$clearButton.closest(this.element()).length) {
                this._$clearButton = this._createClearButton()
            }
            this._$clearButton.prependTo(this._buttonsContainer())
        }
        if (this._$clearButton) {
            this._$clearButton.toggleClass("dx-state-invisible", !clearButtonVisibility)
        }
    },
    _clearButtonVisibility: function() {
        return this.option("showClearButton") && !this.option("readOnly")
    },
    _createClearButton: function() {
        return $("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append($("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS)).on(eventUtils.addNamespace(pointerEvents.down, this.NAME), function(e) {
            if ("mouse" === e.pointerType) {
                e.preventDefault()
            }
        }).on(eventUtils.addNamespace(clickEvent.name, this.NAME), this._clearValueHandler.bind(this))
    },
    _clearValueHandler: function(e) {
        var $input = this._input();
        e.stopPropagation();
        this._valueChangeEventHandler(e);
        this.reset();
        !$input.is(":focus") && $input.focus();
        $input.trigger("input")
    },
    _renderEvents: function() {
        var that = this,
            $input = that._input();
        $.each(EVENTS_LIST, function(_, event) {
            if (that.hasActionSubscription("on" + event)) {
                var action = that._createActionByOption("on" + event, {
                    excludeValidators: ["readOnly"]
                });
                $input.on(eventUtils.addNamespace(event.toLowerCase(), that.NAME), function(e) {
                    if (that._disposed) {
                        return
                    }
                    action({
                        jQueryEvent: e
                    })
                })
            }
        })
    },
    _refreshEvents: function() {
        var that = this,
            $input = this._input();
        $.each(EVENTS_LIST, function(_, event) {
            $input.off(eventUtils.addNamespace(event.toLowerCase(), that.NAME))
        });
        this._renderEvents()
    },
    _keyPressHandler: function() {
        this.option("text", this._input().val())
    },
    _renderValueChangeEvent: function() {
        var keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange"),
            valueChangeEvent = eventUtils.addNamespace(this.option("valueChangeEvent"), this.NAME + "ValueChange");
        this._input().on(keyPressEvent, this._keyPressHandler.bind(this)).on(valueChangeEvent, this._valueChangeEventHandler.bind(this))
    },
    _cleanValueChangeEvent: function() {
        var eventNamespace = this.NAME + "ValueChange",
            keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange");
        this._input().off("." + eventNamespace).off(keyPressEvent)
    },
    _refreshValueChangeEvent: function() {
        this._cleanValueChangeEvent();
        this._renderValueChangeEvent()
    },
    _renderValueEventName: function() {
        return "input change keypress"
    },
    _focusTarget: function() {
        return this._input()
    },
    _focusClassTarget: function() {
        return this.element()
    },
    _toggleFocusClass: function(isFocused, $element) {
        this.callBase(isFocused, this._focusClassTarget($element))
    },
    _hasFocusClass: function(element) {
        return this.callBase($(element || this.element()))
    },
    _renderEmptinessEvent: function() {
        var $input = this._input();
        $input.on("input blur", this._toggleEmptinessEventHandler.bind(this))
    },
    _toggleEmptinessEventHandler: function() {
        var text = this._input().val(),
            isEmpty = ("" === text || null === text) && this._isValueValid();
        this._toggleEmptiness(isEmpty)
    },
    _valueChangeEventHandler: function(e, formattedValue) {
        this._saveValueChangeEvent(e);
        this.option("value", arguments.length > 1 ? formattedValue : this._input().val())
    },
    _renderEnterKeyAction: function() {
        this._enterKeyAction = this._createActionByOption("onEnterKey", {
            excludeValidators: ["readOnly"]
        });
        this._input().off("keyup.onEnterKey.dxTextEditor").on("keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this))
    },
    _enterKeyHandlerUp: function(e) {
        if (this._disposed) {
            return
        }
        if (13 === e.which) {
            this._enterKeyAction({
                jQueryEvent: e
            })
        }
    },
    _updateValue: function() {
        this.option("text", void 0);
        this._renderValue()
    },
    _dispose: function() {
        this._enterKeyAction = void 0;
        this.callBase()
    },
    _getSubmitElement: function() {
        return this._input()
    },
    _optionChanged: function(args) {
        var name = args.name;
        if (inArray(name.replace("on", ""), EVENTS_LIST) > -1) {
            this._refreshEvents();
            return
        }
        switch (name) {
            case "valueChangeEvent":
                this._refreshValueChangeEvent();
                this._refreshFocusEvent();
                this._refreshEvents();
                break;
            case "onValueChanged":
                this._createValueChangeAction();
                break;
            case "readOnly":
                this.callBase(args);
                this._renderInputAddons();
                break;
            case "focusStateEnabled":
                this.callBase(args);
                this._toggleTabIndex();
                break;
            case "spellcheck":
                this._toggleSpellcheckState();
                break;
            case "mode":
                this._renderInputType();
                break;
            case "onEnterKey":
                this._renderEnterKeyAction();
                break;
            case "placeholder":
                this._renderPlaceholder();
                break;
            case "showClearButton":
                this._renderInputAddons();
                break;
            case "text":
                break;
            case "value":
                this._updateValue();
                this.callBase(args);
                break;
            case "inputAttr":
                this._applyInputAttributes(this._input(), args.value);
                break;
            case "valueFormat":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _renderInputType: function() {
        this._setInputType(this.option("mode"))
    },
    _setInputType: function(type) {
        var input = this._input();
        if ("search" === type) {
            type = "text"
        }
        try {
            input.prop("type", type)
        } catch (e) {
            input.prop("type", "text")
        }
    },
    focus: function() {
        this._input().focus()
    },
    blur: function() {
        if (this._input().is(document.activeElement)) {
            domUtils.resetActiveElement()
        }
    },
    reset: function() {
        this.option("value", "")
    },
    on: function(eventName, eventHandler) {
        var result = this.callBase(eventName, eventHandler),
            event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
        if (EVENTS_LIST.indexOf(event) >= 0) {
            this._refreshEvents()
        }
        return result
    }
});
module.exports = TextEditorBase;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.rule.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    commonUtils = __webpack_require__(2),
    noop = commonUtils.noop,
    isFunction = commonUtils.isFunction;
var EMPTY_CHAR = " ";
var BaseMaskRule = Class.inherit({
    ctor: function(config) {
        this._value = EMPTY_CHAR;
        extend(this, config)
    },
    next: function(rule) {
        if (!arguments.length) {
            return this._next
        }
        this._next = rule
    },
    text: noop,
    value: noop,
    rawValue: noop,
    handle: noop,
    _prepareHandlingArgs: function(args, config) {
        config = config || {};
        var handlingProperty = args.hasOwnProperty("value") ? "value" : "text";
        args[handlingProperty] = commonUtils.isDefined(config.str) ? config.str : args[handlingProperty];
        args.start = commonUtils.isDefined(config.start) ? config.start : args.start;
        args.length = commonUtils.isDefined(config.length) ? config.length : args.length;
        args.index = args.index + 1;
        return args
    },
    reset: noop,
    clear: noop,
    isAccepted: function() {
        return false
    },
    adjustedCaret: function(caret, isForwardDirection, char) {
        return isForwardDirection ? this._adjustedForward(caret, 0, char) : this._adjustedBackward(caret, 0, char)
    },
    _adjustedForward: noop,
    _adjustedBackward: noop,
    isValid: noop
});
var EmptyMaskRule = BaseMaskRule.inherit({
    next: noop,
    handle: function() {
        return 0
    },
    text: function() {
        return ""
    },
    value: function() {
        return ""
    },
    rawValue: function() {
        return ""
    },
    adjustedCaret: function() {
        return 0
    },
    isValid: function() {
        return true
    }
});
var MaskRule = BaseMaskRule.inherit({
    text: function() {
        return (this._value !== EMPTY_CHAR ? this._value : this.maskChar) + this.next().text()
    },
    value: function() {
        return this._value + this.next().value()
    },
    rawValue: function() {
        return this._value + this.next().rawValue()
    },
    handle: function(args) {
        var str = args.hasOwnProperty("value") ? args.value : args.text;
        if (!str || !str.length || !args.length) {
            return 0
        }
        if (args.start) {
            return this.next().handle(this._prepareHandlingArgs(args, {
                start: args.start - 1
            }))
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char, args);
        return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        })) + 1 : this.handle(this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        }))
    },
    clear: function(args) {
        this._tryAcceptChar(EMPTY_CHAR, args);
        this.next().clear(this._prepareHandlingArgs(args))
    },
    reset: function() {
        this._accepted(false);
        this.next().reset()
    },
    _tryAcceptChar: function(char, args) {
        this._accepted(false);
        if (!this._isAllowed(char, args)) {
            return
        }
        var acceptedChar = char === EMPTY_CHAR ? this.maskChar : char;
        args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
        this._accepted(true);
        this._value = char
    },
    _accepted: function(value) {
        if (!arguments.length) {
            return !!this._isAccepted
        }
        this._isAccepted = !!value
    },
    _isAllowed: function(char, args) {
        if (char === EMPTY_CHAR) {
            return true
        }
        return this._isValid(char, args)
    },
    _isValid: function(char, args) {
        var allowedChars = this.allowedChars;
        if (allowedChars instanceof RegExp) {
            return allowedChars.test(char)
        }
        if (isFunction(allowedChars)) {
            return allowedChars(char, args.index, args.fullText)
        }
        if (Array.isArray(allowedChars)) {
            return inArray(char, allowedChars) > -1
        }
        return allowedChars === char
    },
    isAccepted: function(caret) {
        return 0 === caret ? this._accepted() : this.next().isAccepted(caret - 1)
    },
    _adjustedForward: function(caret, index, char) {
        if (index >= caret) {
            return index
        }
        return this.next()._adjustedForward(caret, index + 1, char) || index + 1
    },
    _adjustedBackward: function(caret, index) {
        if (index >= caret - 1) {
            return caret
        }
        return this.next()._adjustedBackward(caret, index + 1) || index + 1
    },
    isValid: function(args) {
        return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args))
    }
});
var StubMaskRule = MaskRule.inherit({
    value: function() {
        return this.next().value()
    },
    handle: function(args) {
        var hasValueProperty = args.hasOwnProperty("value");
        var str = hasValueProperty ? args.value : args.text;
        if (!str.length || !args.length) {
            return 0
        }
        if (args.start || hasValueProperty) {
            return this.next().handle(this._prepareHandlingArgs(args, {
                start: args.start && args.start - 1
            }))
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char);
        var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        }) : args;
        return this.next().handle(nextArgs) + 1
    },
    clear: function(args) {
        this._accepted(false);
        this.next().clear(this._prepareHandlingArgs(args))
    },
    _tryAcceptChar: function(char) {
        this._accepted(this._isValid(char))
    },
    _isValid: function(char) {
        return char === this.maskChar
    },
    _adjustedForward: function(caret, index, char) {
        if (index >= caret && char === this.maskChar) {
            return index
        }
        if (caret === index + 1 && this._accepted()) {
            return caret
        }
        return this.next()._adjustedForward(caret, index + 1, char)
    },
    _adjustedBackward: function(caret, index) {
        if (index >= caret - 1) {
            return 0
        }
        return this.next()._adjustedBackward(caret, index + 1)
    },
    isValid: function(args) {
        return this.next().isValid(this._prepareHandlingArgs(args))
    }
});
module.exports.MaskRule = MaskRule;
module.exports.StubMaskRule = StubMaskRule;
module.exports.EmptyMaskRule = EmptyMaskRule;


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    eventUtils = __webpack_require__(3),
    extend = __webpack_require__(1).extend,
    GroupedEditStrategy = __webpack_require__(287),
    messageLocalization = __webpack_require__(8),
    EditProvider = __webpack_require__(288),
    ListBase = __webpack_require__(124);
var LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected",
    LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
var ListEdit = ListBase.inherit({
    _supportedKeys: function() {
        var that = this,
            parent = this.callBase();
        var deleteFocusedItem = function(e) {
            if (that.option("allowItemDeleting")) {
                e.preventDefault();
                that.deleteItem(that.option("focusedElement"))
            }
        };
        var moveFocusedItemUp = function(e) {
            if (e.shiftKey && that.option("allowItemReordering")) {
                e.preventDefault();
                var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
                    $prevItem = that._editStrategy.getItemElement(focusedItemIndex - 1);
                that.reorderItem(that.option("focusedElement"), $prevItem);
                that.scrollToItem(that.option("focusedElement"))
            } else {
                parent.upArrow(e)
            }
        };
        var moveFocusedItemDown = function(e) {
            if (e.shiftKey && that.option("allowItemReordering")) {
                e.preventDefault();
                var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
                    $nextItem = that._editStrategy.getItemElement(focusedItemIndex + 1);
                that.reorderItem(that.option("focusedElement"), $nextItem);
                that.scrollToItem(that.option("focusedElement"))
            } else {
                parent.downArrow(e)
            }
        };
        return extend({}, parent, {
            del: deleteFocusedItem,
            upArrow: moveFocusedItemUp,
            downArrow: moveFocusedItemDown
        })
    },
    _updateSelection: function() {
        this._editProvider.afterItemsRendered();
        this.callBase()
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            showSelectionControls: false,
            selectionMode: "none",
            selectAllMode: "page",
            onSelectAllValueChanged: null,
            selectAllText: messageLocalization.format("dxList-selectAll"),
            menuItems: [],
            menuMode: "context",
            allowItemDeleting: false,
            itemDeleteMode: "toggle",
            allowItemReordering: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return "ios" === device.platform
            },
            options: {
                menuMode: "slide",
                itemDeleteMode: "slideItem"
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                itemDeleteMode: "swipe"
            }
        }, {
            device: {
                platform: "win"
            },
            options: {
                itemDeleteMode: "context"
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                itemDeleteMode: "static"
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initEditProvider()
    },
    _initDataSource: function() {
        this.callBase();
        if (!this._isPageSelectAll()) {
            this._dataSource && this._dataSource.requireTotalCount(true)
        }
    },
    _isPageSelectAll: function() {
        return "page" === this.option("selectAllMode")
    },
    _initEditProvider: function() {
        this._editProvider = new EditProvider(this)
    },
    _disposeEditProvider: function() {
        if (this._editProvider) {
            this._editProvider.dispose()
        }
    },
    _refreshEditProvider: function() {
        this._disposeEditProvider();
        this._initEditProvider()
    },
    _initEditStrategy: function() {
        if (this.option("grouped")) {
            this._editStrategy = new GroupedEditStrategy(this)
        } else {
            this.callBase()
        }
    },
    _render: function() {
        this._refreshEditProvider();
        this.callBase()
    },
    _renderItems: function() {
        this.callBase.apply(this, arguments);
        this._editProvider.afterItemsRendered()
    },
    _selectedItemClass: function() {
        return LIST_ITEM_SELECTED_CLASS
    },
    _itemResponseWaitClass: function() {
        return LIST_ITEM_RESPONSE_WAIT_CLASS
    },
    _itemClickHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
        if (handledByEditProvider) {
            return
        }
        this.callBase.apply(this, arguments)
    },
    _shouldFireContextMenuEvent: function() {
        return this.callBase.apply(this, arguments) || this._editProvider.contextMenuHandlerExists()
    },
    _itemHoldHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var isTouchEvent = eventUtils.isTouchEvent(e),
            handledByEditProvider = isTouchEvent && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
            e.handledByEditProvider = true;
            return
        }
        this.callBase.apply(this, arguments)
    },
    _itemContextMenuHandler: function(e) {
        var $itemElement = $(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
            e.preventDefault();
            return
        }
        this.callBase.apply(this, arguments)
    },
    _postprocessRenderItem: function(args) {
        this.callBase.apply(this, arguments);
        this._editProvider.modifyItemElement(args)
    },
    _clean: function() {
        this._disposeEditProvider();
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "selectAllMode":
                this._initDataSource();
                this._dataSource.pageIndex(0);
                this._dataSource.load();
                break;
            case "grouped":
                this._clearSelectedItems();
                delete this._renderingGroupIndex;
                this._initEditStrategy();
                this.callBase(args);
                break;
            case "showSelectionControls":
            case "menuItems":
            case "menuMode":
            case "allowItemDeleting":
            case "itemDeleteMode":
            case "allowItemReordering":
            case "selectAllText":
                this._invalidate();
                break;
            case "onSelectAllValueChanged":
                break;
            default:
                this.callBase(args)
        }
    },
    selectAll: function() {
        return this._selection.selectAll(this._isPageSelectAll())
    },
    unselectAll: function() {
        return this._selection.deselectAll(this._isPageSelectAll())
    },
    isSelectAll: function() {
        return this._selection.getSelectAllState(this._isPageSelectAll())
    },
    getFlatIndexByItemElement: function(itemElement) {
        return this._itemElements().index(itemElement)
    },
    getItemElementByFlatIndex: function(flatIndex) {
        var $itemElements = this._itemElements();
        if (flatIndex < 0 || flatIndex >= $itemElements.length) {
            return $()
        }
        return $itemElements.eq(flatIndex)
    },
    getItemByIndex: function(index) {
        return this._editStrategy.getItemDataByIndex(index)
    }
});
module.exports = ListEdit;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.strategy.grouped.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    isNumeric = __webpack_require__(2).isNumeric,
    EditStrategy = __webpack_require__(149);
var LIST_ITEM_CLASS = "dx-list-item",
    LIST_GROUP_CLASS = "dx-list-group";
var SELECTION_SHIFT = 20,
    SELECTION_MASK = 2303;
var combineIndex = function(indices) {
    return (indices.group << SELECTION_SHIFT) + indices.item
};
var splitIndex = function(combinedIndex) {
    return {
        group: combinedIndex >> SELECTION_SHIFT,
        item: combinedIndex & SELECTION_MASK
    }
};
var GroupedEditStrategy = EditStrategy.inherit({
    _groupElements: function() {
        return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS)
    },
    _groupItemElements: function($group) {
        return $group.find("." + LIST_ITEM_CLASS)
    },
    getIndexByItemData: function(itemData) {
        var groups = this._collectionWidget.option("items"),
            index = false;
        if (!itemData) {
            return false
        }
        if (itemData.items && itemData.items.length) {
            itemData = itemData.items[0]
        }
        $.each(groups, function(groupIndex, group) {
            if (!group.items) {
                return false
            }
            $.each(group.items, function(itemIndex, item) {
                if (item !== itemData) {
                    return true
                }
                index = {
                    group: groupIndex,
                    item: itemIndex
                };
                return false
            });
            if (index) {
                return false
            }
        });
        return index
    },
    getItemDataByIndex: function(index) {
        var items = this._collectionWidget.option("items");
        if (isNumeric(index)) {
            return this.itemsGetter()[index]
        }
        return index && items[index.group] && items[index.group].items[index.item] || null
    },
    itemsGetter: function() {
        var resultItems = [],
            items = this._collectionWidget.option("items");
        for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                resultItems = resultItems.concat(items[i].items)
            } else {
                resultItems.push(items[i])
            }
        }
        return resultItems
    },
    deleteItemAtIndex: function(index) {
        var indices = splitIndex(index),
            itemGroup = this._collectionWidget.option("items")[indices.group].items;
        itemGroup.splice(indices.item, 1)
    },
    getKeysByItems: function(items) {
        var plainItems = [];
        for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        var result = [];
        for (i = 0; i < plainItems.length; i++) {
            result.push(this._collectionWidget.keyOf(plainItems[i]))
        }
        return result
    },
    getIndexByKey: function(key, items) {
        var groups = items || this._collectionWidget.option("items"),
            index = -1,
            that = this;
        $.each(groups, function(groupIndex, group) {
            if (!group.items) {
                return
            }
            var keys = that.getKeysByItems(group.items);
            $.each(keys, function(keyIndex, itemKey) {
                if (that._equalKeys(itemKey, key)) {
                    index = {
                        group: groupIndex,
                        item: keyIndex
                    };
                    return false
                }
            });
            if (index !== -1) {
                return false
            }
        });
        return index
    },
    getItemsByKeys: function(keys) {
        var result = [];
        $.each(keys, function(_, key) {
            var getItemMeta = function(groups) {
                var index = this.getIndexByKey(key, groups);
                var group = index && groups[index.group];
                if (!group) {
                    return
                }
                return {
                    groupKey: group.key,
                    item: group.items[index.item]
                }
            }.bind(this);
            var itemMeta = getItemMeta(this._collectionWidget.option("items")) || getItemMeta(this._collectionWidget.option("selectedItems"));
            var groupKey = itemMeta.groupKey;
            var item = itemMeta.item;
            var selectedGroup;
            $.each(result, function(_, item) {
                if (item.key === groupKey) {
                    selectedGroup = item;
                    return false
                }
            });
            if (!selectedGroup) {
                selectedGroup = {
                    key: groupKey,
                    items: []
                };
                result.push(selectedGroup)
            }
            selectedGroup.items.push(item)
        }.bind(this));
        return result
    },
    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._collectionWidget.option("items"),
            movingIndices = splitIndex(movingIndex),
            destinationIndices = splitIndex(destinationIndex),
            movingItemGroup = items[movingIndices.group].items,
            destinationItemGroup = items[destinationIndices.group].items,
            movedItemData = movingItemGroup[movingIndices.item];
        movingItemGroup.splice(movingIndices.item, 1);
        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
    },
    _isItemIndex: function(index) {
        return index && isNumeric(index.group) && isNumeric(index.item)
    },
    _getNormalizedItemIndex: function(itemElement) {
        var $item = $(itemElement),
            $group = $item.closest("." + LIST_GROUP_CLASS);
        if (!$group.length) {
            return -1
        }
        return combineIndex({
            group: this._groupElements().index($group),
            item: this._groupItemElements($group).index($item)
        })
    },
    _normalizeItemIndex: function(index) {
        return combineIndex(index)
    },
    _denormalizeItemIndex: function(index) {
        return splitIndex(index)
    },
    _getItemByNormalizedIndex: function(index) {
        var indices = splitIndex(index),
            $group = this._groupElements().eq(indices.group);
        return this._groupItemElements($group).eq(indices.item)
    },
    _itemsFromSameParent: function(firstIndex, secondIndex) {
        return splitIndex(firstIndex).group === splitIndex(secondIndex).group
    }
});
module.exports = GroupedEditStrategy;


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.provider.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    errors = __webpack_require__(16),
    decoratorRegistry = __webpack_require__(59);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(301);
__webpack_require__(303);
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
    editOptionsRegistry.push({
        enabled: enabledFunc,
        decoratorType: decoratorTypeFunc,
        decoratorSubType: decoratorSubTypeFunc
    })
};
registerOption(function() {
    return this.option("menuItems").length
}, function() {
    return "menu"
}, function() {
    return this.option("menuMode")
});
registerOption(function() {
    return !this.option("menuItems").length && this.option("allowItemDeleting")
}, function() {
    var mode = this.option("itemDeleteMode");
    return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu"
}, function() {
    var mode = this.option("itemDeleteMode");
    if ("slideItem" === mode) {
        mode = "slide"
    }
    if ("hold" === mode) {
        mode = "context"
    }
    return mode
});
registerOption(function() {
    return "none" !== this.option("selectionMode") && this.option("showSelectionControls")
}, function() {
    return "selection"
}, function() {
    return "default"
});
registerOption(function() {
    return this.option("allowItemReordering")
}, function() {
    return "reorder"
}, function() {
    return "default"
});
var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag",
    LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag",
    DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag",
    DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag",
    DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement",
    DECORATOR_AFTER_RENDER_METHOD = "afterRender";
var EditProvider = Class.inherit({
    ctor: function(list) {
        this._list = list;
        this._fetchRequiredDecorators()
    },
    dispose: function() {
        if (this._decorators && this._decorators.length) {
            $.each(this._decorators, function(_, decorator) {
                decorator.dispose()
            })
        }
    },
    _fetchRequiredDecorators: function() {
        this._decorators = [];
        $.each(editOptionsRegistry, function(_, option) {
            var optionEnabled = option.enabled.call(this._list);
            if (optionEnabled) {
                var decoratorType = option.decoratorType.call(this._list),
                    decoratorSubType = option.decoratorSubType.call(this._list),
                    decorator = this._createDecorator(decoratorType, decoratorSubType);
                this._decorators.push(decorator)
            }
        }.bind(this))
    },
    _createDecorator: function(type, subType) {
        var decoratorClass = this._findDecorator(type, subType);
        return new decoratorClass(this._list)
    },
    _findDecorator: function(type, subType) {
        var foundDecorator = decoratorRegistry.registry[type][subType];
        if (!foundDecorator) {
            throw errors.Error("E1012", type, subType)
        }
        return foundDecorator
    },
    modifyItemElement: function(args) {
        var $itemElement = $(args.itemElement);
        var config = {
            $itemElement: $itemElement
        };
        this._prependBeforeBags($itemElement, config);
        this._appendAfterBags($itemElement, config);
        this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config)
    },
    afterItemsRendered: function() {
        this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD)
    },
    _prependBeforeBags: function($itemElement, config) {
        var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config, LIST_ITEM_BEFORE_BAG_CLASS);
        $itemElement.prepend($beforeBags)
    },
    _appendAfterBags: function($itemElement, config) {
        var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config, LIST_ITEM_AFTER_BAG_CLASS);
        $itemElement.append($afterBags)
    },
    _collectDecoratorsMarkup: function(method, config, containerClass) {
        var $collector = $("<div />");
        $.each(this._decorators, function() {
            var $container = $("<div />").addClass(containerClass);
            this[method](extend({
                $container: $container
            }, config));
            if ($container.children().length) {
                $collector.append($container)
            }
        });
        return $collector.children()
    },
    _applyDecorators: function(method, config) {
        $.each(this._decorators, function() {
            this[method](config)
        })
    },
    _handlerExists: function(name) {
        if (!this._decorators) {
            return false
        }
        var decorators = this._decorators,
            length = decorators.length;
        for (var i = 0; i < length; i++) {
            if (decorators[i][name] !== noop) {
                return true
            }
        }
        return false
    },
    _eventHandler: function(name, $itemElement, e) {
        if (!this._decorators) {
            return false
        }
        var response = false,
            decorators = this._decorators,
            length = decorators.length;
        for (var i = 0; i < length; i++) {
            response = decorators[i][name]($itemElement, e);
            if (response) {
                break
            }
        }
        return response
    },
    handleClick: function($itemElement, e) {
        return this._eventHandler("handleClick", $itemElement, e)
    },
    contextMenuHandlerExists: function() {
        return this._handlerExists("handleContextMenu")
    },
    handleContextMenu: function($itemElement, e) {
        return this._eventHandler("handleContextMenu", $itemElement, e)
    }
});
module.exports = EditProvider;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.static.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Button = __webpack_require__(25),
    registerDecorator = __webpack_require__(59).register,
    EditDecorator = __webpack_require__(80);
var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container",
    STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
registerDecorator("delete", "static", EditDecorator.inherit({
    afterBag: function(config) {
        var $itemElement = config.$itemElement,
            $container = config.$container;
        var $button = $("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, Button, {
            icon: "remove",
            onClick: function(args) {
                args.jQueryEvent.stopPropagation();
                this._deleteItem($itemElement)
            }.bind(this),
            integrationOptions: {}
        });
        $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button)
    },
    _deleteItem: function($itemElement) {
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        this._list.deleteItem($itemElement)
    }
}));


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.button.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    fx = __webpack_require__(22),
    Button = __webpack_require__(25),
    messageLocalization = __webpack_require__(8),
    registerDecorator = __webpack_require__(59).register,
    SwitchableEditDecorator = __webpack_require__(194);
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container",
    SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper",
    SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper",
    SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button",
    SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
var SwitchableButtonEditDecorator = SwitchableEditDecorator.inherit({
    _init: function() {
        this.callBase.apply(this, arguments);
        var $buttonContainer = $("<div >").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS),
            $buttonWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS),
            $buttonInnerWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS),
            $button = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, Button, {
            text: messageLocalization.format("dxListEditDecorator-delete"),
            type: "danger",
            onClick: function(e) {
                this._deleteItem();
                e.jQueryEvent.stopPropagation()
            }.bind(this),
            integrationOptions: {}
        });
        $buttonContainer.append($buttonWrapper);
        $buttonWrapper.append($buttonInnerWrapper);
        $buttonInnerWrapper.append($button);
        this._$buttonContainer = $buttonContainer
    },
    _enablePositioning: function($itemElement) {
        this.callBase.apply(this, arguments);
        fx.stop(this._$buttonContainer, true);
        this._$buttonContainer.appendTo($itemElement)
    },
    _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonContainer.detach()
    },
    _animatePrepareDeleteReady: function() {
        var rtl = this._isRtlEnabled(),
            listWidth = this._list.element().width(),
            buttonWidth = this._buttonWidth(),
            fromValue = rtl ? listWidth : -buttonWidth,
            toValue = rtl ? listWidth - buttonWidth : 0;
        return fx.animate(this._$buttonContainer, {
            type: "custom",
            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
            from: {
                right: fromValue
            },
            to: {
                right: toValue
            }
        })
    },
    _animateForgetDeleteReady: function() {
        var rtl = this._isRtlEnabled(),
            listWidth = this._list.element().width(),
            buttonWidth = this._buttonWidth(),
            fromValue = rtl ? listWidth - buttonWidth : 0,
            toValue = rtl ? listWidth : -buttonWidth;
        return fx.animate(this._$buttonContainer, {
            type: "custom",
            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
            from: {
                right: fromValue
            },
            to: {
                right: toValue
            }
        })
    },
    _buttonWidth: function() {
        if (!this._buttonContainerWidth) {
            this._buttonContainerWidth = this._$buttonContainer.outerWidth()
        }
        return this._buttonContainerWidth
    },
    dispose: function() {
        if (this._$buttonContainer) {
            this._$buttonContainer.remove()
        }
        this.callBase.apply(this, arguments)
    }
});
var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container",
    TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
registerDecorator("delete", "toggle", SwitchableButtonEditDecorator.inherit({
    beforeBag: function(config) {
        var $itemElement = config.$itemElement,
            $container = config.$container;
        var $toggle = $("<div />").addClass(TOGGLE_DELETE_SWITCH_CLASS);
        this._list._createComponent($toggle, Button, {
            icon: "toggle-delete",
            onClick: function(e) {
                this._toggleDeleteReady($itemElement);
                e.jQueryEvent.stopPropagation()
            }.bind(this),
            integrationOptions: {}
        });
        $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
        $container.append($toggle)
    }
}));
registerDecorator("delete", "slideButton", SwitchableButtonEditDecorator.inherit({
    _shouldHandleSwipe: true,
    _swipeEndHandler: function($itemElement, args) {
        if (0 !== args.targetOffset) {
            this._toggleDeleteReady($itemElement)
        }
        return true
    }
}));
module.exports = SwitchableButtonEditDecorator;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.slide.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    clickEvent = __webpack_require__(11),
    messageLocalization = __webpack_require__(8),
    translator = __webpack_require__(19),
    eventUtils = __webpack_require__(3),
    feedbackEvents = __webpack_require__(75),
    EditDecoratorMenuHelperMixin = __webpack_require__(195),
    registerDecorator = __webpack_require__(59).register,
    SwitchableEditDecorator = __webpack_require__(194),
    fx = __webpack_require__(22),
    ActionSheet = __webpack_require__(196);
var LIST_EDIT_DECORATOR = "dxListEditDecorator",
    CLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, LIST_EDIT_DECORATOR),
    ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
    SLIDE_MENU_CLASS = "dx-list-slide-menu",
    SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper",
    SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content",
    SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container",
    SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons",
    SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button",
    SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu",
    SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete",
    SLIDE_MENU_ANIMATION_DURATION = 400,
    SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
registerDecorator("menu", "slide", SwitchableEditDecorator.inherit({
    _shouldHandleSwipe: true,
    _init: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS).on(ACTIVE_EVENT_NAME, noop);
        this._$buttons = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
        this._renderMenu();
        this._renderDeleteButton()
    },
    _renderMenu: function() {
        if (!this._menuEnabled()) {
            return
        }
        var menuItems = this._menuItems();
        if (1 === menuItems.length) {
            var menuItem = menuItems[0];
            this._renderMenuButton(menuItem.text, function(e) {
                e.stopPropagation();
                this._fireAction(menuItem)
            }.bind(this))
        } else {
            var $menu = $("<div />").addClass(SLIDE_MENU_CLASS);
            this._menu = this._list._createComponent($menu, ActionSheet, {
                showTitle: false,
                items: menuItems,
                onItemClick: function(args) {
                    this._fireAction(args.itemData)
                }.bind(this),
                integrationOptions: {}
            });
            $menu.appendTo(this._list.element());
            var $menuButton = this._renderMenuButton(messageLocalization.format("dxListEditDecorator-more"), function(e) {
                e.stopPropagation();
                this._menu.show()
            }.bind(this));
            this._menu.option("target", $menuButton)
        }
    },
    _renderMenuButton: function(text, action) {
        var $menuButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
        this._$buttons.append($menuButton);
        $menuButton.on(CLICK_EVENT_NAME, action);
        return $menuButton
    },
    _renderDeleteButton: function() {
        if (!this._deleteEnabled()) {
            return
        }
        var $deleteButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(messageLocalization.format("dxListEditDecorator-delete"));
        $deleteButton.on(CLICK_EVENT_NAME, function(e) {
            e.stopPropagation();
            this._deleteItem()
        }.bind(this));
        this._$buttons.append($deleteButton)
    },
    _fireAction: function(menuItem) {
        this._fireMenuAction($(this._cachedNode), menuItem.action);
        this._cancelDeleteReadyItem()
    },
    modifyElement: function(config) {
        this.callBase.apply(this, arguments);
        var $itemElement = config.$itemElement;
        $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
        var $slideMenuContent = $("<div/>").addClass(SLIDE_MENU_CONTENT_CLASS);
        $itemElement.wrapInner($slideMenuContent)
    },
    handleClick: function(_, e) {
        if ($(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length) {
            return this.callBase.apply(this, arguments)
        }
        return false
    },
    _swipeStartHandler: function($itemElement) {
        this._enablePositioning($itemElement);
        this._cacheItemData($itemElement);
        this._setPositions(this._getPositions(0))
    },
    _swipeUpdateHandler: function($itemElement, args) {
        var rtl = this._isRtlEnabled(),
            signCorrection = rtl ? -1 : 1,
            isItemReadyToDelete = this._isReadyToDelete($itemElement),
            moveJustStarted = this._getCurrentPositions().content === this._getStartPositions().content;
        if (moveJustStarted && !isItemReadyToDelete && args.offset * signCorrection > 0) {
            args.cancel = true;
            return
        }
        var offset = this._cachedItemWidth * args.offset,
            startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0,
            correctedOffset = (offset + startOffset) * signCorrection,
            percent = correctedOffset < 0 ? Math.abs((offset + startOffset) / this._cachedButtonWidth) : 0;
        this._setPositions(this._getPositions(percent));
        return true
    },
    _getStartPositions: function() {
        var rtl = this._isRtlEnabled(),
            signCorrection = rtl ? -1 : 1;
        return {
            content: 0,
            buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
            buttons: -this._cachedButtonWidth * signCorrection
        }
    },
    _getPositions: function(percent) {
        var rtl = this._isRtlEnabled(),
            signCorrection = rtl ? -1 : 1,
            startPositions = this._getStartPositions();
        return {
            content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
            buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
            buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
        }
    },
    _getCurrentPositions: function() {
        return {
            content: translator.locate(this._$cachedContent).left,
            buttonsContainer: translator.locate(this._$buttonsContainer).left,
            buttons: translator.locate(this._$buttons).left
        }
    },
    _setPositions: function(positions) {
        translator.move(this._$cachedContent, {
            left: positions.content
        });
        translator.move(this._$buttonsContainer, {
            left: positions.buttonsContainer
        });
        translator.move(this._$buttons, {
            left: positions.buttons
        })
    },
    _cacheItemData: function($itemElement) {
        if ($itemElement[0] === this._cachedNode) {
            return
        }
        this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
        this._cachedItemWidth = $itemElement.outerWidth();
        this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
        this._$buttonsContainer.width(this._cachedButtonWidth);
        if (this._$cachedContent.length) {
            this._cachedNode = $itemElement[0]
        }
    },
    _minButtonContainerLeftOffset: function() {
        return this._cachedItemWidth - this._cachedButtonWidth
    },
    _swipeEndHandler: function($itemElement, args) {
        this._cacheItemData($itemElement);
        var signCorrection = this._isRtlEnabled() ? 1 : -1,
            offset = this._cachedItemWidth * args.offset,
            endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset * signCorrection > .2 * this._cachedButtonWidth,
            readyToDelete = args.targetOffset === signCorrection && endedAtReadyToDelete;
        this._toggleDeleteReady($itemElement, readyToDelete);
        return true
    },
    _enablePositioning: function($itemElement) {
        fx.stop(this._$cachedContent, true);
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.appendTo($itemElement)
    },
    _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.detach()
    },
    _animatePrepareDeleteReady: function() {
        return this._animateToPositions(this._getPositions(1))
    },
    _animateForgetDeleteReady: function($itemElement) {
        this._cacheItemData($itemElement);
        return this._animateToPositions(this._getPositions(0))
    },
    _animateToPositions: function(positions) {
        var that = this,
            currentPosition = this._getCurrentPositions(),
            durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
        return fx.animate(this._$cachedContent, {
            from: currentPosition,
            to: positions,
            easing: SLIDE_MENU_ANIMATION_EASING,
            duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
            strategy: "frame",
            draw: function(positions) {
                that._setPositions(positions)
            }
        })
    },
    dispose: function() {
        if (this._menu) {
            this._menu.element().remove()
        }
        if (this._$buttonsContainer) {
            this._$buttonsContainer.remove()
        }
        this.callBase.apply(this, arguments)
    }
}).include(EditDecoratorMenuHelperMixin));


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.swipe.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    fx = __webpack_require__(22),
    registerDecorator = __webpack_require__(59).register,
    EditDecorator = __webpack_require__(80);
registerDecorator("delete", "swipe", EditDecorator.inherit({
    _shouldHandleSwipe: true,
    _renderItemPosition: function($itemElement, offset, animate) {
        var deferred = $.Deferred(),
            itemOffset = offset * this._itemElementWidth;
        if (animate) {
            fx.animate($itemElement, {
                to: {
                    left: itemOffset
                },
                type: "slide",
                complete: function() {
                    deferred.resolve($itemElement, offset)
                }
            })
        } else {
            translator.move($itemElement, {
                left: itemOffset
            });
            deferred.resolve()
        }
        return deferred.promise()
    },
    _swipeStartHandler: function($itemElement) {
        this._itemElementWidth = $itemElement.width();
        return true
    },
    _swipeUpdateHandler: function($itemElement, args) {
        this._renderItemPosition($itemElement, args.offset);
        return true
    },
    _swipeEndHandler: function($itemElement, args) {
        var offset = args.targetOffset;
        this._renderItemPosition($itemElement, offset, true).done(function($itemElement, offset) {
            if (Math.abs(offset)) {
                this._list.deleteItem($itemElement).fail(function() {
                    this._renderItemPosition($itemElement, 0, true)
                }.bind(this))
            }
        }.bind(this));
        return true
    }
}));


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.context.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    EditDecoratorMenuHelperMixin = __webpack_require__(195),
    messageLocalization = __webpack_require__(8),
    registerDecorator = __webpack_require__(59).register,
    EditDecorator = __webpack_require__(80),
    Overlay = __webpack_require__(39),
    ListBase = __webpack_require__(124);
var CONTEXTMENU_CLASS = "dx-list-context-menu",
    CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
registerDecorator("menu", "context", EditDecorator.inherit({
    _init: function() {
        var $menu = $("<div/>").addClass(CONTEXTMENU_CLASS);
        this._list.element().append($menu);
        this._menu = this._renderOverlay($menu)
    },
    _renderOverlay: function($element) {
        return this._list._createComponent($element, Overlay, {
            shading: false,
            deferRendering: true,
            closeOnTargetScroll: true,
            closeOnOutsideClick: function(e) {
                return !$(e.target).closest("." + CONTEXTMENU_CLASS).length
            },
            animation: {
                show: {
                    type: "slide",
                    duration: 300,
                    from: {
                        height: 0,
                        opacity: 1
                    },
                    to: {
                        height: function() {
                            return this._$menuList.outerHeight()
                        }.bind(this),
                        opacity: 1
                    }
                },
                hide: {
                    type: "slide",
                    duration: 0,
                    from: {
                        opacity: 1
                    },
                    to: {
                        opacity: 0
                    }
                }
            },
            height: function() {
                return this._$menuList ? this._$menuList.outerHeight() : 0
            }.bind(this),
            width: function() {
                return this._list.element().outerWidth()
            }.bind(this),
            onContentReady: this._renderMenuContent.bind(this)
        })
    },
    _renderMenuContent: function(e) {
        var $overlayContent = e.component.content();
        var items = this._menuItems().slice();
        if (this._deleteEnabled()) {
            items.push({
                text: messageLocalization.format("dxListEditDecorator-delete"),
                action: this._deleteItem.bind(this)
            })
        }
        this._$menuList = $("<div>");
        this._list._createComponent(this._$menuList, ListBase, {
            items: items,
            onItemClick: this._menuItemClickHandler.bind(this),
            height: "auto",
            integrationOptions: {}
        });
        $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
        $overlayContent.append(this._$menuList)
    },
    _menuItemClickHandler: function(args) {
        this._menu.hide();
        this._fireMenuAction(this._$itemWithMenu, args.itemData.action)
    },
    _deleteItem: function() {
        this._list.deleteItem(this._$itemWithMenu)
    },
    handleContextMenu: function($itemElement) {
        this._$itemWithMenu = $itemElement;
        this._menu.option({
            position: {
                my: "top",
                at: "bottom",
                of: $itemElement,
                collision: "flip"
            }
        });
        this._menu.show();
        return true
    },
    dispose: function() {
        if (this._menu) {
            this._menu.element().remove()
        }
        this.callBase.apply(this, arguments)
    }
}).include(EditDecoratorMenuHelperMixin));


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/item.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    CollectionWidgetItem = __webpack_require__(122);
var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
    LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
    BADGE_CLASS = "dx-badge",
    LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
    LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
var ListItem = CollectionWidgetItem.inherit({
    _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this));
        this._startWatcher("showChevron", this._renderShowChevron.bind(this))
    },
    _renderBadge: function(badge) {
        this._$element.children("." + LIST_ITEM_BADGE_CONTAINER_CLASS).remove();
        if (!badge) {
            return
        }
        var $badge = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).append($("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge));
        var $chevron = this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).first();
        $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element)
    },
    _renderShowChevron: function(showChevron) {
        this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).remove();
        if (!showChevron) {
            return
        }
        var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS),
            $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
        $chevronContainer.append($chevron).appendTo(this._$element)
    }
});
module.exports = ListItem;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    messageLocalization = __webpack_require__(8),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    PullDownStrategy = __webpack_require__(296),
    SwipeDownStrategy = __webpack_require__(297),
    SlideDownStrategy = __webpack_require__(298),
    SimulatedStrategy = __webpack_require__(299),
    Scrollable = __webpack_require__(70),
    LoadIndicator = __webpack_require__(53),
    config = __webpack_require__(31),
    LoadPanel = __webpack_require__(151);
var SCROLLVIEW_CLASS = "dx-scrollview",
    SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content",
    SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket",
    SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket",
    SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down",
    SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom",
    SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator",
    SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text",
    SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
var refreshStrategies = {
    pullDown: PullDownStrategy,
    swipeDown: SwipeDownStrategy,
    slideDown: SlideDownStrategy,
    simulated: SimulatedStrategy
};
var ScrollView = Scrollable.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            pullingDownText: messageLocalization.format("dxScrollView-pullingDownText"),
            pulledDownText: messageLocalization.format("dxScrollView-pulledDownText"),
            refreshingText: messageLocalization.format("dxScrollView-refreshingText"),
            reachBottomText: messageLocalization.format("dxScrollView-reachBottomText"),
            onPullDown: null,
            onReachBottom: null,
            refreshStrategy: "pullDown"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var realDevice = devices.real();
                return "android" === realDevice.platform
            },
            options: {
                refreshStrategy: "swipeDown"
            }
        }, {
            device: function() {
                return "win" === devices.real().platform
            },
            options: {
                refreshStrategy: "slideDown"
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._loadingIndicatorEnabled = true
    },
    _initMarkup: function() {
        this.callBase();
        this.element().addClass(SCROLLVIEW_CLASS);
        this._initContent();
        this._initTopPocket();
        this._initBottomPocket();
        this._initLoadPanel()
    },
    _initContent: function() {
        var $content = $("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
        this._$content.wrapInner($content)
    },
    _initTopPocket: function() {
        var $topPocket = this._$topPocket = $("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS),
            $pullDown = this._$pullDown = $("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
        $topPocket.append($pullDown);
        this._$content.prepend($topPocket)
    },
    _initBottomPocket: function() {
        var $bottomPocket = this._$bottomPocket = $("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS),
            $reachBottom = this._$reachBottom = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS),
            $loadContainer = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS),
            $loadIndicator = new LoadIndicator($("<div>")).element(),
            $text = this._$reachBottomText = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
        this._updateReachBottomText();
        $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
        $bottomPocket.append($reachBottom);
        this._$content.append($bottomPocket)
    },
    _initLoadPanel: function() {
        this._loadPanel = this._createComponent($("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.element()), LoadPanel, {
            shading: false,
            delay: 400,
            message: this.option("refreshingText"),
            position: { of: this.element()
            }
        })
    },
    _updateReachBottomText: function() {
        this._$reachBottomText.text(this.option("reachBottomText"))
    },
    _createStrategy: function() {
        var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
        var strategyClass = refreshStrategies[strategyName];
        if (!strategyClass) {
            throw Error("E1030", this.option("refreshStrategy"))
        }
        this._strategy = new strategyClass(this);
        this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
        this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
        this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this))
    },
    _createActions: function() {
        this.callBase();
        this._pullDownAction = this._createActionByOption("onPullDown");
        this._reachBottomAction = this._createActionByOption("onReachBottom");
        this._refreshPocketState()
    },
    _refreshPocketState: function() {
        this._pullDownEnable(this.hasActionSubscription("onPullDown") && !config().designMode);
        this._reachBottomEnable(this.hasActionSubscription("onReachBottom") && !config().designMode)
    },
    on: function(eventName) {
        var result = this.callBase.apply(this, arguments);
        if ("pullDown" === eventName || "reachBottom" === eventName) {
            this._refreshPocketState()
        }
        return result
    },
    _pullDownEnable: function(enabled) {
        if (0 === arguments.length) {
            return this._pullDownEnabled
        }
        this._$pullDown.toggle(enabled);
        this._strategy.pullDownEnable(enabled);
        this._pullDownEnabled = enabled
    },
    _reachBottomEnable: function(enabled) {
        if (0 === arguments.length) {
            return this._reachBottomEnabled
        }
        this._$reachBottom.toggle(enabled);
        this._strategy.reachBottomEnable(enabled);
        this._reachBottomEnabled = enabled
    },
    _pullDownHandler: function() {
        this._loadingIndicator(false);
        this._pullDownLoading()
    },
    _loadingIndicator: function(value) {
        if (arguments.length < 1) {
            return this._loadingIndicatorEnabled
        }
        this._loadingIndicatorEnabled = value
    },
    _pullDownLoading: function() {
        this.startLoading();
        this._pullDownAction()
    },
    _reachBottomHandler: function() {
        this._loadingIndicator(false);
        this._reachBottomLoading()
    },
    _reachBottomLoading: function() {
        this.startLoading();
        this._reachBottomAction()
    },
    _releaseHandler: function() {
        this.finishLoading();
        this._loadingIndicator(true)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onPullDown":
            case "onReachBottom":
                this._createActions();
                break;
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "refreshStrategy":
                this._invalidate();
                break;
            case "reachBottomText":
                this._updateReachBottomText();
                break;
            default:
                this.callBase(args)
        }
    },
    isEmpty: function() {
        return !this.content().children().length
    },
    content: function() {
        return this._$content.children().eq(1)
    },
    release: function(preventReachBottom) {
        if (void 0 !== preventReachBottom) {
            this.toggleLoading(!preventReachBottom)
        }
        return this._strategy.release()
    },
    toggleLoading: function(showOrHide) {
        this._reachBottomEnable(showOrHide)
    },
    isFull: function() {
        return this.content().height() > this._$container.height()
    },
    refresh: function() {
        if (!this.hasActionSubscription("onPullDown")) {
            return
        }
        this._strategy.pendingRelease();
        this._pullDownLoading()
    },
    startLoading: function() {
        if (this._loadingIndicator() && this.element().is(":visible")) {
            this._loadPanel.show()
        }
        this._lock()
    },
    finishLoading: function() {
        this._loadPanel.hide();
        this._unlock()
    },
    _dispose: function() {
        this._strategy.dispose();
        this.callBase();
        if (this._loadPanel) {
            this._loadPanel.element().remove()
        }
    }
});
registerComponent("dxScrollView", ScrollView);
module.exports = ScrollView;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.native.pull_down.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    NativeStrategy = __webpack_require__(125),
    LoadIndicator = __webpack_require__(53);
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
    SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
    SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
    SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
    STATE_RELEASED = 0,
    STATE_READY = 1,
    STATE_REFRESHING = 2,
    STATE_LOADING = 3,
    PULLDOWN_RELEASE_TIME = 400;
var PullDownNativeScrollViewStrategy = NativeStrategy.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._$refreshingText = scrollView._$refreshingText;
        this._$scrollViewContent = scrollView.content();
        this._initCallbacks()
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = $.Callbacks();
        this.releaseCallbacks = $.Callbacks();
        this.reachBottomCallbacks = $.Callbacks()
    },
    render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState()
    },
    _renderPullDown: function() {
        var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
            $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
            $loadIndicator = new LoadIndicator($("<div>")).element(),
            $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
        this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._refreshPullDownText()
    },
    _pushBackFromBoundary: function() {
        if (!this._isLocked() && !this._component.isEmpty()) {
            this.callBase()
        }
    },
    _refreshPullDownText: function() {
        this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
        this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
        this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
    },
    update: function() {
        this.callBase();
        this._setTopPocketOffset()
    },
    _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.height();
        this._bottomPocketSize = this._$bottomPocket.height();
        this._scrollOffset = this._$container.height() - this._$content.height()
    },
    _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections
    },
    _setTopPocketOffset: function() {
        this._$topPocket.css({
            top: -this._topPocketSize
        })
    },
    handleEnd: function() {
        this.callBase();
        this._complete()
    },
    handleStop: function() {
        this.callBase();
        this._complete()
    },
    _complete: function() {
        if (this._state === STATE_READY) {
            this._setPullDownOffset(this._topPocketSize);
            clearTimeout(this._pullDownRefreshTimeout);
            this._pullDownRefreshTimeout = setTimeout(function() {
                this._pullDownRefreshing()
            }.bind(this), 400)
        }
    },
    _setPullDownOffset: function(offset) {
        translator.move(this._$topPocket, {
            top: offset
        });
        translator.move(this._$scrollViewContent, {
            top: offset
        })
    },
    handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING) {
            return
        }
        var currentLocation = this.location().top,
            scrollDelta = (this._location || 0) - currentLocation;
        this._location = currentLocation;
        if (this._isPullDown()) {
            this._pullDownReady()
        } else {
            if (scrollDelta > 0 && this._isReachBottom()) {
                this._reachBottom()
            } else {
                this._stateReleased()
            }
        }
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._location >= this._topPocketSize
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
    },
    _reachBottom: function() {
        if (this._state === STATE_LOADING) {
            return
        }
        this._state = STATE_LOADING;
        this.reachBottomCallbacks.fire()
    },
    _pullDownReady: function() {
        if (this._state === STATE_READY) {
            return
        }
        this._state = STATE_READY;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._releaseState()
    },
    _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING) {
            return
        }
        this._state = STATE_REFRESHING;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire()
    },
    pullDownEnable: function(enabled) {
        if (enabled) {
            this._updateDimensions();
            this._setTopPocketOffset()
        }
        this._pullDownEnabled = enabled
    },
    reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled
    },
    pendingRelease: function() {
        this._state = STATE_READY
    },
    release: function() {
        var deferred = $.Deferred();
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        if (this._state === STATE_LOADING) {
            this._state = STATE_RELEASED
        }
        this._releaseTimeout = setTimeout(function() {
            this._setPullDownOffset(0);
            this._stateReleased();
            this.releaseCallbacks.fire();
            this._updateAction();
            deferred.resolve()
        }.bind(this), PULLDOWN_RELEASE_TIME);
        return deferred.promise()
    },
    dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase()
    }
});
module.exports = PullDownNativeScrollViewStrategy;


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.native.swipe_down.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    eventUtils = __webpack_require__(3),
    NativeStrategy = __webpack_require__(125),
    LoadIndicator = __webpack_require__(53);
var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading",
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
    SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-refreshing",
    PULLDOWN_ICON_CLASS = "dx-icon-pulldown",
    STATE_RELEASED = 0,
    STATE_READY = 1,
    STATE_REFRESHING = 2,
    STATE_TOUCHED = 4,
    STATE_PULLED = 5;
var SwipeDownNativeScrollViewStrategy = NativeStrategy.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$scrollViewContent = scrollView.content();
        this._initCallbacks();
        this._location = 0
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = $.Callbacks();
        this.releaseCallbacks = $.Callbacks();
        this.reachBottomCallbacks = $.Callbacks()
    },
    render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState()
    },
    _renderPullDown: function() {
        var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
            $loadIndicator = new LoadIndicator($("<div>")).element();
        this._$icon = $("<div>").addClass(PULLDOWN_ICON_CLASS);
        this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator))
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._releasePullDown();
        this._updateDimensions()
    },
    _releasePullDown: function() {
        this._$pullDown.css({
            opacity: 0
        })
    },
    _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.height();
        this._bottomPocketSize = this._$bottomPocket.height();
        this._scrollOffset = this._$container.height() - this._$content.height()
    },
    _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections
    },
    handleInit: function(e) {
        this.callBase(e);
        if (this._state === STATE_RELEASED && 0 === this._location) {
            this._startClientY = eventUtils.eventData(e.originalEvent).y;
            this._state = STATE_TOUCHED
        }
    },
    handleMove: function(e) {
        this.callBase(e);
        this._deltaY = eventUtils.eventData(e.originalEvent).y - this._startClientY;
        if (this._state === STATE_TOUCHED) {
            if (this._pullDownEnabled && this._deltaY > 0) {
                this._state = STATE_PULLED
            } else {
                this._complete()
            }
        }
        if (this._state === STATE_PULLED) {
            e.preventDefault();
            this._movePullDown()
        }
    },
    _movePullDown: function() {
        var pullDownHeight = this._getPullDownHeight(),
            top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition()),
            angle = 180 * top / pullDownHeight / 3;
        this._$pullDown.css({
            opacity: 1
        }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
        translator.move(this._$pullDown, {
            top: top
        });
        this._$icon.css({
            transform: "rotate(" + angle + "deg)"
        })
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition()
    },
    _getPullDownHeight: function() {
        return Math.round(.05 * this._$element.outerHeight())
    },
    _getPullDownStartPosition: function() {
        return -Math.round(1.5 * this._$pullDown.outerHeight())
    },
    handleEnd: function() {
        if (this._isPullDown()) {
            this._pullDownRefreshing()
        }
        this._complete()
    },
    handleStop: function() {
        this._complete()
    },
    _complete: function() {
        if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
            this._releaseState()
        }
    },
    handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING) {
            return
        }
        var currentLocation = this.location().top,
            scrollDelta = this._location - currentLocation;
        this._location = currentLocation;
        if (scrollDelta > 0 && this._isReachBottom()) {
            this._reachBottom()
        } else {
            this._stateReleased()
        }
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
    },
    _reachBottom: function() {
        this.reachBottomCallbacks.fire()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        this._releaseState()
    },
    _pullDownRefreshing: function() {
        this._state = STATE_REFRESHING;
        this._pullDownRefreshHandler()
    },
    _pullDownRefreshHandler: function() {
        this._refreshPullDown();
        this.pullDownCallbacks.fire()
    },
    _refreshPullDown: function() {
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        translator.move(this._$pullDown, {
            top: this._getPullDownHeight()
        })
    },
    pullDownEnable: function(enabled) {
        this._$topPocket.toggle(enabled);
        this._pullDownEnabled = enabled
    },
    reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled
    },
    pendingRelease: function() {
        this._state = STATE_READY
    },
    release: function() {
        var deferred = $.Deferred();
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        this._releaseTimeout = setTimeout(function() {
            this._stateReleased();
            this.releaseCallbacks.fire();
            this._updateAction();
            deferred.resolve()
        }.bind(this), 800);
        return deferred.promise()
    },
    dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase()
    }
});
module.exports = SwipeDownNativeScrollViewStrategy;


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.native.slide_down.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    NativeStrategy = __webpack_require__(125);
var STATE_RELEASED = 0,
    STATE_READY = 1,
    STATE_LOADING = 2,
    LOADING_HEIGHT = 80;
var SlideDownNativeScrollViewStrategy = NativeStrategy.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._initCallbacks()
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = $.Callbacks();
        this.releaseCallbacks = $.Callbacks();
        this.reachBottomCallbacks = $.Callbacks()
    },
    render: function() {
        this.callBase();
        this._renderPullDown();
        this._renderBottom();
        this._releaseState();
        this._updateDimensions()
    },
    _renderPullDown: function() {
        this._$topPocket.empty()
    },
    _renderBottom: function() {
        this._$bottomPocket.empty().append("<progress>")
    },
    _releaseState: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._state = STATE_RELEASED
    },
    _updateDimensions: function() {
        this._scrollOffset = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
        this._containerSize = {
            height: this._$container.prop("clientHeight"),
            width: this._$container.prop("clientWidth")
        };
        this._contentSize = this._componentContentSize = {
            height: this._$container.prop("scrollHeight"),
            width: this._$container.prop("scrollWidth")
        }
    },
    handleScroll: function(e) {
        this.callBase(e);
        if (this._isReachBottom(this._lastLocation.top)) {
            this._reachBottom()
        }
    },
    _isReachBottom: function(location) {
        this._scrollContent = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
        return this._reachBottomEnabled && location < -this._scrollContent + LOADING_HEIGHT
    },
    _reachBottom: function() {
        if (this._state === STATE_LOADING) {
            return
        }
        this._state = STATE_LOADING;
        this.reachBottomCallbacks.fire()
    },
    pullDownEnable: function(enabled) {
        this._pullDownEnabled = enabled
    },
    reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled;
        this._$bottomPocket.toggle(enabled)
    },
    pendingRelease: function() {
        this._state = STATE_READY
    },
    release: function() {
        var deferred = $.Deferred();
        this._state = STATE_RELEASED;
        this.releaseCallbacks.fire();
        this.update();
        return deferred.resolve().promise()
    }
});
module.exports = SlideDownNativeScrollViewStrategy;


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.simulated.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    math = Math,
    simulatedStrategy = __webpack_require__(199),
    LoadIndicator = __webpack_require__(53);
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
    SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
    SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
    SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
    STATE_RELEASED = 0,
    STATE_READY = 1,
    STATE_REFRESHING = 2,
    STATE_LOADING = 3;
var ScrollViewScroller = simulatedStrategy.Scroller.inherit({
    ctor: function() {
        this._topPocketSize = 0;
        this.callBase.apply(this, arguments);
        this._initCallbacks();
        this._releaseState()
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._refreshPullDownText()
    },
    _refreshPullDownText: function() {
        this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
        this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
        this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = $.Callbacks();
        this.releaseCallbacks = $.Callbacks();
        this.reachBottomCallbacks = $.Callbacks()
    },
    _updateBounds: function() {
        var considerPockets = "horizontal" !== this._direction;
        this._topPocketSize = considerPockets ? this._$topPocket[this._dimension]() : 0;
        this._bottomPocketSize = considerPockets ? this._$bottomPocket[this._dimension]() : 0;
        this.callBase();
        this._bottomBound = this._minOffset + this._bottomPocketSize
    },
    _updateScrollbar: function() {
        this._scrollbar.option({
            containerSize: this._containerSize(),
            contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize
        })
    },
    _moveContent: function() {
        this.callBase();
        if (this._isPullDown()) {
            this._pullDownReady()
        } else {
            if (this._isReachBottom()) {
                this._reachBottomReady()
            } else {
                if (this._state !== STATE_RELEASED) {
                    this._stateReleased()
                }
            }
        }
    },
    _moveScrollbar: function() {
        this._scrollbar.moveTo(this._topPocketSize + this._location)
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._location >= 0
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location <= this._bottomBound
    },
    _scrollComplete: function() {
        if (this._inBounds() && this._state === STATE_READY) {
            this._pullDownRefreshing()
        } else {
            if (this._inBounds() && this._state === STATE_LOADING) {
                this._reachBottomLoading()
            } else {
                this.callBase()
            }
        }
    },
    _reachBottomReady: function() {
        if (this._state === STATE_LOADING) {
            return
        }
        this._state = STATE_LOADING;
        this._minOffset = this._getMinOffset()
    },
    _getMaxOffset: function() {
        return -this._topPocketSize
    },
    _getMinOffset: function() {
        return math.min(this.callBase(), -this._topPocketSize)
    },
    _reachBottomLoading: function() {
        this.reachBottomCallbacks.fire()
    },
    _pullDownReady: function() {
        if (this._state === STATE_READY) {
            return
        }
        this._state = STATE_READY;
        this._maxOffset = 0;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._releaseState();
        this._updateBounds();
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this.releaseCallbacks.fire()
    },
    _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING) {
            return
        }
        this._state = STATE_REFRESHING;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire()
    },
    _releaseHandler: function() {
        if (this._state === STATE_RELEASED) {
            this._moveToBounds()
        }
        this._update();
        if (this._releaseTask) {
            this._releaseTask.abort()
        }
        this._releaseTask = commonUtils.executeAsync(this._release.bind(this));
        return this._releaseTask.promise
    },
    _release: function() {
        this._stateReleased();
        this._scrollComplete()
    },
    _reachBottomEnablingHandler: function(enabled) {
        if (this._reachBottomEnabled === enabled) {
            return
        }
        this._reachBottomEnabled = enabled;
        this._updateBounds()
    },
    _pullDownEnablingHandler: function(enabled) {
        if (this._pullDownEnabled === enabled) {
            return
        }
        this._pullDownEnabled = enabled;
        this._considerTopPocketChange();
        this._updateHandler()
    },
    _considerTopPocketChange: function() {
        this._location -= this._$topPocket.height() || -this._topPocketSize;
        this._maxOffset = 0;
        this._move()
    },
    _pendingReleaseHandler: function() {
        this._state = STATE_READY
    },
    dispose: function() {
        if (this._releaseTask) {
            this._releaseTask.abort()
        }
        this.callBase()
    }
});
var SimulatedScrollViewStrategy = simulatedStrategy.SimulatedStrategy.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$pullDown = scrollView._$pullDown;
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._initCallbacks()
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = $.Callbacks();
        this.releaseCallbacks = $.Callbacks();
        this.reachBottomCallbacks = $.Callbacks()
    },
    render: function() {
        this._renderPullDown();
        this.callBase()
    },
    _renderPullDown: function() {
        var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
            $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
            $loadIndicator = new LoadIndicator($("<div>")).element(),
            $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
        this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
    },
    pullDownEnable: function(enabled) {
        this._eventHandler("pullDownEnabling", enabled)
    },
    reachBottomEnable: function(enabled) {
        this._eventHandler("reachBottomEnabling", enabled)
    },
    _createScroller: function(direction) {
        var that = this;
        var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
        scroller.pullDownCallbacks.add(function() {
            that.pullDownCallbacks.fire()
        });
        scroller.releaseCallbacks.add(function() {
            that.releaseCallbacks.fire()
        });
        scroller.reachBottomCallbacks.add(function() {
            that.reachBottomCallbacks.fire()
        })
    },
    _scrollerOptions: function(direction) {
        return extend(this.callBase(direction), {
            $topPocket: this._$topPocket,
            $bottomPocket: this._$bottomPocket,
            $pullDown: this._$pullDown,
            $pullDownText: this._$pullDownText,
            $pullingDownText: this._$pullingDownText,
            $pulledDownText: this._$pulledDownText,
            $refreshingText: this._$refreshingText
        })
    },
    pendingRelease: function() {
        this._eventHandler("pendingRelease")
    },
    release: function() {
        return this._eventHandler("release").done(this._updateAction)
    },
    location: function() {
        var location = this.callBase();
        location.top += this._$topPocket.height();
        return location
    },
    dispose: function() {
        $.each(this._scrollers, function() {
            this.dispose()
        });
        this.callBase()
    }
});
module.exports = SimulatedScrollViewStrategy;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/scroll_view/ui.events.emitter.gesture.scroll.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    abstract = Class.abstract,
    eventUtils = __webpack_require__(3),
    GestureEmitter = __webpack_require__(111),
    registerEmitter = __webpack_require__(63),
    animationFrame = __webpack_require__(87),
    realDevice = __webpack_require__(6).real(),
    compareVersions = __webpack_require__(37).compare;
var SCROLL_INIT_EVENT = "dxscrollinit",
    SCROLL_START_EVENT = "dxscrollstart",
    SCROLL_MOVE_EVENT = "dxscroll",
    SCROLL_END_EVENT = "dxscrollend",
    SCROLL_STOP_EVENT = "dxscrollstop",
    SCROLL_CANCEL_EVENT = "dxscrollcancel";
var isWheelEvent = function(e) {
    return "dxmousewheel" === e.type
};
var Locker = Class.inherit(function() {
    var NAMESPACED_SCROLL_EVENT = eventUtils.addNamespace("scroll", "dxScrollEmitter");
    return {
        ctor: function(element) {
            this._element = element;
            this._locked = false;
            var that = this;
            this._proxiedScroll = function(e) {
                that._scroll(e)
            };
            $(this._element).on(NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
        },
        _scroll: abstract,
        check: function(e, callback) {
            if (this._locked) {
                callback()
            }
        },
        dispose: function() {
            $(this._element).off(NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
        }
    }
}());
var TimeoutLocker = Locker.inherit(function() {
    return {
        ctor: function(element, timeout) {
            this.callBase(element);
            this._timeout = timeout
        },
        _scroll: function() {
            this._prepare();
            this._forget()
        },
        _prepare: function() {
            if (this._timer) {
                this._clearTimer()
            }
            this._locked = true
        },
        _clearTimer: function() {
            clearTimeout(this._timer);
            this._locked = false;
            this._timer = null
        },
        _forget: function() {
            var that = this;
            this._timer = setTimeout(function() {
                that._clearTimer()
            }, this._timeout)
        },
        dispose: function() {
            this.callBase();
            this._clearTimer()
        }
    }
}());
var WheelLocker = TimeoutLocker.inherit(function() {
    var WHEEL_UNLOCK_TIMEOUT = 400;
    return {
        ctor: function(element) {
            this.callBase(element, WHEEL_UNLOCK_TIMEOUT);
            this._lastWheelDirection = null
        },
        check: function(e, callback) {
            this._checkDirectionChanged(e);
            this.callBase(e, callback)
        },
        _checkDirectionChanged: function(e) {
            if (!isWheelEvent(e)) {
                this._lastWheelDirection = null;
                return
            }
            var direction = e.shiftKey || false,
                directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
            this._lastWheelDirection = direction;
            this._locked = this._locked && !directionChange
        }
    }
}());
var PointerLocker = TimeoutLocker.inherit(function() {
    var POINTER_UNLOCK_TIMEOUT = 400;
    return {
        ctor: function(element) {
            this.callBase(element, POINTER_UNLOCK_TIMEOUT)
        }
    }
}());
! function() {
    var ios8_greater = realDevice.ios && compareVersions(realDevice.version, [8]) >= 0,
        android5_greater = realDevice.android && compareVersions(realDevice.version, [5]) >= 0;
    if (!(ios8_greater || android5_greater)) {
        return
    }
    PointerLocker = Locker.inherit(function() {
        return {
            _scroll: function() {
                this._locked = true;
                var that = this;
                animationFrame.cancelAnimationFrame(this._scrollFrame);
                this._scrollFrame = animationFrame.requestAnimationFrame(function() {
                    that._locked = false
                })
            },
            check: function(e, callback) {
                animationFrame.cancelAnimationFrame(this._scrollFrame);
                animationFrame.cancelAnimationFrame(this._checkFrame);
                var that = this,
                    callBase = this.callBase;
                this._checkFrame = animationFrame.requestAnimationFrame(function() {
                    callBase.call(that, e, callback);
                    that._locked = false
                })
            },
            dispose: function() {
                this.callBase();
                animationFrame.cancelAnimationFrame(this._scrollFrame);
                animationFrame.cancelAnimationFrame(this._checkFrame)
            }
        }
    }())
}();
var ScrollEmitter = GestureEmitter.inherit(function() {
    var INERTIA_TIMEOUT = 100,
        VELOCITY_CALC_TIMEOUT = 200,
        FRAME_DURATION = Math.round(1e3 / 60);
    return {
        ctor: function(element) {
            this.callBase.apply(this, arguments);
            this.direction = "both";
            this._pointerLocker = new PointerLocker(element);
            this._wheelLocker = new WheelLocker(element)
        },
        validate: function() {
            return true
        },
        configure: function(data) {
            if (data.scrollTarget) {
                this._pointerLocker.dispose();
                this._wheelLocker.dispose();
                this._pointerLocker = new PointerLocker(data.scrollTarget);
                this._wheelLocker = new WheelLocker(data.scrollTarget)
            }
            this.callBase(data)
        },
        _init: function(e) {
            this._wheelLocker.check(e, function() {
                if (isWheelEvent(e)) {
                    this._accept(e)
                }
            }.bind(this));
            this._pointerLocker.check(e, function() {
                var skipCheck = this.isNative && eventUtils.isMouseEvent(e);
                if (!isWheelEvent(e) && !skipCheck) {
                    this._accept(e)
                }
            }.bind(this));
            this._fireEvent(SCROLL_INIT_EVENT, e);
            this._prevEventData = eventUtils.eventData(e)
        },
        move: function(e) {
            this.callBase.apply(this, arguments);
            e.isScrollingEvent = this.isNative || e.isScrollingEvent
        },
        _start: function(e) {
            this._savedEventData = eventUtils.eventData(e);
            this._fireEvent(SCROLL_START_EVENT, e);
            this._prevEventData = eventUtils.eventData(e)
        },
        _move: function(e) {
            var currentEventData = eventUtils.eventData(e);
            this._fireEvent(SCROLL_MOVE_EVENT, e, {
                delta: eventUtils.eventDelta(this._prevEventData, currentEventData)
            });
            var eventDelta = eventUtils.eventDelta(this._savedEventData, currentEventData);
            if (eventDelta.time > VELOCITY_CALC_TIMEOUT) {
                this._savedEventData = this._prevEventData
            }
            this._prevEventData = eventUtils.eventData(e)
        },
        _end: function(e) {
            var endEventDelta = eventUtils.eventDelta(this._prevEventData, eventUtils.eventData(e));
            var velocity = {
                x: 0,
                y: 0
            };
            if (!isWheelEvent(e) && endEventDelta.time < INERTIA_TIMEOUT) {
                var eventDelta = eventUtils.eventDelta(this._savedEventData, this._prevEventData),
                    velocityMultiplier = FRAME_DURATION / eventDelta.time;
                velocity = {
                    x: eventDelta.x * velocityMultiplier,
                    y: eventDelta.y * velocityMultiplier
                }
            }
            this._fireEvent(SCROLL_END_EVENT, e, {
                velocity: velocity
            })
        },
        _stop: function(e) {
            this._fireEvent(SCROLL_STOP_EVENT, e)
        },
        cancel: function(e) {
            this.callBase.apply(this, arguments);
            this._fireEvent(SCROLL_CANCEL_EVENT, e)
        },
        dispose: function() {
            this.callBase.apply(this, arguments);
            this._pointerLocker.dispose();
            this._wheelLocker.dispose()
        },
        _clearSelection: function() {
            if (this.isNative) {
                return
            }
            return this.callBase.apply(this, arguments)
        },
        _toggleGestureCover: function() {
            if (this.isNative) {
                return
            }
            return this.callBase.apply(this, arguments)
        }
    }
}());
registerEmitter({
    emitter: ScrollEmitter,
    events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
});
module.exports = {
    init: SCROLL_INIT_EVENT,
    start: SCROLL_START_EVENT,
    move: SCROLL_MOVE_EVENT,
    end: SCROLL_END_EVENT,
    stop: SCROLL_STOP_EVENT,
    cancel: SCROLL_CANCEL_EVENT
};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.selection.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    clickEvent = __webpack_require__(11),
    extend = __webpack_require__(1).extend,
    CheckBox = __webpack_require__(99),
    RadioButton = __webpack_require__(302),
    eventUtils = __webpack_require__(3),
    registerDecorator = __webpack_require__(59).register,
    EditDecorator = __webpack_require__(80);
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled",
    SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all",
    SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox",
    SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label",
    SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container",
    SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox",
    SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container",
    SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var CLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, "dxListEditDecorator");
registerDecorator("selection", "default", EditDecorator.inherit({
    _init: function() {
        this.callBase.apply(this, arguments);
        var selectionMode = this._list.option("selectionMode");
        this._singleStrategy = "single" === selectionMode;
        this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
        this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
        this._controlWidget = this._singleStrategy ? RadioButton : CheckBox;
        this._list.element().addClass(SELECT_DECORATOR_ENABLED_CLASS)
    },
    beforeBag: function(config) {
        var $itemElement = config.$itemElement,
            $container = config.$container;
        var $control = $("<div />").addClass(this._controlClass);
        new this._controlWidget($control, extend(this._commonOptions(), {
            value: this._isSelected($itemElement),
            focusStateEnabled: false,
            hoverStateEnabled: false,
            onValueChanged: function(e) {
                this._processCheckedState($itemElement, e.value);
                e.jQueryEvent && e.jQueryEvent.stopPropagation()
            }.bind(this)
        }));
        $container.addClass(this._containerClass);
        $container.append($control)
    },
    modifyElement: function(config) {
        this.callBase.apply(this, arguments);
        var $itemElement = config.$itemElement,
            control = this._controlWidget.getInstance($itemElement.find("." + this._controlClass));
        $itemElement.on("stateChanged", function(e, state) {
            control.option("value", state)
        }.bind(this))
    },
    _updateSelectAllState: function() {
        if (!this._$selectAll) {
            return
        }
        this._selectAllCheckBox.option("value", this._list.isSelectAll())
    },
    afterRender: function() {
        if ("all" !== this._list.option("selectionMode")) {
            return
        }
        if (!this._$selectAll) {
            this._renderSelectAll()
        } else {
            this._updateSelectAllState()
        }
    },
    _renderSelectAll: function() {
        var $selectAll = this._$selectAll = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
        this._selectAllCheckBox = this._list._createComponent($("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), CheckBox);
        $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
        this._list.itemsContainer().prepend($selectAll);
        this._updateSelectAllState();
        this._attachSelectAllHandler()
    },
    _attachSelectAllHandler: function() {
        this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
        this._$selectAll.off(CLICK_EVENT_NAME).on(CLICK_EVENT_NAME, this._selectAllClickHandler.bind(this))
    },
    _selectAllHandler: function(e) {
        e.jQueryEvent && e.jQueryEvent.stopPropagation();
        var isSelectedAll = this._selectAllCheckBox.option("value");
        var result = this._list._createActionByOption("onSelectAllValueChanged")({
            value: isSelectedAll
        });
        if (false === result) {
            return
        }
        if (true === isSelectedAll) {
            this._selectAllItems()
        } else {
            if (false === isSelectedAll) {
                this._unselectAllItems()
            }
        }
    },
    _selectAllItems: function() {
        this._list._selection.selectAll("page" === this._list.option("selectAllMode"))
    },
    _unselectAllItems: function() {
        this._list._selection.deselectAll("page" === this._list.option("selectAllMode"))
    },
    _selectAllClickHandler: function() {
        this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"))
    },
    _isSelected: function($itemElement) {
        return this._list.isItemSelected($itemElement)
    },
    _processCheckedState: function($itemElement, checked) {
        if (checked) {
            this._list.selectItem($itemElement)
        } else {
            this._list.unselectItem($itemElement)
        }
    },
    dispose: function() {
        this._disposeSelectAll();
        this._list.element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
        this.callBase.apply(this, arguments)
    },
    _disposeSelectAll: function() {
        if (this._$selectAll) {
            this._$selectAll.remove();
            this._$selectAll = null
        }
    }
}));


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/radio_group/radio_button.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    inkRipple = __webpack_require__(43),
    registerComponent = __webpack_require__(4),
    Editor = __webpack_require__(33),
    eventUtils = __webpack_require__(3),
    themes = __webpack_require__(20),
    clickEvent = __webpack_require__(11);
var RADIO_BUTTON_CLASS = "dx-radiobutton",
    RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon",
    RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot",
    RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
var RadioButton = Editor.inherit({
    _supportedKeys: function() {
        var click = function(e) {
            e.preventDefault();
            this._clickAction({
                jQueryEvent: e
            })
        };
        return extend(this.callBase(), {
            space: click
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            value: false,
            useInkRipple: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.element().addClass(RADIO_BUTTON_CLASS)
    },
    _render: function() {
        this.callBase();
        this._renderIcon();
        this.option("useInkRipple") && this._renderInkRipple();
        this._renderCheckedState(this.option("value"));
        this._renderClick();
        this.setAria("role", "radio")
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render({
            waveSizeCoefficient: 3.3,
            useHoldAnimation: false,
            wavesNumber: 2,
            isCentered: true
        })
    },
    _renderInkWave: function(element, jQueryEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: element,
            jQueryEvent: jQueryEvent,
            wave: waveIndex
        };
        if (doRender) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _updateFocusState: function(e, value) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 0)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 1)
    },
    _renderIcon: function() {
        this._$icon = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
        $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
        this.element().append(this._$icon)
    },
    _renderCheckedState: function(checked) {
        this.element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked);
        this.setAria("checked", checked)
    },
    _renderClick: function() {
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        this._clickAction = this._createAction(function(args) {
            this._clickHandler(args.jQueryEvent)
        }.bind(this));
        this.element().off(eventName).on(eventName, function(e) {
            this._clickAction({
                jQueryEvent: e
            })
        }.bind(this))
    },
    _clickHandler: function(e) {
        this._saveValueChangeEvent(e);
        this.option("value", true)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
                this._invalidate();
                break;
            case "value":
                this._renderCheckedState(args.value);
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxRadioButton", RadioButton);
module.exports = RadioButton;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/list/ui.list.edit.decorator.reorder.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    fx = __webpack_require__(22),
    dragEvents = __webpack_require__(76),
    mathUtils = __webpack_require__(56),
    Animator = __webpack_require__(200),
    eventUtils = __webpack_require__(3),
    registerDecorator = __webpack_require__(59).register,
    EditDecorator = __webpack_require__(80);
var ReorderScrollAnimator = Animator.inherit({
    ctor: function(strategy) {
        this.callBase();
        this._strategy = strategy
    },
    _isFinished: function() {
        return this._strategy.scrollFinished()
    },
    _step: function() {
        this._strategy.scrollByStep()
    }
});
var LIST_EDIT_DECORATOR = "dxListEditDecorator",
    DRAG_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, LIST_EDIT_DECORATOR),
    DRAG_UPDATE_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, LIST_EDIT_DECORATOR),
    DRAG_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, LIST_EDIT_DECORATOR),
    REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container",
    REORDER_HANDLE_CLASS = "dx-list-reorder-handle",
    REOREDERING_ITEM_CLASS = "dx-list-item-reordering",
    REOREDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering";
registerDecorator("reorder", "default", EditDecorator.inherit({
    _init: function() {
        this._groupedEnabled = this._list.option("grouped");
        this._initAnimator()
    },
    _initAnimator: function() {
        this._scrollAnimator = new ReorderScrollAnimator(this)
    },
    _startAnimator: function() {
        if (!this._scrollAnimator.inProgress()) {
            this._scrollAnimator.start()
        }
    },
    _stopAnimator: function() {
        this._scrollAnimator.stop()
    },
    afterBag: function(config) {
        var $itemElement = config.$itemElement,
            $container = config.$container;
        var $handle = $("<div>").addClass(REORDER_HANDLE_CLASS);
        var lockedDrag = false;
        $handle.on("dxpointerdown", function(e) {
            lockedDrag = !eventUtils.isMouseEvent(e)
        });
        $handle.on("dxhold", {
            timeout: 30
        }, function(e) {
            e.cancel = true;
            lockedDrag = false
        });
        $handle.on(DRAG_START_EVENT_NAME, {
            direction: "vertical",
            immediate: true
        }, function(e) {
            if (lockedDrag) {
                e.cancel = true;
                return
            }
            this._dragStartHandler($itemElement, e)
        }.bind(this));
        $handle.on(DRAG_UPDATE_EVENT_NAME, this._dragHandler.bind(this, $itemElement));
        $handle.on(DRAG_END_EVENT_NAME, this._dragEndHandler.bind(this, $itemElement));
        $container.addClass(REORDER_HANDLE_CONTAINER_CLASS);
        $container.append($handle)
    },
    _dragStartHandler: function($itemElement, e) {
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        this._stopPreviousAnimation();
        e.targetElements = [];
        this._cacheItemsPositions();
        this._startPointerOffset = e.pageY - $itemElement.offset().top;
        this._elementHeight = $itemElement.outerHeight();
        var itemIndex = this._list.getFlatIndexByItemElement($itemElement);
        this._startIndex = itemIndex;
        this._lastIndex = itemIndex;
        this._cacheScrollData();
        var that = this;
        this._createGhostTimeout = setTimeout(function() {
            that._createGhost($itemElement);
            that._updateGhostPosition();
            $itemElement.addClass(REOREDERING_ITEM_CLASS)
        })
    },
    _stopPreviousAnimation: function() {
        fx.stop(this._$ghostItem, true)
    },
    _cacheItemsPositions: function() {
        var itemPositions = this._itemPositions = [];
        $.each(this._list.itemElements(), function(index, item) {
            var cachedPosition = null;
            itemPositions.push(function() {
                cachedPosition = null === cachedPosition ? $(item).position().top : cachedPosition;
                return cachedPosition
            })
        })
    },
    _getDraggingElementPosition: function() {
        return this._itemPositions[this._startIndex]()
    },
    _getLastElementPosition: function() {
        return this._itemPositions[this._lastIndex]()
    },
    _cacheScrollData: function() {
        this._list.updateDimensions();
        this._startScrollTop = this._list.scrollTop();
        this._scrollOffset = 0;
        this._scrollHeight = this._list.scrollHeight();
        this._clientHeight = this._list.clientHeight()
    },
    _scrollTop: function() {
        return this._startScrollTop + this._scrollOffset
    },
    _createGhost: function($itemElement) {
        this._$ghostItem = $itemElement.clone();
        this._$ghostItem.addClass(REOREDERING_ITEM_GHOST_CLASS).appendTo(this._list.itemsContainer());
        this._startGhostPosition = this._getDraggingElementPosition() - this._$ghostItem.position().top;
        translator.move(this._$ghostItem, {
            top: this._startGhostPosition
        })
    },
    _dragHandler: function($itemElement, e) {
        this._topOffset = e.offset.y;
        this._updateItemPositions();
        var pointerPosition = this._getPointerPosition();
        this._toggleScroll(pointerPosition)
    },
    _getPointerPosition: function() {
        return this._getDraggingElementPosition() + this._startPointerOffset + this._scrollOffset + this._topOffset
    },
    _toggleScroll: function(pointerPosition) {
        if (this._scrollHeight <= this._clientHeight) {
            return
        }
        var minOffset = .7 * this._elementHeight,
            topOffset = this._clientHeight - (pointerPosition - this._scrollTop()),
            topOffsetRatio = topOffset / minOffset,
            bottomOffset = pointerPosition - this._scrollTop(),
            bottomOffsetRatio = bottomOffset / minOffset;
        if (topOffsetRatio < 1) {
            this._stepSize = this._adjustRationIntoRange(topOffsetRatio);
            this._startAnimator()
        } else {
            if (bottomOffsetRatio < 1) {
                this._stepSize = -this._adjustRationIntoRange(bottomOffsetRatio);
                this._startAnimator()
            } else {
                this._stopAnimator()
            }
        }
    },
    _adjustRationIntoRange: function(ratio) {
        return mathUtils.fitIntoRange(Math.round(7 * Math.abs(ratio - 1)), 1, 7)
    },
    _updateItemPositions: function() {
        this._updateGhostPosition();
        this._updateOthersPositions()
    },
    _updateGhostPosition: function() {
        if (!this._$ghostItem) {
            return
        }
        translator.move(this._$ghostItem, {
            top: this._startGhostPosition + this._scrollOffset + this._topOffset
        })
    },
    _updateOthersPositions: function() {
        var currentIndex = this._findItemIndexByPosition(this._getPointerPosition());
        if (this._lastIndex === currentIndex || this._groupedEnabled && !this._sameParent(currentIndex)) {
            return
        }
        var currentIndexOffset = currentIndex - this._startIndex,
            currentDirection = mathUtils.sign(currentIndexOffset),
            minIndex = Math.min(currentIndex, this._lastIndex),
            maxIndex = Math.max(currentIndex, this._lastIndex);
        for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
            if (itemIndex === this._startIndex) {
                continue
            }
            var $item = this._list.getItemElementByFlatIndex(itemIndex),
                itemIndexOffset = itemIndex - this._startIndex,
                itemDirection = mathUtils.sign(itemIndexOffset),
                offsetsDifference = Math.abs(itemIndexOffset) <= Math.abs(currentIndexOffset),
                sameDirections = currentDirection === itemDirection,
                setupPosition = offsetsDifference && sameDirections,
                resetPosition = !offsetsDifference || !sameDirections;
            fx.stop($item);
            if (setupPosition) {
                fx.animate($item, {
                    type: "slide",
                    to: {
                        top: this._elementHeight * -currentDirection
                    },
                    duration: 300
                })
            }
            if (resetPosition) {
                fx.animate($item, {
                    type: "slide",
                    to: {
                        top: 0
                    },
                    duration: 300
                })
            }
        }
        this._lastIndex = currentIndex
    },
    _sameParent: function(index) {
        var $dragging = this._list.getItemElementByFlatIndex(this._startIndex),
            $over = this._list.getItemElementByFlatIndex(index);
        return $over.parent().get(0) === $dragging.parent().get(0)
    },
    scrollByStep: function() {
        this._scrollOffset += this._stepSize;
        this._list.scrollBy(this._stepSize);
        this._updateItemPositions()
    },
    scrollFinished: function() {
        var scrollTop = this._scrollTop(),
            rejectScrollTop = scrollTop <= 0 && this._stepSize < 0,
            rejectScrollBottom = scrollTop >= this._scrollHeight - this._clientHeight && this._stepSize > 0;
        return rejectScrollTop || rejectScrollBottom
    },
    _dragEndHandler: function($itemElement) {
        this._scrollAnimator.stop();
        fx.animate(this._$ghostItem, {
            type: "slide",
            to: {
                top: this._startGhostPosition + this._getLastElementPosition() - this._getDraggingElementPosition()
            },
            duration: 300
        }).done(function() {
            $itemElement.removeClass(REOREDERING_ITEM_CLASS);
            this._resetPositions();
            this._list.reorderItem($itemElement, this._list.getItemElementByFlatIndex(this._lastIndex));
            this._deleteGhost()
        }.bind(this))
    },
    _deleteGhost: function() {
        if (!this._$ghostItem) {
            return
        }
        this._$ghostItem.remove()
    },
    _resetPositions: function() {
        var minIndex = Math.min(this._startIndex, this._lastIndex),
            maxIndex = Math.max(this._startIndex, this._lastIndex);
        for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
            var $item = this._list.getItemElementByFlatIndex(itemIndex);
            translator.resetPosition($item)
        }
    },
    _findItemIndexByPosition: function(position) {
        var minIndex = 0;
        var maxIndex = this._itemPositions.length - 1;
        var currentIndex;
        var currentPosition;
        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentPosition = this._itemPositions[currentIndex]();
            if (currentPosition < position) {
                minIndex = currentIndex + 1
            } else {
                if (currentPosition > position) {
                    maxIndex = currentIndex - 1
                } else {
                    return currentIndex
                }
            }
        }
        return mathUtils.fitIntoRange(minIndex, 0, Math.max(maxIndex, 0))
    },
    dispose: function() {
        clearTimeout(this._createGhostTimeout);
        this.callBase.apply(this, arguments)
    }
}));


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/color_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(305);
module.exports.default = module.exports;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/color_box/color_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Color = __webpack_require__(85),
    ColorView = __webpack_require__(306),
    extend = __webpack_require__(1).extend,
    isFunction = __webpack_require__(2).isFunction,
    registerComponent = __webpack_require__(4),
    DropDownEditor = __webpack_require__(123);
var COLOR_BOX_CLASS = "dx-colorbox",
    COLOR_BOX_INPUT_CLASS = COLOR_BOX_CLASS + "-input",
    COLOR_BOX_INPUT_CONTAINER_CLASS = COLOR_BOX_INPUT_CLASS + "-container",
    COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS = COLOR_BOX_CLASS + "-color-result-preview",
    COLOR_BOX_COLOR_IS_NOT_DEFINED = COLOR_BOX_CLASS + "-color-is-not-defined",
    COLOR_BOX_OVERLAY_CLASS = COLOR_BOX_CLASS + "-overlay",
    COLOR_BOX_CONTAINER_CELL_CLASS = "dx-colorview-container-cell",
    COLOR_BOX_BUTTON_CELL_CLASS = "dx-colorview-button-cell",
    COLOR_BOX_BUTTONS_CONTAINER_CLASS = "dx-colorview-buttons-container",
    COLOR_BOX_APPLY_BUTTON_CLASS = "dx-colorview-apply-button",
    COLOR_BOX_CANCEL_BUTTON_CLASS = "dx-colorview-cancel-button";
var colorEditorPrototype = ColorView.prototype,
    colorUtils = {
        makeTransparentBackground: colorEditorPrototype._makeTransparentBackground.bind(colorEditorPrototype),
        makeRgba: colorEditorPrototype._makeRgba.bind(colorEditorPrototype)
    };
var ColorBox = DropDownEditor.inherit({
    _supportedKeys: function() {
        var arrowHandler = function(e) {
            e.stopPropagation();
            if (this.option("opened")) {
                e.preventDefault();
                return true
            }
        };
        var upArrowHandler = function(e) {
            if (!this.option("opened")) {
                e.preventDefault();
                return false
            }
            if (e.altKey) {
                this.close();
                return false
            }
            return true
        };
        var downArrowHandler = function(e) {
            if (!this.option("opened") && !e.altKey) {
                e.preventDefault();
                return false
            }
            if (!this.option("opened") && e.altKey) {
                this._validatedOpening();
                return false
            }
            return true
        };
        return extend(this.callBase(), {
            tab: function(e) {
                if (this.option("opened")) {
                    e.preventDefault();
                    this._colorView._rgbInputs[0].focus()
                }
            },
            enter: this._enterKeyHandler,
            leftArrow: arrowHandler,
            rightArrow: arrowHandler,
            upArrow: upArrowHandler,
            downArrow: downArrowHandler
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            editAlphaChannel: false,
            applyValueMode: "useButtons",
            keyStep: 1,
            fieldTemplate: null,
            onApplyButtonClick: null,
            onCancelButtonClick: null,
            buttonsLocation: "bottom after"
        })
    },
    _popupConfig: function() {
        return extend(this.callBase(), {
            height: "auto",
            width: ""
        })
    },
    _contentReadyHandler: function() {
        this._createColorView();
        this._addPopupBottomClasses()
    },
    _addPopupBottomClasses: function() {
        var $popupBottom = this._popup.bottomToolbar();
        if ($popupBottom) {
            $popupBottom.addClass(COLOR_BOX_CONTAINER_CELL_CLASS).addClass(COLOR_BOX_BUTTON_CELL_CLASS).find(".dx-toolbar-items-container").addClass(COLOR_BOX_BUTTONS_CONTAINER_CLASS);
            $popupBottom.find(".dx-popup-done").addClass(COLOR_BOX_APPLY_BUTTON_CLASS);
            $popupBottom.find(".dx-popup-cancel").addClass(COLOR_BOX_CANCEL_BUTTON_CLASS)
        }
    },
    _createColorView: function() {
        this._popup.overlayContent().addClass(COLOR_BOX_OVERLAY_CLASS);
        var $colorView = $("<div>").appendTo(this._popup.content());
        this._colorView = this._createComponent($colorView, ColorView, this._colorViewConfig());
        $colorView.on("focus", function() {
            this.focus()
        }.bind(this))
    },
    _applyNewColor: function(value) {
        this.option("value", value);
        if (value) {
            colorUtils.makeTransparentBackground(this._$colorResultPreview, value)
        }
        if (this._colorViewEnterKeyPressed) {
            this.close();
            this._colorViewEnterKeyPressed = false
        }
    },
    _colorViewConfig: function() {
        var that = this;
        return {
            value: that.option("value"),
            editAlphaChannel: that.option("editAlphaChannel"),
            applyValueMode: that.option("applyValueMode"),
            focusStateEnabled: that.option("focusStateEnabled"),
            onEnterKeyPressed: function() {
                that._colorViewEnterKeyPressed = true;
                if (that._colorView.option("value") !== that.option("value")) {
                    that._applyNewColor(that._colorView.option("value"));
                    that.close()
                }
            },
            onValueChanged: function(args) {
                var instantlyMode = "instantly" === that.option("applyValueMode");
                if (!instantlyMode && !that._colorViewEnterKeyPressed) {
                    return
                }
                that._applyNewColor(args.value)
            },
            _keyboardProcessor: that._colorViewProcessor
        }
    },
    _enterKeyHandler: function() {
        var newValue = this._input().val(),
            value = this.option("value"),
            oldValue = this.option("editAlphaChannel") ? colorUtils.makeRgba(value) : value;
        if (!newValue) {
            return false
        }
        var color = new Color(newValue);
        if (color.colorIsInvalid) {
            this._input().val(oldValue);
            return
        }
        if (newValue !== oldValue) {
            this._applyColorFromInput(newValue);
            this.option("value", this.option("editAlphaChannel") ? colorUtils.makeRgba(newValue) : newValue)
        }
        if (this._colorView) {
            var colorViewValue = this._colorView.option("value");
            if (value !== colorViewValue) {
                this.option("value", colorViewValue)
            }
        }
        this.close();
        return false
    },
    _applyButtonHandler: function() {
        this._applyNewColor(this._colorView.option("value"));
        if (isFunction(this.option("onApplyButtonClick"))) {
            this.option("onApplyButtonClick")()
        }
        this.callBase()
    },
    _cancelButtonHandler: function() {
        this._resetInputValue();
        if (isFunction(this.option("onCancelButtonClick"))) {
            this.option("onCancelButtonClick")()
        }
        this.callBase()
    },
    _attachChildKeyboardEvents: function() {
        this._colorViewProcessor = this._keyboardProcessor.attachChildProcessor();
        if (this._colorView) {
            this._colorView.option("_keyboardProcessor", this._colorViewProcessor);
            return
        }
    },
    _init: function() {
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this.element().addClass(COLOR_BOX_CLASS)
    },
    _renderInput: function() {
        this.callBase();
        this._input().addClass(COLOR_BOX_INPUT_CLASS);
        this._renderColorPreview()
    },
    _renderColorPreview: function() {
        this.element().wrapInner($("<div/>").addClass(COLOR_BOX_INPUT_CONTAINER_CLASS));
        this._$colorBoxInputContainer = this.element().children().eq(0);
        this._$colorResultPreview = $("<div>", {
            "class": COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS,
            appendTo: this._$colorBoxInputContainer
        });
        if (!this.option("value")) {
            this._$colorBoxInputContainer.addClass(COLOR_BOX_COLOR_IS_NOT_DEFINED)
        } else {
            colorUtils.makeTransparentBackground(this._$colorResultPreview, this.option("value"))
        }
    },
    _renderValue: function() {
        var value = this.option("value");
        this.option("text", this.option("editAlphaChannel") ? colorUtils.makeRgba(value) : value);
        this.callBase()
    },
    _resetInputValue: function() {
        var $input = this._input(),
            value = this.option("value");
        $input.val(value);
        this._colorView && this._colorView.option("value", value)
    },
    _valueChangeEventHandler: function(e) {
        var value = this._input().val();
        if (value) {
            value = this._applyColorFromInput(value);
            this._colorView && this._colorView.option("value", value)
        }
        this.callBase(e, value)
    },
    _applyColorFromInput: function(value) {
        var newColor = new Color(value);
        if (newColor.colorIsInvalid) {
            this._resetInputValue();
            value = this.option("value")
        }
        return value
    },
    _optionChanged: function(args) {
        var value = args.value,
            name = args.name;
        switch (name) {
            case "value":
                this._$colorBoxInputContainer.toggleClass(COLOR_BOX_COLOR_IS_NOT_DEFINED, !value);
                if (value) {
                    colorUtils.makeTransparentBackground(this._$colorResultPreview, value)
                } else {
                    this._$colorResultPreview.removeAttr("style")
                }
                if (this._colorView) {
                    this._colorView.option("value", value)
                }
                this.callBase(args);
                break;
            case "applyButtonText":
            case "cancelButtonText":
                this.callBase(args);
                this._popup && this._addPopupBottomClasses();
                break;
            case "editAlphaChannel":
            case "onCancelButtonClick":
            case "onApplyButtonClick":
            case "keyStep":
                if (this._colorView) {
                    this._colorView.option(name, value)
                }
                break;
            case "applyValueMode":
                this.callBase(args);
                break;
            case "rtlEnabled":
                if (this._colorView) {
                    this._colorView.option(name, value)
                }
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxColorBox", ColorBox);
module.exports = ColorBox;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/color_box/color_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    translator = __webpack_require__(19),
    extend = __webpack_require__(1).extend,
    Color = __webpack_require__(85),
    messageLocalization = __webpack_require__(8),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    Editor = __webpack_require__(33),
    NumberBox = __webpack_require__(81),
    TextBox = __webpack_require__(69),
    Draggable = __webpack_require__(309),
    clickEvent = __webpack_require__(11);
var COLOR_VIEW_CLASS = "dx-colorview",
    COLOR_VIEW_CONTAINER_CLASS = "dx-colorview-container",
    COLOR_VIEW_ROW_CLASS = "dx-colorview-container-row",
    COLOR_VIEW_CELL_CLASS = "dx-colorview-container-cell",
    COLOR_VIEW_PALETTE_CLASS = "dx-colorview-palette",
    COLOR_VIEW_PALETTE_CELL_CLASS = "dx-colorview-palette-cell",
    COLOR_VIEW_PALETTE_HANDLE_CLASS = "dx-colorview-palette-handle",
    COLOR_VIEW_PALETTE_GRADIENT_CLASS = "dx-colorview-palette-gradient",
    COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS = "dx-colorview-palette-gradient-white",
    COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS = "dx-colorview-palette-gradient-black",
    COLOR_VIEW_HUE_SCALE_CLASS = "dx-colorview-hue-scale",
    COLOR_VIEW_HUE_SCALE_CELL_CLASS = "dx-colorview-hue-scale-cell",
    COLOR_VIEW_HUE_SCALE_HANDLE_CLASS = "dx-colorview-hue-scale-handle",
    COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS = "dx-colorview-hue-scale-wrapper",
    COLOR_VIEW_CONTROLS_CONTAINER_CLASS = "dx-colorview-controls-container",
    COLOR_VIEW_RED_LABEL_CLASS = "dx-colorview-label-red",
    COLOR_VIEW_GREEN_LABEL_CLASS = "dx-colorview-label-green",
    COLOR_VIEW_BLUE_LABEL_CLASS = "dx-colorview-label-blue",
    COLOR_VIEW_HEX_LABEL_CLASS = "dx-colorview-label-hex",
    COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS = "dx-colorview-alpha-channel-scale",
    COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS = "dx-colorview-alpha-channel-row",
    COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS = "dx-colorview-alpha-channel-wrapper",
    COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS = "dx-colorview-alpha-channel-label",
    COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS = "dx-colorview-alpha-channel-handle",
    COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS = "dx-colorview-alpha-channel-cell",
    COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS = "dx-colorview-alpha-channel-border",
    COLOR_VIEW_COLOR_PREVIEW = "dx-colorview-color-preview",
    COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS = "dx-colorview-color-preview-container",
    COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS = "dx-colorview-color-preview-container-inner",
    COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT = "dx-colorview-color-preview-color-current",
    COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW = "dx-colorview-color-preview-color-new";
var ColorView = Editor.inherit({
    _supportedKeys: function() {
        var isRTL = this.option("rtlEnabled");
        var that = this,
            getHorizontalPaletteStep = function(e) {
                var step = 100 / that._paletteWidth;
                if (e.shiftKey) {
                    step *= that.option("keyStep")
                }
                step = step > 1 ? step : 1;
                return Math.round(step)
            },
            updateHorizontalPaletteValue = function(step) {
                var value = that._currentColor.hsv.s + step;
                if (value > 100) {
                    value = 100
                } else {
                    if (value < 0) {
                        value = 0
                    }
                }
                that._currentColor.hsv.s = value;
                updatePaletteValue()
            },
            getVerticalPaletteStep = function(e) {
                var step = 100 / that._paletteHeight;
                if (e.shiftKey) {
                    step *= that.option("keyStep")
                }
                step = step > 1 ? step : 1;
                return Math.round(step)
            },
            updateVerticalPaletteValue = function(step) {
                var value = that._currentColor.hsv.v + step;
                if (value > 100) {
                    value = 100
                } else {
                    if (value < 0) {
                        value = 0
                    }
                }
                that._currentColor.hsv.v = value;
                updatePaletteValue()
            },
            updatePaletteValue = function() {
                that._placePaletteHandle();
                that._updateColorFromHsv(that._currentColor.hsv.h, that._currentColor.hsv.s, that._currentColor.hsv.v)
            },
            getHueScaleStep = function(e) {
                var step = 360 / (that._hueScaleWrapperHeight - that._hueScaleHandleHeight);
                if (e.shiftKey) {
                    step *= that.option("keyStep")
                }
                step = step > 1 ? step : 1;
                return step
            },
            updateHueScaleValue = function(step) {
                that._currentColor.hsv.h += step;
                that._placeHueScaleHandle();
                var handleLocation = translator.locate(that._$hueScaleHandle);
                that._updateColorHue(handleLocation.top + that._hueScaleHandleHeight / 2)
            },
            getAlphaScaleStep = function(e) {
                var step = 1 / that._alphaChannelScaleWorkWidth;
                if (e.shiftKey) {
                    step *= that.option("keyStep")
                }
                step = step > .01 ? step : .01;
                step = isRTL ? -step : step;
                return step
            },
            updateAlphaScaleValue = function(step) {
                that._currentColor.a += step;
                that._placeAlphaChannelHandle();
                var handleLocation = translator.locate(that._$alphaChannelHandle);
                that._calculateColorTransparencyByScaleWidth(handleLocation.left + that._alphaChannelHandleWidth / 2)
            };
        return extend(this.callBase(), {
            upArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.ctrlKey) {
                    if (this._currentColor.hsv.h <= 360 && !this._isTopColorHue) {
                        updateHueScaleValue(getHueScaleStep(e))
                    }
                } else {
                    if (this._currentColor.hsv.v < 100) {
                        updateVerticalPaletteValue(getVerticalPaletteStep(e))
                    }
                }
            },
            downArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.ctrlKey) {
                    if (this._currentColor.hsv.h >= 0) {
                        if (this._isTopColorHue) {
                            this._currentColor.hsv.h = 360
                        }
                        updateHueScaleValue(-getHueScaleStep(e))
                    }
                } else {
                    if (this._currentColor.hsv.v > 0) {
                        updateVerticalPaletteValue(-getVerticalPaletteStep(e))
                    }
                }
            },
            rightArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.ctrlKey) {
                    if (isRTL ? this._currentColor.a < 1 : this._currentColor.a > 0 && this.option("editAlphaChannel")) {
                        updateAlphaScaleValue(-getAlphaScaleStep(e))
                    }
                } else {
                    if (this._currentColor.hsv.s < 100) {
                        updateHorizontalPaletteValue(getHorizontalPaletteStep(e))
                    }
                }
            },
            leftArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.ctrlKey) {
                    if (isRTL ? this._currentColor.a > 0 : this._currentColor.a < 1 && this.option("editAlphaChannel")) {
                        updateAlphaScaleValue(getAlphaScaleStep(e))
                    }
                } else {
                    if (this._currentColor.hsv.s > 0) {
                        updateHorizontalPaletteValue(-getHorizontalPaletteStep(e))
                    }
                }
            },
            enter: function(e) {
                this._fireEnterKeyPressed(e)
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: null,
            onEnterKeyPressed: void 0,
            editAlphaChannel: false,
            keyStep: 1
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initColorAndOpacity();
        this._initEnterKeyPressedAction()
    },
    _initEnterKeyPressedAction: function() {
        this._onEnterKeyPressedAction = this._createActionByOption("onEnterKeyPressed")
    },
    _fireEnterKeyPressed: function(e) {
        if (!this._onEnterKeyPressedAction) {
            return
        }
        this._onEnterKeyPressedAction({
            jQueryEvent: e
        })
    },
    _initColorAndOpacity: function() {
        this._setCurrentColor(this.option("value"))
    },
    _setCurrentColor: function(value) {
        value = value || "#000000";
        var newColor = new Color(value);
        if (!newColor.colorIsInvalid) {
            if (!this._currentColor || this._makeRgba(this._currentColor) !== this._makeRgba(newColor)) {
                this._currentColor = newColor;
                if (this._$currentColor) {
                    this._makeTransparentBackground(this._$currentColor, newColor)
                }
            }
        } else {
            this.option("value", this._currentColor.baseColor)
        }
    },
    _render: function() {
        this.callBase();
        this.element().addClass(COLOR_VIEW_CLASS);
        this._renderColorPickerContainer()
    },
    _makeTransparentBackground: function($el, color) {
        if (!(color instanceof Color)) {
            color = new Color(color)
        }
        $el.css("backgroundColor", this._makeRgba(color))
    },
    _makeRgba: function(color) {
        if (!(color instanceof Color)) {
            color = new Color(color)
        }
        return "rgba(" + [color.r, color.g, color.b, color.a].join(", ") + ")"
    },
    _renderValue: function() {
        this.callBase(this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this.option("value"))
    },
    _renderColorPickerContainer: function() {
        var $parent = this.element();
        this._$colorPickerContainer = $("<div>", {
            "class": COLOR_VIEW_CONTAINER_CLASS,
            appendTo: $parent
        });
        this._renderHtmlRows();
        this._renderPalette();
        this._renderHueScale();
        this._renderControlsContainer();
        this._renderControls();
        this._renderAlphaChannelElements()
    },
    _renderHtmlRows: function(updatedOption) {
        var $renderedRows = this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS),
            renderedRowsCount = $renderedRows.length,
            rowCount = this.option("editAlphaChannel") ? 2 : 1,
            delta = renderedRowsCount - rowCount;
        if (delta > 0) {
            $renderedRows.eq(-1).remove()
        }
        if (delta < 0) {
            delta = Math.abs(delta);
            var i, rows = [];
            for (i = 0; i < delta; i++) {
                rows.push($("<div>", {
                    "class": COLOR_VIEW_ROW_CLASS
                }))
            }
            if (renderedRowsCount) {
                for (i = 0; i < rows.length; i++) {
                    $renderedRows.eq(0).after(rows[i])
                }
            } else {
                this._$colorPickerContainer.append(rows)
            }
        }
    },
    _renderHtmlCellInsideRow: function(index, $rowParent, additionalClass) {
        return $("<div>", {
            "class": COLOR_VIEW_CELL_CLASS,
            addClass: additionalClass,
            appendTo: $rowParent.find("." + COLOR_VIEW_ROW_CLASS).eq(index)
        })
    },
    _renderPalette: function() {
        var $paletteCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer, COLOR_VIEW_PALETTE_CELL_CLASS),
            $paletteGradientWhite = $("<div>", {
                "class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS].join(" ")
            }),
            $paletteGradientBlack = $("<div>", {
                "class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS].join(" ")
            });
        this._$palette = $("<div>", {
            "class": COLOR_VIEW_PALETTE_CLASS,
            css: {
                backgroundColor: this._currentColor.getPureColor().toHex()
            },
            appendTo: $paletteCell
        });
        this._paletteHeight = this._$palette.height();
        this._paletteWidth = this._$palette.width();
        this._renderPaletteHandle();
        this._$palette.append([$paletteGradientWhite, $paletteGradientBlack])
    },
    _renderPaletteHandle: function() {
        this._createComponent(this._$paletteHandle = $("<div>", {
            "class": COLOR_VIEW_PALETTE_HANDLE_CLASS,
            appendTo: this._$palette
        }), Draggable, {
            area: this._$palette,
            allowMoveByClick: true,
            boundOffset: function() {
                return -this._paletteHandleHeight / 2
            }.bind(this),
            onDrag: function() {
                var paletteHandlePosition = translator.locate(this._$paletteHandle);
                this._updateByDrag = true;
                this._updateColorFromHsv(this._currentColor.hsv.h, this._calculateColorSaturation(paletteHandlePosition), this._calculateColorValue(paletteHandlePosition))
            }.bind(this)
        });
        this._paletteHandleWidth = this._$paletteHandle.width();
        this._paletteHandleHeight = this._$paletteHandle.height();
        this._placePaletteHandle()
    },
    _placePaletteHandle: function() {
        translator.move(this._$paletteHandle, {
            left: Math.round(this._paletteWidth * this._currentColor.hsv.s / 100 - this._paletteHandleWidth / 2),
            top: Math.round(this._paletteHeight - this._paletteHeight * this._currentColor.hsv.v / 100 - this._paletteHandleHeight / 2)
        })
    },
    _calculateColorValue: function(paletteHandlePosition) {
        var value = Math.floor(paletteHandlePosition.top + this._paletteHandleHeight / 2);
        return 100 - Math.round(100 * value / this._paletteHeight)
    },
    _calculateColorSaturation: function(paletteHandlePosition) {
        var saturation = Math.floor(paletteHandlePosition.left + this._paletteHandleWidth / 2);
        return Math.round(100 * saturation / this._paletteWidth)
    },
    _updateColorFromHsv: function(hue, saturation, value) {
        var a = this._currentColor.a;
        this._currentColor = new Color("hsv(" + [hue, saturation, value].join(",") + ")");
        this._currentColor.a = a;
        this._updateColorParamsAndColorPreview();
        this.applyColor()
    },
    _renderHueScale: function() {
        var $hueScaleCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer, COLOR_VIEW_HUE_SCALE_CELL_CLASS);
        this._$hueScaleWrapper = $("<div>", {
            "class": COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS,
            appendTo: $hueScaleCell
        });
        this._$hueScale = $("<div>", {
            "class": COLOR_VIEW_HUE_SCALE_CLASS,
            appendTo: this._$hueScaleWrapper
        });
        this._hueScaleHeight = this._$hueScale.height();
        this._hueScaleWrapperHeight = this._$hueScaleWrapper.outerHeight();
        this._renderHueScaleHandle()
    },
    _renderHueScaleHandle: function() {
        this._createComponent(this._$hueScaleHandle = $("<div>", {
            "class": COLOR_VIEW_HUE_SCALE_HANDLE_CLASS,
            appendTo: this._$hueScaleWrapper
        }), Draggable, {
            area: this._$hueScaleWrapper,
            allowMoveByClick: true,
            direction: "vertical",
            onDrag: function() {
                this._updateByDrag = true;
                this._updateColorHue(translator.locate(this._$hueScaleHandle).top + this._hueScaleHandleHeight / 2)
            }.bind(this)
        });
        this._hueScaleHandleHeight = this._$hueScaleHandle.height();
        this._placeHueScaleHandle()
    },
    _placeHueScaleHandle: function() {
        var hueScaleHeight = this._hueScaleWrapperHeight,
            handleHeight = this._hueScaleHandleHeight,
            top = (hueScaleHeight - handleHeight) * (360 - this._currentColor.hsv.h) / 360;
        if (hueScaleHeight < top + handleHeight) {
            top = hueScaleHeight - handleHeight
        }
        if (top < 0) {
            top = 0
        }
        translator.move(this._$hueScaleHandle, {
            top: Math.round(top)
        })
    },
    _updateColorHue: function(handlePosition) {
        var hue = 360 - Math.round(360 * (handlePosition - this._hueScaleHandleHeight / 2) / (this._hueScaleWrapperHeight - this._hueScaleHandleHeight)),
            saturation = this._currentColor.hsv.s,
            value = this._currentColor.hsv.v;
        this._isTopColorHue = false;
        hue = hue < 0 ? 0 : hue;
        if (hue >= 360) {
            this._isTopColorHue = true;
            hue = 0
        }
        this._updateColorFromHsv(hue, saturation, value);
        this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex())
    },
    _renderControlsContainer: function() {
        var $controlsContainerCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer);
        this._$controlsContainer = $("<div>", {
            "class": COLOR_VIEW_CONTROLS_CONTAINER_CLASS,
            appendTo: $controlsContainerCell
        })
    },
    _renderControls: function() {
        this._renderColorsPreview();
        this._renderRgbInputs();
        this._renderHexInput()
    },
    _renderColorsPreview: function() {
        var $colorsPreviewContainer = $("<div>", {
                "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS,
                appendTo: this._$controlsContainer
            }),
            $colorsPreviewContainerInner = $("<div>", {
                "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS,
                appendTo: $colorsPreviewContainer
            });
        this._$currentColor = $("<div>", {
            "class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT].join(" ")
        });
        this._$newColor = $("<div>", {
            "class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW].join(" ")
        });
        this._makeTransparentBackground(this._$currentColor, this._currentColor);
        this._makeTransparentBackground(this._$newColor, this._currentColor);
        $colorsPreviewContainerInner.append([this._$currentColor, this._$newColor])
    },
    _renderAlphaChannelElements: function() {
        if (this.option("editAlphaChannel")) {
            this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS).eq(1).addClass(COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS);
            this._renderAlphaChannelScale();
            this._renderAlphaChannelInput()
        }
    },
    _renderRgbInputs: function() {
        this._rgbInputsWithLabels = [this._renderEditorWithLabel({
            editorType: NumberBox,
            value: this._currentColor.r,
            onValueChanged: this._updateColor.bind(this, false),
            labelText: "R",
            labelAriaText: messageLocalization.format("dxColorView-ariaRed"),
            labelClass: COLOR_VIEW_RED_LABEL_CLASS
        }), this._renderEditorWithLabel({
            editorType: NumberBox,
            value: this._currentColor.g,
            onValueChanged: this._updateColor.bind(this, false),
            labelText: "G",
            labelAriaText: messageLocalization.format("dxColorView-ariaGreen"),
            labelClass: COLOR_VIEW_GREEN_LABEL_CLASS
        }), this._renderEditorWithLabel({
            editorType: NumberBox,
            value: this._currentColor.b,
            onValueChanged: this._updateColor.bind(this, false),
            labelText: "B",
            labelAriaText: messageLocalization.format("dxColorView-ariaBlue"),
            labelClass: COLOR_VIEW_BLUE_LABEL_CLASS
        })];
        this._$controlsContainer.append(this._rgbInputsWithLabels);
        this._rgbInputs = [this._rgbInputsWithLabels[0].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[1].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[2].find(".dx-numberbox").dxNumberBox("instance")]
    },
    _renderEditorWithLabel: function(options) {
        var $editor = $("<div>"),
            $label = $("<label>", {
                "class": options.labelClass,
                text: options.labelText + ":",
                append: $editor
            }).off(clickEvent.name).on(clickEvent.name, function(e) {
                e.preventDefault()
            }),
            editorType = options.editorType,
            editorOptions = {
                value: options.value,
                onValueChanged: options.onValueChanged
            };
        if (editorType === NumberBox) {
            editorOptions.min = options.min || 0;
            editorOptions.max = options.max || 255;
            editorOptions.step = options.step || 1
        }
        var editor = new editorType($editor, editorOptions);
        editor.registerKeyHandler("enter", function(e) {
            this._fireEnterKeyPressed(e)
        }.bind(this));
        this.setAria("label", options.labelAriaText, $editor);
        return $label
    },
    hexInputOptions: function() {
        return {
            editorType: TextBox,
            value: this._currentColor.toHex().replace("#", ""),
            onValueChanged: this._updateColor.bind(this, true),
            labelClass: COLOR_VIEW_HEX_LABEL_CLASS,
            labelText: "#",
            labelAriaText: messageLocalization.format("dxColorView-ariaHex")
        }
    },
    _renderHexInput: function() {
        this._hexInput = TextBox.getInstance(this._renderEditorWithLabel(this.hexInputOptions()).appendTo(this._$controlsContainer).find(".dx-textbox"))
    },
    _renderAlphaChannelScale: function() {
        var $alphaChannelScaleCell = this._renderHtmlCellInsideRow(1, this._$colorPickerContainer, COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS),
            $alphaChannelBorder = $("<div>", {
                "class": COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS,
                appendTo: $alphaChannelScaleCell
            }),
            $alphaChannelScaleWrapper = $("<div>", {
                "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS,
                appendTo: $alphaChannelBorder
            });
        this._$alphaChannelScale = $("<div>", {
            "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS,
            appendTo: $alphaChannelScaleWrapper
        });
        this._makeCSSLinearGradient(this._$alphaChannelScale);
        this._renderAlphaChannelHandle($alphaChannelScaleCell)
    },
    _makeCSSLinearGradient: function($el) {
        var color = this._currentColor,
            colorAsRgb = [color.r, color.g, color.b].join(","),
            colorAsHex = color.toHex().replace("#", "");
        var combineGradientString = function(colorAsRgb, colorAsHex) {
            var rtlEnabled = this.option("rtlEnabled"),
                startColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "1" : "0") + ")",
                finishColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "0" : "1") + ")",
                startColorIE = "'#" + (rtlEnabled ? "00" : "") + colorAsHex + "'",
                finishColorIE = "'#" + (rtlEnabled ? "" : "00") + colorAsHex + "'";
            return ["background-image: -webkit-linear-gradient(180deg, " + startColor + ", " + finishColor + ")", "background-image: -moz-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -ms-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -o-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=" + startColorIE + ", endColorstr=" + finishColorIE + ")"].join(";")
        };
        $el.attr("style", combineGradientString.call(this, colorAsRgb, colorAsHex))
    },
    _renderAlphaChannelInput: function() {
        var that = this,
            $alphaChannelInputCell = this._renderHtmlCellInsideRow(1, this._$colorPickerContainer);
        that._alphaChannelInput = this._renderEditorWithLabel({
            editorType: NumberBox,
            value: this._currentColor.a,
            max: 1,
            step: .1,
            onValueChanged: function(e) {
                var value = e.value;
                value = that._currentColor.isValidAlpha(value) ? value : that._currentColor.a;
                that._updateColorTransparency(value);
                that._placeAlphaChannelHandle()
            },
            labelClass: COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS,
            labelText: "Alpha",
            labelAriaText: messageLocalization.format("dxColorView-ariaAlpha")
        }).appendTo($alphaChannelInputCell).find(".dx-numberbox").dxNumberBox("instance")
    },
    _updateColorTransparency: function(transparency) {
        this._currentColor.a = transparency;
        this._makeTransparentBackground(this._$newColor, this._currentColor);
        this.applyColor()
    },
    _renderAlphaChannelHandle: function($parent) {
        this._createComponent(this._$alphaChannelHandle = $("<div>", {
            "class": COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS,
            appendTo: $parent
        }), Draggable, {
            area: $parent,
            allowMoveByClick: true,
            direction: "horizontal",
            onDrag: function() {
                this._updateByDrag = true;
                var $alphaChannelHandle = this._$alphaChannelHandle,
                    alphaChannelHandlePosition = translator.locate($alphaChannelHandle).left + this._alphaChannelHandleWidth / 2;
                this._calculateColorTransparencyByScaleWidth(alphaChannelHandlePosition)
            }.bind(this)
        });
        this._alphaChannelHandleWidth = this._$alphaChannelHandle.width();
        this._alphaChannelScaleWorkWidth = $parent.width() - this._alphaChannelHandleWidth;
        this._placeAlphaChannelHandle()
    },
    _calculateColorTransparencyByScaleWidth: function(handlePosition) {
        var transparency = (handlePosition - this._alphaChannelHandleWidth / 2) / this._alphaChannelScaleWorkWidth,
            rtlEnabled = this.option("rtlEnabled");
        transparency = rtlEnabled ? transparency : 1 - transparency;
        if (handlePosition >= this._alphaChannelScaleWorkWidth + this._alphaChannelHandleWidth / 2) {
            transparency = rtlEnabled ? 1 : 0
        } else {
            if (transparency < 1) {
                transparency = transparency.toFixed(2)
            }
        }
        transparency = Math.max(transparency, 0);
        transparency = Math.min(transparency, 1);
        this._alphaChannelInput.option("value", transparency)
    },
    _placeAlphaChannelHandle: function() {
        var left = this._alphaChannelScaleWorkWidth * (1 - this._currentColor.a);
        if (left < 0) {
            left = 0
        }
        if (this._alphaChannelScaleWorkWidth < left) {
            left = this._alphaChannelScaleWorkWidth
        }
        translator.move(this._$alphaChannelHandle, {
            left: this.option("rtlEnabled") ? this._alphaChannelScaleWorkWidth - left : left
        })
    },
    applyColor: function() {
        var colorValue = this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this._currentColor.toHex();
        this._makeTransparentBackground(this._$currentColor, this._currentColor);
        this.option("value", colorValue)
    },
    cancelColor: function() {
        this._initColorAndOpacity();
        this._refreshMarkup()
    },
    _updateColor: function(isHex, e) {
        var rgba, newColor;
        if (isHex) {
            newColor = this._validateHex("#" + this._hexInput.option("value"))
        } else {
            rgba = this._validateRgb();
            if (this._alphaChannelInput) {
                rgba.push(this._alphaChannelInput.option("value"));
                newColor = "rgba(" + rgba.join(", ") + ")"
            } else {
                newColor = "rgb(" + rgba.join(", ") + ")"
            }
        }
        if (!this._suppressEditorsValueUpdating) {
            this._currentColor = new Color(newColor);
            this.applyColor();
            this._refreshMarkup()
        }
    },
    _validateHex: function(hex) {
        return this._currentColor.isValidHex(hex) ? hex : this._currentColor.toHex()
    },
    _validateRgb: function() {
        var r = this._rgbInputs[0].option("value"),
            g = this._rgbInputs[1].option("value"),
            b = this._rgbInputs[2].option("value");
        if (!this._currentColor.isValidRGB(r, g, b)) {
            r = this._currentColor.r;
            g = this._currentColor.g;
            b = this._currentColor.b
        }
        return [r, g, b]
    },
    _refreshMarkup: function() {
        this._placeHueScaleHandle();
        this._placePaletteHandle();
        this._updateColorParamsAndColorPreview();
        this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex());
        if (this._$alphaChannelHandle) {
            this._updateColorTransparency(this._currentColor.a);
            this._placeAlphaChannelHandle()
        }
    },
    _updateColorParamsAndColorPreview: function() {
        this._suppressEditorsValueUpdating = true;
        this._hexInput.option("value", this._currentColor.toHex().replace("#", ""));
        this._rgbInputs[0].option("value", this._currentColor.r);
        this._rgbInputs[1].option("value", this._currentColor.g);
        this._rgbInputs[2].option("value", this._currentColor.b);
        this._suppressEditorsValueUpdating = false;
        this._makeTransparentBackground(this._$newColor, this._currentColor);
        if (this.option("editAlphaChannel")) {
            this._makeCSSLinearGradient.call(this, this._$alphaChannelScale);
            this._alphaChannelInput.option("value", this._currentColor.a)
        }
    },
    _optionChanged: function(args) {
        var value = args.value;
        switch (args.name) {
            case "value":
                this._setCurrentColor(value);
                if (!this._updateByDrag) {
                    this._refreshMarkup()
                }
                this._updateByDrag = false;
                this.callBase(args);
                break;
            case "onEnterKeyPressed":
                this._initEnterKeyPressedAction();
                break;
            case "editAlphaChannel":
                if (this._$colorPickerContainer) {
                    this._renderHtmlRows("editAlphaChannel");
                    this._renderAlphaChannelElements()
                }
                break;
            case "keyStep":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxColorView", ColorView);
module.exports = ColorView;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/number_box/number_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    mathUtils = __webpack_require__(56),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    TextEditor = __webpack_require__(192),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    wheelEvent = __webpack_require__(137),
    SpinButton = __webpack_require__(308),
    messageLocalization = __webpack_require__(8);
var math = Math;
var WIDGET_CLASS = "dx-numberbox",
    SPIN_CLASS = "dx-numberbox-spin",
    SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container",
    SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var FIREFOX_CONTROL_KEYS = ["Tab", "Del", "Delete", "Backspace", "Left", "ArrowLeft", "Right", "ArrowRight", "Home", "End", "Enter"];
var NumberBox = TextEditor.inherit({
    _supportedKeys: function() {
        return extend(this.callBase(), {
            upArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                this._spinUpChangeHandler(e)
            },
            downArrow: function(e) {
                e.preventDefault();
                e.stopPropagation();
                this._spinDownChangeHandler(e)
            },
            enter: function() {}
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: 0,
            min: void 0,
            max: void 0,
            step: 1,
            showSpinButtons: false,
            useLargeSpinButtons: true,
            mode: "text",
            invalidValueMessage: messageLocalization.format("dxNumberBox-invalidValueMessage")
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return devices.real().generic && !devices.isSimulator()
            },
            options: {
                useLargeSpinButtons: false
            }
        }, {
            device: function() {
                return "generic" !== devices.real().platform
            },
            options: {
                mode: "number"
            }
        }])
    },
    _render: function() {
        this._renderSubmitElement();
        this._setSubmitValue(this.option("value"));
        this.callBase();
        this.option("isValid") && this._validateValue(this.option("value"));
        this.element().addClass(WIDGET_CLASS);
        this.setAria("role", "spinbutton");
        this._renderMouseWheelHandler()
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _setSubmitValue: function(value) {
        this._$submitElement.val(commonUtils.applyServerDecimalSeparator(value))
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _keyPressHandler: function(e) {
        this.callBase(e);
        var ch = String.fromCharCode(e.which),
            validCharRegExp = /[\d.,eE\-+]/,
            isInputCharValid = validCharRegExp.test(ch);
        if (!isInputCharValid) {
            if (e.metaKey || e.ctrlKey || e.key && inArray(e.key, FIREFOX_CONTROL_KEYS) >= 0) {
                return
            }
            e.preventDefault();
            return false
        }
        this._keyPressed = true
    },
    _renderMouseWheelHandler: function() {
        var eventName = eventUtils.addNamespace(wheelEvent.name, this.NAME);
        var mouseWheelAction = this._createAction(function(e) {
            this._mouseWheelHandler(e.jQueryEvent)
        }.bind(this));
        this._input().off(eventName).on(eventName, function(e) {
            mouseWheelAction({
                jQueryEvent: e
            })
        })
    },
    _mouseWheelHandler: function(jQueryEvent) {
        if (!this._input().is(":focus")) {
            return
        }
        jQueryEvent.delta > 0 ? this._spinValueChange(1, jQueryEvent) : this._spinValueChange(-1, jQueryEvent);
        jQueryEvent.preventDefault();
        jQueryEvent.stopPropagation()
    },
    _renderValue: function() {
        var inputValue = this._input().val();
        if (!inputValue.length || Number(inputValue) !== this.option("value")) {
            this._forceValueRender();
            this._toggleEmptinessEventHandler()
        }
        var value = this.option("value");
        this._renderInputAddons();
        this.setAria("valuenow", value)
    },
    _renderValueEventName: function() {
        return this.callBase() + " keypress"
    },
    _toggleDisabledState: function(value) {
        if (this._$spinUp) {
            SpinButton.getInstance(this._$spinUp).option("disabled", value)
        }
        if (this._$spinDown) {
            SpinButton.getInstance(this._$spinDown).option("disabled", value)
        }
        this.callBase.apply(this, arguments)
    },
    _forceValueRender: function() {
        var value = this.option("value"),
            number = Number(value),
            valueFormat = this.option("valueFormat"),
            formattedValue = isNaN(number) ? "" : valueFormat(value);
        this._renderDisplayText(formattedValue)
    },
    _renderProps: function() {
        this.callBase();
        this._input().prop({
            min: this.option("min"),
            max: this.option("max"),
            step: this.option("step")
        });
        this.setAria({
            valuemin: this.option("min") || "undefined",
            valuemax: this.option("max") || "undefined"
        })
    },
    _renderInputAddons: function() {
        this.callBase();
        this._renderSpinButtons()
    },
    _renderSpinButtons: function() {
        var spinButtonsVisible = this.option("showSpinButtons");
        this.element().toggleClass(SPIN_CLASS, spinButtonsVisible);
        this._toggleTouchFriendlyClass();
        if (!spinButtonsVisible) {
            this._$spinContainer && this._$spinContainer.remove();
            this._$spinContainer = null;
            return
        }
        if (!this._$spinContainer) {
            this._$spinContainer = this._createSpinButtons()
        }
        this._$spinContainer.prependTo(this._buttonsContainer())
    },
    _toggleTouchFriendlyClass: function() {
        this.element().toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, this.option("showSpinButtons") && this.option("useLargeSpinButtons"))
    },
    _createSpinButtons: function() {
        var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
        var pointerDownAction = this._createAction(this._spinButtonsPointerDownHandler.bind(this));
        var $spinContainer = $("<div>").addClass(SPIN_CONTAINER_CLASS).off(eventName).on(eventName, function(e) {
            pointerDownAction({
                jQueryEvent: e
            })
        });
        this._$spinUp = $("<div>").appendTo($spinContainer);
        this._createComponent(this._$spinUp, SpinButton, {
            direction: "up",
            onChange: this._spinUpChangeHandler.bind(this)
        });
        this._$spinDown = $("<div>").appendTo($spinContainer);
        this._createComponent(this._$spinDown, SpinButton, {
            direction: "down",
            onChange: this._spinDownChangeHandler.bind(this)
        });
        return $spinContainer
    },
    _spinButtonsPointerDownHandler: function() {
        var $input = this._input();
        if (!this.option("useLargeSpinButtons") && document.activeElement !== $input[0]) {
            $input.trigger("focus")
        }
    },
    _spinUpChangeHandler: function(e) {
        if (!this.option("readOnly")) {
            this._spinValueChange(1, e.jQueryEvent || e)
        }
    },
    _spinDownChangeHandler: function(e) {
        if (!this.option("readOnly")) {
            this._spinValueChange(-1, e.jQueryEvent || e)
        }
    },
    _spinValueChange: function(sign, jQueryEvent) {
        var value = parseFloat(this._normalizeInputValue()) || 0,
            step = parseFloat(this.option("step"));
        value = this._correctRounding(value, step * sign);
        var min = this.option("min"),
            max = this.option("max");
        if (void 0 !== min) {
            value = Math.max(min, value)
        }
        if (void 0 !== max) {
            value = Math.min(max, value)
        }
        this._saveValueChangeEvent(jQueryEvent);
        this.option("value", value)
    },
    _correctRounding: function(value, step) {
        var regex = /[,.](.*)/;
        var isFloatValue = regex.test(value),
            isFloatStep = regex.test(step);
        if (isFloatValue || isFloatStep) {
            var valueAccuracy = isFloatValue ? regex.exec(value)[0].length : 0,
                stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0,
                accuracy = math.max(valueAccuracy, stepAccuracy);
            value = this._round(value + step, accuracy);
            return value
        }
        return value + step
    },
    _round: function(value, precision) {
        precision = precision || 0;
        var multiplier = Math.pow(10, precision);
        value *= multiplier;
        value = Math.round(value) / multiplier;
        return value
    },
    _renderValueChangeEvent: function() {
        this.callBase();
        this._input().focusout(this._forceRefreshInputValue.bind(this))
    },
    _forceRefreshInputValue: function() {
        if ("number" === this.option("mode")) {
            return
        }
        var $input = this._input(),
            valueFormat = this.option("valueFormat");
        $input.val(null);
        $input.val(valueFormat(this.option("value")))
    },
    _valueChangeEventHandler: function(e) {
        var $input = this._input(),
            inputValue = this._normalizeText(),
            valueFormat = this.option("valueFormat"),
            value = this._parseValue(inputValue),
            valueHasDigits = "." !== inputValue && "-" !== inputValue,
            isValueIncomplete = this._isValueIncomplete(inputValue),
            isValueCorrect = this._isValueInRange(inputValue);
        if (this._isValueValid() && !this._validateValue(value)) {
            $input.val(valueFormat(value));
            return
        }
        if (valueHasDigits) {
            this.callBase(e, isNaN(value) ? null : value)
        }
        if (!isValueIncomplete && !isValueCorrect && null !== value) {
            if (Number(inputValue) !== value) {
                $input.val(valueFormat(value))
            }
        }
        this.validationRequest.fire({
            value: value,
            editor: this
        })
    },
    _replaceCommaWithPoint: function(value) {
        return value.replace(",", ".")
    },
    _inputIsInvalid: function() {
        var isNumberMode = "number" === this.option("mode");
        var validityState = this._input().get(0).validity;
        return isNumberMode && validityState && validityState.badInput
    },
    _renderDisplayText: function(text) {
        if (this._inputIsInvalid()) {
            return
        }
        this.callBase(text)
    },
    _isValueIncomplete: function(value) {
        var incompleteRegex = /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i;
        return incompleteRegex.test(value)
    },
    _isValueInRange: function(value) {
        return mathUtils.inRange(value, this.option("min"), this.option("max"))
    },
    _isNumber: function(value) {
        return null !== this._parseValue(value)
    },
    _validateValue: function(value) {
        var inputValue = this._normalizeText(),
            isValueValid = this._isValueValid(),
            isValid = true,
            isNumber = this._isNumber(inputValue);
        if (isNaN(Number(value))) {
            isValid = false
        }
        if (!value && isValueValid) {
            isValid = true
        } else {
            if (!isNumber && !isValueValid) {
                isValid = false
            }
        }
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: this.option("invalidValueMessage")
            }
        });
        return isValid
    },
    _normalizeInputValue: function() {
        return this._normalizeValue()
    },
    _normalizeValue: function(value) {
        return this._parseValue(this._normalizeText(value))
    },
    _normalizeText: function(value) {
        value = $.trim(commonUtils.isDefined(value) ? value : this._input().val());
        return this._replaceCommaWithPoint(value)
    },
    _parseValue: function(value) {
        var number = parseFloat(value);
        if (isNaN(number)) {
            return null
        }
        return mathUtils.fitIntoRange(number, this.option("min"), this.option("max"))
    },
    _clean: function() {
        delete this._$spinContainer;
        delete this._$spinUp;
        delete this._$spinDown;
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "value":
                this._validateValue(args.value);
                this._setSubmitValue(args.value);
                this.callBase(args);
                this._resumeValueChangeAction();
                break;
            case "step":
            case "min":
            case "max":
                this._renderProps();
                break;
            case "showSpinButtons":
                this._renderInputAddons();
                break;
            case "useLargeSpinButtons":
                this._toggleTouchFriendlyClass();
                break;
            case "invalidValueMessage":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxNumberBox", NumberBox);
module.exports = NumberBox;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/number_box/number_box.spin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Widget = __webpack_require__(27),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    feedbackEvents = __webpack_require__(75),
    holdEvent = __webpack_require__(66);
var SPIN_CLASS = "dx-numberbox-spin",
    SPIN_BUTTON_CLASS = "dx-numberbox-spin-button",
    SPIN_HOLD_DELAY = 100,
    NUMBER_BOX = "dxNumberBox",
    POINTERUP_EVENT_NAME = eventUtils.addNamespace(pointerEvents.up, NUMBER_BOX),
    POINTERCANCEL_EVENT_NAME = eventUtils.addNamespace(pointerEvents.cancel, NUMBER_BOX);
var SpinButton = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            direction: "up",
            onChange: null,
            activeStateEnabled: true,
            hoverStateEnabled: true
        })
    },
    _render: function() {
        this.callBase();
        var $element = this.element(),
            direction = SPIN_CLASS + "-" + this.option("direction");
        var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
        $element.addClass(SPIN_BUTTON_CLASS).addClass(direction).off(eventName).on(eventName, this._spinDownHandler.bind(this));
        this._spinIcon = $("<div>").addClass(direction + "-icon").appendTo(this.element());
        this._spinChangeHandler = this._createActionByOption("onChange")
    },
    _spinDownHandler: function(e) {
        e.preventDefault();
        this._clearTimer();
        this.element().on(holdEvent.name, function() {
            this._feedBackDeferred = $.Deferred();
            feedbackEvents.lock(this._feedBackDeferred);
            this._spinChangeHandler({
                jQueryEvent: e
            });
            this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {
                jQueryEvent: e
            })
        }.bind(this));
        $(document).on(POINTERUP_EVENT_NAME, this._clearTimer.bind(this)).on(POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
        this._spinChangeHandler({
            jQueryEvent: e
        })
    },
    _dispose: function() {
        this._clearTimer();
        this.callBase()
    },
    _clearTimer: function() {
        this.element().off(holdEvent.name);
        $(document).off(POINTERUP_EVENT_NAME).off(POINTERCANCEL_EVENT_NAME);
        if (this._feedBackDeferred) {
            this._feedBackDeferred.resolve()
        }
        if (this._holdTimer) {
            clearInterval(this._holdTimer)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onChange":
            case "direction":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
module.exports = SpinButton;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/draggable.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    stringUtils = __webpack_require__(30),
    registerComponent = __webpack_require__(4),
    translator = __webpack_require__(19),
    dasherize = __webpack_require__(36).dasherize,
    extend = __webpack_require__(1).extend,
    DOMComponent = __webpack_require__(45),
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    dragEvents = __webpack_require__(76),
    positionUtils = __webpack_require__(46),
    isFunction = commonUtils.isFunction,
    noop = commonUtils.noop;
var DRAGGABLE = "dxDraggable",
    DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, DRAGGABLE),
    DRAG_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, DRAGGABLE),
    DRAGEND_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, DRAGGABLE),
    POINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, DRAGGABLE),
    DRAGGABLE_CLASS = dasherize(DRAGGABLE),
    DRAGGABLE_DRAGGING_CLASS = DRAGGABLE_CLASS + "-dragging";
var Draggable = DOMComponent.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            onDragStart: noop,
            onDrag: noop,
            onDragEnd: noop,
            immediate: true,
            direction: "both",
            area: window,
            boundOffset: 0,
            allowMoveByClick: false
        })
    },
    _init: function() {
        this.callBase();
        this._attachEventHandlers()
    },
    _attachEventHandlers: function() {
        if (this.option("disabled")) {
            return
        }
        var $element = this.element().css("position", "absolute"),
            eventHandlers = {},
            allowMoveByClick = this.option("allowMoveByClick");
        eventHandlers[DRAGSTART_EVENT_NAME] = this._dragStartHandler.bind(this);
        eventHandlers[DRAG_EVENT_NAME] = this._dragHandler.bind(this);
        eventHandlers[DRAGEND_EVENT_NAME] = this._dragEndHandler.bind(this);
        if (allowMoveByClick) {
            eventHandlers[POINTERDOWN_EVENT_NAME] = this._pointerDownHandler.bind(this);
            $element = this._getArea()
        }
        $element.on(eventHandlers, {
            direction: this.option("direction"),
            immediate: this.option("immediate")
        })
    },
    _detachEventHandlers: function() {
        this.element().off("." + DRAGGABLE);
        this._getArea().off("." + DRAGGABLE)
    },
    _move: function(position) {
        translator.move(this.element(), position)
    },
    _pointerDownHandler: function(e) {
        if (eventUtils.needSkipEvent(e)) {
            return
        }
        var areaOffset = this._getAreaOffset($(e.currentTarget)),
            direction = this.option("direction"),
            position = {};
        if ("horizontal" === direction || "both" === direction) {
            position.left = e.pageX - this.element().width() / 2 - areaOffset.left
        }
        if ("vertical" === direction || "both" === direction) {
            position.top = e.pageY - this.element().height() / 2 - areaOffset.top
        }
        this._move(position);
        this._getAction("onDrag")({
            jQueryEvent: e
        })
    },
    _dragStartHandler: function(e) {
        var $element = this.element();
        if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        var $area = this._getArea(),
            areaOffset = this._getAreaOffset($area),
            boundOffset = this._getBoundOffset(),
            areaWidth = $area.outerWidth(),
            areaHeight = $area.outerHeight(),
            elementWidth = $element.width(),
            elementHeight = $element.height();
        this._toggleDraggingClass(true);
        var startOffset = {
            left: $element.offset().left - areaOffset.left,
            top: $element.offset().top - areaOffset.top
        };
        this._startPosition = translator.locate($element);
        e.maxLeftOffset = startOffset.left - boundOffset.left;
        e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
        e.maxTopOffset = startOffset.top - boundOffset.top;
        e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;
        this._getAction("onDragStart")({
            jQueryEvent: e
        })
    },
    _getAreaOffset: function($area) {
        var offset = $area && positionUtils.offset($area);
        return offset ? offset : {
            left: 0,
            top: 0
        }
    },
    _toggleDraggingClass: function(value) {
        this.element().toggleClass(DRAGGABLE_DRAGGING_CLASS, value)
    },
    _getBoundOffset: function() {
        var boundOffset = this.option("boundOffset");
        if (isFunction(boundOffset)) {
            boundOffset = boundOffset.call(this)
        }
        return stringUtils.quadToObject(boundOffset)
    },
    _getArea: function() {
        var area = this.option("area");
        if (isFunction(area)) {
            area = area.call(this)
        }
        return $(area)
    },
    _dragHandler: function(e) {
        var offset = e.offset,
            startPosition = this._startPosition;
        this._move({
            left: startPosition.left + offset.x,
            top: startPosition.top + offset.y
        });
        this._getAction("onDrag")({
            jQueryEvent: e
        })
    },
    _dragEndHandler: function(e) {
        this._toggleDraggingClass(false);
        this._getAction("onDragEnd")({
            jQueryEvent: e
        })
    },
    _getAction: function(name) {
        return this["_" + name + "Action"] || this._createActionByOption(name)
    },
    _render: function() {
        this.callBase();
        this.element().addClass(DRAGGABLE_CLASS)
    },
    _optionChanged: function(args) {
        var name = args.name;
        switch (name) {
            case "onDragStart":
            case "onDrag":
            case "onDragEnd":
                this["_" + name + "Action"] = this._createActionByOption(name);
                break;
            case "allowMoveByClick":
            case "direction":
            case "disabled":
                this._detachEventHandlers();
                this._attachEventHandlers();
                break;
            case "boundOffset":
            case "area":
                break;
            default:
                this.callBase(args)
        }
    },
    _dispose: function() {
        this.callBase();
        this._detachEventHandlers()
    }
});
registerComponent(DRAGGABLE, Draggable);
module.exports = Draggable;


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    compareVersions = __webpack_require__(37).compare,
    extend = __webpack_require__(1).extend,
    support = __webpack_require__(24),
    devices = __webpack_require__(6),
    config = __webpack_require__(31),
    dateUtils = __webpack_require__(55),
    uiDateUtils = __webpack_require__(100),
    dateSerialization = __webpack_require__(71),
    DropDownEditor = __webpack_require__(123),
    dateLocalization = __webpack_require__(32),
    messageLocalization = __webpack_require__(8),
    DATEBOX_CLASS = "dx-datebox",
    DX_AUTO_WIDTH_CLASS = "dx-auto-width",
    DATEBOX_WRAPPER_CLASS = "dx-datebox-wrapper";
var PICKER_TYPE = {
    calendar: "calendar",
    rollers: "rollers",
    list: "list",
    "native": "native"
};
var TYPE = {
    date: "date",
    datetime: "datetime",
    time: "time"
};
var STRATEGY_NAME = {
    calendar: "Calendar",
    dateView: "DateView",
    "native": "Native",
    calendarWithTime: "CalendarWithTime",
    list: "List"
};
var STRATEGY_CLASSES = {
    Calendar: __webpack_require__(201),
    DateView: __webpack_require__(316),
    Native: __webpack_require__(319),
    CalendarWithTime: __webpack_require__(320),
    List: __webpack_require__(322)
};
var isRealWidthSet = function($element) {
    var explicitWidth = $element[0].style.width;
    if (explicitWidth && "auto" !== explicitWidth && "inherit" !== explicitWidth) {
        return true
    }
    return false
};
var calculateWidth = function(value, $input, $element) {
    var IE_ROUNDING_ERROR = 10;
    var NATIVE_BUTTONS_WIDTH = 48;
    var $longestValueElement = $("<div>").text(value).css({
        "font-style": $input.css("font-style"),
        "font-variant": $input.css("font-variant"),
        "font-weight": $input.css("font-weight"),
        "font-size": $input.css("font-size"),
        "font-family": $input.css("font-family"),
        "letter-spacing": $input.css("letter-spacing"),
        "padding-left": $input.css("padding-left"),
        "padding-right": $input.css("padding-right"),
        border: $input.css("border"),
        visibility: "hidden",
        "white-space": "nowrap",
        position: "absolute",
        "float": "left"
    });
    $longestValueElement.appendTo($element);
    var width = $longestValueElement.outerWidth() + IE_ROUNDING_ERROR + ("text" !== $input.prop("type") ? NATIVE_BUTTONS_WIDTH : 0);
    $longestValueElement.remove();
    return width
};
var DateBox = DropDownEditor.inherit({
    _supportedKeys: function() {
        return extend(this.callBase(), this._strategy.supportedKeys())
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            format: {
                since: "16.1",
                alias: "type"
            },
            formatString: {
                since: "16.1",
                alias: "displayFormat"
            },
            useNative: {
                since: "15.1",
                message: "'useNative' option is deprecated in 15.1. Use the 'pickerType' option instead"
            },
            useCalendar: {
                since: "15.1",
                message: "'useCalendar' option is deprecated in 15.1. Use the 'pickerType' option instead"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            type: "date",
            value: null,
            dateSerializationFormat: void 0,
            min: void 0,
            max: void 0,
            useCalendar: false,
            displayFormat: null,
            interval: 30,
            maxZoomLevel: "month",
            minZoomLevel: "century",
            useNative: true,
            pickerType: PICKER_TYPE.native,
            invalidDateMessage: messageLocalization.format("dxDateBox-validation-datetime"),
            dateOutOfRangeMessage: messageLocalization.format("validation-range"),
            applyButtonText: messageLocalization.format("Done"),
            adaptivityEnabled: false,
            onContentReady: null
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                showPopupTitle: true
            }
        }, {
            device: function(device) {
                return "android" === device.platform
            },
            options: {
                buttonsLocation: "bottom after"
            }
        }, {
            device: function(device) {
                return "win" === device.platform && device.version && 8 === device.version[0]
            },
            options: {
                buttonsLocation: "bottom after"
            }
        }, {
            device: function(device) {
                return "win" === device.platform && device.version && 10 === device.version[0]
            },
            options: {
                buttonsLocation: "bottom center"
            }
        }, {
            device: function() {
                var realDevice = devices.real(),
                    platform = realDevice.platform,
                    version = realDevice.version;
                return "generic" === platform || "win" === platform || "android" === platform && compareVersions(version, [4, 4]) < 0
            },
            options: {
                pickerType: PICKER_TYPE.rollers
            }
        }, {
            device: {
                platform: "generic",
                deviceType: "desktop"
            },
            options: {
                pickerType: PICKER_TYPE.calendar,
                buttonsLocation: "bottom after"
            }
        }, {
            device: function() {
                var realDevice = devices.real(),
                    platform = realDevice.platform,
                    isPhone = realDevice.phone;
                return "win" === platform && !isPhone
            },
            options: {
                pickerType: PICKER_TYPE.calendar
            }
        }])
    },
    _initOptions: function(options) {
        this._userOptions = extend({}, options);
        this.callBase(options);
        this._updatePickerOptions(this._userOptions)
    },
    _updatePickerOptions: function(userOptions) {
        var pickerType = this._getPickerTypeByDeprecatedOptions(userOptions);
        var type = this.option("type");
        if (pickerType === PICKER_TYPE.list && (type === TYPE.datetime || type === TYPE.date)) {
            pickerType = PICKER_TYPE.calendar
        }
        if (type === TYPE.time && pickerType === PICKER_TYPE.calendar) {
            pickerType = PICKER_TYPE.list
        }
        this.option("showDropDownButton", "generic" !== devices.real().platform || pickerType !== PICKER_TYPE.native);
        this._pickerType = pickerType
    },
    _getPickerTypeByDeprecatedOptions: function(userOptions) {
        return userOptions.pickerType ? userOptions.pickerType : commonUtils.isDefined(userOptions.useCalendar) || commonUtils.isDefined(userOptions.useNative) ? this._getPickerType() : this._pickerType || this.option("pickerType")
    },
    _getPickerType: function() {
        if (this.option().useCalendar) {
            return this.option("type") === TYPE.time ? PICKER_TYPE.list : PICKER_TYPE.calendar
        }
        if (this.option().useNative) {
            return PICKER_TYPE.native
        }
        return PICKER_TYPE.rollers
    },
    _init: function() {
        this._initStrategy();
        this.option(extend({}, this._strategy.getDefaultOptions(), this._userOptions));
        delete this._userOptions;
        this.callBase()
    },
    _toLowerCaseFirstLetter: function(string) {
        return string.charAt(0).toLowerCase() + string.substr(1)
    },
    _initStrategy: function() {
        var strategyName = this._getStrategyName(this._getFormatType()),
            strategy = STRATEGY_CLASSES[strategyName];
        if (!(this._strategy && this._strategy.NAME === strategyName)) {
            this._strategy = new strategy(this)
        }
    },
    _getFormatType: function() {
        var currentType = this.option("type");
        var isTime = /h|m|s/g.test(currentType),
            isDate = /d|M|Y/g.test(currentType);
        var type = "";
        if (isDate) {
            type += TYPE.date
        }
        if (isTime) {
            type += TYPE.time
        }
        return type
    },
    _getStrategyName: function(type) {
        var pickerType = this._pickerType;
        if (pickerType === PICKER_TYPE.rollers) {
            return this.option().useCalendar ? STRATEGY_NAME.calendar : STRATEGY_NAME.dateView
        }
        if (pickerType === PICKER_TYPE.native) {
            return STRATEGY_NAME.native
        }
        if (type === TYPE.date) {
            return STRATEGY_NAME.calendar
        }
        if (type === TYPE.datetime) {
            return STRATEGY_NAME.calendarWithTime
        }
        return STRATEGY_NAME.list
    },
    _render: function() {
        this.element().addClass(DATEBOX_CLASS);
        this._refreshFormatClass();
        this._refreshPickerTypeClass();
        this._renderSubmitElement();
        this.callBase();
        this._updateSize();
        this._strategy.renderInputMinMax(this._input())
    },
    _renderDimensions: function() {
        this.callBase();
        this.element().toggleClass(DX_AUTO_WIDTH_CLASS, !this.option("width"))
    },
    _refreshFormatClass: function() {
        var $element = this.element();
        $.each(TYPE, function(_, item) {
            $element.removeClass(DATEBOX_CLASS + "-" + item)
        });
        $element.addClass(DATEBOX_CLASS + "-" + this.option("type"))
    },
    _refreshPickerTypeClass: function() {
        var $element = this.element();
        $.each(PICKER_TYPE, function(_, item) {
            $element.removeClass(DATEBOX_CLASS + "-" + item)
        });
        $element.addClass(DATEBOX_CLASS + "-" + this._pickerType)
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _updateSize: function() {
        var $element = this.element(),
            widthOption = this.option("width"),
            isWidthSet = commonUtils.isDefined(widthOption) || isRealWidthSet($element) && !this._isSizeUpdatable,
            isElementVisible = $element.is(":visible"),
            pickerType = this._pickerType,
            shouldCalculateWidth = pickerType !== PICKER_TYPE.rollers && "generic" === devices.current().platform;
        if (isWidthSet || !(shouldCalculateWidth && isElementVisible)) {
            return
        }
        var $input = this._input(),
            format = this._strategy.getDisplayFormat(this.option("displayFormat")),
            longestValue = dateLocalization.format(uiDateUtils.getLongestDate(format, dateLocalization.getMonthNames(), dateLocalization.getDayNames()), format);
        $element.width(calculateWidth(longestValue, $input, this.element()));
        this._isSizeUpdatable = true
    },
    _attachChildKeyboardEvents: function() {
        this._strategy.attachKeyboardEvents(this._keyboardProcessor)
    },
    _renderPopup: function() {
        this.callBase();
        this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS);
        this._renderPopupWrapper()
    },
    _popupConfig: function() {
        var popupConfig = this.callBase();
        return extend(this._strategy.popupConfig(popupConfig), {
            title: this._getPopupTitle(),
            dragEnabled: false
        })
    },
    _renderPopupWrapper: function() {
        if (!this._popup) {
            return
        }
        var $element = this.element();
        var classPostfixes = extend({}, TYPE, PICKER_TYPE);
        $.each(classPostfixes, function(_, item) {
            $element.removeClass(DATEBOX_WRAPPER_CLASS + "-" + item)
        }.bind(this));
        this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS + "-" + this.option("type")).addClass(DATEBOX_WRAPPER_CLASS + "-" + this._pickerType)
    },
    _renderPopupContent: function() {
        this.callBase();
        this._strategy.renderPopupContent()
    },
    _getFirstPopupElement: function() {
        return this._strategy.getFirstPopupElement() || this.callBase()
    },
    _getLastPopupElement: function() {
        return this._strategy.getLastPopupElement() || this.callBase()
    },
    _popupShowingHandler: function() {
        this.callBase();
        this._strategy.popupShowingHandler()
    },
    _popupHiddenHandler: function() {
        this.callBase();
        this._strategy.popupHiddenHandler()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateSize()
        }
    },
    _readOnlyPropValue: function() {
        return this.callBase() || this._pickerType === PICKER_TYPE.rollers
    },
    _clearButtonVisibility: function() {
        return this.callBase() && !this._isNativeType()
    },
    _renderValue: function() {
        var value = this.dateOption("value"),
            dateSerializationFormat = this.option("dateSerializationFormat");
        this.option("text", this._getDisplayedText(value));
        var submitFormat = uiDateUtils.SUBMIT_FORMATS_MAP[this.option("type")];
        var submitValue = dateSerializationFormat ? dateSerialization.serializeDate(value, dateSerializationFormat) : uiDateUtils.toStandardDateFormat(value, submitFormat);
        this._$submitElement.val(submitValue);
        this._strategy.renderValue();
        this.callBase()
    },
    _getDisplayedText: function(value) {
        var displayedText, mode = this.option("mode");
        if ("text" === mode) {
            var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
            displayedText = dateLocalization.format(value, displayFormat)
        } else {
            var format = this._getFormatByMode(mode);
            if (format) {
                displayedText = dateLocalization.format(value, format)
            } else {
                displayedText = uiDateUtils.toStandardDateFormat(value, mode)
            }
        }
        return displayedText
    },
    _getFormatByMode: function(mode) {
        return support.inputType(mode) ? null : uiDateUtils.FORMATS_MAP[mode]
    },
    _valueChangeEventHandler: function(e) {
        var text = this.option("text"),
            parsedDate = this._getParsedDate(text),
            value = this.dateOption("value") || this._getDateByDefault(),
            type = this.option("type"),
            newValue = uiDateUtils.mergeDates(value, parsedDate, type),
            date = parsedDate && "time" === type ? newValue : parsedDate;
        if (this._validateValue(date)) {
            var displayedText = this._getDisplayedText(newValue);
            if (value && newValue && value.getTime() === newValue.getTime() && displayedText !== text) {
                this._renderValue()
            } else {
                this.dateValue(newValue, e)
            }
        }
        this.validationRequest.fire({
            value: newValue,
            editor: this
        })
    },
    _getDateByDefault: function() {
        return this._strategy.useCurrentDateByDefault() && new Date
    },
    _getParsedDate: function(text) {
        var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var parsedText = this._strategy.getParsedText(text, displayFormat);
        return commonUtils.isDefined(parsedText) ? parsedText : void 0
    },
    _validateValue: function(value) {
        var text = this.option("text"),
            hasText = !!text && null !== value,
            isDate = !!value && commonUtils.isDate(value) && !isNaN(value.getTime()),
            isDateInRange = isDate && dateUtils.dateInRange(value, this.dateOption("min"), this.dateOption("max"), this.option("type")),
            isValid = !hasText || !hasText && !value || isDateInRange,
            validationMessage = "";
        if (!isDate) {
            validationMessage = this.option("invalidDateMessage")
        } else {
            if (!isDateInRange) {
                validationMessage = this.option("dateOutOfRangeMessage")
            }
        }
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: validationMessage
            }
        });
        return isValid
    },
    _isValueChanged: function(newValue) {
        var oldValue = this.dateOption("value"),
            oldTime = oldValue && oldValue.getTime(),
            newTime = newValue && newValue.getTime();
        return oldTime !== newTime
    },
    _renderProps: function() {
        this.callBase();
        this._input().attr("autocomplete", "off")
    },
    _renderOpenedState: function() {
        if (!this._isNativeType()) {
            this.callBase()
        }
        if (this._strategy.isAdaptivityChanged()) {
            this._refreshStrategy()
        }
        this._strategy.renderOpenedState()
    },
    _getPopupTitle: function() {
        var placeholder = this.option("placeholder");
        if (placeholder) {
            return placeholder
        }
        var type = this.option("type");
        if (type === TYPE.time) {
            return messageLocalization.format("dxDateBox-simulatedDataPickerTitleTime")
        }
        if (type === TYPE.date || type === TYPE.datetime) {
            return messageLocalization.format("dxDateBox-simulatedDataPickerTitleDate")
        }
        return ""
    },
    _renderPlaceholder: function() {
        this._popup && this._popup.option("title", this._getPopupTitle());
        this.callBase()
    },
    _refreshStrategy: function() {
        this._strategy.dispose();
        this._initStrategy();
        this.option(this._strategy.getDefaultOptions());
        this._refresh()
    },
    _applyButtonHandler: function() {
        this.dateValue(this._strategy.getValue());
        this.callBase()
    },
    _dispose: function() {
        this._strategy && this._strategy.dispose();
        this.callBase()
    },
    _isNativeType: function() {
        return this._pickerType === PICKER_TYPE.native
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useCalendar":
                this._updatePickerOptions({
                    useCalendar: args.value
                });
                this._refreshStrategy();
                break;
            case "useNative":
                this._updatePickerOptions({
                    useNative: args.value
                });
                this._refreshStrategy();
                break;
            case "showClearButton":
                this.callBase.apply(this, arguments);
                this._updateSize();
                break;
            case "pickerType":
                this._updatePickerOptions({
                    pickerType: args.value
                });
                this._refreshStrategy();
                this._refreshPickerTypeClass();
                this._invalidate();
                break;
            case "type":
                this._updatePickerOptions({
                    format: args.value
                });
                this._refreshStrategy();
                this._refreshFormatClass();
                this._renderPopupWrapper();
                this._updateSize();
                break;
            case "placeholder":
                this._renderPlaceholder();
                break;
            case "min":
            case "max":
                this._validateValue(this.dateOption("value"));
                this._invalidate();
                break;
            case "dateSerializationFormat":
            case "readOnly":
            case "interval":
            case "minZoomLevel":
            case "maxZoomLevel":
                this._invalidate();
                break;
            case "displayFormat":
                this._updateValue();
                break;
            case "formatWidthCalculator":
                break;
            case "closeOnValueChange":
                var applyValueMode = args.value ? "instantly" : "useButtons";
                this.option("applyValueMode", applyValueMode);
                break;
            case "applyValueMode":
                this._suppressDeprecatedWarnings();
                this.option("closeOnValueChange", "instantly" === args.value);
                this._resumeDeprecatedWarnings();
                this.callBase.apply(this, arguments);
                break;
            case "text":
                this._strategy.textChangedHandler(args.value);
                this.callBase.apply(this, arguments);
                break;
            case "isValid":
                this.callBase.apply(this, arguments);
                this._updateSize();
                break;
            case "value":
                this._validateValue(this.dateOption("value"));
                this.callBase.apply(this, arguments);
                break;
            case "showDropDownButton":
            case "invalidDateMessage":
            case "dateOutOfRangeMessage":
            case "adaptivityEnabled":
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    _getSerializationFormat: function() {
        var value = this.option("value");
        if (this.option("dateSerializationFormat") && config().forceIsoDateParsing) {
            return this.option("dateSerializationFormat")
        }
        if (commonUtils.isNumeric(value)) {
            return "number"
        }
        if (!commonUtils.isString(value)) {
            return
        }
        return dateSerialization.getDateSerializationFormat(value)
    },
    dateValue: function(value, jQueryEvent) {
        if (this._isValueChanged(value) && jQueryEvent) {
            this._saveValueChangeEvent(jQueryEvent)
        }
        return this.dateOption("value", value)
    },
    dateOption: function(optionName, value) {
        if (1 === arguments.length) {
            return dateSerialization.deserializeDate(this.option(optionName))
        }
        var serializationFormat = this._getSerializationFormat();
        this.option(optionName, dateSerialization.serializeDate(value, serializationFormat))
    },
    reset: function() {
        this.callBase();
        this._updateValue()
    }
});
registerComponent("dxDateBox", DateBox);
module.exports = DateBox;


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/calendar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(312);
module.exports.default = module.exports;


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/calendar/ui.calendar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    Button = __webpack_require__(25),
    Editor = __webpack_require__(33),
    Swipeable = __webpack_require__(126),
    Navigator = __webpack_require__(313),
    Views = __webpack_require__(314),
    translator = __webpack_require__(19),
    browser = __webpack_require__(21),
    dateUtils = __webpack_require__(55),
    dateSerialization = __webpack_require__(71),
    devices = __webpack_require__(6),
    config = __webpack_require__(31),
    fx = __webpack_require__(22),
    messageLocalization = __webpack_require__(8),
    FunctionTemplate = __webpack_require__(91);
var CALENDAR_CLASS = "dx-calendar",
    CALENDAR_BODY_CLASS = "dx-calendar-body",
    CALENDAR_CELL_CLASS = "dx-calendar-cell",
    CALENDAR_FOOTER_CLASS = "dx-calendar-footer",
    CALENDAR_TODAY_BUTTON_CLASS = "dx-calendar-today-button",
    CALENDAR_HAS_FOOTER_CLASS = "dx-calendar-with-footer",
    CALENDAR_VIEWS_WRAPPER_CLASS = "dx-calendar-views-wrapper",
    CALENDAR_VIEW_CLASS = "dx-calendar-view",
    FOCUSED_STATE_CLASS = "dx-state-focused",
    ANIMATION_DURATION_SHOW_VIEW = 250,
    POP_ANIMATION_FROM = .6,
    POP_ANIMATION_TO = 1,
    CALENDAR_INPUT_STANDARD_PATTERN = "yyyy-MM-dd",
    CALENDAR_DATE_VALUE_KEY = "dxDateValueKey",
    LEVEL_COMPARE_MAP = {
        month: 3,
        year: 2,
        decade: 1,
        century: 0
    };
var Calendar = Editor.inherit({
    _activeStateUnit: "." + CALENDAR_CELL_CLASS,
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            currentDate: new Date,
            value: null,
            dateSerializationFormat: void 0,
            min: new Date(1e3, 0),
            max: new Date(3e3, 0),
            firstDayOfWeek: void 0,
            zoomLevel: "month",
            maxZoomLevel: "month",
            minZoomLevel: "century",
            showTodayButton: false,
            cellTemplate: "cell",
            onCellClick: null,
            onContouredChanged: null,
            hasFocus: function(element) {
                return element.hasClass(FOCUSED_STATE_CLASS)
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _supportedKeys: function() {
        return extend(this.callBase(), {
            rightArrow: function(e) {
                e.preventDefault();
                if (e.ctrlKey) {
                    this._waitRenderView(1)
                } else {
                    this._moveCurrentDate(1 * this._getRtlCorrection())
                }
            },
            leftArrow: function(e) {
                e.preventDefault();
                if (e.ctrlKey) {
                    this._waitRenderView(-1)
                } else {
                    this._moveCurrentDate(-1 * this._getRtlCorrection())
                }
            },
            upArrow: function(e) {
                e.preventDefault();
                if (e.ctrlKey) {
                    this._navigateUp()
                } else {
                    if (fx.isAnimating(this._view.element())) {
                        return
                    }
                    this._moveCurrentDate(-1 * this._view.option("colCount"))
                }
            },
            downArrow: function(e) {
                e.preventDefault();
                if (e.ctrlKey) {
                    this._navigateDown()
                } else {
                    if (fx.isAnimating(this._view.element())) {
                        return
                    }
                    this._moveCurrentDate(1 * this._view.option("colCount"))
                }
            },
            home: function(e) {
                e.preventDefault();
                var zoomLevel = this.option("zoomLevel");
                var currentDate = this.option("currentDate");
                var min = this._dateOption("min");
                var date = dateUtils.sameView(zoomLevel, currentDate, min) ? min : dateUtils.getViewFirstCellDate(zoomLevel, currentDate);
                this.option("currentDate", date)
            },
            end: function(e) {
                e.preventDefault();
                var zoomLevel = this.option("zoomLevel");
                var currentDate = this.option("currentDate");
                var max = this._dateOption("max");
                var date = dateUtils.sameView(zoomLevel, currentDate, max) ? max : dateUtils.getViewLastCellDate(zoomLevel, currentDate);
                this.option("currentDate", date)
            },
            pageUp: function(e) {
                e.preventDefault();
                this._waitRenderView(-1)
            },
            pageDown: function(e) {
                e.preventDefault();
                this._waitRenderView(1)
            },
            tab: commonUtils.noop,
            enter: function(e) {
                if (!this._isMaxZoomLevel()) {
                    this._navigateDown()
                } else {
                    var value = this._updateTimeComponent(this.option("currentDate"));
                    this._dateValue(value, e)
                }
            }
        })
    },
    _getSerializationFormat: function(optionName) {
        var value = this.option(optionName || "value");
        if (this.option("dateSerializationFormat")) {
            return this.option("dateSerializationFormat")
        }
        if (commonUtils.isNumeric(value)) {
            return "number"
        }
        if (!commonUtils.isString(value)) {
            return
        }
        return dateSerialization.getDateSerializationFormat(value)
    },
    _convertToDate: function(value, optionName) {
        return dateSerialization.deserializeDate(value)
    },
    _dateValue: function(value, jQueryEvent) {
        if (jQueryEvent) {
            this._saveValueChangeEvent(jQueryEvent)
        }
        this._dateOption("value", value)
    },
    _dateOption: function(optionName, optionValue) {
        if (1 === arguments.length) {
            return this._convertToDate(this.option(optionName), optionName)
        }
        var serializationFormat = this._getSerializationFormat(optionName);
        this.option(optionName, dateSerialization.serializeDate(optionValue, serializationFormat))
    },
    _moveCurrentDate: function(offset) {
        var currentDate = new Date(this.option("currentDate"));
        var newDate = new Date(currentDate);
        var zoomLevel = this.option("zoomLevel");
        switch (zoomLevel) {
            case "month":
                newDate.setDate(currentDate.getDate() + offset);
                break;
            case "year":
                newDate.setMonth(currentDate.getMonth() + offset);
                break;
            case "decade":
                newDate.setFullYear(currentDate.getFullYear() + offset);
                break;
            case "century":
                newDate.setFullYear(currentDate.getFullYear() + 10 * offset)
        }
        var offsetCorrection = 2 * offset / Math.abs(offset);
        if (Math.abs(offset) > 1 && !dateUtils.sameView(zoomLevel, currentDate, newDate)) {
            if ("decade" === zoomLevel) {
                newDate.setFullYear(currentDate.getFullYear() + offset - offsetCorrection)
            }
            if ("century" === zoomLevel) {
                newDate.setFullYear(currentDate.getFullYear() + 10 * (offset - offsetCorrection))
            }
        }
        this.option("currentDate", newDate)
    },
    _init: function() {
        this.callBase();
        this._correctZoomLevel();
        this._initCurrentDate();
        this._initActions()
    },
    _correctZoomLevel: function() {
        var minZoomLevel = this.option("minZoomLevel"),
            maxZoomLevel = this.option("maxZoomLevel"),
            zoomLevel = this.option("zoomLevel");
        if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
            return
        }
        if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
            this.option("zoomLevel", maxZoomLevel)
        } else {
            if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
                this.option("zoomLevel", minZoomLevel)
            }
        }
    },
    _initCurrentDate: function() {
        var currentDate = this._getNormalizedDate(this._dateOption("value")) || this._getNormalizedDate(this.option("currentDate"));
        this.option("currentDate", currentDate)
    },
    _getNormalizedDate: function(date) {
        date = dateUtils.normalizeDate(date, this._getMinDate(), this._getMaxDate());
        return commonUtils.isDefined(date) ? new Date(date) : date
    },
    _initActions: function() {
        this._cellClickAction = this._createActionByOption("onCellClick");
        this._onContouredChanged = this._createActionByOption("onContouredChanged")
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.cell = new FunctionTemplate(function(options) {
            var data = options.model;
            options.container.append($("<span>").text(data && data.text || String(data)))
        }, this)
    },
    _updateCurrentDate: function(date) {
        if (fx.isAnimating(this._$viewsWrapper)) {
            fx.stop(this._$viewsWrapper, true)
        }
        var min = this._getMinDate(),
            max = this._getMaxDate();
        if (min > max) {
            this.option("currentDate", new Date);
            return
        }
        var normalizedDate = this._getNormalizedDate(date);
        if (date.getTime() !== normalizedDate.getTime()) {
            this.option("currentDate", new Date(normalizedDate));
            return
        }
        var offset = this._getViewsOffset(this._view.option("date"), normalizedDate);
        if (0 !== offset && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
            offset = 0
        }
        if (this._view && 0 !== offset && !this._suppressNavigation) {
            this._navigate(offset, normalizedDate)
        } else {
            this._renderNavigator();
            this._setViewContoured(normalizedDate);
            this._updateAriaId(normalizedDate)
        }
    },
    _setViewContoured: function(date) {
        if (this.option("hasFocus")(this._focusTarget())) {
            this._view.option("contouredDate", date)
        }
    },
    _getMinDate: function() {
        if (this.min) {
            return this.min
        }
        this.min = this._dateOption("min") || new Date(1e3, 0);
        return this.min
    },
    _getMaxDate: function() {
        if (this.max) {
            return this.max
        }
        this.max = this._dateOption("max") || new Date(3e3, 0);
        return this.max
    },
    _getViewsOffset: function(startDate, endDate) {
        var zoomLevel = this.option("zoomLevel");
        if ("month" === zoomLevel) {
            return this._getMonthsOffset(startDate, endDate)
        }
        var zoomCorrection;
        switch (zoomLevel) {
            case "century":
                zoomCorrection = 100;
                break;
            case "decade":
                zoomCorrection = 10;
                break;
            default:
                zoomCorrection = 1
        }
        return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection)
    },
    _getMonthsOffset: function(startDate, endDate) {
        var yearOffset = endDate.getFullYear() - startDate.getFullYear(),
            monthOffset = endDate.getMonth() - startDate.getMonth();
        return 12 * yearOffset + monthOffset
    },
    _waitRenderView: function(offset) {
        if (this._alreadyViewRender) {
            return
        }
        this._alreadyViewRender = true;
        var date = this._getDateByOffset(offset * this._getRtlCorrection());
        this.option("currentDate", date);
        setTimeout(function() {
            this._alreadyViewRender = false
        }.bind(this))
    },
    _getRtlCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1
    },
    _getDateByOffset: function(offset, date) {
        date = new Date(date || this.option("currentDate"));
        var currentDay = date.getDate();
        var difference = dateUtils.getDifferenceInMonth(this.option("zoomLevel")) * offset;
        date.setDate(1);
        date.setMonth(date.getMonth() + difference);
        var lastDay = dateUtils.getLastMonthDate(date).getDate();
        date.setDate(currentDay > lastDay ? lastDay : currentDay);
        return date
    },
    _focusTarget: function() {
        return this.element()
    },
    _render: function() {
        this._renderSubmitElement();
        this.callBase();
        var $element = this.element();
        $element.addClass(CALENDAR_CLASS);
        this._renderBody();
        $element.append(this.$body);
        this._renderViews();
        this._renderNavigator();
        this._renderSwipeable();
        this._renderFooter();
        this.setAria({
            role: "listbox",
            label: messageLocalization.format("dxCalendar-ariaWidgetName")
        });
        this._updateAriaSelected();
        this._updateAriaId();
        this._setViewContoured(this.option("currentDate"));
        $element.append(this._navigator.element())
    },
    _renderBody: function() {
        if (!this._$viewsWrapper) {
            this.$body = $("<div>").addClass(CALENDAR_BODY_CLASS);
            this._$viewsWrapper = $("<div>").addClass(CALENDAR_VIEWS_WRAPPER_CLASS);
            this.$body.append(this._$viewsWrapper)
        }
    },
    _renderViews: function() {
        this.element().addClass(CALENDAR_VIEW_CLASS + "-" + this.option("zoomLevel"));
        var currentDate = this.option("currentDate");
        this._view = this._renderSpecificView(currentDate);
        this._view.option("_keyboardProcessor", this._viewKeyboardProcessor);
        var beforeDate = this._getDateByOffset(-1, currentDate);
        this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
        var afterDate = this._getDateByOffset(1, currentDate);
        this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
        this._translateViews()
    },
    _renderSpecificView: function(date) {
        var specificView = Views[this.option("zoomLevel")],
            $view = $("<div>").appendTo(this._$viewsWrapper),
            config = this._viewConfig(date);
        return new specificView($view, config)
    },
    _viewConfig: function(date) {
        return {
            date: date,
            min: this._getMinDate(),
            max: this._getMaxDate(),
            firstDayOfWeek: this.option("firstDayOfWeek"),
            value: this._dateOption("value"),
            rtl: this.option("rtlEnabled"),
            disabled: this.option("disabled") || config().designMode,
            tabIndex: void 0,
            focusStateEnabled: this.option("focusStateEnabled"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            onCellClick: this._cellClickHandler.bind(this),
            cellTemplate: this._getTemplateByOption("cellTemplate"),
            allowValueSelection: this._isMaxZoomLevel()
        }
    },
    _isViewAvailable: function(date) {
        var zoomLevel = this.option("zoomLevel");
        var min = dateUtils.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
        var max = dateUtils.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
        return dateUtils.dateInRange(date, min, max)
    },
    _translateViews: function() {
        translator.move(this._view.element(), {
            left: 0,
            top: 0
        });
        this._beforeView && translator.move(this._beforeView.element(), {
            left: this._getViewPosition(-1),
            top: 0
        });
        this._afterView && translator.move(this._afterView.element(), {
            left: this._getViewPosition(1),
            top: 0
        })
    },
    _getViewPosition: function(coefficient) {
        var rtlCorrection = this.option("rtlEnabled") && !browser.msie ? -1 : 1;
        return 100 * coefficient * rtlCorrection + "%"
    },
    _cellClickHandler: function(e) {
        var zoomLevel = this.option("zoomLevel"),
            nextView = dateUtils.getViewDown(zoomLevel);
        var isMaxZoomLevel = this._isMaxZoomLevel();
        if (nextView && !isMaxZoomLevel) {
            this._navigateDown(e.jQueryEvent.currentTarget)
        } else {
            var newValue = this._updateTimeComponent(e.value);
            this._dateValue(newValue, e.jQueryEvent);
            this._cellClickAction(e)
        }
    },
    _updateTimeComponent: function(date) {
        var result = new Date(date);
        var currentValue = this._dateOption("value");
        if (currentValue) {
            result.setHours(currentValue.getHours());
            result.setMinutes(currentValue.getMinutes());
            result.setSeconds(currentValue.getSeconds());
            result.setMilliseconds(currentValue.getMilliseconds())
        }
        return result
    },
    _isMaxZoomLevel: function() {
        return this.option("zoomLevel") === this.option("maxZoomLevel")
    },
    _navigateDown: function(cell) {
        var zoomLevel = this.option("zoomLevel");
        if (this._isMaxZoomLevel()) {
            return
        }
        var nextView = dateUtils.getViewDown(zoomLevel);
        if (!nextView) {
            return
        }
        var newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
        if (cell) {
            newCurrentDate = $(cell).data(CALENDAR_DATE_VALUE_KEY)
        }
        this._isOtherViewCellClicked = true;
        this.option("currentDate", newCurrentDate);
        this.option("zoomLevel", nextView);
        this._isOtherViewCellClicked = false;
        this._renderNavigator();
        this._animateShowView();
        this._setViewContoured(this._getNormalizedDate(newCurrentDate))
    },
    _renderNavigator: function() {
        if (!this._navigator) {
            this._navigator = new Navigator($("<div>"), this._navigatorConfig())
        }
        this._navigator.option("text", this._view.getNavigatorCaption());
        this._updateButtonsVisibility()
    },
    _navigatorConfig: function() {
        return {
            text: this._view.getNavigatorCaption(),
            onClick: this._navigatorClickHandler.bind(this),
            onCaptionClick: this._navigateUp.bind(this),
            rtlEnabled: this.option("rtlEnabled")
        }
    },
    _navigatorClickHandler: function(e) {
        var currentDate = this._getDateByOffset(e.direction, this.option("currentDate"));
        this.option("currentDate", currentDate);
        this._updateNavigatorCaption(-e.direction * this._getRtlCorrection())
    },
    _navigateUp: function() {
        var zoomLevel = this.option("zoomLevel"),
            nextView = dateUtils.getViewUp(zoomLevel);
        if (!nextView || this._isMinZoomLevel(zoomLevel)) {
            return
        }
        var contouredDate = this._view.option("contouredDate");
        this.option("zoomLevel", nextView);
        this.option("currentDate", contouredDate || this._view.option("date"));
        this._renderNavigator();
        this._animateShowView().done(function() {
            this._setViewContoured(contouredDate)
        }.bind(this))
    },
    _isMinZoomLevel: function(zoomLevel) {
        var min = this._getMinDate(),
            max = this._getMaxDate();
        return dateUtils.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel
    },
    _updateButtonsVisibility: function() {
        this._navigator.toggleButton("next", !commonUtils.isDefined(this._getRequiredView("next")));
        this._navigator.toggleButton("prev", !commonUtils.isDefined(this._getRequiredView("prev")))
    },
    _renderSwipeable: function() {
        if (!this._swipeable) {
            this._swipeable = this._createComponent(this.element(), Swipeable, {
                onStart: this._swipeStartHandler.bind(this),
                onUpdated: this._swipeUpdateHandler.bind(this),
                onEnd: this._swipeEndHandler.bind(this),
                itemSizeFunc: this._viewWidth.bind(this)
            })
        }
    },
    _swipeStartHandler: function(e) {
        fx.stop(this._$viewsWrapper, true);
        e.jQueryEvent.maxLeftOffset = this._getRequiredView("next") ? 1 : 0;
        e.jQueryEvent.maxRightOffset = this._getRequiredView("prev") ? 1 : 0
    },
    _getRequiredView: function(name) {
        var view;
        var isRtl = this.option("rtlEnabled");
        if ("next" === name) {
            view = isRtl ? this._beforeView : this._afterView
        } else {
            if ("prev" === name) {
                view = isRtl ? this._afterView : this._beforeView
            }
        }
        return view
    },
    _swipeUpdateHandler: function(e) {
        var offset = e.jQueryEvent.offset;
        translator.move(this._$viewsWrapper, {
            left: offset * this._viewWidth(),
            top: 0
        });
        this._updateNavigatorCaption(offset)
    },
    _swipeEndHandler: function(e) {
        var targetOffset = e.jQueryEvent.targetOffset,
            moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
        if (0 === moveOffset) {
            this._animateWrapper(0, ANIMATION_DURATION_SHOW_VIEW);
            return
        }
        var date = this._getDateByOffset(-moveOffset * this._getRtlCorrection());
        if (this._isDateInInvalidRange(date)) {
            if (moveOffset >= 0) {
                date = new Date(this._getMinDate())
            } else {
                date = new Date(this._getMaxDate())
            }
        }
        this.option("currentDate", date)
    },
    _viewWidth: function() {
        if (!this._viewWidthValue) {
            this._viewWidthValue = this.element().width()
        }
        return this._viewWidthValue
    },
    _updateNavigatorCaption: function(offset) {
        offset *= this._getRtlCorrection();
        var view = this._view;
        if (offset > .5 && this._beforeView) {
            view = this._beforeView
        } else {
            if (offset < -.5 && this._afterView) {
                view = this._afterView
            }
        }
        this._navigator.option("text", view.getNavigatorCaption())
    },
    _isDateInInvalidRange: function(date) {
        if (this._view.isBoundary(date)) {
            return
        }
        var min = this._getMinDate(),
            max = this._getMaxDate(),
            normalizedDate = dateUtils.normalizeDate(date, min, max);
        return normalizedDate === min || normalizedDate === max
    },
    _renderFooter: function() {
        var showTodayButton = this.option("showTodayButton");
        if (showTodayButton) {
            var $todayButton = this._createComponent($("<a>"), Button, {
                focusStateEnabled: false,
                text: messageLocalization.format("dxCalendar-todayButtonText"),
                onClick: function() {
                    this._toTodayView()
                }.bind(this),
                integrationOptions: {}
            }).element().addClass(CALENDAR_TODAY_BUTTON_CLASS);
            this._$footer = $("<div>").addClass(CALENDAR_FOOTER_CLASS).append($todayButton);
            this.element().append(this._$footer)
        }
        this.element().toggleClass(CALENDAR_HAS_FOOTER_CLASS, showTodayButton)
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element());
        this._setSubmitValue(this.option("value"))
    },
    _setSubmitValue: function(value) {
        var dateValue = this._convertToDate(value);
        this._$submitElement.val(dateSerialization.serializeDate(dateValue, CALENDAR_INPUT_STANDARD_PATTERN))
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _animateShowView: function() {
        fx.stop(this._view.element(), true);
        return this._popAnimationView(this._view, POP_ANIMATION_FROM, POP_ANIMATION_TO, ANIMATION_DURATION_SHOW_VIEW).promise()
    },
    _popAnimationView: function(view, from, to, duration) {
        return fx.animate(view.element(), {
            type: "pop",
            from: {
                scale: from,
                opacity: from
            },
            to: {
                scale: to,
                opacity: to
            },
            duration: duration
        })
    },
    _navigate: function(offset, value) {
        if (0 !== offset && 1 !== Math.abs(offset) && this._isViewAvailable(value)) {
            var newView = this._renderSpecificView(value);
            if (offset > 0) {
                this._afterView && this._afterView.element().remove();
                this._afterView = newView
            } else {
                this._beforeView && this._beforeView.element().remove();
                this._beforeView = newView
            }
            this._translateViews()
        }
        var rtlCorrection = this._getRtlCorrection(),
            offsetSign = offset > 0 ? 1 : offset < 0 ? -1 : 0,
            endPosition = -rtlCorrection * offsetSign * this._viewWidth();
        var viewsWrapperPosition = this._$viewsWrapper.position().left;
        if (viewsWrapperPosition !== endPosition) {
            if (this._preventViewChangeAnimation) {
                this._wrapperAnimationEndHandler(offset, value)
            } else {
                this._animateWrapper(endPosition, ANIMATION_DURATION_SHOW_VIEW).done(this._wrapperAnimationEndHandler.bind(this, offset, value))
            }
        }
    },
    _animateWrapper: function(to, duration) {
        return fx.animate(this._$viewsWrapper, {
            type: "slide",
            from: {
                left: this._$viewsWrapper.position().left
            },
            to: {
                left: to
            },
            duration: duration
        })
    },
    _toTodayView: function() {
        var today = new Date;
        if (this._isMaxZoomLevel()) {
            this._dateOption("value", today);
            return
        }
        this._preventViewChangeAnimation = true;
        this.option("zoomLevel", this.option("maxZoomLevel"));
        this._dateOption("value", today);
        this._animateShowView();
        this._preventViewChangeAnimation = false
    },
    _wrapperAnimationEndHandler: function(offset, newDate) {
        this._rearrangeViews(offset);
        this._translateViews();
        this._resetLocation();
        this._renderNavigator();
        this._setViewContoured(newDate);
        this._updateAriaId(newDate)
    },
    _rearrangeViews: function(offset) {
        if (0 === offset) {
            return
        }
        var viewOffset, viewToCreateKey, viewToRemoveKey;
        if (offset < 0) {
            viewOffset = 1;
            viewToCreateKey = "_beforeView";
            viewToRemoveKey = "_afterView"
        } else {
            viewOffset = -1;
            viewToCreateKey = "_afterView";
            viewToRemoveKey = "_beforeView"
        }
        if (!this[viewToCreateKey]) {
            return
        }
        var destinationDate = this[viewToCreateKey].option("date");
        if (this[viewToRemoveKey]) {
            this[viewToRemoveKey].element().remove()
        }
        if (offset === viewOffset) {
            this[viewToRemoveKey] = this._view
        } else {
            this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset, destinationDate));
            this._view.element().remove()
        }
        this._view = this[viewToCreateKey];
        var dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
        this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null
    },
    _resetLocation: function() {
        translator.move(this._$viewsWrapper, {
            left: 0,
            top: 0
        })
    },
    _clean: function() {
        this.callBase();
        this._clearViewWidthCache();
        delete this._$viewsWrapper;
        delete this._navigator;
        delete this._$footer
    },
    _clearViewWidthCache: function() {
        delete this._viewWidthValue
    },
    _disposeViews: function() {
        this._view.element().remove();
        this._beforeView && this._beforeView.element().remove();
        this._afterView && this._afterView.element().remove();
        delete this._view;
        delete this._beforeView;
        delete this._afterView
    },
    _refreshViews: function() {
        this._disposeViews();
        this._renderViews()
    },
    _visibilityChanged: function() {
        this._translateViews()
    },
    _focusInHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", this.option("currentDate"))
    },
    _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", null)
    },
    _updateViewsValue: function(value) {
        var newValue = value ? new Date(value) : null;
        this._view.option("value", newValue);
        this._beforeView && this._beforeView.option("value", newValue);
        this._afterView && this._afterView.option("value", newValue)
    },
    _updateAriaSelected: function(value, previousValue) {
        value = value || this._dateOption("value");
        var $prevSelectedCell = this._view._getCellByDate(previousValue);
        var $selectedCell = this._view._getCellByDate(value);
        this.setAria("selected", void 0, $prevSelectedCell);
        this.setAria("selected", true, $selectedCell);
        if (value && this.option("currentDate").getTime() === value.getTime()) {
            this._updateAriaId(value)
        }
    },
    _updateAriaId: function(value) {
        value = value || this.option("currentDate");
        var ariaId = "dx-" + new Guid;
        var $newCell = this._view._getCellByDate(value);
        this.setAria("id", ariaId, $newCell);
        this.setAria("activedescendant", ariaId);
        this._onContouredChanged(ariaId)
    },
    _suppressingNavigation: function(callback, args) {
        this._suppressNavigation = true;
        callback.apply(this, args);
        delete this._suppressNavigation
    },
    _optionChanged: function(args) {
        var value = args.value;
        var previousValue = args.previousValue;
        switch (args.name) {
            case "width":
                this.callBase(args);
                this._clearViewWidthCache();
                break;
            case "min":
            case "max":
                this.min = void 0;
                this.max = void 0;
                this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
                this._refreshViews();
                this._renderNavigator();
                break;
            case "firstDayOfWeek":
                this._refreshViews();
                this._updateButtonsVisibility();
                break;
            case "currentDate":
                this.setAria("id", void 0, this._view._getCellByDate(previousValue));
                this._updateCurrentDate(value);
                break;
            case "zoomLevel":
                this.element().removeClass(CALENDAR_VIEW_CLASS + "-" + previousValue);
                this._correctZoomLevel();
                this._refreshViews();
                this._renderNavigator();
                this._updateAriaId();
                break;
            case "minZoomLevel":
            case "maxZoomLevel":
                this._correctZoomLevel();
                this._updateButtonsVisibility();
                break;
            case "value":
                value = this._convertToDate(value);
                previousValue = this._convertToDate(previousValue);
                this._updateAriaSelected(value, previousValue);
                this.option("currentDate", commonUtils.isDefined(value) ? new Date(value) : new Date);
                this._updateViewsValue(value);
                this._setSubmitValue(value);
                this.callBase(args);
                break;
            case "disabled":
                this._view.option("disabled", value);
                this.callBase(args);
                break;
            case "showTodayButton":
                this._invalidate();
                break;
            case "onCellClick":
                this._view.option("onCellClick", value);
                break;
            case "onContouredChanged":
                this._onContouredChanged = this._createActionByOption("onContouredChanged");
                break;
            case "dateSerializationFormat":
            case "cellTemplate":
                this._invalidate();
                break;
            case "hasFocus":
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxCalendar", Calendar);
module.exports = Calendar;


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/calendar/ui.calendar.navigator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    Widget = __webpack_require__(27),
    Button = __webpack_require__(25);
var CALENDAR_NAVIGATOR_CLASS = "dx-calendar-navigator",
    CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = "dx-calendar-navigator-previous-month",
    CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = "dx-calendar-navigator-next-month",
    CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS = "dx-calendar-navigator-previous-view",
    CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS = "dx-calendar-navigator-next-view",
    CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS = "dx-calendar-disabled-navigator-link",
    CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS = "dx-calendar-caption-button";
var Navigator = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            onClick: null,
            onCaptionClick: null,
            text: ""
        })
    },
    _init: function() {
        this.callBase();
        this._initActions()
    },
    _initActions: function() {
        this._clickAction = this._createActionByOption("onClick");
        this._captionClickAction = this._createActionByOption("onCaptionClick")
    },
    _render: function() {
        this.callBase();
        this.element().addClass(CALENDAR_NAVIGATOR_CLASS);
        this._renderButtons();
        this._renderCaption()
    },
    _renderButtons: function() {
        var that = this,
            direction = this.option("rtlEnabled") ? -1 : 1;
        this._prevButton = this._createComponent($("<a>"), Button, {
            focusStateEnabled: false,
            icon: "chevronleft",
            onClick: function(e) {
                that._clickAction({
                    direction: -direction,
                    jQueryEvent: e
                })
            },
            integrationOptions: {}
        });
        var $prevButton = this._prevButton.element().addClass(CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
        this._nextButton = this._createComponent($("<a>"), Button, {
            focusStateEnabled: false,
            icon: "chevronright",
            onClick: function(e) {
                that._clickAction({
                    direction: direction,
                    jQueryEvent: e
                })
            },
            integrationOptions: {}
        });
        var $nextButton = this._nextButton.element().addClass(CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
        this._caption = this._createComponent($("<a>").addClass(CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS), Button, {
            focusStateEnabled: false,
            onClick: function(e) {
                that._captionClickAction({
                    jQueryEvent: e
                })
            },
            integrationOptions: {}
        });
        var $caption = this._caption.element();
        this.element().append($prevButton, $caption, $nextButton)
    },
    _renderCaption: function() {
        this._caption.option("text", this.option("text"))
    },
    toggleButton: function(buttonPrefix, value) {
        var buttonName = "_" + buttonPrefix + "Button",
            button = this[buttonName];
        if (button) {
            button.option("disabled", value);
            button.element().toggleClass(CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, value)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "text":
                this._renderCaption();
                break;
            default:
                this.callBase(args)
        }
    }
});
module.exports = Navigator;


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/calendar/ui.calendar.views.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    BaseView = __webpack_require__(315),
    dateUtils = __webpack_require__(55),
    extend = __webpack_require__(1).extend,
    dateLocalization = __webpack_require__(32),
    dateSerialization = __webpack_require__(71);
var CALENDAR_OTHER_MONTH_CLASS = "dx-calendar-other-month",
    CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
var Views = {
    month: BaseView.inherit({
        _getViewName: function() {
            return "month"
        },
        _getDefaultOptions: function() {
            return extend(this.callBase(), {
                firstDayOfWeek: void 0,
                rowCount: 6,
                colCount: 7
            })
        },
        _renderImpl: function() {
            this.callBase();
            this._renderHeader()
        },
        _renderBody: function() {
            this.callBase();
            this._$table.find("." + CALENDAR_OTHER_VIEW_CLASS).addClass(CALENDAR_OTHER_MONTH_CLASS)
        },
        _renderFocusTarget: noop,
        getCellAriaLabel: function(date) {
            return dateLocalization.format(date, "longdate")
        },
        _renderHeader: function() {
            var that = this;
            var $header = $("<thead>");
            this._$table.prepend($header);
            var $headerRow = $("<tr>");
            $header.append($headerRow);
            var appendCell = this.option("rtl") ? function(row, cell) {
                row.prepend(cell)
            } : function(row, cell) {
                row.append(cell)
            };
            this._iterateCells(this.option("colCount"), function(i) {
                var $cell = $("<th>").text(that._getDayCaption(that._getFirstDayOfWeek() + i));
                appendCell($headerRow, $cell)
            })
        },
        getNavigatorCaption: function() {
            return dateLocalization.format(this.option("date"), "monthandyear")
        },
        _isTodayCell: function(cellDate) {
            var today = new Date;
            return dateUtils.sameDate(cellDate, today)
        },
        _isDateOutOfRange: function(cellDate) {
            var minDate = this.option("min"),
                maxDate = this.option("max");
            return !dateUtils.dateInRange(cellDate, minDate, maxDate, "date")
        },
        _isOtherView: function(cellDate) {
            return cellDate.getMonth() !== this.option("date").getMonth()
        },
        _getCellText: function(cellDate) {
            return cellDate.getDate()
        },
        _getDayCaption: function(day) {
            var daysInWeek = this.option("colCount");
            return dateLocalization.getDayNames("abbreviated")[day % daysInWeek]
        },
        _getFirstCellData: function() {
            var firstDay = dateUtils.getFirstMonthDate(this.option("date")),
                firstMonthDayOffset = this._getFirstDayOfWeek() - firstDay.getDay(),
                daysInWeek = this.option("colCount");
            if (firstMonthDayOffset >= 0) {
                firstMonthDayOffset -= daysInWeek
            }
            firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
            return firstDay
        },
        _getNextCellData: function(date) {
            date = new Date(date);
            date.setDate(date.getDate() + 1);
            return date
        },
        _getFirstDayOfWeek: function() {
            return this.option("firstDayOfWeek") || dateLocalization.firstDayOfWeekIndex()
        },
        _getCellByDate: function(date) {
            return this._$table.find("td[data-value='" + dateSerialization.serializeDate(date, dateUtils.getShortDateFormat()) + "']")
        },
        isBoundary: function(date) {
            return dateUtils.sameMonthAndYear(date, this.option("min")) || dateUtils.sameMonthAndYear(date, this.option("max"))
        }
    }),
    year: BaseView.inherit({
        _getViewName: function() {
            return "year"
        },
        _isTodayCell: function(cellDate) {
            return dateUtils.sameMonthAndYear(cellDate, new Date)
        },
        _isDateOutOfRange: function(cellDate) {
            return !dateUtils.dateInRange(cellDate, dateUtils.getFirstMonthDate(this.option("min")), dateUtils.getLastMonthDate(this.option("max")))
        },
        _isOtherView: function() {
            return false
        },
        _getCellText: function(cellDate) {
            return dateLocalization.getMonthNames()[cellDate.getMonth()].slice(0, 3)
        },
        _getFirstCellData: function() {
            var data = new Date(this.option("date"));
            data.setDate(1);
            data.setMonth(0);
            return data
        },
        _getNextCellData: function(date) {
            date = new Date(date);
            date.setMonth(date.getMonth() + 1);
            return date
        },
        _getCellByDate: function(date) {
            var foundDate = new Date(date);
            foundDate.setDate(1);
            return this._$table.find("td[data-value='" + dateSerialization.serializeDate(foundDate, dateUtils.getShortDateFormat()) + "']")
        },
        getCellAriaLabel: function(date) {
            return dateLocalization.format(date, "monthandyear")
        },
        getNavigatorCaption: function() {
            return this.option("date").getFullYear()
        },
        isBoundary: function(date) {
            return dateUtils.sameYear(date, this.option("min")) || dateUtils.sameYear(date, this.option("max"))
        }
    }),
    decade: BaseView.inherit({
        _getViewName: function() {
            return "decade"
        },
        _isTodayCell: function(cellDate) {
            return dateUtils.sameYear(cellDate, new Date)
        },
        _isDateOutOfRange: function(cellDate) {
            var min = this.option("min"),
                max = this.option("max");
            return !dateUtils.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear())
        },
        _isOtherView: function(cellDate) {
            var date = new Date(cellDate);
            date.setMonth(1);
            return !dateUtils.sameDecade(date, this.option("date"))
        },
        _getCellText: function(cellDate) {
            return cellDate.getFullYear()
        },
        _getFirstCellData: function() {
            var year = dateUtils.getFirstYearInDecade(this.option("date")) - 1;
            return new Date(year, 0, 1)
        },
        _getNextCellData: function(date) {
            date = new Date(date);
            date.setFullYear(date.getFullYear() + 1);
            return date
        },
        getNavigatorCaption: function() {
            var year = dateUtils.getFirstYearInDecade(this.option("date"));
            return year + "-" + (year + 9)
        },
        _isValueOnCurrentView: function(currentDate, value) {
            return dateUtils.sameDecade(currentDate, value)
        },
        _getCellByDate: function(date) {
            var foundDate = new Date(date);
            foundDate.setDate(1);
            foundDate.setMonth(0);
            return this._$table.find("td[data-value='" + dateSerialization.serializeDate(foundDate, dateUtils.getShortDateFormat()) + "']")
        },
        isBoundary: function(date) {
            return dateUtils.sameDecade(date, this.option("min")) || dateUtils.sameDecade(date, this.option("max"))
        }
    }),
    century: BaseView.inherit({
        _getViewName: function() {
            return "century"
        },
        _isTodayCell: function(cellDate) {
            return dateUtils.sameDecade(cellDate, new Date)
        },
        _isDateOutOfRange: function(cellDate) {
            var decade = dateUtils.getFirstYearInDecade(cellDate),
                minDecade = dateUtils.getFirstYearInDecade(this.option("min")),
                maxDecade = dateUtils.getFirstYearInDecade(this.option("max"));
            return !dateUtils.dateInRange(decade, minDecade, maxDecade)
        },
        _isOtherView: function(cellDate) {
            var date = new Date(cellDate);
            date.setMonth(1);
            return !dateUtils.sameCentury(date, this.option("date"))
        },
        _getCellText: function(cellDate) {
            var decade = cellDate.getFullYear();
            return decade + " - " + (decade + 9)
        },
        _getFirstCellData: function() {
            var decade = dateUtils.getFirstDecadeInCentury(this.option("date")) - 10;
            return new Date(decade, 0, 1)
        },
        _getNextCellData: function(date) {
            date = new Date(date);
            date.setFullYear(date.getFullYear() + 10);
            return date
        },
        _getCellByDate: function(date) {
            var foundDate = new Date(date);
            foundDate.setDate(1);
            foundDate.setMonth(0);
            foundDate.setFullYear(dateUtils.getFirstYearInDecade(foundDate));
            return this._$table.find("td[data-value='" + dateSerialization.serializeDate(foundDate, dateUtils.getShortDateFormat()) + "']")
        },
        getNavigatorCaption: function() {
            var decade = dateUtils.getFirstDecadeInCentury(this.option("date"));
            return decade + "-" + (decade + 99)
        },
        isBoundary: function(date) {
            return dateUtils.sameCentury(date, this.option("min")) || dateUtils.sameCentury(date, this.option("max"))
        }
    })
};
module.exports = Views;


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/calendar/ui.calendar.base_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Widget = __webpack_require__(27),
    dateUtils = __webpack_require__(55),
    extend = __webpack_require__(1).extend,
    dateSerialization = __webpack_require__(71),
    eventUtils = __webpack_require__(3),
    clickEvent = __webpack_require__(11);
var abstract = Widget.abstract,
    CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view",
    CALENDAR_CELL_CLASS = "dx-calendar-cell",
    CALENDAR_EMPTY_CELL_CLASS = "dx-calendar-empty-cell",
    CALENDAR_TODAY_CLASS = "dx-calendar-today",
    CALENDAR_SELECTED_DATE_CLASS = "dx-calendar-selected-date",
    CALENDAR_CONTOURED_DATE_CLASS = "dx-calendar-contoured-date",
    CALENDAR_DXCLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, "dxCalendar"),
    CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
var BaseView = Widget.inherit({
    _getViewName: function() {
        return "base"
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            date: new Date,
            focusStateEnabled: false,
            cellTemplate: null,
            onCellClick: null,
            rowCount: 3,
            colCount: 4,
            allowValueSelection: true
        })
    },
    _init: function() {
        this.callBase();
        var value = this.option("value");
        this.option("value", new Date(value));
        if (!this.option("value").valueOf()) {
            this.option("value", new Date(0, 0, 0, 0, 0, 0))
        }
    },
    _render: function() {
        this.callBase();
        this._renderImpl()
    },
    _renderImpl: function() {
        this._$table = $("<table>");
        this.element().append(this._$table);
        this._renderBody();
        this._renderContouredDate();
        this._renderValue();
        this._renderEvents()
    },
    _renderBody: function() {
        this.$body = $("<tbody>").appendTo(this._$table);
        var that = this,
            cellTemplate = this.option("cellTemplate");
        var appendChild = this.option("rtl") ? function(row, cell) {
            row.insertBefore(cell, row.firstChild)
        } : function(row, cell) {
            row.appendChild(cell)
        };

        function renderCell(cellIndex) {
            if (prevCellDate) {
                dateUtils.fixTimezoneGap(prevCellDate, cellDate)
            }
            prevCellDate = cellDate;
            var cell = document.createElement("td"),
                className = CALENDAR_CELL_CLASS;
            if (that._isTodayCell(cellDate)) {
                className = className + " " + CALENDAR_TODAY_CLASS
            }
            if (that._isDateOutOfRange(cellDate)) {
                className = className + " " + CALENDAR_EMPTY_CELL_CLASS
            }
            if (that._isOtherView(cellDate)) {
                className = className + " " + CALENDAR_OTHER_VIEW_CLASS
            }
            cell.className = className;
            cell.setAttribute("data-value", dateSerialization.serializeDate(cellDate, dateUtils.getShortDateFormat()));
            $.data(cell, CALENDAR_DATE_VALUE_KEY, cellDate);
            that.setAria({
                role: "option",
                label: that.getCellAriaLabel(cellDate)
            }, $(cell));
            appendChild(row, cell);
            if (cellTemplate) {
                cellTemplate.render({
                    model: {
                        text: that._getCellText(cellDate),
                        date: cellDate,
                        view: that._getViewName()
                    },
                    container: $(cell),
                    index: cellIndex
                })
            } else {
                cell.innerHTML = that._getCellText(cellDate)
            }
            cellDate = that._getNextCellData(cellDate)
        }
        var prevCellDate, cellDate = this._getFirstCellData(),
            colCount = this.option("colCount");
        for (var indexRow = 0, len = this.option("rowCount"); indexRow < len; indexRow++) {
            var row = document.createElement("tr");
            this.$body.get(0).appendChild(row);
            this._iterateCells(colCount, renderCell)
        }
    },
    _iterateCells: function(colCount, delegate) {
        var i = 0;
        while (i < colCount) {
            delegate(i);
            ++i
        }
    },
    _renderEvents: function() {
        this._createCellClickAction();
        this._$table.off(CALENDAR_DXCLICK_EVENT_NAME).on(CALENDAR_DXCLICK_EVENT_NAME, "td", function(e) {
            if (!$(e.currentTarget).hasClass(CALENDAR_EMPTY_CELL_CLASS)) {
                this._cellClickAction({
                    jQueryEvent: e,
                    value: $(e.currentTarget).data(CALENDAR_DATE_VALUE_KEY)
                })
            }
        }.bind(this))
    },
    _createCellClickAction: function() {
        this._cellClickAction = this._createActionByOption("onCellClick")
    },
    _isTodayCell: abstract,
    _isDateOutOfRange: abstract,
    _isOtherView: abstract,
    _getCellText: abstract,
    _getFirstCellData: abstract,
    _getNextCellData: abstract,
    _renderContouredDate: function(contouredDate) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        contouredDate = contouredDate || this.option("contouredDate");
        var $oldContouredCell = this._$table.find("." + CALENDAR_CONTOURED_DATE_CLASS);
        var $newContouredCell = this._getCellByDate(contouredDate);
        $oldContouredCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS);
        $newContouredCell.addClass(CALENDAR_CONTOURED_DATE_CLASS)
    },
    _dispose: function() {
        this._keyboardProcessor = void 0;
        this.callBase()
    },
    _changeValue: function(cellDate) {
        if (cellDate) {
            var value = this.option("value"),
                newValue = value ? new Date(value) : new Date;
            newValue.setDate(cellDate.getDate());
            newValue.setMonth(cellDate.getMonth());
            newValue.setFullYear(cellDate.getFullYear());
            newValue.setDate(cellDate.getDate());
            this.option("value", newValue)
        } else {
            this.option("value", null)
        }
    },
    _renderValue: function() {
        if (!this.option("allowValueSelection")) {
            return
        }
        var value = this.option("value"),
            selectedCell = this._getCellByDate(value);
        if (this._selectedCell) {
            this._selectedCell.removeClass(CALENDAR_SELECTED_DATE_CLASS)
        }
        selectedCell.addClass(CALENDAR_SELECTED_DATE_CLASS);
        this._selectedCell = selectedCell
    },
    getCellAriaLabel: function(date) {
        return this._getCellText(date)
    },
    _getFirstAvailableDate: function() {
        var date = this.option("date"),
            min = this.option("min");
        date = dateUtils.getFirstDateView(this._getViewName(), date);
        return new Date(min && date < min ? min : date)
    },
    _getCellByDate: abstract,
    isBoundary: abstract,
    _optionChanged: function(args) {
        var name = args.name;
        switch (name) {
            case "value":
                this._renderValue();
                break;
            case "contouredDate":
                this._renderContouredDate(args.value);
                break;
            case "onCellClick":
                this._createCellClickAction();
                break;
            case "cellTemplate":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
module.exports = BaseView;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.date_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    DateView = __webpack_require__(317),
    DateBoxStrategy = __webpack_require__(127),
    support = __webpack_require__(24),
    extend = __webpack_require__(1).extend,
    themes = __webpack_require__(20),
    dateUtils = __webpack_require__(100),
    messageLocalization = __webpack_require__(8);
var DateViewStrategy = DateBoxStrategy.inherit({
    NAME: "DateView",
    getDefaultOptions: function() {
        return extend(this.callBase(), {
            openOnFieldClick: true,
            applyButtonText: messageLocalization.format("Done")
        })
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || dateUtils.FORMATS_MAP[this.dateBox.option("type")]
    },
    popupConfig: function() {
        return {
            showTitle: true,
            toolbarItems: this.dateBox._popupToolbarItemsConfig(),
            defaultOptionsRules: [{
                device: function(device) {
                    return "win" === device.platform && device.version && 8 === device.version[0]
                },
                options: {
                    showNames: true
                }
            }, {
                device: function(device) {
                    return "win" === device.platform && device.phone && device.version && 8 === device.version[0]
                },
                options: {
                    animation: null
                }
            }, {
                device: function() {
                    var currentTheme = (themes.current() || "").split(".")[0];
                    return "win8" === currentTheme
                },
                options: {
                    fullScreen: true
                }
            }, {
                device: {
                    platform: "android"
                },
                options: {
                    width: 333,
                    height: 331
                }
            }, {
                device: function(device) {
                    var platform = device.platform,
                        version = device.version;
                    return "generic" === platform || "ios" === platform || "win" === platform && version && 10 === version[0]
                },
                options: {
                    width: "auto",
                    height: "auto"
                }
            }, {
                device: function(device) {
                    var platform = device.platform,
                        phone = device.phone;
                    return "generic" === platform && phone
                },
                options: {
                    width: 333,
                    height: "auto",
                    position: {
                        collision: "flipfit flip"
                    }
                }
            }, {
                device: function(device) {
                    var currentTheme = (themes.current() || "").split(".")[0];
                    return device.phone && "win10" === currentTheme
                },
                options: {
                    width: 333,
                    height: "auto"
                }
            }, {
                device: {
                    platform: "ios",
                    phone: true
                },
                options: {
                    width: "100%",
                    position: {
                        my: "bottom",
                        at: "bottom",
                        of: window
                    }
                }
            }]
        }
    },
    _renderWidget: function() {
        if (support.inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
            if (this._widget) {
                this._widget.element().remove();
                this._widget = null
            }
            return
        }
        var popup = this._getPopup();
        if (this._widget) {
            this._widget.option(this._getWidgetOptions())
        } else {
            var element = $("<div>").appendTo(popup.content());
            this._widget = this._createWidget(element)
        }
        this._widget.element().appendTo(this._getWidgetContainer())
    },
    _getWidgetName: function() {
        return DateView
    },
    _getWidgetOptions: function() {
        return {
            value: this.dateBoxValue() || new Date,
            type: this.dateBox.option("type"),
            minDate: this.dateBox.dateOption("min") || new Date(1900, 1, 1),
            maxDate: this.dateBox.dateOption("max") || new Date($.now() + 50 * dateUtils.ONE_YEAR),
            onDisposing: function() {
                this._widget = null
            }.bind(this)
        }
    },
    _updateValue: function() {
        this._widget && this._widget.option("value", this.dateBoxValue())
    }
});
module.exports = DateViewStrategy;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Editor = __webpack_require__(33),
    DateViewRoller = __webpack_require__(318),
    dateUtils = __webpack_require__(55),
    extend = __webpack_require__(1).extend,
    uiDateUtils = __webpack_require__(100),
    registerComponent = __webpack_require__(4),
    dateLocalization = __webpack_require__(32);
var DATEVIEW_CLASS = "dx-dateview",
    DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper",
    DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers",
    DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
var TYPE = {
    date: "date",
    datetime: "datetime",
    time: "time"
};
var ROLLER_TYPE = {
    year: "year",
    month: "month",
    day: "day"
};
var DateView = Editor.inherit({
    _valueOption: function() {
        var value = this.option("value"),
            date = new Date(value);
        return !value || isNaN(date) ? this._getDefaultDate() : date
    },
    _getDefaultDate: function() {
        var date = new Date;
        if (this.option("type") === TYPE.date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate())
        }
        return date
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            minDate: uiDateUtils.MIN_DATEVIEW_DEFAULT_DATE,
            maxDate: uiDateUtils.MAX_DATEVIEW_DEFAULT_DATE,
            type: TYPE.date,
            value: new Date,
            showNames: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return "win" === device.platform && device.version && 8 === device.version[0]
            },
            options: {
                showNames: true
            }
        }])
    },
    _render: function() {
        this.callBase();
        this.element().addClass(DATEVIEW_CLASS);
        this._toggleFormatClasses(this.option("type"))
    },
    _toggleFormatClasses: function(currentFormat, previousFormat) {
        this.element().addClass(DATEVIEW_CLASS + "-" + currentFormat);
        previousFormat && this.element().removeClass(DATEVIEW_CLASS + "-" + previousFormat)
    },
    _wrapper: function() {
        return this._$wrapper
    },
    _renderContentImpl: function() {
        this._$wrapper = $("<div>").addClass(DATEVIEW_WRAPPER_CLASS);
        this._renderRollers();
        this._$wrapper.appendTo(this.element())
    },
    _renderRollers: function() {
        if (!this._$rollersContainer) {
            this._$rollersContainer = $("<div>").addClass(DATEVIEW_ROLLER_CONTAINER_CLASS)
        }
        this._$rollersContainer.empty();
        this._createRollerConfigs();
        this._rollers = {};
        var that = this;
        $.each(that._rollerConfigs, function(name) {
            var $roller = $("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS + "-" + that._rollerConfigs[name].type);
            that._rollers[that._rollerConfigs[name].type] = that._createComponent($roller, DateViewRoller, {
                items: that._rollerConfigs[name].displayItems,
                selectedIndex: that._rollerConfigs[name].selectedIndex,
                showScrollbar: false,
                onStart: function(e) {
                    var roller = e.component;
                    roller._toggleActive(true);
                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"))
                },
                onEnd: function(e) {
                    var roller = e.component;
                    roller._toggleActive(false)
                },
                onClick: function(e) {
                    var roller = e.component;
                    roller._toggleActive(true);
                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"));
                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"));
                    roller._toggleActive(false)
                },
                onSelectedIndexChanged: function(e) {
                    var roller = e.component;
                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"))
                }
            })
        });
        that._$rollersContainer.appendTo(that._wrapper())
    },
    _createRollerConfigs: function(type) {
        var that = this;
        type = type || that.option("type");
        that._rollerConfigs = {};
        dateLocalization.getFormatParts(uiDateUtils.FORMATS_MAP[type]).forEach(function(partName) {
            that._createRollerConfig(partName)
        })
    },
    _createRollerConfig: function(componentName) {
        var componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
            valueRange = this._calculateRollerConfigValueRange(componentName),
            startValue = valueRange.startValue,
            endValue = valueRange.endValue,
            formatter = componentInfo.formatter,
            showNames = this.option("showNames"),
            curDate = this._getCurrentDate();
        var config = {
            type: componentName,
            setValue: componentInfo.setter,
            valueItems: [],
            displayItems: [],
            getIndex: function(value) {
                return value[componentInfo.getter]() - startValue
            }
        };
        for (var i = startValue; i <= endValue; i++) {
            config.valueItems.push(i);
            config.displayItems.push(formatter(i, showNames, curDate))
        }
        config.selectedIndex = config.getIndex(curDate);
        this._rollerConfigs[componentName] = config
    },
    _setActiveRoller: function(currentRoller) {
        var activeRoller = currentRoller && this._rollers[currentRoller.type];
        $.each(this._rollers, function() {
            this.toggleActiveState(this === activeRoller)
        })
    },
    _updateRollersPosition: function() {
        var that = this;
        $.each(this._rollers, function(type) {
            var correctIndex = that._rollerConfigs[type].getIndex(that._getCurrentDate());
            this.option("selectedIndex", correctIndex)
        })
    },
    _setRollerState: function(roller, selectedIndex) {
        if (selectedIndex !== roller.selectedIndex) {
            var rollerValue = roller.valueItems[selectedIndex],
                setValue = roller.setValue,
                currentValue = new Date(this._getCurrentDate()),
                currentDate = currentValue.getDate();
            if (roller.type === ROLLER_TYPE.month) {
                currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(currentValue.getFullYear(), rollerValue))
            } else {
                if (roller.type === ROLLER_TYPE.year) {
                    currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(rollerValue, currentValue.getMonth()))
                }
            }
            currentValue.setDate(currentDate);
            currentValue[setValue](rollerValue);
            currentValue = dateUtils.normalizeDate(currentValue, this.option("minDate"), this.option("maxDate"));
            this.option("value", currentValue);
            roller.selectedIndex = selectedIndex
        }
        if (roller.type === ROLLER_TYPE.year) {
            this._refreshMonthRoller();
            this._refreshDayRoller()
        }
        if (roller.type === ROLLER_TYPE.month) {
            this._refreshDayRoller()
        }
    },
    _refreshMonthRoller: function() {
        var monthRoller = this._rollers[ROLLER_TYPE.month];
        if (monthRoller) {
            this._createRollerConfig(ROLLER_TYPE.month);
            var monthRollerConfig = this._rollerConfigs[ROLLER_TYPE.month];
            if (monthRollerConfig.displayItems.length !== monthRoller.option("items").length) {
                monthRoller.option({
                    items: monthRollerConfig.displayItems,
                    selectedIndex: monthRollerConfig.selectedIndex
                })
            }
        }
    },
    _refreshDayRoller: function() {
        var dayRoller = this._rollers[ROLLER_TYPE.day];
        if (dayRoller) {
            this._createRollerConfig(ROLLER_TYPE.day);
            var dayRollerConfig = this._rollerConfigs[ROLLER_TYPE.day];
            dayRoller.option({
                items: dayRollerConfig.displayItems,
                selectedIndex: dayRollerConfig.selectedIndex
            })
        }
    },
    _getCurrentDate: function() {
        var curDate = this._valueOption(),
            minDate = this.option("minDate"),
            maxDate = this.option("maxDate");
        if (minDate && curDate.getTime() <= minDate.getTime()) {
            curDate = minDate
        } else {
            if (maxDate && curDate.getTime() >= maxDate.getTime()) {
                curDate = maxDate
            }
        }
        return curDate
    },
    _calculateRollerConfigValueRange: function(componentName) {
        var curDate = this._getCurrentDate(),
            minDate = this.option("minDate"),
            maxDate = this.option("maxDate"),
            minYear = dateUtils.sameYear(curDate, minDate),
            minMonth = minYear && curDate.getMonth() === minDate.getMonth(),
            maxYear = dateUtils.sameYear(curDate, maxDate),
            maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth(),
            componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
            startValue = componentInfo.startValue,
            endValue = componentInfo.endValue;
        if (componentName === ROLLER_TYPE.year) {
            startValue = minDate.getFullYear();
            endValue = maxDate.getFullYear()
        }
        if (componentName === ROLLER_TYPE.month) {
            if (minYear) {
                startValue = minDate.getMonth()
            }
            if (maxYear) {
                endValue = maxDate.getMonth()
            }
        }
        if (componentName === ROLLER_TYPE.day) {
            endValue = uiDateUtils.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
            if (minYear && minMonth) {
                startValue = minDate.getDate()
            }
            if (maxYear && maxMonth) {
                endValue = maxDate.getDate()
            }
        }
        return {
            startValue: startValue,
            endValue: endValue
        }
    },
    _refreshRollers: function() {
        this._refreshMonthRoller();
        this._refreshDayRoller()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "showNames":
            case "minDate":
            case "maxDate":
            case "type":
                this._renderRollers();
                this._toggleFormatClasses(args.value, args.previousValue);
                break;
            case "visible":
                this.callBase(args);
                if (args.value) {
                    this._renderRollers()
                }
                break;
            case "value":
                this.option("value", this._valueOption());
                this._refreshRollers();
                this._updateRollersPosition();
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        this.callBase();
        delete this._$rollersContainer
    },
    _dispose: function() {
        clearTimeout(this._deferredRenderDayTimeout);
        clearTimeout(this._deferredRenderMonthTimeout);
        this.callBase()
    }
});
registerComponent("dxDateView", DateView);
module.exports = DateView;


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_view_roller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3),
    clickEvent = __webpack_require__(11),
    Scrollable = __webpack_require__(70),
    fx = __webpack_require__(22),
    translator = __webpack_require__(19);
var DATEVIEW_ROLLER_CLASS = "dx-dateviewroller",
    DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active",
    DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateviewroller-current",
    DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item",
    DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected",
    DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame",
    DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border";
var DateViewRoller = Scrollable.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            showScrollbar: false,
            useNative: false,
            selectedIndex: 0,
            bounceEnabled: false,
            items: [],
            showOnClick: false,
            onClick: null,
            onSelectedIndexChanged: null
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(device) {
                return "win" === device.platform && device.version && 8 === device.version[0]
            },
            options: {
                showOnClick: true
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                scrollByContent: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._renderSelectedItemFrame()
    },
    _render: function() {
        this.callBase();
        this.element().addClass(DATEVIEW_ROLLER_CLASS);
        this._renderContainerClick();
        this._renderItems();
        this._renderSelectedValue();
        this._renderItemsClick();
        this._wrapAction("_endAction", this._endActionHandler.bind(this));
        this._renderSelectedIndexChanged()
    },
    _renderSelectedIndexChanged: function() {
        this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged")
    },
    _renderContainerClick: function() {
        if (!this.option("showOnClick")) {
            return
        }
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        var clickAction = this._createActionByOption("onClick");
        this._$container.off(eventName).on(eventName, function(e) {
            clickAction({
                jQueryEvent: e
            })
        })
    },
    _wrapAction: function(actionName, callback) {
        var strategy = this._strategy,
            originalAction = strategy[actionName];
        strategy[actionName] = function() {
            callback.apply(this, arguments);
            return originalAction.apply(this, arguments)
        }
    },
    _renderItems: function() {
        var items = this.option("items") || [],
            $items = $();
        this._$content.empty();
        $.each(items, function() {
            $items = $items.add($("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(this))
        });
        this._$content.append($items);
        this._$items = $items;
        this.update()
    },
    _renderSelectedItemFrame: function() {
        $("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append($("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container)
    },
    _renderSelectedValue: function(selectedIndex) {
        var index = this._fitIndex(selectedIndex || this.option("selectedIndex"));
        this._moveTo({
            top: this._getItemPosition(index)
        });
        this._renderActiveStateItem()
    },
    _fitIndex: function(index) {
        var items = this.option("items") || [],
            itemCount = items.length;
        if (index >= itemCount) {
            return itemCount - 1
        }
        if (index < 0) {
            return 0
        }
        return index
    },
    _getItemPosition: function(index) {
        return Math.round(this._itemHeight() * index)
    },
    _renderItemsClick: function() {
        var itemSelector = this._getItemSelector(),
            eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        this.element().off(eventName, itemSelector);
        this.element().on(eventName, itemSelector, this._itemClickHandler.bind(this))
    },
    _getItemSelector: function() {
        return "." + DATEVIEW_ROLLER_ITEM_CLASS
    },
    _itemClickHandler: function(e) {
        this.option("selectedIndex", this._itemElementIndex(e.currentTarget))
    },
    _itemElementIndex: function(itemElement) {
        return this._itemElements().index(itemElement)
    },
    _itemElements: function() {
        return this.element().find(this._getItemSelector())
    },
    _renderActiveStateItem: function() {
        var selectedIndex = this.option("selectedIndex");
        $.each(this._$items, function(index) {
            $(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index)
        })
    },
    _moveTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        var location = this._location(),
            delta = {
                x: -(location.left - targetLocation.left),
                y: -(location.top - targetLocation.top)
            };
        if (this._isVisible() && (delta.x || delta.y)) {
            this._strategy._prepareDirections(true);
            if (this._animation) {
                var that = this;
                fx.stop(this._$content);
                fx.animate(this._$content, {
                    duration: 200,
                    type: "slide",
                    to: {
                        top: Math.floor(delta.y)
                    },
                    complete: function() {
                        translator.resetPosition(that._$content);
                        that._strategy.handleMove({
                            delta: delta
                        })
                    }
                });
                delete this._animation
            } else {
                this._strategy.handleMove({
                    delta: delta
                })
            }
        }
    },
    _validate: function(e) {
        return this._strategy.validate(e)
    },
    _endActionHandler: function() {
        var currentSelectedIndex = this.option("selectedIndex"),
            ratio = -this._location().top / this._itemHeight(),
            newSelectedIndex = Math.round(ratio);
        this._animation = true;
        if (newSelectedIndex === currentSelectedIndex) {
            this._renderSelectedValue(newSelectedIndex)
        } else {
            this.option("selectedIndex", newSelectedIndex)
        }
    },
    _itemHeight: function() {
        var $item = this._$items.first();
        return $item.get(0) && $item.get(0).getBoundingClientRect().height || 0
    },
    _toggleActive: function(state) {
        this.element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state)
    },
    _isVisible: function() {
        return this._$container.is(":visible")
    },
    _fireSelectedIndexChanged: function(value, previousValue) {
        this._selectedIndexChanged({
            value: value,
            previousValue: previousValue,
            jQueryEvent: void 0
        })
    },
    _visibilityChanged: function(visible) {
        this.callBase(visible);
        if (visible) {
            this._renderSelectedValue(this.option("selectedIndex"))
        }
        this.toggleActiveState(false)
    },
    toggleActiveState: function(state) {
        this.element().toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, state)
    },
    _refreshSelectedIndex: function() {
        var selectedIndex = this.option("selectedIndex");
        var fitIndex = this._fitIndex(selectedIndex);
        fitIndex === selectedIndex ? this._renderActiveStateItem() : this.option("selectedIndex", fitIndex)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "selectedIndex":
                this._fireSelectedIndexChanged(args.value, args.previousValue);
                this._renderSelectedValue(args.value);
                break;
            case "items":
                this._renderItems();
                this._refreshSelectedIndex();
                break;
            case "onClick":
            case "showOnClick":
                this._renderContainerClick();
                break;
            case "onSelectedIndexChanged":
                this._renderSelectedIndexChanged();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxDateViewRoller", DateViewRoller);
module.exports = DateViewRoller;


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.native.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var noop = __webpack_require__(2).noop,
    DateBoxStrategy = __webpack_require__(127),
    support = __webpack_require__(24),
    inArray = __webpack_require__(7).inArray,
    dateUtils = __webpack_require__(100),
    dateSerialization = __webpack_require__(71);
var NativeStrategy = DateBoxStrategy.inherit({
    NAME: "Native",
    popupConfig: noop,
    getParsedText: function(text) {
        if (!text) {
            return null
        }
        if ("datetime" === this.dateBox.option("type")) {
            return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0])
        }
        return dateUtils.fromStandardDateFormat(text)
    },
    renderPopupContent: noop,
    _getWidgetName: noop,
    _getWidgetOptions: noop,
    _getDateBoxType: function() {
        var type = this.dateBox.option("type");
        if (inArray(type, dateUtils.SUPPORTED_FORMATS) === -1) {
            type = "date"
        } else {
            if ("datetime" === type && !support.inputType(type)) {
                type = "datetime-local"
            }
        }
        return type
    },
    getDefaultOptions: function() {
        return {
            mode: this._getDateBoxType()
        }
    },
    getDisplayFormat: function(displayFormat) {
        var type = this._getDateBoxType();
        return displayFormat || dateUtils.FORMATS_MAP[type]
    },
    renderInputMinMax: function($input) {
        $input.attr({
            min: dateSerialization.serializeDate(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
            max: dateSerialization.serializeDate(this.dateBox.dateOption("max"), "yyyy-MM-dd")
        })
    }
});
module.exports = NativeStrategy;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar_with_time.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    CalendarStrategy = __webpack_require__(201),
    TimeView = __webpack_require__(321),
    extend = __webpack_require__(1).extend,
    Box = __webpack_require__(154);
var SHRINK_VIEW_SCREEN_WIDTH = 573,
    DATEBOX_ADAPTIVITY_MODE_CLASS = "dx-datebox-adaptivity-mode";
var CalendarWithTimeStrategy = CalendarStrategy.inherit({
    NAME: "CalendarWithTime",
    getDefaultOptions: function() {
        return extend(this.callBase(), {
            applyValueMode: "useButtons",
            buttonsLocation: "bottom after",
            showPopupTitle: false
        })
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdateshorttime"
    },
    _renderWidget: function() {
        this.callBase();
        this._timeView = this.dateBox._createComponent($("<div>"), TimeView, {
            value: this.dateBoxValue(),
            _showClock: !this._isShrinkView(),
            onValueChanged: this._valueChangedHandler.bind(this)
        })
    },
    renderOpenedState: function() {
        this.callBase();
        var popup = this._getPopup();
        if (popup) {
            popup._wrapper().toggleClass(DATEBOX_ADAPTIVITY_MODE_CLASS, this._isSmallScreen())
        }
        clearTimeout(this._repaintTimer);
        this._repaintTimer = setTimeout(function() {
            this._getPopup() && this._getPopup().repaint()
        }.bind(this), 0)
    },
    isAdaptivityChanged: function() {
        var isAdaptiveMode = this._isShrinkView();
        if (isAdaptiveMode !== this._currentAdaptiveMode) {
            this._currentAdaptiveMode = isAdaptiveMode;
            return true
        }
        return this.callBase()
    },
    _updateValue: function(preventDefaultValue) {
        var date = this.dateBoxValue();
        if (!date && !preventDefaultValue) {
            date = new Date
        }
        this.callBase();
        if (this._timeView && date) {
            this._timeView.option("value", date)
        }
    },
    _isSmallScreen: function() {
        return $(window).width() <= SHRINK_VIEW_SCREEN_WIDTH
    },
    _isShrinkView: function() {
        return this.dateBox.option("adaptivityEnabled") && this._isSmallScreen()
    },
    _getBoxItems: function() {
        var items = [{
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            name: "calendar"
        }];
        if (!this._isShrinkView()) {
            items.push({
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                name: "time"
            })
        }
        return items
    },
    renderPopupContent: function() {
        this.callBase();
        this._currentAdaptiveMode = this._isShrinkView();
        var $popupContent = this._getPopup().content();
        this._box = this.dateBox._createComponent($("<div>").appendTo($popupContent), Box, {
            direction: "row",
            crossAlign: "start",
            items: this._getBoxItems(),
            itemTemplate: function(data) {
                var $container = $("<div>");
                switch (data.name) {
                    case "calendar":
                        $container.append(this._widget.element());
                        if (this._isShrinkView()) {
                            $container.append(this._timeView.element())
                        }
                        break;
                    case "time":
                        $container.append(this._timeView.element())
                }
                return $container
            }.bind(this)
        });
        this._attachTabHandler()
    },
    popupConfig: function(popupConfig) {
        var calendarPopupConfig = this.callBase(popupConfig),
            result = extend(calendarPopupConfig, {
                onShowing: function() {
                    if ("fallback" === this._box.option("_layoutStrategy")) {
                        var clockMinWidth = this._getPopup().content().find(".dx-timeview-clock").css("minWidth");
                        this._timeView.element().css("width", clockMinWidth)
                    }
                }.bind(this)
            });
        return result
    },
    getFirstPopupElement: function() {
        return this._timeView._hourBox.element().find("input")
    },
    _attachTabHandler: function() {
        var dateBox = this.dateBox,
            handler = function(e) {
                if (e.shiftKey) {
                    e.preventDefault();
                    dateBox.focus()
                }
            };
        this._timeView._hourBox.registerKeyHandler("tab", handler)
    },
    _preventFocusOnPopup: function(e) {
        if (!$(e.target).hasClass("dx-texteditor-input")) {
            this.callBase.apply(this, arguments);
            if (!this.dateBox._hasFocusClass()) {
                this.dateBox.focus()
            }
        }
    },
    getValue: function() {
        var date = this._widget.option("value"),
            time = this._timeView.option("value");
        date = date ? new Date(date) : new Date;
        date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
        return date
    },
    dispose: function() {
        clearTimeout(this._removeMinWidthTimer);
        clearTimeout(this._repaintTimer);
        this.callBase()
    }
});
module.exports = CalendarWithTimeStrategy;


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.time_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Editor = __webpack_require__(33),
    NumberBox = __webpack_require__(81),
    Box = __webpack_require__(154),
    extend = __webpack_require__(1).extend,
    registerComponent = __webpack_require__(4),
    dateLocalization = __webpack_require__(32);
var TIMEVIEW_CLASS = "dx-timeview",
    TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock",
    TIMEVIEW_FIELD_CLASS = "dx-timeview-field",
    TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow",
    TIMEVIEW_TIME_SEPARATOR_CLASS = "dx-timeview-time-separator",
    TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
var rotateArrow = function($arrow, angle, offset) {
    cssRotate($arrow, angle, offset)
};
var cssRotate = function($arrow, angle, offset) {
    $arrow.css("transform", "rotate(" + angle + "deg) translate(0," + offset + "px)")
};
var TimeView = Editor.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: new Date($.now()),
            _showClock: true,
            _arrowOffset: 0
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "android"
            },
            options: {
                _arrowOffset: 15
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                _arrowOffset: 5
            }
        }])
    },
    _getValue: function() {
        return this.option("value") || new Date
    },
    _init: function() {
        this.callBase();
        this.element().addClass(TIMEVIEW_CLASS)
    },
    _render: function() {
        this.callBase();
        this._renderBox();
        this._updateTime()
    },
    _renderBox: function() {
        var $box = $("<div>").appendTo(this.element()),
            items = [];
        if (this.option("_showClock")) {
            items.push({
                ratio: 1,
                shrink: 0,
                baseSize: "auto",
                template: this._renderClock.bind(this)
            })
        }
        items.push({
            ratio: 0,
            shrink: 0,
            baseSize: 50,
            template: this._renderField.bind(this)
        });
        this._createComponent($box, Box, {
            height: "100%",
            width: "100%",
            direction: "col",
            items: items
        })
    },
    _renderClock: function(_, __, $container) {
        this._$hourArrow = $("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
        this._$minuteArrow = $("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
        $container.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow);
        this.setAria("role", "presentation", $container)
    },
    _updateClock: function() {
        var time = this._getValue(),
            hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30,
            minuteArrowAngle = time.getMinutes() / 60 * 360;
        rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
        rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"))
    },
    _renderField: function() {
        this._createHourBox();
        this._createMinuteBox();
        return this._createComponent($("<div>").addClass(TIMEVIEW_FIELD_CLASS), Box, {
            direction: "row",
            align: "center",
            crossAlign: "center",
            items: [{
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                template: function() {
                    return this._hourBox.element()
                }.bind(this)
            }, {
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                template: $("<div>", {
                    "class": TIMEVIEW_TIME_SEPARATOR_CLASS
                }).text(dateLocalization.getTimeSeparator())
            }, {
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                template: function() {
                    return this._minuteBox.element()
                }.bind(this)
            }]
        }).element()
    },
    _createHourBox: function() {
        this._hourBox = this._createComponent($("<div>"), NumberBox, extend({
            min: -1,
            max: 24,
            value: this._getValue().getHours(),
            onValueChanged: function(args) {
                var newHours = (24 + args.value) % 24;
                this._hourBox.option("value", newHours);
                var time = new Date(this._getValue());
                time.setHours(newHours);
                this.option("value", time)
            }.bind(this)
        }, this._getNumberBoxConfig()));
        this._hourBox.setAria("label", "hours")
    },
    _createMinuteBox: function() {
        this._minuteBox = this._createComponent($("<div>"), NumberBox, extend({
            min: -1,
            max: 60,
            value: this._getValue().getMinutes(),
            onValueChanged: function(args) {
                var newMinutes = (60 + args.value) % 60;
                this._minuteBox.option("value", newMinutes);
                var time = new Date(this._getValue());
                time.setMinutes(newMinutes);
                this.option("value", time)
            }.bind(this)
        }, this._getNumberBoxConfig()));
        this._minuteBox.setAria("label", "minutes")
    },
    _getNumberBoxConfig: function() {
        return {
            showSpinButtons: true,
            disabled: this.option("disabled"),
            valueFormat: function(value) {
                return (value < 10 ? "0" : "") + value
            }
        }
    },
    _updateField: function() {
        this._hourBox && this._hourBox.option("value", this._getValue().getHours());
        this._minuteBox && this._minuteBox.option("value", this._getValue().getMinutes())
    },
    _updateTime: function() {
        if (this.option("_showClock")) {
            this._updateClock()
        }
        this._updateField()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateTime()
        }
    },
    _toggleDisabledState: function(value) {
        this._hourBox && this._hourBox.option("disabled", value);
        this._minuteBox && this._minuteBox.option("disabled", value)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "value":
                this._updateTime();
                this.callBase(args);
                break;
            case "_arrowOffset":
                break;
            case "_showClock":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxTimeView", TimeView);
module.exports = TimeView;


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.list.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    List = __webpack_require__(79),
    DateBoxStrategy = __webpack_require__(127),
    devices = __webpack_require__(6),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    dateUtils = __webpack_require__(100),
    dateLocalization = __webpack_require__(32);
var BOUNDARY_VALUES = {
    min: new Date(0, 0, 0, 0, 0),
    max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = DateBoxStrategy.inherit({
    NAME: "List",
    supportedKeys: function() {
        return {
            tab: function() {
                if (this.option("opened")) {
                    this.close()
                }
            },
            space: commonUtils.noop,
            home: commonUtils.noop,
            end: commonUtils.noop
        }
    },
    getDefaultOptions: function() {
        return extend(this.callBase(), {
            applyValueMode: "instantly"
        })
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shorttime"
    },
    popupConfig: function(popupConfig) {
        var device = devices.current(),
            result = extend(popupConfig, {
                width: this._getPopupWidth()
            });
        if ("android" === device.platform) {
            extend(result, {
                position: {
                    offset: {
                        h: -16,
                        v: -10
                    }
                }
            })
        }
        return result
    },
    useCurrentDateByDefault: function() {
        return true
    },
    _getPopupWidth: function() {
        var device = devices.current(),
            result = this.dateBox.element().outerWidth();
        if ("android" === device.platform) {
            result += 32
        }
        return result
    },
    popupShowingHandler: function() {
        this._dimensionChanged()
    },
    _renderWidget: function() {
        this.callBase();
        this._refreshItems()
    },
    _getWidgetName: function() {
        return List
    },
    _getWidgetOptions: function() {
        var keyboardProcessor = this.dateBox._keyboardProcessor;
        return {
            _keyboardProcessor: keyboardProcessor ? keyboardProcessor.attachChildProcessor() : null,
            itemTemplate: this._timeListItemTemplate.bind(this),
            onItemClick: this._listItemClickHandler.bind(this),
            tabIndex: -1,
            onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
            selectionMode: "single"
        }
    },
    _refreshActiveDescendant: function(e) {
        this.dateBox.setAria("activedescendant", "");
        this.dateBox.setAria("activedescendant", e.actionValue)
    },
    _refreshItems: function() {
        this._widgetItems = this._getTimeListItems();
        this._widget.option("items", this._widgetItems)
    },
    renderOpenedState: function() {
        if (!this._widget) {
            return
        }
        this._widget.option("focusedElement", null);
        this._setSelectedItemsByValue();
        if (this._widget.option("templatesRenderAsynchronously")) {
            this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this))
        } else {
            this._scrollToSelectedItem()
        }
    },
    dispose: function() {
        this.callBase();
        clearTimeout(this._asyncScrollTimeout)
    },
    _updateValue: function() {
        if (!this._widget) {
            return
        }
        this._refreshItems();
        this._setSelectedItemsByValue();
        this._scrollToSelectedItem()
    },
    _setSelectedItemsByValue: function() {
        var value = this.dateBoxValue();
        var dateIndex = this._getDateIndex(value);
        if (dateIndex === -1) {
            this._widget.option("selectedItems", [])
        } else {
            this._widget.option("selectedIndex", dateIndex)
        }
    },
    _scrollToSelectedItem: function() {
        this._widget.scrollToItem(this._widget.option("selectedIndex"))
    },
    _getDateIndex: function(date) {
        var result = -1;
        for (var i = 0, n = this._widgetItems.length; i < n; i++) {
            if (this._areDatesEqual(date, this._widgetItems[i])) {
                result = i;
                break
            }
        }
        return result
    },
    _areDatesEqual: function(first, second) {
        return commonUtils.isDate(first) && commonUtils.isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes()
    },
    _getTimeListItems: function() {
        var min = this.dateBox.dateOption("min") || this._getBoundaryDate("min"),
            max = this.dateBox.dateOption("max") || this._getBoundaryDate("max"),
            value = this.dateBox.dateOption("value") || null,
            delta = max - min,
            minutes = min.getMinutes() % this.dateBox.option("interval");
        if (delta < 0) {
            return []
        }
        if (delta > dateUtils.ONE_DAY) {
            delta = dateUtils.ONE_DAY
        }
        if (value - min < dateUtils.ONE_DAY) {
            return this._getRangeItems(min, new Date(min), delta)
        }
        min = this._getBoundaryDate("min");
        min.setMinutes(minutes);
        if (value && Math.abs(value - max) < dateUtils.ONE_DAY) {
            delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * dateUtils.ONE_MINUTE
        }
        return this._getRangeItems(min, new Date(min), delta)
    },
    _getRangeItems: function(startValue, currentValue, rangeDuration) {
        var rangeItems = [];
        var interval = this.dateBox.option("interval");
        while (currentValue - startValue < rangeDuration) {
            rangeItems.push(new Date(currentValue));
            currentValue.setMinutes(currentValue.getMinutes() + interval)
        }
        return rangeItems
    },
    _getBoundaryDate: function(boundary) {
        var boundaryValue = BOUNDARY_VALUES[boundary],
            currentValue = this.dateBox.dateOption("value") || new Date;
        return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes())
    },
    _timeListItemTemplate: function(itemData) {
        var displayFormat = this.dateBox.option("displayFormat");
        return dateLocalization.format(itemData, this.getDisplayFormat(displayFormat))
    },
    _listItemClickHandler: function(e) {
        this.dateBox.option("opened", false);
        var date = this.dateBox.option("value");
        date = date ? new Date(date) : new Date;
        date.setHours(e.itemData.getHours());
        date.setMinutes(e.itemData.getMinutes());
        date.setSeconds(e.itemData.getSeconds());
        this.dateBoxValue(date)
    },
    attachKeyboardEvents: function(keyboardProcessor) {
        var child = keyboardProcessor.attachChildProcessor();
        if (this._widget) {
            this._widget.option("_keyboardProcessor", child)
        }
    },
    _dimensionChanged: function() {
        this._getPopup() && this._updatePopupDimensions()
    },
    _updatePopupDimensions: function() {
        this._updatePopupWidth();
        this._updatePopupHeight()
    },
    _updatePopupWidth: function() {
        this.dateBox._setPopupOption("width", this._getPopupWidth())
    },
    _updatePopupHeight: function() {
        this.dateBox._setPopupOption("height", "auto");
        var popupHeight = this._widget.element().outerHeight();
        var maxHeight = .45 * $(window).height();
        this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
        this.dateBox._timeList && this.dateBox._timeList.updateDimensions()
    }
});
module.exports = ListStrategy;


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/defer_rendering.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    domUtils = __webpack_require__(15),
    TransitionExecutorModule = __webpack_require__(88),
    Widget = __webpack_require__(27),
    LoadIndicator = __webpack_require__(53);
var WIDGET_CLASS = "dx-widget",
    DEFER_RENDERING_CLASS = "dx-deferrendering",
    PENDING_RENDERING_CLASS = "dx-pending-rendering",
    PENDING_RENDERING_MANUAL_CLASS = "dx-pending-rendering-manual",
    PENDING_RENDERING_ACTIVE_CLASS = "dx-pending-rendering-active",
    VISIBLE_WHILE_PENDING_RENDERING_CLASS = "dx-visible-while-pending-rendering",
    INVISIBLE_WHILE_PENDING_RENDERING_CLASS = "dx-invisible-while-pending-rendering",
    LOADINDICATOR_CONTAINER_CLASS = "dx-loadindicator-container",
    DEFER_RENDERING_LOADINDICATOR_CONTAINER_CLASS = "dx-deferrendering-loadindicator-container",
    DEFER_DEFER_RENDERING_LOAD_INDICATOR = "dx-deferrendering-load-indicator",
    ANONYMOUS_TEMPLATE_NAME = "content",
    ACTIONS = ["onRendered", "onShown"];
var DeferRendering = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            showLoadIndicator: false,
            renderWhen: void 0,
            animation: void 0,
            staggerItemSelector: void 0,
            onRendered: null,
            onShown: null
        })
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _init: function() {
        this.transitionExecutor = new TransitionExecutorModule.TransitionExecutor;
        this._initElement();
        this._initRender();
        this._$initialContent = this.element().clone().contents();
        this._initActions();
        this.callBase()
    },
    _initElement: function() {
        this.element().addClass(DEFER_RENDERING_CLASS)
    },
    _initRender: function() {
        var that = this,
            $element = this.element(),
            renderWhen = this.option("renderWhen");
        var doRender = function() {
            return that._renderDeferredContent()
        };
        if (renderWhen && renderWhen.done) {
            renderWhen.done(doRender)
        } else {
            $element.data("dx-render-delegate", doRender);
            if (void 0 === renderWhen) {
                $element.addClass(PENDING_RENDERING_MANUAL_CLASS)
            }
        }
    },
    _initActions: function() {
        this._actions = {};
        $.each(ACTIONS, function(_, action) {
            this._actions[action] = this._createActionByOption(action) || commonUtils.noop
        }.bind(this))
    },
    _renderContentImpl: function() {
        this.element().removeClass(WIDGET_CLASS);
        this.element().append(this._$initialContent);
        this._setLoadingState()
    },
    _renderDeferredContent: function() {
        var that = this,
            $element = this.element(),
            result = $.Deferred();
        $element.removeClass(PENDING_RENDERING_MANUAL_CLASS);
        $element.addClass(PENDING_RENDERING_ACTIVE_CLASS);
        this._renderTask = commonUtils.executeAsync(function() {
            that._renderImpl().done(function() {
                var shownArgs = {
                    element: $element
                };
                that._actions.onShown([shownArgs]);
                result.resolve(shownArgs)
            }).fail(function() {
                result.rejectWith(result, arguments)
            })
        });
        return result.promise()
    },
    _isElementInViewport: function(element) {
        var rect = element.getBoundingClientRect();
        return rect.bottom >= 0 && rect.right >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth)
    },
    _animate: function() {
        var animatePromise, that = this,
            $element = this.element(),
            animation = this.option("animation"),
            staggerItemSelector = this.option("staggerItemSelector");
        that.transitionExecutor.stop();
        if (animation) {
            if (staggerItemSelector) {
                $element.find(staggerItemSelector).each(function() {
                    if (that._isElementInViewport(this)) {
                        that.transitionExecutor.enter($(this), animation)
                    }
                })
            } else {
                that.transitionExecutor.enter($element, animation)
            }
            animatePromise = that.transitionExecutor.start()
        } else {
            animatePromise = $.Deferred().resolve().promise()
        }
        return animatePromise
    },
    _renderImpl: function() {
        var $element = this.element(),
            renderedArgs = {
                element: $element
            };
        var contentTemplate = this._getTemplate(this._getAnonymousTemplateName());
        if (contentTemplate) {
            contentTemplate.render({
                container: $element.empty(),
                noModel: true
            })
        }
        this._setRenderedState($element);
        $element.trigger("dxcontentrendered");
        this._actions.onRendered([renderedArgs]);
        this._isRendered = true;
        return this._animate()
    },
    _setLoadingState: function() {
        var $element = this.element(),
            hasCustomLoadIndicator = !!$element.find("." + VISIBLE_WHILE_PENDING_RENDERING_CLASS).length;
        $element.addClass(PENDING_RENDERING_CLASS);
        if (!hasCustomLoadIndicator) {
            $element.children().addClass(INVISIBLE_WHILE_PENDING_RENDERING_CLASS)
        }
        if (this.option("showLoadIndicator")) {
            this._showLoadIndicator($element)
        }
    },
    _showLoadIndicator: function($container) {
        this._$loadIndicator = new LoadIndicator($("<div/>"), {
            visible: true
        }).element().addClass(DEFER_DEFER_RENDERING_LOAD_INDICATOR);
        $("<div/>").addClass(LOADINDICATOR_CONTAINER_CLASS).addClass(DEFER_RENDERING_LOADINDICATOR_CONTAINER_CLASS).append(this._$loadIndicator).appendTo($container)
    },
    _setRenderedState: function() {
        var $element = this.element();
        if (this._$loadIndicator) {
            this._$loadIndicator.remove()
        }
        $element.removeClass(PENDING_RENDERING_CLASS);
        $element.removeClass(PENDING_RENDERING_ACTIVE_CLASS);
        domUtils.triggerShownEvent($element.children())
    },
    _optionChanged: function(args) {
        var value = args.value,
            previousValue = args.previousValue;
        switch (args.name) {
            case "renderWhen":
                if (false === previousValue && true === value) {
                    this._renderOrAnimate()
                } else {
                    if (true === previousValue && false === value) {
                        this._setLoadingState()
                    }
                }
                break;
            case "showLoadIndicator":
            case "onRendered":
            case "onShown":
                break;
            default:
                this.callBase(args)
        }
    },
    _renderOrAnimate: function() {
        var result;
        if (this._isRendered) {
            this._setRenderedState();
            result = this._animate()
        } else {
            result = this._renderDeferredContent()
        }
        return result
    },
    renderContent: function() {
        return this._renderOrAnimate()
    },
    _dispose: function() {
        this.transitionExecutor.stop(true);
        if (this._renderTask) {
            this._renderTask.abort()
        }
        this._actions = null;
        this._$initialContent = null;
        this.callBase()
    }
});
registerComponent("dxDeferRendering", DeferRendering);
module.exports = DeferRendering;
module.exports.default = module.exports;


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/drop_down_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DropDownEditor = __webpack_require__(123),
    DataExpressionMixin = __webpack_require__(152),
    commonUtils = __webpack_require__(2),
    selectors = __webpack_require__(92),
    KeyboardProcessor = __webpack_require__(112),
    when = __webpack_require__(10).when,
    $ = __webpack_require__(0),
    grep = __webpack_require__(2).grep,
    extend = __webpack_require__(1).extend,
    registerComponent = __webpack_require__(4);
var DROP_DOWN_BOX_CLASS = "dx-dropdownbox",
    DIMENSION_DEPENDENT_OPTIONS = ["width", "height", "maxWidth", "maxHeight", "minWidth", "minHeight"];
var DropDownBox = DropDownEditor.inherit({
    _supportedKeys: function() {
        return extend({}, this.callBase(), {
            tab: function(e) {
                if (!this.option("opened")) {
                    return
                }
                var $tabbableElements = this._getTabbableElements(),
                    $focusableElement = e.shiftKey ? $tabbableElements.last() : $tabbableElements.first();
                $focusableElement && $focusableElement.focus();
                e.preventDefault()
            }
        })
    },
    _getTabbableElements: function() {
        return this._getElements().filter(selectors.tabbable)
    },
    _getElements: function() {
        return this.content().find("*")
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            acceptCustomValue: false,
            contentTemplate: null,
            dropDownOptions: {},
            openOnFieldClick: true,
            valueFormat: function(value) {
                return Array.isArray(value) ? value.join(", ") : value
            }
        })
    },
    _init: function() {
        this.callBase();
        this._initDataExpressions()
    },
    _render: function() {
        this._renderSubmitElement();
        this.callBase();
        this.element().addClass(DROP_DOWN_BOX_CLASS)
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _renderValue: function() {
        this._setSubmitValue();
        this.callBase()
    },
    _setSubmitValue: function() {
        var value = this.option("value"),
            submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value) : value;
        this._$submitElement.val(submitValue)
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _renderInputValue: function() {
        var callBase = this.callBase.bind(this),
            currentValue = this._getCurrentValue(),
            keys = commonUtils.ensureDefined(currentValue, []),
            values = [];
        keys = Array.isArray(keys) ? keys : [keys];
        var itemLoadDeferreds = $.map(keys, function(key) {
            return this._loadItem(key).always(function(item) {
                var displayValue = this._displayGetter(item);
                if (commonUtils.isDefined(displayValue)) {
                    values.push(displayValue)
                }
            }.bind(this))
        }.bind(this));
        when.apply(this, itemLoadDeferreds).done(function() {
            this.option("displayValue", values);
            callBase(values.length && values)
        }.bind(this)).fail(callBase);
        return itemLoadDeferreds
    },
    _loadItem: function(value) {
        var selectedItem = grep(this.option("items") || [], function(item) {
            return this._isValueEquals(this._valueGetter(item), value)
        }.bind(this))[0];
        return void 0 !== selectedItem ? $.Deferred().resolve(selectedItem).promise() : this._loadValue(value)
    },
    _clearValueHandler: function(e) {
        e.stopPropagation();
        this.reset()
    },
    _updatePopupWidth: function() {
        this._setPopupOption("width", this.element().outerWidth())
    },
    _dimensionChanged: function() {
        this._popup && !this.option("dropDownOptions.width") && this._updatePopupWidth()
    },
    _popupElementTabHandler: function(e) {
        if ("tab" !== e.key) {
            return
        }
        var $firstTabbable = this._getTabbableElements().first().get(0),
            $lastTabbable = this._getTabbableElements().last().get(0),
            $target = e.originalEvent.target,
            moveBackward = !!($target === $firstTabbable && e.shift),
            moveForward = !!($target === $lastTabbable && !e.shift);
        if (moveBackward || moveForward) {
            this.close();
            this._input().focus();
            if (moveBackward) {
                e.originalEvent.preventDefault()
            }
        }
    },
    _renderPopup: function(e) {
        this.callBase();
        if (this.option("focusStateEnabled")) {
            this._popup._keyboardProcessor.push(new KeyboardProcessor({
                element: this.content(),
                handler: this._popupElementTabHandler,
                context: this
            }))
        }
    },
    _popupConfig: function() {
        return extend(this.callBase(), {
            width: this.element().outerWidth(),
            height: "auto",
            tabIndex: -1,
            dragEnabled: false,
            focusStateEnabled: this.option("focusStateEnabled"),
            maxHeight: this._getMaxHeight.bind(this)
        }, this.option("dropDownOptions"))
    },
    _getMaxHeight: function() {
        var $element = this.element(),
            offsetTop = $element.offset().top - $(window).scrollTop(),
            offsetBottom = $(window).innerHeight() - offsetTop - $element.outerHeight(),
            maxHeight = .9 * Math.max(offsetTop, offsetBottom);
        return maxHeight
    },
    _popupShownHandler: function() {
        this.callBase();
        var $firstElement = this._getTabbableElements().first();
        $firstElement.focus()
    },
    _popupOptionChanged: function(args) {
        var options = {};
        if (args.name === args.fullName) {
            options = args.value
        } else {
            var option = args.fullName.split(".").pop();
            options[option] = args.value
        }
        this._setPopupOption(options);
        Object.keys(options).every(function(option) {
            if (DIMENSION_DEPENDENT_OPTIONS.indexOf(option) >= 0) {
                this._dimensionChanged();
                return false
            }
            return true
        }, this)
    },
    _setCollectionWidgetOption: commonUtils.noop,
    _optionChanged: function(args) {
        this._dataExpressionOptionChanged(args);
        switch (args.name) {
            case "width":
                this.callBase(args);
                this._dimensionChanged();
                break;
            case "dropDownOptions":
                this._popupOptionChanged(args);
                break;
            case "dataSource":
                this._renderInputValue();
                break;
            case "displayValue":
                this.option("text", args.value);
                break;
            case "displayExpr":
                this._renderValue();
                break;
            default:
                this.callBase(args)
        }
    }
}).include(DataExpressionMixin);
registerComponent("dxDropDownBox", DropDownBox);
module.exports = DropDownBox;
module.exports.default = module.exports;


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/file_uploader.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    Editor = __webpack_require__(33),
    Button = __webpack_require__(25),
    ProgressBar = __webpack_require__(202),
    browser = __webpack_require__(21),
    devices = __webpack_require__(6),
    eventUtils = __webpack_require__(3),
    clickEvent = __webpack_require__(11),
    messageLocalization = __webpack_require__(8);
var FILEUPLOADER_CLASS = "dx-fileuploader",
    FILEUPLOADER_EMPTY_CLASS = "dx-fileuploader-empty",
    FILEUPLOADER_SHOW_FILE_LIST_CLASS = "dx-fileuploader-show-file-list",
    FILEUPLOADER_DRAGOVER_CLASS = "dx-fileuploader-dragover",
    FILEUPLOADER_FILEINPUT_TAG = "<input type='file'>",
    FILEUPLOADER_WRAPPER_CLASS = "dx-fileuploader-wrapper",
    FILEUPLOADER_CONTAINER_CLASS = "dx-fileuploader-container",
    FILEUPLOADER_CONTENT_CLASS = "dx-fileuploader-content",
    FILEUPLOADER_INPUT_WRAPPER_CLASS = "dx-fileuploader-input-wrapper",
    FILEUPLOADER_INPUT_CONTAINER_CLASS = "dx-fileuploader-input-container",
    FILEUPLOADER_INPUT_LABEL_CLASS = "dx-fileuploader-input-label",
    FILEUPLOADER_INPUT_CLASS = "dx-fileuploader-input",
    FILEUPLOADER_FILES_CONTAINER_CLASS = "dx-fileuploader-files-container",
    FILEUPLOADER_FILE_CONTAINER_CLASS = "dx-fileuploader-file-container",
    FILEUPLOADER_FILE_INFO_CLASS = "dx-fileuploader-file-info",
    FILEUPLOADER_FILE_STATUS_MESSAGE_CLASS = "dx-fileuploader-file-status-message",
    FILEUPLOADER_FILE_CLASS = "dx-fileuploader-file",
    FILEUPLOADER_FILE_NAME_CLASS = "dx-fileuploader-file-name",
    FILEUPLOADER_FILE_SIZE_CLASS = "dx-fileuploader-file-size",
    FILEUPLOADER_BUTTON_CLASS = "dx-fileuploader-button",
    FILEUPLOADER_BUTTON_CONTAINER_CLASS = "dx-fileuploader-button-container",
    FILEUPLOADER_CANCEL_BUTTON_CLASS = "dx-fileuploader-cancel-button",
    FILEUPLOADER_UPLOAD_BUTTON_CLASS = "dx-fileuploader-upload-button",
    FILEUPLOADER_AFTER_LOAD_DELAY = 400;
var isFormDataSupported = function() {
    return !!window.FormData
};
var FileUploader = Editor.inherit({
    _supportedKeys: function() {
        var click = function(e) {
            e.preventDefault();
            var $selectButton = this._selectButton.element();
            $selectButton.trigger(clickEvent.name)
        };
        return extend(this.callBase(), {
            space: click,
            enter: click
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            value: true
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            buttonText: {
                since: "15.1",
                alias: "selectButtonText"
            },
            values: {
                since: "16.1",
                alias: "value"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: [],
            selectButtonText: messageLocalization.format("dxFileUploader-selectFile"),
            uploadButtonText: messageLocalization.format("dxFileUploader-upload"),
            labelText: messageLocalization.format("dxFileUploader-dropFile"),
            name: "files[]",
            multiple: false,
            accept: "",
            uploadUrl: "/",
            allowCanceling: true,
            showFileList: true,
            progress: 0,
            readyToUploadMessage: messageLocalization.format("dxFileUploader-readyToUpload"),
            uploadedMessage: messageLocalization.format("dxFileUploader-uploaded"),
            uploadFailedMessage: messageLocalization.format("dxFileUploader-uploadFailedMessage"),
            uploadMode: "instantly",
            uploadMethod: "POST",
            uploadHeaders: {},
            onUploadStarted: null,
            onUploaded: null,
            onProgress: null,
            onUploadError: null,
            onUploadAborted: null,
            extendSelection: true,
            validationMessageMode: "always",
            validationMessageOffset: {
                h: 0,
                v: 0
            },
            useNativeInputClick: false,
            useDragOver: true,
            nativeDropSupported: true
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: [{
                platform: "android"
            }, {
                platform: "win"
            }],
            options: {
                validationMessageOffset: {
                    v: 0
                }
            }
        }, {
            device: function() {
                return browser.msie && browser.version <= 10
            },
            options: {
                uploadMode: "useForm",
                useNativeInputClick: true
            }
        }, {
            device: function() {
                return "generic" !== devices.real().platform
            },
            options: {
                useDragOver: false
            }
        }, {
            device: function() {
                return !isFormDataSupported()
            },
            options: {
                uploadMode: "useForm"
            }
        }, {
            device: function() {
                return browser.msie || "generic" !== devices.real().platform
            },
            options: {
                nativeDropSupported: false
            }
        }])
    },
    _init: function() {
        this.callBase.apply(this, arguments);
        this._initFileInput();
        this._initLabel();
        this._createFiles();
        this._createUploadStartedAction();
        this._createUploadedAction();
        this._createProgressAction();
        this._createUploadErrorAction();
        this._createUploadAbortedAction()
    },
    _initFileInput: function() {
        this._isCustomClickEvent = false;
        if (!this._$fileInput) {
            this._$fileInput = $(FILEUPLOADER_FILEINPUT_TAG);
            this._$fileInput.on("change", this._inputChangeHandler.bind(this)).on("click", function(e) {
                e.stopPropagation();
                return this.option("useNativeInputClick") || this._isCustomClickEvent
            }.bind(this))
        }
        this._$fileInput.prop({
            multiple: this.option("multiple"),
            accept: this.option("accept"),
            tabindex: -1
        })
    },
    _inputChangeHandler: function() {
        if (this._doPreventInputChange) {
            return
        }
        var fileName = this._$fileInput.val().replace(/^.*\\/, ""),
            files = this._$fileInput.prop("files");
        if (files && !files.length) {
            return
        }
        var value = files ? this._getFiles(files) : [{
            name: fileName
        }];
        this._changeValue(value);
        if ("instantly" === this.option("uploadMode")) {
            this._uploadFiles()
        }
    },
    _shouldFileListBeExtended: function() {
        return "useForm" !== this.option("uploadMode") && this.option("extendSelection") && this.option("multiple")
    },
    _removeDuplicates: function(files, value) {
        var result = [];
        for (var i = 0; i < value.length; i++) {
            if (!this._isFileInArray(files, value[i])) {
                result.push(value[i])
            }
        }
        return result
    },
    _isFileInArray: function(files, file) {
        for (var i = 0; i < files.length; i++) {
            var item = files[i];
            if (item.size === file.size && item.name === file.name) {
                return true
            }
        }
        return false
    },
    _changeValue: function(value) {
        var files = this._shouldFileListBeExtended() ? this.option("value").slice() : [];
        if ("instantly" !== this.option("uploadMode")) {
            value = this._removeDuplicates(files, value)
        }
        this.option("value", files.concat(value))
    },
    _getFiles: function(fileList) {
        var values = [];
        $.each(fileList, function(_, value) {
            values.push(value)
        });
        return values
    },
    _initLabel: function() {
        if (!this._$inputLabel) {
            this._$inputLabel = $("<div>")
        }
        this._$inputLabel.text(this.option("labelText"))
    },
    _focusTarget: function() {
        return this.element().find("." + FILEUPLOADER_BUTTON_CLASS)
    },
    _getSubmitElement: function() {
        return this._$fileInput
    },
    _render: function() {
        this.element().addClass(FILEUPLOADER_CLASS);
        this._renderWrapper();
        this._renderInputWrapper();
        this._renderDragEvents();
        this._renderSelectButton();
        this._renderInputContainer();
        this._renderFiles();
        this._renderUploadButton();
        this.callBase.apply(this, arguments)
    },
    _createFiles: function() {
        var value = this.option("value");
        if (!this._files || 0 === value.length || !this._shouldFileListBeExtended()) {
            this._files = []
        }
        $.each(value.slice(this._files.length), function(_, value) {
            this._files.push(this._createFile(value))
        }.bind(this))
    },
    _createUploadStartedAction: function() {
        this._uploadStartedAction = this._createActionByOption("onUploadStarted")
    },
    _createUploadedAction: function() {
        this._uploadedAction = this._createActionByOption("onUploaded")
    },
    _createProgressAction: function() {
        this._progressAction = this._createActionByOption("onProgress")
    },
    _createUploadAbortedAction: function() {
        this._uploadAbortedAction = this._createActionByOption("onUploadAborted")
    },
    _createUploadErrorAction: function() {
        this._uploadErrorAction = this._createActionByOption("onUploadError")
    },
    _createFile: function(value) {
        return {
            value: value,
            loadedSize: 0,
            onProgress: $.Callbacks(),
            onAbort: $.Callbacks(),
            onLoad: $.Callbacks(),
            onError: $.Callbacks(),
            onLoadStart: $.Callbacks()
        }
    },
    _renderFiles: function() {
        var value = this.option("value");
        if (!this._$filesContainer) {
            this._$filesContainer = $("<div>").addClass(FILEUPLOADER_FILES_CONTAINER_CLASS).appendTo(this._$content)
        } else {
            if (!this._shouldFileListBeExtended() || 0 === value.length) {
                this._$filesContainer.empty()
            }
        }
        var showFileList = this.option("showFileList");
        if (showFileList) {
            var that = this;
            $.each(this._files, function(_, file) {
                if (!file.$file) {
                    that._renderFile(file)
                }
            })
        }
        this.element().toggleClass(FILEUPLOADER_SHOW_FILE_LIST_CLASS, showFileList);
        this.element().toggleClass(FILEUPLOADER_EMPTY_CLASS, !this._files.length);
        this._updateFileNameMaxWidth();
        this._$validationMessage && this._$validationMessage.dxOverlay("instance").repaint()
    },
    _renderFile: function(file) {
        var value = file.value;
        var $fileContainer = $("<div>").addClass(FILEUPLOADER_FILE_CONTAINER_CLASS).appendTo(this._$filesContainer);
        this._renderFileButtons(file, $fileContainer);
        file.$file = $("<div>").addClass(FILEUPLOADER_FILE_CLASS).appendTo($fileContainer);
        var $fileInfo = $("<div>").addClass(FILEUPLOADER_FILE_INFO_CLASS).appendTo(file.$file);
        file.$statusMessage = $("<div>").addClass(FILEUPLOADER_FILE_STATUS_MESSAGE_CLASS).text(this.option("readyToUploadMessage")).appendTo(file.$file);
        $("<div>").addClass(FILEUPLOADER_FILE_NAME_CLASS).text(value.name).appendTo($fileInfo);
        if (commonUtils.isDefined(value.size)) {
            $("<div>").addClass(FILEUPLOADER_FILE_SIZE_CLASS).text(this._getFileSize(value.size)).appendTo($fileInfo)
        }
    },
    _updateFileNameMaxWidth: function() {
        var cancelButtonsCount = this.option("allowCanceling") && "useForm" !== this.option("uploadMode") ? 1 : 0,
            uploadButtonsCount = "useButtons" === this.option("uploadMode") ? 1 : 0,
            filesContainerWidth = this._$filesContainer.width(),
            $buttonContainer = this._$filesContainer.find("." + FILEUPLOADER_BUTTON_CONTAINER_CLASS).eq(0),
            buttonsWidth = $buttonContainer.width() * (cancelButtonsCount + uploadButtonsCount),
            $fileSize = this._$filesContainer.find("." + FILEUPLOADER_FILE_SIZE_CLASS).eq(0);
        var prevFileSize = $fileSize.text();
        $fileSize.text("1000 Mb");
        var fileSizeWidth = $fileSize.width();
        $fileSize.text(prevFileSize);
        this._$filesContainer.find("." + FILEUPLOADER_FILE_NAME_CLASS).css("max-width", filesContainerWidth - buttonsWidth - fileSizeWidth)
    },
    _renderFileButtons: function(file, $container) {
        var $cancelButton = this._getCancelButton(file);
        $cancelButton && $container.append($cancelButton);
        var $uploadButton = this._getUploadButton(file);
        $uploadButton && $container.append($uploadButton)
    },
    _getCancelButton: function(file) {
        if ("useForm" === this.option("uploadMode")) {
            return null
        }
        file.cancelButton = this._createComponent($("<div>").addClass(FILEUPLOADER_BUTTON_CLASS + " " + FILEUPLOADER_CANCEL_BUTTON_CLASS), Button, {
            onClick: function() {
                this._removeFile(file)
            }.bind(this),
            icon: "close",
            visible: this.option("allowCanceling"),
            integrationOptions: {}
        });
        return $("<div>").addClass(FILEUPLOADER_BUTTON_CONTAINER_CLASS).append(file.cancelButton.element())
    },
    _getUploadButton: function(file) {
        if ("useButtons" !== this.option("uploadMode")) {
            return null
        }
        file.uploadButton = this._createComponent($("<div>").addClass(FILEUPLOADER_BUTTON_CLASS + " " + FILEUPLOADER_UPLOAD_BUTTON_CLASS), Button, {
            onClick: function() {
                this._uploadFile(file)
            }.bind(this),
            icon: "upload"
        });
        file.onLoadStart.add(function() {
            file.uploadButton.element().remove()
        }.bind(this));
        return $("<div>").addClass(FILEUPLOADER_BUTTON_CONTAINER_CLASS).append(file.uploadButton.element())
    },
    _removeFile: function(file) {
        file.$file.parent().remove();
        this._files.splice(inArray(file, this._files), 1);
        var value = this.option("value").slice();
        value.splice(inArray(file.value, value), 1);
        this._doPreventRecreatingFiles = true;
        this.option("value", value);
        this._doPreventRecreatingFiles = false;
        this.element().toggleClass(FILEUPLOADER_EMPTY_CLASS, !this._files.length);
        this._doPreventInputChange = true;
        this._$fileInput.val("");
        this._doPreventInputChange = false
    },
    _getFileSize: function(size) {
        var i = 0,
            labels = [messageLocalization.format("dxFileUploader-bytes"), messageLocalization.format("dxFileUploader-kb"), messageLocalization.format("dxFileUploader-Mb"), messageLocalization.format("dxFileUploader-Gb")],
            count = labels.length - 1;
        while (i < count && size >= 1024) {
            size /= 1024;
            i++
        }
        return Math.round(size) + " " + labels[i]
    },
    _renderSelectButton: function() {
        var $button = $("<div>").addClass(FILEUPLOADER_BUTTON_CLASS).appendTo(this._$inputWrapper);
        this._selectButton = this._createComponent($button, Button, {
            text: this.option("selectButtonText"),
            focusStateEnabled: false,
            integrationOptions: {}
        });
        if ("desktop" === devices.real().deviceType) {
            this._selectButton.option("onClick", this._selectButtonClickHandler.bind(this))
        } else {
            $button.off("click").on("click", this._selectButtonClickHandler.bind(this))
        }
    },
    _selectButtonClickHandler: function() {
        var that = this;
        if (that.option("useNativeInputClick")) {
            return
        }
        if (that.option("disabled")) {
            return false
        }
        that._isCustomClickEvent = true;
        that._$fileInput.trigger("click");
        that._isCustomClickEvent = false
    },
    _renderUploadButton: function() {
        if ("useButtons" !== this.option("uploadMode")) {
            return
        }
        var $uploadButton = $("<div>").addClass(FILEUPLOADER_BUTTON_CLASS).addClass(FILEUPLOADER_UPLOAD_BUTTON_CLASS).appendTo(this._$content);
        this._uploadButton = this._createComponent($uploadButton, Button, {
            text: this.option("uploadButtonText"),
            onClick: this._uploadButtonClickHandler.bind(this),
            integrationOptions: {}
        })
    },
    _uploadButtonClickHandler: function() {
        this._uploadFiles()
    },
    _shouldDragOverBeRendered: function() {
        return "useForm" !== this.option("uploadMode") || this.option("nativeDropSupported")
    },
    _renderInputContainer: function() {
        this._$inputContainer = $("<div>").addClass(FILEUPLOADER_INPUT_CONTAINER_CLASS).appendTo(this._$inputWrapper);
        if (!this._shouldDragOverBeRendered()) {
            this._$inputContainer.css("display", "none")
        }
        this._$fileInput.addClass(FILEUPLOADER_INPUT_CLASS);
        this._renderInput();
        this._$inputLabel.addClass(FILEUPLOADER_INPUT_LABEL_CLASS).appendTo(this._$inputContainer)
    },
    _renderInput: function() {
        if (this.option("useNativeInputClick")) {
            this._selectButton.option("template", this._selectButtonInputTemplate.bind(this))
        } else {
            this._$fileInput.appendTo(this._$inputContainer);
            this._selectButton.option("template", "content")
        }
    },
    _selectButtonInputTemplate: function(data, $content) {
        var $text = $("<span>").addClass("dx-button-text").text(data.text);
        $content.append($text).append(this._$fileInput);
        return $content
    },
    _renderInputWrapper: function() {
        this._$inputWrapper = $("<div>").addClass(FILEUPLOADER_INPUT_WRAPPER_CLASS).appendTo(this._$content)
    },
    _renderDragEvents: function() {
        this._$inputWrapper.off("." + this.NAME);
        if (!this._shouldDragOverBeRendered()) {
            return
        }
        this._dragEventsCount = 0;
        this._$inputWrapper.on(eventUtils.addNamespace("dragenter", this.NAME), this._dragEnterHandler.bind(this)).on(eventUtils.addNamespace("dragover", this.NAME), this._dragOverHandler.bind(this)).on(eventUtils.addNamespace("dragleave", this.NAME), this._dragLeaveHandler.bind(this)).on(eventUtils.addNamespace("drop", this.NAME), this._dropHandler.bind(this))
    },
    _useInputForDrop: function() {
        return this.option("nativeDropSupported") && "useForm" === this.option("uploadMode")
    },
    _dragEnterHandler: function(e) {
        if (this.option("disabled")) {
            return false
        }
        if (!this._useInputForDrop()) {
            e.preventDefault()
        }
        this._dragEventsCount++;
        this.element().addClass(FILEUPLOADER_DRAGOVER_CLASS)
    },
    _dragOverHandler: function(e) {
        if (!this._useInputForDrop()) {
            e.preventDefault()
        }
    },
    _dragLeaveHandler: function(e) {
        if (!this._useInputForDrop()) {
            e.preventDefault()
        }
        this._dragEventsCount--;
        if (this._dragEventsCount <= 0) {
            this.element().removeClass(FILEUPLOADER_DRAGOVER_CLASS)
        }
    },
    _dropHandler: function(e) {
        this._dragEventsCount = 0;
        this.element().removeClass(FILEUPLOADER_DRAGOVER_CLASS);
        if (this._useInputForDrop()) {
            return
        }
        e.preventDefault();
        var fileList = e.originalEvent.dataTransfer.files,
            files = this._getFiles(fileList);
        if (!this.option("multiple") && files.length > 1) {
            return
        }
        this._changeValue(this._filterFiles(files));
        if ("instantly" === this.option("uploadMode")) {
            this._uploadFiles()
        }
    },
    _filterFiles: function(files) {
        if (!files.length) {
            return files
        }
        var accept = this.option("accept");
        if (!accept.length) {
            return files
        }
        var result = [],
            allowedTypes = this._getAllowedFileTypes(accept);
        for (var i = 0, n = files.length; i < n; i++) {
            if (this._isFileTypeAllowed(files[i], allowedTypes)) {
                result.push(files[i])
            }
        }
        return result
    },
    _getAllowedFileTypes: function(acceptSting) {
        if (!acceptSting.length) {
            return []
        }
        return acceptSting.split(",").map(function(item) {
            return item.trim()
        })
    },
    _isFileTypeAllowed: function(file, allowedTypes) {
        for (var i = 0, n = allowedTypes.length; i < n; i++) {
            var allowedType = allowedTypes[i];
            if ("." === allowedType[0]) {
                allowedType = allowedType.replace(".", "\\.");
                if (file.name.match(allowedType)) {
                    return true
                }
            } else {
                allowedType = allowedType.replace("*", "");
                if (file.type.match(allowedType)) {
                    return true
                }
            }
        }
        return false
    },
    _renderWrapper: function() {
        var $wrapper = $("<div>").addClass(FILEUPLOADER_WRAPPER_CLASS).appendTo(this.element());
        var $container = $("<div>").addClass(FILEUPLOADER_CONTAINER_CLASS).appendTo($wrapper);
        this._$content = $("<div>").addClass(FILEUPLOADER_CONTENT_CLASS).appendTo($container)
    },
    _clean: function() {
        this._$fileInput.detach();
        delete this._$filesContainer;
        this.callBase.apply(this, arguments)
    },
    _uploadFiles: function() {
        if (!isFormDataSupported()) {
            return
        }
        $.each(this._files, function(_, file) {
            this._uploadFile(file)
        }.bind(this))
    },
    _uploadFile: function(file) {
        if (file.uploadStarted) {
            return
        }
        var $file = file.$file,
            value = file.value;
        this._initUploadRequest(file);
        if ($file) {
            file.progressBar = this._createProgressBar(value.size);
            file.progressBar.element().appendTo($file);
            this._initStatusMessage(file);
            this._initCancelButton(file)
        }
        file.onLoadStart.add(this._onUploadStarted.bind(this, file));
        file.onLoad.add(this._onLoadedHandler.bind(this, file));
        file.onError.add(this._onErrorHandler.bind(this, file));
        file.onAbort.add(this._onAbortHandler.bind(this, file));
        file.onProgress.add(this._onProgressHandler.bind(this, file));
        file.request.send(this._createFormData(this.option("name"), value))
    },
    _onUploadStarted: function(file, e) {
        file.uploadStarted = true;
        this._uploadStartedAction({
            file: file.value,
            jQueryEvent: e,
            request: file.request
        })
    },
    _onErrorHandler: function(file, e) {
        var that = this;
        setTimeout(function() {
            if (that.option("showFileList")) {
                file.$statusMessage.text(that.option("uploadFailedMessage"));
                file.$statusMessage.css("display", "");
                file.progressBar.element().remove()
            }
        }, FILEUPLOADER_AFTER_LOAD_DELAY);
        this._uploadErrorAction({
            file: file.value,
            jQueryEvent: e,
            request: file.request
        })
    },
    _onAbortHandler: function(file, e) {
        this._uploadAbortedAction({
            file: file.value,
            jQueryEvent: e,
            request: file.request
        })
    },
    _onLoadedHandler: function(file, e) {
        var that = this;
        setTimeout(function() {
            if (that.option("showFileList")) {
                file.$statusMessage.text(that.option("uploadedMessage"));
                file.$statusMessage.css("display", "");
                file.progressBar.element().remove()
            }
        }, FILEUPLOADER_AFTER_LOAD_DELAY);
        this._uploadedAction({
            file: file.value,
            jQueryEvent: e,
            request: file.request
        })
    },
    _onProgressHandler: function(file, e) {
        var totalSize = this._getTotalSize(),
            currentLoadedSize = 0,
            loadedSize = this._getLoadedSize(),
            progress = 0;
        if (file) {
            currentLoadedSize = Math.min(e.loaded, file.value.size);
            var segmentSize = currentLoadedSize - file.loadedSize;
            loadedSize += segmentSize;
            file.progressBar && file.progressBar.option({
                value: currentLoadedSize,
                showStatus: true
            });
            this._progressAction({
                file: file.value,
                segmentSize: segmentSize,
                bytesLoaded: e.loaded,
                bytesTotal: e.total,
                jQueryEvent: e,
                request: file.request
            });
            file.loadedSize = currentLoadedSize
        }
        if (totalSize) {
            progress = Math.round(loadedSize / totalSize * 100)
        }
        this.option("progress", progress);
        this._setLoadedSize(loadedSize)
    },
    _initStatusMessage: function(file) {
        file.$statusMessage.css("display", "none")
    },
    _initCancelButton: function(file) {
        var cancelClickHandler = function() {
            file.request.abort();
            this._removeFile(file)
        }.bind(this);
        file.cancelButton.option("onClick", cancelClickHandler);
        var hideCancelButton = function() {
            setTimeout(function() {
                file.cancelButton.option({
                    visible: false
                })
            }, FILEUPLOADER_AFTER_LOAD_DELAY)
        };
        file.onLoad.add(hideCancelButton);
        file.onError.add(hideCancelButton)
    },
    _initUploadRequest: function(file) {
        var that = this;
        file.request = this._createRequest(this.option("uploadUrl"));
        file.loadedSize = 0;
        this._initUploadHeaders(file.request);
        file.request.onreadystatechange = function(e) {
            if (4 === e.currentTarget.readyState) {
                var status = e.currentTarget.status;
                if (that._isStatusSuccess(status)) {
                    this.onLoad.fire(e)
                } else {
                    if (that._isStatusError(status) || !this._isProgressStarted) {
                        this._isError = true;
                        this.onError.fire(e)
                    }
                }
            }
        }.bind(file);
        file.request.upload.onprogress = function(e) {
            if (this._isError) {
                return
            }
            this._isProgressStarted = true;
            this.onProgress.fire(e)
        }.bind(file);
        file.request.upload.onloadstart = function(e) {
            this.onLoadStart.fire(e)
        }.bind(file);
        file.request.upload.onabort = function(e) {
            this.onAbort.fire(e)
        }.bind(file)
    },
    _initUploadHeaders: function(request) {
        var headers = this.option("uploadHeaders");
        for (var name in headers) {
            if (headers.hasOwnProperty(name)) {
                request.setRequestHeader(name, headers[name])
            }
        }
    },
    _isStatusSuccess: function(status) {
        return 200 <= status && status < 300
    },
    _isStatusError: function(status) {
        return 400 <= status && status < 500 || 500 <= status && status < 600
    },
    _createRequest: function(url) {
        var request = new XMLHttpRequest;
        request.open(this.option("uploadMethod"), url, true);
        return request
    },
    _createFormData: function(fieldName, fieldValue) {
        var formData = new FormData;
        formData.append(fieldName, fieldValue);
        return formData
    },
    _createProgressBar: function(fileSize) {
        return this._createComponent($("<div>"), ProgressBar, {
            value: void 0,
            min: 0,
            max: fileSize,
            statusFormat: function(ratio) {
                return Math.round(100 * ratio) + "%"
            },
            showStatus: false,
            statusPosition: "right"
        })
    },
    _getTotalSize: function() {
        if (!this._totalSize) {
            var value = this.option("value"),
                totalSize = 0;
            $.each(value, function(_, file) {
                totalSize += file.size
            });
            this._totalSize = totalSize
        }
        return this._totalSize
    },
    _getLoadedSize: function() {
        if (!this._loadedSize) {
            var loadedSize = 0;
            $.each(this._files, function(_, file) {
                loadedSize += file.loadedSize
            });
            this._loadedSize = loadedSize
        }
        return this._loadedSize
    },
    _setLoadedSize: function(value) {
        this._loadedSize = value
    },
    _recalculateProgress: function() {
        delete this._totalSize;
        delete this._loadedSize;
        this._onProgressHandler()
    },
    _getValidationMessageTarget: function() {
        return this._$inputWrapper
    },
    _optionChanged: function(args) {
        var value = args.value;
        switch (args.name) {
            case "height":
            case "width":
                this._updateFileNameMaxWidth();
                this.callBase(args);
                break;
            case "value":
                !value.length && this._$fileInput.val("");
                if (!this._doPreventRecreatingFiles) {
                    this._createFiles();
                    this._renderFiles()
                }
                this._recalculateProgress();
                this.callBase(args);
                break;
            case "name":
                this._initFileInput();
                this.callBase(args);
                break;
            case "accept":
                this._initFileInput();
                break;
            case "multiple":
                this._initFileInput();
                if (!args.value) {
                    this.reset()
                }
                break;
            case "selectButtonText":
                this._selectButton.option("text", value);
                break;
            case "uploadButtonText":
                this._uploadButton && this._uploadButton.option("text", value);
                break;
            case "readyToUploadMessage":
            case "uploadedMessage":
            case "uploadFailedMessage":
                this._invalidate();
                break;
            case "labelText":
                this._$inputLabel.text(value);
                break;
            case "showFileList":
                this._renderFiles();
                break;
            case "uploadUrl":
            case "progress":
            case "uploadMethod":
            case "uploadHeaders":
            case "extendSelection":
                break;
            case "allowCanceling":
            case "uploadMode":
                this.reset();
                this._invalidate();
                break;
            case "onUploadStarted":
                this._createUploadStartedAction();
                break;
            case "onUploaded":
                this._createUploadedAction();
                break;
            case "onProgress":
                this._createProgressAction();
                break;
            case "onUploadError":
                this._createUploadErrorAction();
                break;
            case "onUploadAborted":
                this._createUploadAbortedAction();
                break;
            case "useNativeInputClick":
                this._renderInput();
                break;
            case "useDragOver":
                this._renderDragEvents();
                break;
            case "nativeDropSupported":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    reset: function() {
        this.option("value", [])
    }
});
registerComponent("dxFileUploader", FileUploader);
module.exports = FileUploader;
module.exports.default = module.exports;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/track_bar.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Editor = __webpack_require__(33),
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    fx = __webpack_require__(22);
var TRACKBAR_CLASS = "dx-trackbar",
    TRACKBAR_CONTAINER_CLASS = "dx-trackbar-container",
    TRACKBAR_RANGE_CLASS = "dx-trackbar-range",
    TRACKBAR_WRAPPER_CLASS = "dx-trackbar-wrapper";
var TrackBar = Editor.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            min: 0,
            max: 100,
            value: 0
        })
    },
    _render: function() {
        this.element().addClass(TRACKBAR_CLASS);
        this._renderWrapper();
        this._renderContainer();
        this._renderRange();
        this.callBase();
        this._renderValue()
    },
    _renderWrapper: function() {
        this._$wrapper = $("<div>").addClass(TRACKBAR_WRAPPER_CLASS).appendTo(this.element())
    },
    _renderContainer: function() {
        this._$bar = $("<div>").addClass(TRACKBAR_CONTAINER_CLASS).appendTo(this._$wrapper)
    },
    _renderRange: function() {
        this._$range = $("<div>").addClass(TRACKBAR_RANGE_CLASS).appendTo(this._$bar)
    },
    _renderValue: function() {
        var val = this.option("value"),
            min = this.option("min"),
            max = this.option("max");
        if (min > max) {
            return
        }
        if (val < min) {
            this.option("value", min);
            this._currentRatio = 0;
            return
        }
        if (val > max) {
            this.option("value", max);
            this._currentRatio = 1;
            return
        }
        var ratio = min === max ? 0 : (val - min) / (max - min);
        !this._needPreventAnimation && this._setRangeStyles({
            width: 100 * ratio + "%"
        });
        this.setAria({
            valuemin: this.option("min"),
            valuemax: max,
            valuenow: val
        });
        this._currentRatio = ratio
    },
    _setRangeStyles: function(options) {
        fx.stop(this._$range);
        if (!this._needPreventAnimation) {
            fx.animate(this._$range, {
                type: "custom",
                duration: 100,
                to: options
            })
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "value":
                this._renderValue();
                this.callBase(args);
                break;
            case "max":
            case "min":
                this._renderValue();
                break;
            default:
                this.callBase(args)
        }
    },
    _dispose: function() {
        fx.stop(this._$range);
        this.callBase()
    }
});
registerComponent("dxTrackBar", TrackBar);
module.exports = TrackBar;


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/lookup.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    support = __webpack_require__(24),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    inkRipple = __webpack_require__(43),
    messageLocalization = __webpack_require__(8),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    eventUtils = __webpack_require__(3),
    DropDownList = __webpack_require__(150),
    themes = __webpack_require__(20),
    clickEvent = __webpack_require__(11),
    Popover = __webpack_require__(98),
    TextBox = __webpack_require__(69),
    ChildDefaultTemplate = __webpack_require__(74);
var LOOKUP_CLASS = "dx-lookup",
    LOOKUP_SEARCH_CLASS = "dx-lookup-search",
    LOOKUP_SEARCH_WRAPPER_CLASS = "dx-lookup-search-wrapper",
    LOOKUP_FIELD_CLASS = "dx-lookup-field",
    LOOKUP_ARROW_CLASS = "dx-lookup-arrow",
    LOOKUP_FIELD_WRAPPER_CLASS = "dx-lookup-field-wrapper",
    LOOKUP_POPUP_CLASS = "dx-lookup-popup",
    LOOKUP_POPUP_WRAPPER_CLASS = "dx-lookup-popup-wrapper",
    LOOKUP_POPUP_SEARCH_CLASS = "dx-lookup-popup-search",
    LOOKUP_POPOVER_MODE = "dx-lookup-popover-mode",
    LOOKUP_EMPTY_CLASS = "dx-lookup-empty",
    LOOKUP_POPUP_VALIDATION_MESSAGE = "dx-lookup-validation-message",
    LOOKUP_POPUP_INVALID_CLASS = "dx-lookup-invalid";
var POPUP_OPTION_MAP = {
    popupWidth: "width",
    popupHeight: "height"
};
var Lookup = DropDownList.inherit({
    _supportedKeys: function() {
        return extend(this.callBase(), {
            space: function(e) {
                e.preventDefault();
                this._validatedOpening()
            },
            enter: function() {
                this._validatedOpening()
            }
        })
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            showNextButton: {
                since: "15.1",
                message: "Use the 'pageLoadMode' option instead"
            },
            pagingEnabled: {
                since: "15.1",
                message: "Use the 'dataSource.paginate' option instead"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            title: "",
            titleTemplate: "title",
            onTitleRendered: null,
            placeholder: messageLocalization.format("Select"),
            searchPlaceholder: messageLocalization.format("Search"),
            searchEnabled: true,
            cleanSearchOnOpening: true,
            fullScreen: false,
            showCancelButton: true,
            showClearButton: false,
            clearButtonText: messageLocalization.format("Clear"),
            applyButtonText: messageLocalization.format("Done"),
            popupWidth: function() {
                return .8 * $(window).width()
            },
            popupHeight: function() {
                return .8 * $(window).height()
            },
            shading: true,
            closeOnOutsideClick: false,
            position: void 0,
            animation: {},
            pullRefreshEnabled: false,
            useNativeScrolling: true,
            pullingDownText: messageLocalization.format("dxList-pullingDownText"),
            pulledDownText: messageLocalization.format("dxList-pulledDownText"),
            refreshingText: messageLocalization.format("dxList-refreshingText"),
            pageLoadingText: messageLocalization.format("dxList-pageLoadingText"),
            onScroll: null,
            onPullRefresh: null,
            onPageLoading: null,
            pageLoadMode: "scrollBottom",
            nextButtonText: messageLocalization.format("dxList-nextButtonText"),
            grouped: false,
            groupTemplate: "group",
            usePopover: false,
            showDropDownButton: false,
            showPopupTitle: true,
            focusStateEnabled: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return !support.nativeScrolling
            },
            options: {
                useNativeScrolling: false
            }
        }, {
            device: function(device) {
                return !devices.isSimulator() && "generic" === devices.real().platform && "generic" === device.platform
            },
            options: {
                usePopover: true,
                popupHeight: "auto"
            }
        }, {
            device: function(device) {
                return "win" === device.platform && device.phone && device.version && 8 === device.version[0]
            },
            options: {
                showCancelButton: false,
                fullScreen: true
            }
        }, {
            device: function(device) {
                return "win" === device.platform && !device.phone && device.version && 8 === device.version[0]
            },
            options: {
                popupWidth: function() {
                    return $(window).width()
                }
            }
        }, {
            device: {
                platform: "ios",
                phone: true
            },
            options: {
                fullScreen: true
            }
        }, {
            device: {
                platform: "ios",
                tablet: true
            },
            options: {
                popupWidth: function() {
                    return .4 * Math.min($(window).width(), $(window).height())
                },
                popupHeight: "auto",
                usePopover: true,
                useInkRipple: false
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _dataSourceOptions: function() {
        this._suppressDeprecatedWarnings();
        var pagingEnabled = commonUtils.ensureDefined(this.option("pagingEnabled"), true);
        pagingEnabled = commonUtils.isDefined(this.option("showNextButton")) ? pagingEnabled || this.option("showNextButton") : pagingEnabled;
        this._resumeDeprecatedWarnings();
        return extend(this.callBase(), {
            paginate: pagingEnabled
        })
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.group = new ChildDefaultTemplate("group", this);
        this._defaultTemplates.title = new ChildDefaultTemplate("title", this)
    },
    _inputWrapper: function() {
        return this.element().find("." + LOOKUP_FIELD_WRAPPER_CLASS)
    },
    _render: function() {
        this._renderSubmitElement();
        this.callBase();
        this.element().addClass(LOOKUP_CLASS).toggleClass(LOOKUP_POPOVER_MODE, this.option("usePopover"))
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _fireContentReadyAction: commonUtils.noop,
    _popupWrapperClass: function() {
        return ""
    },
    _renderInput: function() {
        var fieldClickAction = this._createAction(function() {
            this._toggleOpenState()
        }.bind(this));
        this._$field = $("<div>").addClass(LOOKUP_FIELD_CLASS).on(eventUtils.addNamespace(clickEvent.name, this.NAME), function(e) {
            fieldClickAction({
                jQueryEvent: e
            })
        });
        var $arrow = $("<div>").addClass(LOOKUP_ARROW_CLASS);
        this._$fieldWrapper = $("<div>").addClass(LOOKUP_FIELD_WRAPPER_CLASS).append(this._$field).append($arrow).appendTo(this.element());
        this.option("useInkRipple") && this._renderInkRipple()
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: this._inputWrapper(),
            jQueryEvent: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _renderField: function() {
        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
        if (fieldTemplate && this.option("fieldTemplate")) {
            this._renderFieldTemplate(fieldTemplate);
            return
        }
        this._$field.text(this.option("displayValue") || this.option("placeholder"));
        this.element().toggleClass(LOOKUP_EMPTY_CLASS, !this.option("selectedItem"))
    },
    _renderFieldTemplate: function(template) {
        this._$field.empty();
        var data = this._fieldRenderData();
        template.render({
            model: data,
            container: this._$field
        })
    },
    _fieldRenderData: function() {
        return this.option("selectedItem")
    },
    _popupShowingHandler: function() {
        var validationError;
        if (this._$popupValidationMessage) {
            validationError = this.option("validationError");
            if (validationError && validationError.message) {
                this._$popupValidationMessage.text(validationError.message);
                this._popup.content().addClass(LOOKUP_POPUP_INVALID_CLASS)
            } else {
                this._popup.content().removeClass(LOOKUP_POPUP_INVALID_CLASS)
            }
        }
        this.callBase.apply(this, arguments);
        if (this.option("cleanSearchOnOpening")) {
            if (this.option("searchEnabled") && this._searchBox.option("value")) {
                this._searchBox.option("value", "");
                this._searchCanceled();
                this._searchDataSource()
            }
            this._list && this._list.option("focusedElement", null)
        }
        this._attachSearchChildProcessor()
    },
    _renderPopup: function() {
        if (this.option("usePopover") && !this.option("fullScreen")) {
            this._renderPopover()
        } else {
            this.callBase()
        }
        this._$popup.addClass(LOOKUP_POPUP_CLASS);
        this._popup._wrapper().addClass(LOOKUP_POPUP_WRAPPER_CLASS)
    },
    _popupOptionMap: function(optionName) {
        return POPUP_OPTION_MAP[optionName] || optionName
    },
    _renderPopover: function() {
        this._popup = this._createComponent(this._$popup, Popover, extend(this._popupConfig(), {
            showEvent: null,
            hideEvent: null,
            target: this.element(),
            fullScreen: false,
            shading: false,
            closeOnTargetScroll: true,
            width: this._isInitialOptionValue("popupWidth") ? function() {
                return this.element().outerWidth()
            }.bind(this) : this._popupConfig().width
        }));
        this._popup.on({
            showing: this._popupShowingHandler.bind(this),
            shown: this._popupShownHandler.bind(this),
            hiding: this._popupHidingHandler.bind(this),
            hidden: this._popupHiddenHandler.bind(this)
        });
        this._popup.option("onContentReady", this._contentReadyHandler.bind(this));
        this._contentReadyHandler()
    },
    _popupHidingHandler: function() {
        this.callBase();
        this.option("focusStateEnabled") && this.focus()
    },
    _preventFocusOnPopup: commonUtils.noop,
    _popupConfig: function() {
        var result = extend(this.callBase(), {
            showTitle: this.option("showPopupTitle"),
            title: this.option("title"),
            titleTemplate: this._getTemplateByOption("titleTemplate"),
            onTitleRendered: this.option("onTitleRendered"),
            toolbarItems: this._getPopupToolbarItems(),
            fullScreen: this.option("fullScreen"),
            shading: this.option("shading"),
            closeOnTargetScroll: false,
            closeOnOutsideClick: this.option("closeOnOutsideClick"),
            onPositioned: null
        });
        delete result.animation;
        delete result.position;
        result.maxHeight = function() {
            return $(window).height()
        };
        $.each(["position", "animation", "popupWidth", "popupHeight"], function(_, optionName) {
            if (void 0 !== this.option(optionName)) {
                result[this._popupOptionMap(optionName)] = this.option(optionName)
            }
        }.bind(this));
        return result
    },
    _getPopupToolbarItems: function() {
        var buttonsConfig = "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : [];
        var cancelButton = this._getCancelButtonConfig();
        if (cancelButton) {
            buttonsConfig.push(cancelButton)
        }
        var clearButton = this._getClearButtonConfig();
        if (clearButton) {
            buttonsConfig.push(clearButton)
        }
        return this._applyButtonsLocation(buttonsConfig)
    },
    _popupToolbarItemsConfig: function() {
        return [{
            shortcut: "done",
            options: {
                onClick: this._applyButtonHandler.bind(this),
                text: this.option("applyButtonText")
            }
        }]
    },
    _getCancelButtonConfig: function() {
        return this.option("showCancelButton") ? {
            shortcut: "cancel",
            onClick: this._cancelButtonHandler.bind(this),
            options: {
                text: this.option("cancelButtonText")
            }
        } : null
    },
    _getClearButtonConfig: function() {
        return this.option("showClearButton") ? {
            shortcut: "clear",
            onClick: this._resetValue.bind(this),
            options: {
                text: this.option("clearButtonText")
            }
        } : null
    },
    _applyButtonHandler: function() {
        this.option("value", this._valueGetter(this._currentSelectedItem()));
        this.callBase()
    },
    _cancelButtonHandler: function() {
        this._refreshSelected();
        this.callBase()
    },
    _refreshPopupVisibility: function() {
        if (this.option("opened")) {
            this._updatePopupHeight()
        }
    },
    _dimensionChanged: function() {
        if (this.option("usePopover") && !this.option("popupWidth")) {
            this.option("popupWidth", this.element().width())
        }
        this.callBase()
    },
    _updatePopupDimensions: function() {
        this._updatePopupHeight()
    },
    _input: function() {
        return this._$searchBox || this.callBase()
    },
    _renderPopupContent: function() {
        if ("dxPopup" === this._popup.NAME) {
            this._$popupValidationMessage = $("<div>").addClass(LOOKUP_POPUP_VALIDATION_MESSAGE).appendTo(this._popup.content())
        }
        this.callBase();
        this._renderSearch();
        this._attachSearchChildProcessor()
    },
    _attachSearchChildProcessor: function() {
        if (this.option("searchEnabled") && this._searchBox) {
            this._listKeyboardProcessor = this._searchBox._keyboardProcessor.attachChildProcessor();
            this._setListOption("_keyboardProcessor", this._listKeyboardProcessor)
        } else {
            this._setListOption("_keyboardProcessor", void 0)
        }
    },
    _renderSearch: function() {
        this._$searchWrapper && this._$searchWrapper.remove();
        delete this._$searchWrapper;
        this._$searchBox && this._$searchBox.remove();
        delete this._$searchBox;
        delete this._searchBox;
        if (this.option("searchEnabled")) {
            var $searchWrapper = this._$searchWrapper = $("<div>").addClass(LOOKUP_SEARCH_WRAPPER_CLASS);
            var $searchBox = this._$searchBox = $("<div>").addClass(LOOKUP_SEARCH_CLASS).appendTo($searchWrapper);
            var currentDevice = devices.current(),
                searchMode = currentDevice.android && currentDevice.version[0] >= 5 ? "text" : "search";
            this._searchBox = this._createComponent($searchBox, TextBox, {
                mode: searchMode,
                showClearButton: true,
                valueChangeEvent: this.option("valueChangeEvent"),
                onValueChanged: this._searchHandler.bind(this)
            });
            this._registerSearchKeyHandlers();
            $searchWrapper.insertBefore(this._$list)
        }
        this._renderSearchVisibility();
        this._setSearchPlaceholder()
    },
    _selectListItemHandler: function(e) {
        var $itemElement = this._list.option("focusedElement");
        if (!$itemElement) {
            return
        }
        e.preventDefault();
        this._selectListItem(e.itemData, $itemElement)
    },
    _registerSearchKeyHandlers: function() {
        this._searchBox.registerKeyHandler("escape", this.close.bind(this));
        this._searchBox.registerKeyHandler("enter", this._selectListItemHandler.bind(this));
        this._searchBox.registerKeyHandler("space", this._selectListItemHandler.bind(this));
        this._searchBox.registerKeyHandler("end", commonUtils.noop);
        this._searchBox.registerKeyHandler("home", commonUtils.noop)
    },
    _renderSearchVisibility: function() {
        if (this._popup) {
            this._popup._wrapper().toggleClass(LOOKUP_POPUP_SEARCH_CLASS, this.option("searchEnabled"))
        }
    },
    _setSearchPlaceholder: function() {
        if (!this._$searchBox) {
            return
        }
        var minSearchLength = this.option("minSearchLength");
        var placeholder = this.option("searchPlaceholder");
        if (minSearchLength && placeholder === messageLocalization.format("Search")) {
            placeholder = messageLocalization.getFormatter("dxLookup-searchPlaceholder")(minSearchLength)
        }
        this._searchBox.option("placeholder", placeholder)
    },
    _setAriaTargetForList: commonUtils.noop,
    _renderList: function() {
        this.callBase();
        this._list.registerKeyHandler("escape", function() {
            this.close()
        }.bind(this))
    },
    _listConfig: function() {
        return extend(this.callBase(), {
            tabIndex: 0,
            grouped: this.option("grouped"),
            groupTemplate: this._getTemplateByOption("groupTemplate"),
            pullRefreshEnabled: this.option("pullRefreshEnabled"),
            useNativeScrolling: this.option("useNativeScrolling"),
            pullingDownText: this.option("pullingDownText"),
            pulledDownText: this.option("pulledDownText"),
            refreshingText: this.option("refreshingText"),
            pageLoadingText: this.option("pageLoadingText"),
            onScroll: this.option("onScroll"),
            onPullRefresh: this.option("onPullRefresh"),
            onPageLoading: this.option("onPageLoading"),
            pageLoadMode: this._getPageLoadMode(),
            nextButtonText: this.option("nextButtonText"),
            _keyboardProcessor: this._listKeyboardProcessor,
            onFocusIn: this._onFocusInHandler.bind(this),
            onSelectionChanged: this._getSelectionChangedHandler()
        })
    },
    _getSelectionChangedHandler: function() {
        return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : commonUtils.noop
    },
    _onFocusInHandler: function() {
        this._setListOption("_keyboardProcessor", void 0)
    },
    _listContentReadyHandler: function() {
        this.callBase.apply(this, arguments);
        this._refreshSelected()
    },
    _getPageLoadMode: function() {
        this._suppressDeprecatedWarnings();
        var result = commonUtils.isDefined(this.option("showNextButton")) ? "nextButton" : this.option("pageLoadMode");
        this._resumeDeprecatedWarnings();
        return result
    },
    _setFocusPolicy: function() {
        if (!this.option("focusStateEnabled")) {
            return
        }
        if (this.option("searchEnabled")) {
            this._searchBox.focus()
        } else {
            this._$list.focus()
        }
    },
    _attachChildKeyboardEvents: commonUtils.noop,
    _focusTarget: function() {
        return this._$field
    },
    _keyboardEventBindingTarget: function() {
        return this._$field
    },
    _listItemClickHandler: function(e) {
        this._selectListItem(e.itemData, e.jQueryEvent.currentTarget)
    },
    _selectListItem: function(itemData, target) {
        this._list.selectItem(target);
        if ("instantly" === this.option("applyValueMode")) {
            this._applyButtonHandler()
        }
    },
    _currentSelectedItem: function() {
        return this.option("grouped") ? this._list.option("selectedItems[0]").items[0] : this._list.option("selectedItems[0]")
    },
    _resetValue: function() {
        this.option("value", null);
        this.option("opened", false)
    },
    _searchValue: function() {
        return this.option("searchEnabled") && this._searchBox ? this._searchBox.option("value") : ""
    },
    _renderInputValue: function() {
        return this.callBase().always(function() {
            this._renderField();
            this._refreshSelected();
            this._setSubmitValue()
        }.bind(this))
    },
    _setSubmitValue: function() {
        var value = this.option("value"),
            submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value) : value;
        this._$submitElement.val(submitValue)
    },
    _renderPlaceholder: function() {
        if (0 === this.element().find("input").length) {
            return
        }
        this.callBase()
    },
    _clean: function() {
        this._$fieldWrapper.remove();
        this._$searchBox = null;
        this.callBase()
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        switch (name) {
            case "searchEnabled":
                this._popup && this._renderSearch();
                this._attachSearchChildProcessor();
                break;
            case "searchPlaceholder":
                this._setSearchPlaceholder();
                break;
            case "minSearchLength":
                this._setSearchPlaceholder();
                this.callBase.apply(this, arguments);
                break;
            case "title":
            case "titleTemplate":
            case "onTitleRendered":
            case "shading":
            case "animation":
            case "position":
            case "closeOnOutsideClick":
                this._setPopupOption(name);
                break;
            case "fullScreen":
            case "usePopover":
            case "placeholder":
                this._invalidate();
                break;
            case "clearButtonText":
            case "showClearButton":
            case "showCancelButton":
                this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
                break;
            case "applyValueMode":
                this.callBase.apply(this, arguments);
                break;
            case "popupWidth":
                this._setPopupOption("popupWidth", "auto" === value ? this.initialOption("popupWidth") : value);
                break;
            case "popupHeight":
                this._setPopupOption("popupHeight", "auto" === value ? this.initialOption("popupHeight") : value);
                break;
            case "pullRefreshEnabled":
            case "useNativeScrolling":
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "pageLoadingText":
            case "onScroll":
            case "onPullRefresh":
            case "onPageLoading":
            case "nextButtonText":
            case "grouped":
            case "groupTemplate":
                this._setListOption(name);
                break;
            case "showNextButton":
            case "pageLoadMode":
                this._setListOption("pageLoadMode", this._getPageLoadMode());
                break;
            case "cleanSearchOnOpening":
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    focus: function() {
        this.option("opened") ? this._setFocusPolicy() : this._focusTarget().focus()
    },
    field: function() {
        return this._$field
    }
});
registerComponent("dxLookup", Lookup);
module.exports = Lookup;
module.exports.default = module.exports;


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/radio_group.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(329);
module.exports.default = module.exports;


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/radio_group/radio_group.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    registerComponent = __webpack_require__(4),
    Editor = __webpack_require__(33),
    inkRipple = __webpack_require__(43),
    DataExpressionMixin = __webpack_require__(152),
    themes = __webpack_require__(20),
    CollectionWidget = __webpack_require__(40),
    ChildDefaultTemplate = __webpack_require__(74);
var RADIO_GROUP_CLASS = "dx-radiogroup",
    RADIO_GROUP_VERTICAL_CLASS = "dx-radiogroup-vertical",
    RADIO_GROUP_HORIZONTAL_CLASS = "dx-radiogroup-horizontal",
    RADIO_BUTTON_CLASS = "dx-radiobutton",
    RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon",
    RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot",
    RADIO_VALUE_CONTAINER_CLASS = "dx-radio-value-container",
    RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked",
    ITEM_DATA_KEY = "dxItemData",
    RADIO_FEEDBACK_HIDE_TIMEOUT = 100;
var RadioCollection = CollectionWidget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), DataExpressionMixin._dataExpressionDefaultOptions(), {
            _itemAttributes: {
                role: "radio"
            }
        })
    },
    _supportedKeys: function() {
        var parent = this.callBase();
        return extend({}, parent, {
            enter: function(e) {
                e.preventDefault();
                return parent.enter.apply(this, arguments)
            },
            space: function(e) {
                e.preventDefault();
                return parent.space.apply(this, arguments)
            }
        })
    },
    _focusTarget: function() {
        return this.element().parent()
    },
    _keyboardEventBindingTarget: function() {
        return this._focusTarget()
    }
});
var RadioGroup = Editor.inherit({
    _activeStateUnit: "." + RADIO_BUTTON_CLASS,
    _getDefaultOptions: function() {
        return extend(this.callBase(), extend(DataExpressionMixin._dataExpressionDefaultOptions(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            layout: "vertical",
            useInkRipple: false
        }))
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                tablet: true
            },
            options: {
                layout: "horizontal"
            }
        }, {
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            value: true
        })
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _init: function() {
        this.callBase();
        this._initDataExpressions();
        this._feedbackHideTimeout = RADIO_FEEDBACK_HIDE_TIMEOUT
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.item = new ChildDefaultTemplate("item", this)
    },
    _render: function() {
        this.element().addClass(RADIO_GROUP_CLASS);
        this._renderSubmitElement();
        this._renderRadios();
        this.setAria("role", "radiogroup");
        this.callBase();
        this._renderLayout();
        this._updateItemsSize();
        this.option("useInkRipple") && this._renderInkRipple()
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render({
            waveSizeCoefficient: 3.3,
            useHoldAnimation: false,
            isCentered: true
        })
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        if (value) {
            this._inkRipple.showWave({
                element: $element.find("." + RADIO_BUTTON_ICON_CLASS),
                jQueryEvent: e
            })
        } else {
            this._inkRipple.hideWave({
                element: $element.find("." + RADIO_BUTTON_ICON_CLASS),
                jQueryEvent: e
            })
        }
    },
    _renderFocusState: noop,
    _renderRadios: function() {
        var $radios = $("<div>").appendTo(this.element());
        this._radios = this._createComponent($radios, RadioCollection, {
            dataSource: this._dataSource,
            onItemRendered: this._itemRenderedHandler.bind(this),
            onItemClick: this._itemClickHandler.bind(this),
            itemTemplate: this._getTemplateByOption("itemTemplate"),
            scrollingEnabled: false,
            focusStateEnabled: this.option("focusStateEnabled"),
            accessKey: this.option("accessKey"),
            tabIndex: this.option("tabIndex"),
            noDataText: ""
        });
        this._setCollectionWidgetOption("onContentReady", this._contentReadyHandler.bind(this));
        this._contentReadyHandler()
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element());
        this._setSubmitValue()
    },
    _setSubmitValue: function(value) {
        value = value || this.option("value");
        var submitValue = "this" === this.option("valueExpr") ? this._displayGetter(value) : value;
        this._$submitElement.val(submitValue)
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _contentReadyHandler: function() {
        this.itemElements().addClass(RADIO_BUTTON_CLASS);
        this._refreshSelected()
    },
    _itemRenderedHandler: function(e) {
        if (e.itemData.html) {
            return
        }
        var $radio, $radioContainer;
        $radio = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
        $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo($radio);
        $radioContainer = $("<div>").append($radio).addClass(RADIO_VALUE_CONTAINER_CLASS);
        e.itemElement.prepend($radioContainer)
    },
    _itemClickHandler: function(e) {
        this._saveValueChangeEvent(e.jQueryEvent);
        this.option("value", this._getItemValue(e.itemData))
    },
    _getItemValue: function(item) {
        return !!this._valueGetter ? this._valueGetter(item) : item.text
    },
    itemElements: function() {
        return this._radios.itemElements()
    },
    _renderDimensions: function() {
        this.callBase();
        this._updateItemsSize()
    },
    _renderLayout: function() {
        var layout = this.option("layout");
        this.element().toggleClass(RADIO_GROUP_VERTICAL_CLASS, "vertical" === layout);
        this.element().toggleClass(RADIO_GROUP_HORIZONTAL_CLASS, "horizontal" === layout)
    },
    _refreshSelected: function() {
        var selectedValue = this.option("value");
        this.itemElements().each(function(_, item) {
            var $item = $(item);
            var itemValue = this._valueGetter($item.data(ITEM_DATA_KEY));
            $item.toggleClass(RADIO_BUTTON_CHECKED_CLASS, this._isValueEquals(itemValue, selectedValue));
            this.setAria("checked", this._isValueEquals(itemValue, selectedValue), $item)
        }.bind(this))
    },
    _updateItemsSize: function() {
        if ("horizontal" === this.option("layout")) {
            this.itemElements().css("height", "auto")
        } else {
            var itemsCount = this.option("items").length;
            this.itemElements().css("height", 100 / itemsCount + "%")
        }
    },
    _getAriaTarget: function() {
        return this.element()
    },
    _setCollectionWidgetOption: function() {
        this._setWidgetOption("_radios", arguments)
    },
    focus: function() {
        this._radios && this._radios.focus()
    },
    _optionChanged: function(args) {
        this._dataExpressionOptionChanged(args);
        switch (args.name) {
            case "useInkRipple":
                this._invalidate();
                break;
            case "focusStateEnabled":
            case "accessKey":
            case "tabIndex":
                this._setCollectionWidgetOption(args.name, args.value);
                break;
            case "disabled":
                this.callBase(args);
                this._setCollectionWidgetOption(args.name, args.value);
                break;
            case "dataSource":
                this._setCollectionWidgetOption("dataSource");
                break;
            case "valueExpr":
                this._refreshSelected();
                break;
            case "value":
                this._refreshSelected();
                this._setSubmitValue(args.value);
                this.callBase(args);
                break;
            case "items":
            case "itemTemplate":
            case "displayExpr":
                break;
            case "layout":
                this._renderLayout();
                this._updateItemsSize();
                break;
            default:
                this.callBase(args)
        }
    }
}).include(DataExpressionMixin);
registerComponent("dxRadioGroup", RadioGroup);
module.exports = RadioGroup;


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/switch.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    inkRipple = __webpack_require__(43),
    registerComponent = __webpack_require__(4),
    Editor = __webpack_require__(33),
    eventUtils = __webpack_require__(3),
    feedbackEvents = __webpack_require__(75),
    themes = __webpack_require__(20),
    fx = __webpack_require__(22),
    messageLocalization = __webpack_require__(8),
    clickEvent = __webpack_require__(11),
    Swipeable = __webpack_require__(126);
var SWITCH_CLASS = "dx-switch",
    SWITCH_WRAPPER_CLASS = SWITCH_CLASS + "-wrapper",
    SWITCH_CONTAINER_CLASS = SWITCH_CLASS + "-container",
    SWITCH_INNER_CLASS = SWITCH_CLASS + "-inner",
    SWITCH_HANDLE_CLASS = SWITCH_CLASS + "-handle",
    SWITCH_ON_VALUE_CLASS = SWITCH_CLASS + "-on-value",
    SWITCH_ON_CLASS = SWITCH_CLASS + "-on",
    SWITCH_OFF_CLASS = SWITCH_CLASS + "-off",
    SWITCH_ANIMATION_DURATION = 100;
var Switch = Editor.inherit({
    _supportedKeys: function() {
        var isRTL = this.option("rtlEnabled");
        var click = function(e) {
                e.preventDefault();
                this._clickAction({
                    jQueryEvent: e
                })
            },
            move = function(value, e) {
                e.preventDefault();
                e.stopPropagation();
                this._animateValue(value)
            };
        return extend(this.callBase(), {
            space: click,
            enter: click,
            leftArrow: move.bind(this, isRTL ? true : false),
            rightArrow: move.bind(this, isRTL ? false : true)
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            onText: messageLocalization.format("dxSwitch-onText"),
            offText: messageLocalization.format("dxSwitch-offText"),
            value: false,
            useInkRipple: false,
            useOldRendering: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return /android5/.test(themes.current())
            },
            options: {
                useInkRipple: true
            }
        }, {
            device: function() {
                var device = devices.real();
                return "android" === device.platform && (device.version[0] < 4 || 4 === device.version[0] && device.version[1] < 4)
            },
            options: {
                useOldRendering: true
            }
        }])
    },
    _feedbackHideTimeout: 0,
    _animating: false,
    _render: function() {
        this._renderSwitchInner();
        this._renderLabels();
        this._renderContainers();
        this.option("useInkRipple") && this._renderInkRipple();
        this.element().addClass(SWITCH_CLASS).append(this._$switchWrapper);
        this.setAria("role", "button");
        this._renderSubmitElement();
        this._renderSwipeable();
        this.callBase();
        this._renderHandleWidth();
        this._getHandleOffset = this.option("useOldRendering") ? this._getPixelOffset : this._getCalcOffset;
        this._renderValue();
        this._renderClick()
    },
    _renderHandleWidth: function() {
        this._handleWidth = parseFloat(window.getComputedStyle(this._$handle.get(0)).width)
    },
    _getCalcOffset: function(value, offset) {
        var ratio = offset - Number(!value);
        return "calc(" + 100 * ratio + "% + " + -this._getHandleWidth() * ratio + "px)"
    },
    _getHandleWidth: function() {
        !this._handleWidth && this._renderHandleWidth();
        return this._handleWidth
    },
    _getPixelOffset: function(value, offset) {
        return this._getMarginBound() * (offset - Number(!value))
    },
    _renderSwitchInner: function() {
        this._$switchInner = $("<div>").addClass(SWITCH_INNER_CLASS);
        this._$handle = $("<div>").addClass(SWITCH_HANDLE_CLASS).appendTo(this._$switchInner)
    },
    _renderLabels: function() {
        this._$labelOn = $("<div>").addClass(SWITCH_ON_CLASS).prependTo(this._$switchInner);
        this._$labelOff = $("<div>").addClass(SWITCH_OFF_CLASS).appendTo(this._$switchInner);
        this._setLabelsText()
    },
    _renderContainers: function() {
        this._$switchContainer = $("<div>").addClass(SWITCH_CONTAINER_CLASS).append(this._$switchInner);
        this._$switchWrapper = $("<div>").addClass(SWITCH_WRAPPER_CLASS).append(this._$switchContainer)
    },
    _renderSwipeable: function() {
        this._createComponent(this.element(), Swipeable, {
            elastic: false,
            immediate: true,
            onStart: this._swipeStartHandler.bind(this),
            onUpdated: this._swipeUpdateHandler.bind(this),
            onEnd: this._swipeEndHandler.bind(this),
            itemSizeFunc: this._getMarginBound.bind(this)
        })
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<input>").attr("type", "hidden").appendTo(this.element())
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _renderInkRipple: function() {
        this._inkRipple = inkRipple.render({
            waveSizeCoefficient: 1.7,
            isCentered: true,
            useHoldAnimation: false,
            wavesNumber: 2
        })
    },
    _renderInkWave: function(element, jQueryEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: element,
            jQueryEvent: jQueryEvent,
            wave: waveIndex
        };
        if (doRender) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _updateFocusState: function(e, value) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$handle, e, value, 0)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$handle, e, value, 1)
    },
    _getMarginBound: function() {
        if (!this._marginBound) {
            this._marginBound = this._$switchContainer.outerWidth(true) - this._getHandleWidth()
        }
        return this._marginBound
    },
    _marginDirection: function() {
        return this.option("rtlEnabled") ? "Right" : "Left"
    },
    _offsetDirection: function() {
        return this.option("rtlEnabled") ? -1 : 1
    },
    _renderPosition: function(state, swipeOffset) {
        var marginDirection = this._marginDirection(),
            resetMarginDirection = "Left" === marginDirection ? "Right" : "Left";
        this._$switchInner.css("margin" + marginDirection, this._getHandleOffset(state, swipeOffset));
        this._$switchInner.css("margin" + resetMarginDirection, 0)
    },
    _validateValue: function() {
        var check = this.option("value");
        if ("boolean" !== typeof check) {
            this._options.value = !!check
        }
    },
    _renderClick: function() {
        var eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        this._clickAction = this._createAction(this._clickHandler.bind(this));
        this.element().off(eventName).on(eventName, function(e) {
            this._clickAction({
                jQueryEvent: e
            })
        }.bind(this))
    },
    _clickHandler: function(args) {
        var e = args.jQueryEvent;
        this._saveValueChangeEvent(e);
        if (this._animating || this._swiping) {
            return
        }
        this._animateValue(!this.option("value"))
    },
    _animateValue: function(value) {
        var startValue = this.option("value"),
            endValue = value;
        if (startValue === endValue) {
            return
        }
        this._animating = true;
        var that = this,
            marginDirection = this._marginDirection(),
            resetMarginDirection = "Left" === marginDirection ? "Right" : "Left",
            fromConfig = {},
            toConfig = {};
        this._$switchInner.css("margin" + resetMarginDirection, 0);
        fromConfig["margin" + marginDirection] = this._getHandleOffset(startValue, 0);
        toConfig["margin" + marginDirection] = this._getHandleOffset(endValue, 0);
        fx.animate(this._$switchInner, {
            from: fromConfig,
            to: toConfig,
            duration: SWITCH_ANIMATION_DURATION,
            complete: function() {
                that._animating = false;
                that.option("value", endValue)
            }
        })
    },
    _swipeStartHandler: function(e) {
        var state = this.option("value"),
            rtlEnabled = this.option("rtlEnabled"),
            maxOffOffset = rtlEnabled ? 0 : 1,
            maxOnOffset = rtlEnabled ? 1 : 0;
        e.jQueryEvent.maxLeftOffset = state ? maxOffOffset : maxOnOffset;
        e.jQueryEvent.maxRightOffset = state ? maxOnOffset : maxOffOffset;
        this._swiping = true;
        this._feedbackDeferred = $.Deferred();
        feedbackEvents.lock(this._feedbackDeferred);
        this._toggleActiveState(this.element(), this.option("activeStateEnabled"))
    },
    _swipeUpdateHandler: function(e) {
        this._renderPosition(this.option("value"), this._offsetDirection() * e.jQueryEvent.offset)
    },
    _swipeEndHandler: function(e) {
        var that = this,
            offsetDirection = this._offsetDirection(),
            toConfig = {};
        toConfig["margin" + this._marginDirection()] = this._getHandleOffset(that.option("value"), offsetDirection * e.jQueryEvent.targetOffset);
        fx.animate(this._$switchInner, {
            to: toConfig,
            duration: SWITCH_ANIMATION_DURATION,
            complete: function() {
                that._swiping = false;
                var pos = that.option("value") + offsetDirection * e.jQueryEvent.targetOffset;
                that.option("value", Boolean(pos));
                that._feedbackDeferred.resolve();
                that._toggleActiveState(that.element(), false)
            }
        })
    },
    _renderValue: function() {
        this._validateValue();
        var val = this.option("value");
        this._renderPosition(val, 0);
        this.element().toggleClass(SWITCH_ON_VALUE_CLASS, val);
        this._$submitElement.val(val);
        this.setAria({
            pressed: val,
            label: val ? this.option("onText") : this.option("offText")
        })
    },
    _setLabelsText: function() {
        this._$labelOn.text(this.option("onText"));
        this._$labelOff.text(this.option("offText"))
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this.repaint()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useOldRendering":
            case "useInkRipple":
                this._invalidate();
                break;
            case "width":
                delete this._marginBound;
                this._refresh();
                break;
            case "onText":
            case "offText":
                this._setLabelsText();
                break;
            case "value":
                this._renderValue();
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxSwitch", Switch);
module.exports = Switch;
module.exports.default = module.exports;


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/multi_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    fx = __webpack_require__(22),
    translator = __webpack_require__(19),
    mathUtils = __webpack_require__(56),
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    devices = __webpack_require__(6),
    registerComponent = __webpack_require__(4),
    CollectionWidget = __webpack_require__(40),
    Swipeable = __webpack_require__(126);
var MULTIVIEW_CLASS = "dx-multiview",
    MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper",
    MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container",
    MULTIVIEW_ITEM_CLASS = "dx-multiview-item",
    MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden",
    MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData",
    MULTIVIEW_ANIMATION_DURATION = 200;
var toNumber = function(value) {
    return +value
};
var position = function($element) {
    return translator.locate($element).left
};
var move = function($element, position) {
    translator.move($element, {
        left: position
    })
};
var animation = {
    moveTo: function($element, position, duration, completeAction) {
        fx.animate($element, {
            type: "slide",
            to: {
                left: position
            },
            duration: duration,
            complete: completeAction
        })
    },
    complete: function($element) {
        fx.stop($element, true)
    }
};
var MultiView = CollectionWidget.inherit({
    _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
    _supportedKeys: function() {
        return extend(this.callBase(), {
            pageUp: commonUtils.noop,
            pageDown: commonUtils.noop
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            selectedIndex: 0,
            swipeEnabled: true,
            animationEnabled: true,
            loop: false,
            deferRendering: true,
            _itemAttributes: {
                role: "tabpanel"
            },
            loopItemFocus: false,
            selectOnFocus: true,
            selectionMode: "single",
            selectionRequired: true,
            selectionByClick: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _itemClass: function() {
        return MULTIVIEW_ITEM_CLASS
    },
    _itemDataKey: function() {
        return MULTIVIEW_ITEM_DATA_KEY
    },
    _itemContainer: function() {
        return this._$itemContainer
    },
    _itemElements: function() {
        return this._itemContainer().children(this._itemSelector())
    },
    _itemWidth: function() {
        if (!this._itemWidthValue) {
            this._itemWidthValue = this._$wrapper.width()
        }
        return this._itemWidthValue
    },
    _clearItemWidthCache: function() {
        delete this._itemWidthValue
    },
    _itemsCount: function() {
        return this.option("items").length
    },
    _normalizeIndex: function(index) {
        var count = this._itemsCount();
        if (index < 0) {
            index += count
        }
        if (index >= count) {
            index -= count
        }
        return index
    },
    _getRTLSignCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1
    },
    _init: function() {
        this.callBase.apply(this, arguments);
        var $element = this.element();
        $element.addClass(MULTIVIEW_CLASS);
        this._$wrapper = $("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
        this._$wrapper.appendTo($element);
        this._$itemContainer = $("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
        this._$itemContainer.appendTo(this._$wrapper);
        this.option("loopItemFocus", this.option("loop"));
        this._initSwipeable()
    },
    _render: function() {
        this._deferredItems = [];
        this.callBase()
    },
    _renderItemContent: function(args) {
        var renderContentDeferred = $.Deferred();
        var that = this,
            callBase = this.callBase;
        var deferred = $.Deferred();
        deferred.done(function() {
            var $itemContent = callBase.call(that, args);
            renderContentDeferred.resolve($itemContent)
        });
        this._deferredItems.push(deferred);
        this.option("deferRendering") || deferred.resolve();
        return renderContentDeferred.promise()
    },
    _renderSelection: function(addedSelection) {
        this._updateItems(addedSelection[0])
    },
    _updateItems: function(selectedIndex, newIndex) {
        this._updateItemsPosition(selectedIndex, newIndex);
        this._updateItemsVisibility(selectedIndex, newIndex)
    },
    _updateItemsPosition: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements(),
            positionSign = -this._animationDirection(newIndex, selectedIndex),
            $selectedItem = $itemElements.eq(selectedIndex);
        move($selectedItem, 0);
        move($itemElements.eq(newIndex), 100 * positionSign + "%")
    },
    _updateItemsVisibility: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements();
        $itemElements.each(function(itemIndex, item) {
            var $item = $(item),
                isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
            if (!isHidden) {
                this._renderSpecificItem(itemIndex)
            }
            $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);
            this.setAria("hidden", isHidden || void 0, $item)
        }.bind(this))
    },
    _renderSpecificItem: function(index) {
        var hasItemContent = this._itemElements().eq(index).find(this._itemContentClass()).length > 0;
        if (commonUtils.isDefined(index) && !hasItemContent) {
            this._deferredItems[index].resolve()
        }
    },
    _setAriaSelected: commonUtils.noop,
    _updateSelection: function(addedSelection, removedSelection) {
        var newIndex = addedSelection[0],
            prevIndex = removedSelection[0];
        animation.complete(this._$itemContainer);
        this._updateItems(prevIndex, newIndex);
        var animationDirection = this._animationDirection(newIndex, prevIndex);
        this._animateItemContainer(animationDirection * this._itemWidth(), function() {
            move(this._$itemContainer, 0);
            this._updateItems(newIndex);
            this._$itemContainer.width()
        }.bind(this))
    },
    _animateItemContainer: function(position, completeCallback) {
        var duration = this.option("animationEnabled") ? MULTIVIEW_ANIMATION_DURATION : 0;
        animation.moveTo(this._$itemContainer, position, duration, completeCallback)
    },
    _animationDirection: function(newIndex, prevIndex) {
        var containerPosition = position(this._$itemContainer),
            indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection(),
            isSwipePresent = 0 !== containerPosition,
            directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
        return mathUtils.sign(directionSignVariable)
    },
    _initSwipeable: function() {
        this._createComponent(this.element(), Swipeable, {
            disabled: !this.option("swipeEnabled"),
            elastic: false,
            itemSizeFunc: this._itemWidth.bind(this),
            onStart: function(args) {
                this._swipeStartHandler(args.jQueryEvent)
            }.bind(this),
            onUpdated: function(args) {
                this._swipeUpdateHandler(args.jQueryEvent)
            }.bind(this),
            onEnd: function(args) {
                this._swipeEndHandler(args.jQueryEvent)
            }.bind(this)
        })
    },
    _swipeStartHandler: function(e) {
        animation.complete(this._$itemContainer);
        var selectedIndex = this.option("selectedIndex"),
            loop = this.option("loop"),
            lastIndex = this._itemsCount() - 1,
            rtl = this.option("rtlEnabled");
        e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
        e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));
        this._swipeDirection = null
    },
    _swipeUpdateHandler: function(e) {
        var offset = e.offset,
            swipeDirection = mathUtils.sign(offset) * this._getRTLSignCorrection();
        move(this._$itemContainer, offset * this._itemWidth());
        if (swipeDirection !== this._swipeDirection) {
            this._swipeDirection = swipeDirection;
            var selectedIndex = this.option("selectedIndex"),
                newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
            this._updateItems(selectedIndex, newIndex)
        }
    },
    _swipeEndHandler: function(e) {
        var targetOffset = e.targetOffset * this._getRTLSignCorrection();
        if (targetOffset) {
            this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
            var $selectedElement = this.itemElements().filter(".dx-item-selected");
            this.option("focusStateEnabled") && this.option("focusedElement", $selectedElement)
        } else {
            this._animateItemContainer(0, commonUtils.noop)
        }
    },
    _getItemFocusLoopSignCorrection: function() {
        return this._itemFocusLooped ? -1 : 1
    },
    _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this._itemFocusLooped = false
    },
    _prevItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.last());
        return $result
    },
    _nextItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.first());
        return $result
    },
    _dimensionChanged: function() {
        this._clearItemWidthCache()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _optionChanged: function(args) {
        var value = args.value;
        switch (args.name) {
            case "loop":
                this.option("loopItemFocus", value);
                break;
            case "animationEnabled":
                break;
            case "swipeEnabled":
                Swipeable.getInstance(this.element()).option("disabled", !value);
                break;
            case "deferRendering":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxMultiView", MultiView);
module.exports = MultiView;
module.exports.default = module.exports;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tabs/item.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    CollectionWidgetItem = __webpack_require__(122);
var TABS_ITEM_BADGE_CLASS = "dx-tabs-item-badge",
    BADGE_CLASS = "dx-badge";
var TabsItem = CollectionWidgetItem.inherit({
    _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this))
    },
    _renderBadge: function(badge) {
        this._$element.children("." + BADGE_CLASS).remove();
        if (!badge) {
            return
        }
        var $badge = $("<div>").addClass(TABS_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge);
        this._$element.append($badge)
    }
});
module.exports = TabsItem;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tag_box.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    devices = __webpack_require__(6),
    commonUtils = __webpack_require__(2),
    arrayUtils = __webpack_require__(7),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    messageLocalization = __webpack_require__(8),
    registerComponent = __webpack_require__(4),
    eventUtils = __webpack_require__(3),
    SelectBox = __webpack_require__(128),
    clickEvent = __webpack_require__(11),
    caret = __webpack_require__(193),
    browser = __webpack_require__(21),
    when = __webpack_require__(10).when,
    pointerEvents = __webpack_require__(17),
    BindableTemplate = __webpack_require__(52);
var TAGBOX_TAG_DATA_KEY = "dxTagData";
var TAGBOX_CLASS = "dx-tagbox",
    TAGBOX_TAG_CONTAINER_CLASS = "dx-tag-container",
    TAGBOX_TAG_CLASS = "dx-tag",
    TAGBOX_CUSTOM_TAG_CLASS = "dx-tag-custom",
    TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button",
    TAGBOX_ONLY_SELECT_CLASS = "dx-tagbox-only-select",
    TAGBOX_SINGLE_LINE_CLASS = "dx-tagbox-single-line",
    TAGBOX_POPUP_WRAPPER_CLASS = "dx-tagbox-popup-wrapper",
    LIST_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox",
    TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
    TAGBOX_DEFAULT_FIELD_TEMPLATE_CLASS = "dx-tagbox-default-template",
    TAGBOX_CUSTOM_FIELD_TEMPLATE_CLASS = "dx-tagbox-custom-template",
    NATIVE_CLICK_CLASS = "dx-native-click",
    TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container";
var TAGBOX_MOUSE_WHEEL_DELTA_MULTIPLIER = -.3;
var TagBox = SelectBox.inherit({
    _supportedKeys: function() {
        var parent = this.callBase();
        return extend(parent, {
            backspace: function(e) {
                if (!this._isCaretAtTheStart()) {
                    return
                }
                e.preventDefault();
                e.stopPropagation();
                this._isTagRemoved = true;
                var $tagToDelete = this._$focusedTag || this._tagElements().last();
                if (this._$focusedTag) {
                    this._moveTagFocus("prev", true)
                }
                if (0 === $tagToDelete.length) {
                    return
                }
                this._preserveFocusedTag = true;
                this._removeTagElement($tagToDelete);
                delete this._preserveFocusedTag
            },
            del: function(e) {
                if (!this._$focusedTag || !this._isCaretAtTheStart()) {
                    return
                }
                e.preventDefault();
                e.stopPropagation();
                this._isTagRemoved = true;
                var $tagToDelete = this._$focusedTag;
                this._moveTagFocus("next", true);
                this._preserveFocusedTag = true;
                this._removeTagElement($tagToDelete);
                delete this._preserveFocusedTag
            },
            enter: function(e) {
                var isListItemFocused = this._list && null !== this._list.option("focusedElement"),
                    isCustomItem = this.option("acceptCustomValue") && !isListItemFocused;
                if (isCustomItem) {
                    e.preventDefault();
                    "" !== this._searchValue() && this._customItemAddedHandler();
                    return
                }
                if (!this.option("opened")) {
                    return
                }
                e.preventDefault();
                this._keyboardProcessor._childProcessors[0].process(e)
            },
            leftArrow: function(e) {
                if (!this._isCaretAtTheStart()) {
                    return
                }
                var rtlEnabled = this.option("rtlEnabled");
                if (this._isEditable() && rtlEnabled && !this._$focusedTag) {
                    return
                }
                e.preventDefault();
                var direction = rtlEnabled ? "next" : "prev";
                this._moveTagFocus(direction);
                !this.option("multiline") && this._scrollContainer(direction)
            },
            rightArrow: function(e) {
                if (!this._isCaretAtTheStart()) {
                    return
                }
                var rtlEnabled = this.option("rtlEnabled");
                if (this._isEditable() && !rtlEnabled && !this._$focusedTag) {
                    return
                }
                e.preventDefault();
                var direction = rtlEnabled ? "prev" : "next";
                this._moveTagFocus(direction);
                !this.option("multiline") && this._scrollContainer(direction)
            }
        })
    },
    _isCaretAtTheStart: function() {
        var position = caret(this._input());
        return 0 === position.start && 0 === position.end
    },
    _moveTagFocus: function(direction, clearOnBoundary) {
        if (!this._$focusedTag) {
            var tagElements = this._tagElements();
            this._$focusedTag = "next" === direction ? tagElements.first() : tagElements.last();
            this._toggleFocusClass(true, this._$focusedTag);
            return
        }
        var $nextFocusedTag = this._$focusedTag[direction]("." + TAGBOX_TAG_CLASS);
        if ($nextFocusedTag.length > 0) {
            this._replaceFocusedTag($nextFocusedTag)
        } else {
            if (clearOnBoundary || "next" === direction && this._isEditable()) {
                this._clearTagFocus()
            }
        }
    },
    _replaceFocusedTag: function($nextFocusedTag) {
        this._toggleFocusClass(false, this._$focusedTag);
        this._$focusedTag = $nextFocusedTag;
        this._toggleFocusClass(true, this._$focusedTag)
    },
    _clearTagFocus: function() {
        if (!this._$focusedTag) {
            return
        }
        this._toggleFocusClass(false, this._$focusedTag);
        delete this._$focusedTag
    },
    _focusClassTarget: function($element) {
        if ($element && $element.length && $element[0] !== this._focusTarget()[0]) {
            return $element
        }
        return this.callBase()
    },
    _scrollContainer: function(direction) {
        if (this.option("multiline")) {
            return
        }
        if (!this._$tagsContainer) {
            return
        }
        var scrollPosition = this._getScrollPosition(direction);
        this._$tagsContainer.scrollLeft(scrollPosition)
    },
    _getScrollPosition: function(direction) {
        if ("start" === direction || "end" === direction) {
            return this._getBorderPosition(direction)
        }
        return this._$focusedTag ? this._getFocusedTagPosition(direction) : this._getBorderPosition("end")
    },
    _getBorderPosition: function(direction) {
        var rtlEnabled = this.option("rtlEnabled"),
            isScrollLeft = "end" === direction ^ rtlEnabled,
            isScrollReverted = rtlEnabled && !browser.webkit,
            scrollSign = !rtlEnabled || browser.webkit || browser.msie ? 1 : -1;
        return isScrollLeft ^ !isScrollReverted ? 0 : scrollSign * (this._$tagsContainer.get(0).scrollWidth - this._$tagsContainer.outerWidth())
    },
    _getFocusedTagPosition: function(direction) {
        var rtlEnabled = this.option("rtlEnabled"),
            isScrollLeft = "next" === direction ^ rtlEnabled,
            scrollOffset = this._$focusedTag.position().left,
            scrollLeft = this._$tagsContainer.scrollLeft();
        if (isScrollLeft) {
            scrollOffset += this._$focusedTag.outerWidth(true) - this._$tagsContainer.outerWidth()
        }
        if (isScrollLeft ^ scrollOffset < 0) {
            var scrollCorrection = rtlEnabled && browser.msie ? -1 : 1;
            scrollLeft += scrollOffset * scrollCorrection
        }
        return scrollLeft
    },
    _setNextValue: commonUtils.noop,
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            values: {
                since: "16.1",
                alias: "value"
            }
        })
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            value: [],
            showDropDownButton: false,
            tagTemplate: "tag",
            selectAllText: messageLocalization.format("dxList-selectAll"),
            hideSelectedItems: false,
            selectedItems: [],
            selectAllMode: "page",
            onSelectAllValueChanged: null,
            multiline: true
        })
    },
    _init: function() {
        this.callBase();
        this._selectedItems = [];
        this._initSelectAllValueChangedAction()
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.tag = new BindableTemplate(function($container, data) {
            var $tagContent = $("<div>").addClass(TAGBOX_TAG_CONTENT_CLASS);
            $("<span>").text(data).appendTo($tagContent);
            $("<div>").addClass(TAGBOX_TAG_REMOVE_BUTTON_CLASS).appendTo($tagContent);
            $container.append($tagContent)
        }, [], this.option("integrationOptions.watchMethod"))
    },
    _renderSubmitElement: function() {
        this._$submitElement = $("<select>").attr("multiple", "multiple").css("display", "none").appendTo(this.element())
    },
    _setSubmitValue: function() {
        var value = this._getValue(),
            useDisplayText = "this" === this.option("valueExpr"),
            $options = [];
        for (var i = 0, n = value.length; i < n; i++) {
            $options.push($("<option>").val(useDisplayText ? this._displayGetter(value[i]) : value[i]).attr("selected", "selected"))
        }
        this._$submitElement.html($options)
    },
    _render: function() {
        this._tagElementsCache = $();
        var isSingleLineMode = !this.option("multiline");
        this.element().addClass(TAGBOX_CLASS).toggleClass(TAGBOX_ONLY_SELECT_CLASS, !(this.option("searchEnabled") || this.option("acceptCustomValue"))).toggleClass(TAGBOX_SINGLE_LINE_CLASS, isSingleLineMode);
        this._toggleRTLDirection(this.option("rtlEnabled"));
        this._initTagTemplate();
        this.callBase();
        if (isSingleLineMode) {
            this._renderPreventBlur()
        }
        this._renderTagRemoveAction();
        this._renderSingleLineScroll();
        this._scrollContainer("start")
    },
    _initTagTemplate: function() {
        this._tagTemplate = this._getTemplateByOption("tagTemplate")
    },
    _renderField: function() {
        var isDefaultFieldTemplate = !commonUtils.isDefined(this.option("fieldTemplate"));
        this.element().toggleClass(TAGBOX_DEFAULT_FIELD_TEMPLATE_CLASS, isDefaultFieldTemplate).toggleClass(TAGBOX_CUSTOM_FIELD_TEMPLATE_CLASS, !isDefaultFieldTemplate);
        this.callBase()
    },
    _renderPreventBlur: function() {
        var eventName = eventUtils.addNamespace(pointerEvents.down, "dxTagBoxContainer");
        this._$tagsContainer && this._$tagsContainer.off(eventName).on(eventName, function(e) {
            e.preventDefault()
        })
    },
    _renderTagRemoveAction: function() {
        var tagRemoveAction = this._createAction(this._removeTagHandler.bind(this));
        var eventName = eventUtils.addNamespace(clickEvent.name, "dxTagBoxTagRemove");
        this.element().find("." + TEXTEDITOR_CONTAINER_CLASS).off(eventName).on(eventName, "." + TAGBOX_TAG_REMOVE_BUTTON_CLASS, function(e) {
            tagRemoveAction({
                jQueryEvent: e
            })
        });
        this._renderTypingEvent()
    },
    _renderSingleLineScroll: function() {
        var mouseWheelEvent = eventUtils.addNamespace("dxmousewheel", this.NAME),
            $element = this.element(),
            isMultiline = this.option("multiline");
        $element.off(mouseWheelEvent);
        if ("desktop" !== devices.real().deviceType) {
            this._$tagsContainer && this._$tagsContainer.css("overflow-x", isMultiline ? "" : "auto");
            return
        }
        if (isMultiline) {
            return
        }
        $element.on(mouseWheelEvent, this._tagContainerMouseWheelHandler.bind(this))
    },
    _tagContainerMouseWheelHandler: function(e) {
        var scrollLeft = this._$tagsContainer.scrollLeft();
        this._$tagsContainer.scrollLeft(scrollLeft + e.delta * TAGBOX_MOUSE_WHEEL_DELTA_MULTIPLIER);
        return false
    },
    _renderTypingEvent: function() {
        this._input().on(eventUtils.addNamespace("keydown", this.NAME), function(e) {
            if (!this._isControlKey(e.key) && this._isEditable()) {
                this._clearTagFocus()
            }
        }.bind(this))
    },
    _popupWrapperClass: function() {
        return this.callBase() + " " + TAGBOX_POPUP_WRAPPER_CLASS
    },
    _renderInputValueImpl: function() {
        this._renderMultiSelect()
    },
    _loadInputValue: function() {
        return $.when()
    },
    _clearTextValue: function() {
        this._input().val("")
    },
    _focusInHandler: function(e) {
        this.callBase(e);
        this._scrollContainer("end")
    },
    _focusOutHandler: function(e) {
        if (this.option("opened") && "useButtons" === this.option("applyValueMode")) {
            return
        }
        this.callBase(e);
        this._clearTextValue();
        this._clearTagFocus();
        this._scrollContainer("start")
    },
    _getFirstPopupElement: function() {
        return this.option("showSelectionControls") ? this._popup._wrapper().find("." + LIST_SELECT_ALL_CHECKBOX_CLASS) : this.callBase()
    },
    _suppressingSelectionChanged: function(callback) {
        this._setListOption("onSelectionChanged", commonUtils.noop);
        callback.call(this);
        this._setListOption("onSelectionChanged", this._getSelectionChangeHandler())
    },
    _initSelectAllValueChangedAction: function() {
        this._selectAllValueChangeAction = this._createActionByOption("onSelectAllValueChanged")
    },
    _renderList: function() {
        this.callBase();
        this._setListDataSourceFilter();
        if (!this.option("showSelectionControls")) {
            return
        }
        var $selectAllCheckBox = this._list.element().find("." + LIST_SELECT_ALL_CHECKBOX_CLASS),
            selectAllCheckbox = $selectAllCheckBox.dxCheckBox("instance");
        selectAllCheckbox.registerKeyHandler("tab", this._popupElementTabHandler.bind(this));
        selectAllCheckbox.registerKeyHandler("escape", this._popupElementEscHandler.bind(this))
    },
    _listConfig: function() {
        var that = this,
            selectionMode = this.option("showSelectionControls") ? "all" : "multiple";
        return extend(this.callBase(), {
            selectionMode: selectionMode,
            selectAllText: this.option("selectAllText"),
            onSelectAllValueChanged: function(e) {
                that._selectAllValueChangeAction({
                    value: e.value
                })
            },
            selectAllMode: this.option("selectAllMode"),
            selectedItems: this._selectedItems,
            onFocusedItemChanged: null
        })
    },
    _renderMultiSelect: function() {
        this._$tagsContainer = this.element().find("." + TEXTEDITOR_CONTAINER_CLASS).addClass(TAGBOX_TAG_CONTAINER_CLASS).addClass(NATIVE_CLICK_CLASS);
        this._renderInputSize();
        this._clearFilter();
        this._renderTags();
        this._popup && this._popup.refreshPosition()
    },
    _listItemClickHandler: function(e) {
        !this.option("showSelectionControls") && this._clearTextValue();
        if ("useButtons" === this.option("applyValueMode")) {
            return
        }
        this.callBase(e)
    },
    _renderInputSize: function() {
        var $input = this._input();
        $input.prop("size", $input.val() ? $input.val().length + 2 : 1)
    },
    _renderInputSubstitution: function() {
        this.callBase();
        this._renderInputSize()
    },
    _getValue: function() {
        return this.option("value") || []
    },
    _renderTags: function() {
        this._cleanTags();
        var $input = this._input();
        var itemLoadDeferreds = $.map(this._getValue(), function(value) {
            return this._renderTag(value, $input)
        }.bind(this));
        when.apply($, itemLoadDeferreds).done(function() {
            this._renderInputAddons();
            this._scrollContainer("end");
            this.option("selectedItems", this._selectedItems.slice())
        }.bind(this));
        this._renderEmptyState();
        if (!this._preserveFocusedTag) {
            this._clearTagFocus()
        }
        this._refreshTagElements()
    },
    _renderEmptyState: function() {
        var isEmpty = !(this._getValue().length || this._selectedItems.length || this._searchValue());
        this._toggleEmptiness(isEmpty);
        this._renderDisplayText()
    },
    _renderDisplayText: function() {
        this._renderInputSize()
    },
    _cleanTags: function() {
        var $tags = this._tagElements(),
            values = this._getValue();
        $.each($tags, function(_, tag) {
            var $tag = $(tag),
                index = inArray($tag.data(TAGBOX_TAG_DATA_KEY), values);
            if (index < 0) {
                $tag.remove()
            }
        });
        this._cleanSelectedItems()
    },
    _cleanSelectedItems: function() {
        if (this.option("fieldTemplate")) {
            this._selectedItems = [];
            return
        }
        var values = this._getValue(),
            selectedItemsCount = this._selectedItems.length;
        for (var index = 0; index < selectedItemsCount; index++) {
            var selectedItem = this._selectedItems[index],
                value = this._valueGetter(selectedItem);
            if (inArray(value, values) < 0) {
                this._selectedItems.splice(index, 1);
                index--;
                selectedItemsCount--
            }
        }
    },
    _refreshTagElements: function() {
        this._tagElementsCache = this.element().find("." + TAGBOX_TAG_CLASS)
    },
    _tagElements: function() {
        return this._tagElementsCache
    },
    _getDefaultTagTemplate: function() {
        return this._defaultTemplates.tag
    },
    _renderTag: function(value, $input) {
        var $tag = this._getTag(value);
        if ($tag && !$tag.hasClass(TAGBOX_CUSTOM_TAG_CLASS)) {
            return $.Deferred().resolve()
        }
        $tag && $tag.removeClass(TAGBOX_CUSTOM_TAG_CLASS);
        $tag = $tag || this._createTag(value, $input);
        return this._loadItem(value).always(function(item) {
            if (!commonUtils.isDefined(item)) {
                $tag.addClass(TAGBOX_CUSTOM_TAG_CLASS);
                item = value
            } else {
                this._selectedItems.push(item)
            }
            if (this._displayGetterExpr() && this._tagTemplate === this._getDefaultTagTemplate()) {
                item = this._displayGetter(item)
            }
            this._tagTemplate.render({
                model: item,
                container: $tag
            })
        }.bind(this))
    },
    _getTag: function(value) {
        var $tags = this._tagElements(),
            tagsLength = $tags.length;
        var result = false;
        for (var i = 0; i < tagsLength; i++) {
            var $tag = $tags[i];
            if (value === $.data($tag, TAGBOX_TAG_DATA_KEY)) {
                result = $($tag);
                break
            }
        }
        return result
    },
    _createTag: function(value, $input) {
        return $("<div>").addClass(TAGBOX_TAG_CLASS).data(TAGBOX_TAG_DATA_KEY, value).insertBefore($input)
    },
    _toggleEmptinessEventHandler: function() {
        this._toggleEmptiness(!this._getValue().length && !this._searchValue().length)
    },
    _customItemAddedHandler: function(e) {
        this.callBase(e);
        this._input().val("")
    },
    _removeTagHandler: function(args) {
        var e = args.jQueryEvent;
        e.stopPropagation();
        var $tag = $(e.target).closest("." + TAGBOX_TAG_CLASS);
        this._removeTagElement($tag)
    },
    _removeTagElement: function($tag) {
        var itemValue = $tag.data(TAGBOX_TAG_DATA_KEY);
        this._removeTagWithUpdate(itemValue);
        this._refreshTagElements()
    },
    _updateField: commonUtils.noop,
    _removeTagWithUpdate: function(itemValue) {
        var value = this._getValue().slice();
        this._removeTag(value, itemValue);
        this.option("value", value);
        if (0 === value.length) {
            this._clearTagFocus()
        }
    },
    _getCurrentValue: function() {
        return this._lastValue()
    },
    _selectionChangeHandler: function(e) {
        if ("useButtons" === this.option("applyValueMode")) {
            return
        }
        var value = this._getValue().slice();
        $.each(e.removedItems || [], function(_, removedItem) {
            this._removeTag(value, this._valueGetter(removedItem))
        }.bind(this));
        $.each(e.addedItems || [], function(_, addedItem) {
            this._addTag(value, this._valueGetter(addedItem))
        }.bind(this));
        this._updateWidgetHeight();
        this.option("value", value)
    },
    _removeTag: function(value, item) {
        var index = this._valueIndex(item, value);
        if (index >= 0) {
            value.splice(index, 1)
        }
    },
    _addTag: function(value, item) {
        var index = this._valueIndex(item);
        if (index < 0) {
            value.push(item)
        }
    },
    _fieldRenderData: function() {
        return this._selectedItems.slice()
    },
    _setValue: function(value) {
        if (null === value) {
            return
        }
        if (this.option("showSelectionControls")) {
            return
        }
        var valueIndex = this._valueIndex(value),
            values = this._getValue().slice();
        if (valueIndex >= 0) {
            values.splice(valueIndex, 1)
        } else {
            values.push(value)
        }
        this.option("value", values)
    },
    _isSelectedValue: function(value) {
        return this._valueIndex(value) > -1
    },
    _valueIndex: function(value, values) {
        values = values || this._getValue();
        var result = -1;
        $.each(values, function(index, selectedValue) {
            if (this._isValueEquals(value, selectedValue)) {
                result = index;
                return false
            }
        }.bind(this));
        return result
    },
    _lastValue: function() {
        var values = this._getValue(),
            lastValue = values[values.length - 1];
        return commonUtils.isDefined(lastValue) ? lastValue : null
    },
    _valueChangeEventHandler: commonUtils.noop,
    _shouldRenderSearchEvent: function() {
        return this.option("searchEnabled") || this.option("acceptCustomValue")
    },
    _searchHandler: function(e) {
        if (this.option("searchEnabled") && !!e && !this._isTagRemoved) {
            this.callBase(e)
        }
        this._updateWidgetHeight();
        delete this._isTagRemoved
    },
    _updateWidgetHeight: function() {
        var element = this.element(),
            originalHeight = element.height();
        this._renderInputSize();
        var currentHeight = element.height();
        if (this._popup && this.option("opened") && this._isEditable() && currentHeight !== originalHeight) {
            this._popup.repaint()
        }
    },
    _refreshSelected: function() {
        this._list && this._suppressingSelectionChanged(function() {
            this.callBase()
        })
    },
    _resetListDataSourceFilter: function() {
        var dataSource = this._getDataSource();
        if (!dataSource) {
            return
        }
        dataSource.filter(null);
        dataSource.reload()
    },
    _setListDataSourceFilter: function() {
        if (!this.option("hideSelectedItems") || !this._list) {
            return
        }
        var dataSource = this._getDataSource();
        if (!dataSource) {
            return
        }
        dataSource.filter(this._dataSourceFilter.bind(this));
        dataSource.reload()
    },
    _dataSourceFilter: function(itemData) {
        var itemValue = this._valueGetter(itemData),
            result = true;
        $.each(this._getValue(), function(index, value) {
            if (this._isValueEquals(value, itemValue)) {
                result = false;
                return false
            }
        }.bind(this));
        return result
    },
    _applyButtonHandler: function() {
        this.option("value", this._getListValues());
        this._clearTextValue();
        this.callBase()
    },
    _getListValues: function() {
        if (!this._list) {
            return []
        }
        var that = this,
            selectedItems = this._getPlainItems(this._list.option("selectedItems")),
            result = [];
        $.each(selectedItems, function(index, item) {
            result[index] = that._valueGetter(item)
        });
        return result
    },
    _renderOpenedState: function() {
        this.callBase();
        if (this.option(false)) {
            this._refreshSelected()
        }
    },
    _clean: function() {
        this.callBase();
        delete this._defaultTagTemplate;
        delete this._tagTemplate
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onSelectAllValueChanged":
                this._initSelectAllValueChangedAction();
                break;
            case "hideSelectedItems":
                if (args.value) {
                    this._setListDataSourceFilter()
                } else {
                    this._resetListDataSourceFilter()
                }
                break;
            case "displayExpr":
                this.callBase(args);
                this._invalidate();
                break;
            case "tagTemplate":
                this._initTagTemplate();
                this._invalidate();
                break;
            case "selectAllText":
                this._setListOption("selectAllText", this.option("selectAllText"));
                break;
            case "value":
                this.callBase(args);
                this._setListDataSourceFilter();
                break;
            case "selectAllMode":
                this._setListOption(args.name, args.value);
                break;
            case "selectedItem":
                break;
            case "selectedItems":
                var addedItems = arrayUtils.removeDuplicates(args.value, args.previousValue),
                    removedItems = arrayUtils.removeDuplicates(args.previousValue, args.value);
                this._selectionChangedAction({
                    addedItems: addedItems,
                    removedItems: removedItems
                });
                break;
            case "multiline":
                this.element().toggleClass(TAGBOX_SINGLE_LINE_CLASS, !args.value);
                this._renderSingleLineScroll();
                break;
            default:
                this.callBase(args)
        }
    },
    reset: function() {
        this.option("value", []);
        this._clearFilter();
        this._clearSelectedItem()
    }
});
registerComponent("dxTagBox", TagBox);
module.exports = TagBox;
module.exports.default = module.exports;


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/text_area.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    registerComponent = __webpack_require__(4),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    TextBox = __webpack_require__(69);
var TEXTAREA_CLASS = "dx-textarea",
    TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
var TextArea = TextBox.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            spellcheck: true,
            minHeight: void 0,
            maxHeight: void 0,
            autoResizeEnabled: false
        })
    },
    _render: function() {
        this.callBase();
        this.element().addClass(TEXTAREA_CLASS);
        this.setAria("multiline", "true");
        this._updateInputHeight()
    },
    _renderInput: function() {
        this.callBase();
        this._renderScrollHandler()
    },
    _createInput: function() {
        var $input = $("<textarea>");
        this._applyInputAttributes($input, this.option("inputAttr"));
        return $input
    },
    _applyInputAttributes: function($input, customAttributes) {
        $input.attr(customAttributes).addClass(TEXTEDITOR_INPUT_CLASS)
    },
    _renderScrollHandler: function() {
        var $input = this._input(),
            eventY = 0;
        $input.on(eventUtils.addNamespace(pointerEvents.down, this.NAME), function(e) {
            eventY = eventUtils.eventData(e).y
        });
        $input.on(eventUtils.addNamespace(pointerEvents.move, this.NAME), function(e) {
            var scrollTopPos = $input.scrollTop(),
                scrollBottomPos = $input.prop("scrollHeight") - $input.prop("clientHeight") - scrollTopPos;
            if (0 === scrollTopPos && 0 === scrollBottomPos) {
                return
            }
            var currentEventY = eventUtils.eventData(e).y;
            var isScrollFromTop = 0 === scrollTopPos && eventY >= currentEventY,
                isScrollFromBottom = 0 === scrollBottomPos && eventY <= currentEventY,
                isScrollFromMiddle = scrollTopPos > 0 && scrollBottomPos > 0;
            if (isScrollFromTop || isScrollFromBottom || isScrollFromMiddle) {
                e.isScrollingEvent = true;
                e.stopPropagation()
            }
            eventY = currentEventY
        })
    },
    _renderDimensions: function() {
        var width = this.option("width"),
            height = this.option("height"),
            minHeight = this.option("minHeight"),
            maxHeight = this.option("maxHeight"),
            $element = this.element();
        $element.css({
            "min-height": void 0 !== minHeight ? minHeight : "",
            "max-height": void 0 !== maxHeight ? maxHeight : ""
        });
        $element.outerWidth(width);
        $element.outerHeight(height)
    },
    _resetDimensions: function() {
        this.element().css({
            height: "",
            "min-height": "",
            "max-height": ""
        })
    },
    _renderEvents: function() {
        if (this.option("autoResizeEnabled")) {
            this._input().on(eventUtils.addNamespace("input paste", this.NAME), this._updateInputHeight.bind(this))
        }
        this.callBase()
    },
    _refreshEvents: function() {
        this._input().off(eventUtils.addNamespace("input paste", this.NAME));
        this.callBase()
    },
    _updateInputHeight: function() {
        var $input = this._input();
        if (!this.option("autoResizeEnabled") || void 0 !== this.option("height")) {
            $input.css("height", "");
            return
        }
        this._resetDimensions();
        $input.css("height", 0);
        var heightDifference = this._$element.outerHeight() - $input.outerHeight();
        this._renderDimensions();
        var minHeight = this.option("minHeight"),
            maxHeight = this.option("maxHeight"),
            inputHeight = $input[0].scrollHeight;
        if (void 0 !== minHeight) {
            inputHeight = Math.max(inputHeight, minHeight - heightDifference)
        }
        if (void 0 !== maxHeight) {
            inputHeight = Math.min(inputHeight, maxHeight - heightDifference)
        }
        $input.css("height", inputHeight)
    },
    _renderInputType: noop,
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateInputHeight()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "autoResizeEnabled":
                this._refreshEvents();
                this._updateInputHeight();
                break;
            case "value":
            case "height":
                this.callBase(args);
                this._updateInputHeight();
                break;
            case "minHeight":
            case "maxHeight":
                this._renderDimensions();
                this._updateInputHeight();
                break;
            case "visible":
                this.callBase(args);
                args.value && this._updateInputHeight();
                break;
            default:
                this.callBase(args)
        }
    }
});
registerComponent("dxTextArea", TextArea);
module.exports = TextArea;
module.exports.default = module.exports;


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.action_sheet.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ToolbarStrategy = __webpack_require__(156),
    extend = __webpack_require__(1).extend,
    ActionSheet = __webpack_require__(196);
var ActionSheetStrategy = ToolbarStrategy.inherit({
    NAME: "actionSheet",
    _getMenuItemTemplate: function() {
        return this._toolbar._getTemplate("actionSheetItem")
    },
    render: function() {
        if (!this._hasVisibleMenuItems()) {
            return
        }
        this.callBase()
    },
    _menuWidgetClass: function() {
        return ActionSheet
    },
    _menuContainer: function() {
        return this._toolbar.element()
    },
    _widgetOptions: function() {
        return extend({}, this.callBase(), {
            target: this._$button,
            showTitle: false
        })
    },
    _menuButtonOptions: function() {
        return extend({}, this.callBase(), {
            icon: "overflow"
        })
    },
    _toggleMenu: function() {
        this.callBase.apply(this, arguments);
        this._menu.toggle(this._menuShown);
        this._menuShown = false
    }
});
module.exports = ActionSheetStrategy;


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.drop_down_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    ToolbarStrategy = __webpack_require__(156),
    ToolbarMenu = __webpack_require__(337),
    DropDownMenu = __webpack_require__(155);
var DropDownMenuStrategy = ToolbarStrategy.inherit({
    NAME: "dropDownMenu",
    render: function() {
        if (!this._hasVisibleMenuItems()) {
            return
        }
        this._renderMenuButtonContainer();
        this._renderWidget()
    },
    renderMenuItems: function() {
        if (!this._menu) {
            this.render()
        }
        this.callBase();
        if (this._menu && !this._menu.option("items").length) {
            this._menu.close()
        }
    },
    _menuWidgetClass: function() {
        return DropDownMenu
    },
    _widgetOptions: function() {
        return extend(this.callBase(), {
            deferRendering: true,
            menuWidget: ToolbarMenu,
            popupPosition: {
                at: "bottom right",
                my: "top right"
            }
        })
    },
    _getMenuItems: function() {
        var menuItems = this.callBase(),
            isMenuVisible = menuItems.length && this._hasVisibleMenuItems(menuItems);
        this._toggleMenuVisibility(isMenuVisible);
        return menuItems
    },
    _toggleMenuVisibility: function(value) {
        if (!this._menuContainer()) {
            return
        }
        this._menuContainer().toggleClass("dx-state-invisible", !value)
    },
    _menuContainer: function() {
        return this._$menuButtonContainer
    }
});
module.exports = DropDownMenuStrategy;


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    List = __webpack_require__(124);
var TOOLBAR_MENU_ACTION_CLASS = "dx-toolbar-menu-action",
    TOOLBAR_HIDDEN_BUTTON_CLASS = "dx-toolbar-hidden-button",
    TOOLBAR_MENU_SECTION_CLASS = "dx-toolbar-menu-section",
    TOOLBAR_MENU_LAST_SECTION_CLASS = "dx-toolbar-menu-last-section";
var ToolbarMenu = List.inherit({
    _activeStateUnit: "." + TOOLBAR_MENU_ACTION_CLASS,
    _render: function() {
        this._renderSections();
        this.callBase()
    },
    _getSections: function() {
        return this._itemContainer().children()
    },
    _itemElements: function() {
        return this._getSections().children(this._itemSelector())
    },
    _renderSections: function() {
        var that = this,
            $container = this._itemContainer();
        $.each(["before", "center", "after", "menu"], function() {
            var sectionName = "_$" + this + "Section",
                $section = that[sectionName];
            if (!$section) {
                that[sectionName] = $section = $("<div>").addClass(TOOLBAR_MENU_SECTION_CLASS)
            }
            $section.appendTo($container)
        })
    },
    _renderItems: function() {
        this.callBase.apply(this, arguments);
        this._updateSections()
    },
    _updateSections: function() {
        var $sections = this.element().find("." + TOOLBAR_MENU_SECTION_CLASS);
        $sections.removeClass(TOOLBAR_MENU_LAST_SECTION_CLASS);
        $sections.not(":empty").eq(-1).addClass(TOOLBAR_MENU_LAST_SECTION_CLASS)
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var itemElement, location = item.location || "menu",
            $container = this["_$" + location + "Section"];
        itemElement = this.callBase(index, item, $container, $after);
        if (this._getItemTemplateName({
                itemData: item
            })) {
            itemElement.addClass("dx-toolbar-menu-custom")
        }
        if ("menu" === location || "dxButton" === item.widget || item.isAction) {
            itemElement.addClass(TOOLBAR_MENU_ACTION_CLASS)
        }
        if ("dxButton" === item.widget) {
            itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_CLASS)
        }
        return itemElement
    },
    _getItemTemplateName: function(args) {
        var template = this.callBase(args);
        var data = args.itemData,
            menuTemplate = data && data.menuItemTemplate;
        return menuTemplate || template
    },
    _itemClickHandler: function(e, args, config) {
        if ($(e.target).closest("." + TOOLBAR_MENU_ACTION_CLASS).length) {
            this.callBase(e, args, config)
        }
    },
    _clean: function() {
        this._getSections().empty();
        this.callBase()
    }
});
registerComponent("dxToolbarMenu", ToolbarMenu);
module.exports = ToolbarMenu;


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_bottom.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var ListStrategy = __webpack_require__(207),
    Swipeable = __webpack_require__(126);
var ListBottomStrategy = ListStrategy.inherit({
    NAME: "listBottom",
    _renderWidget: function() {
        this._renderContainerSwipe();
        this.callBase();
        this._toolbar._$toolbarItemsContainer.prependTo(this._listOverlay.content())
    },
    _renderContainerSwipe: function() {
        this._toolbar._createComponent(this._toolbar._$toolbarItemsContainer, Swipeable, {
            elastic: false,
            onStart: this._swipeStartHandler.bind(this),
            onUpdated: this._swipeUpdateHandler.bind(this),
            onEnd: this._swipeEndHandler.bind(this),
            itemSizeFunc: this._getListHeight.bind(this),
            direction: "vertical"
        })
    },
    _swipeStartHandler: function(e) {
        e.jQueryEvent.maxTopOffset = this._menuShown ? 0 : 1;
        e.jQueryEvent.maxBottomOffset = this._menuShown ? 1 : 0
    },
    _swipeUpdateHandler: function(e) {
        var offset = this._menuShown ? e.jQueryEvent.offset : 1 + e.jQueryEvent.offset;
        this._renderMenuPosition(offset, false)
    },
    _swipeEndHandler: function(e) {
        var targetOffset = e.jQueryEvent.targetOffset;
        targetOffset -= this._menuShown - 1;
        this._toggleMenu(0 === targetOffset, true)
    }
});
module.exports = ListBottomStrategy;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.list_top.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    ListStrategy = __webpack_require__(207),
    extend = __webpack_require__(1).extend,
    translator = __webpack_require__(19);
var ListTopStrategy = ListStrategy.inherit({
    NAME: "listTop",
    _listOverlayConfig: function() {
        var config = this.callBase();
        return extend({}, config, {
            onContentReady: this._setItemsContainerZIndex.bind(this)
        })
    },
    _setItemsContainerZIndex: function(e) {
        var overlayZIndex = e.component.content().css("z-index");
        this._toolbar._$toolbarItemsContainer.css("z-index", overlayZIndex + 1)
    },
    _renderMenuPosition: function(offset, animate) {
        var $element = this._toolbar._$toolbarItemsContainer;
        var pos = this._calculateItemsContainerOffset(offset);
        if (animate) {
            this._animateMenuToggling($element, pos, this._menuShown)
        } else {
            translator.move($element, {
                top: pos
            })
        }
        return this.callBase(offset, animate)
    },
    _calculateItemsContainerOffset: function(offset) {
        offset = (offset || 0) - 1;
        var maxOffset = this._getItemsContainerHeight();
        return offset * maxOffset
    },
    _getItemsContainerHeight: function() {
        var semiHiddenHeight = this._toolbar._$toolbarItemsContainer.height() - this._toolbar.element().height();
        return semiHiddenHeight
    },
    _listOutsideClickHandler: function(e) {
        var $target = $(e.target);
        var isOverlayClick = $target.closest(this._listOverlay.content()).length > 0;
        var isItemsContainerClick = $target.closest(this._toolbar._$toolbarItemsContainer).length > 0;
        if (!isOverlayClick && !isItemsContainerClick) {
            this._toggleMenu(false, true)
        }
    }
});
module.exports = ListTopStrategy;


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/validation/default_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5);
var DefaultAdapter = Class.inherit({
    ctor: function(editor, validator) {
        var that = this;
        that.editor = editor;
        that.validator = validator;
        that.validationRequestsCallbacks = $.Callbacks();
        var handler = function() {
            that.validationRequestsCallbacks.fire()
        };
        editor.validationRequest.add(handler);
        editor.on("disposing", function() {
            editor.validationRequest.remove(handler)
        })
    },
    getValue: function() {
        return this.editor.option("value")
    },
    getCurrentValidationError: function() {
        return this.editor.option("validationError")
    },
    bypass: function() {
        return this.editor.option("disabled")
    },
    applyValidationResults: function(params) {
        this.editor.option({
            isValid: params.isValid,
            validationError: params.brokenRule
        })
    },
    reset: function() {
        this.editor.reset()
    },
    focus: function() {
        this.editor.focus()
    }
});
module.exports = DefaultAdapter;


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/accordion.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    fx = __webpack_require__(22),
    clickEvent = __webpack_require__(11),
    devices = __webpack_require__(6),
    extend = __webpack_require__(1).extend,
    isPlainObject = __webpack_require__(9).isPlainObject,
    registerComponent = __webpack_require__(4),
    eventUtils = __webpack_require__(3),
    CollectionWidget = __webpack_require__(40),
    when = __webpack_require__(10).when,
    BindableTemplate = __webpack_require__(52),
    iconUtils = __webpack_require__(77);
var ACCORDION_CLASS = "dx-accordion",
    ACCORDION_WRAPPER_CLASS = "dx-accordion-wrapper",
    ACCORDION_ITEM_CLASS = "dx-accordion-item",
    ACCORDION_ITEM_OPENED_CLASS = "dx-accordion-item-opened",
    ACCORDION_ITEM_CLOSED_CLASS = "dx-accordion-item-closed",
    ACCORDION_ITEM_TITLE_CLASS = "dx-accordion-item-title",
    ACCORDION_ITEM_BODY_CLASS = "dx-accordion-item-body",
    ACCORDION_ITEM_DATA_KEY = "dxAccordionItemData";
var Accordion = CollectionWidget.inherit({
    _activeStateUnit: "." + ACCORDION_ITEM_CLASS,
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            hoverStateEnabled: true,
            height: void 0,
            itemTitleTemplate: "title",
            onItemTitleClick: null,
            selectedIndex: 0,
            collapsible: false,
            multiple: false,
            animationDuration: 300,
            deferRendering: true,
            selectionByClick: true,
            activeStateEnabled: true,
            _itemAttributes: {
                role: "tab"
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === devices.real().deviceType && !devices.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _itemElements: function() {
        return this._itemContainer().children(this._itemSelector())
    },
    _init: function() {
        this.callBase();
        this.option("selectionRequired", !this.option("collapsible"));
        this.option("selectionMode", this.option("multiple") ? "multiple" : "single");
        var $element = this.element();
        $element.addClass(ACCORDION_CLASS);
        this._$container = $("<div>").addClass(ACCORDION_WRAPPER_CLASS);
        $element.append(this._$container)
    },
    _initTemplates: function() {
        this.callBase();
        this._defaultTemplates.title = new BindableTemplate(function($container, data) {
            if (isPlainObject(data)) {
                if (data.title) {
                    $container.text(data.title)
                }
                $container.append(iconUtils.getImageContainer(data.icon || data.iconSrc))
            } else {
                $container.html(String(data))
            }
        }, ["title", "icon", "iconSrc"], this.option("integrationOptions.watchMethod"))
    },
    _render: function() {
        this._deferredItems = [];
        this.callBase();
        this._fireContentReadyAction();
        this.setAria({
            role: "tablist",
            multiselectable: this.option("multiple")
        });
        this._attachItemTitleClickAction()
    },
    _renderContent: function() {
        this._renderContentImpl()
    },
    _itemDataKey: function() {
        return ACCORDION_ITEM_DATA_KEY
    },
    _itemClass: function() {
        return ACCORDION_ITEM_CLASS
    },
    _itemContainer: function() {
        return this._$container
    },
    _itemTitles: function() {
        return this._itemElements().find("." + ACCORDION_ITEM_TITLE_CLASS)
    },
    _itemContents: function() {
        return this._itemElements().find("." + ACCORDION_ITEM_BODY_CLASS)
    },
    _getItemData: function(target) {
        return $(target).parent().data(this._itemDataKey()) || this.callBase.apply(this, arguments)
    },
    _executeItemRenderAction: function(itemData) {
        if (itemData.type) {
            return
        }
        this.callBase.apply(this, arguments)
    },
    _itemSelectHandler: function(e) {
        if ($(e.target).closest(this._itemContents()).length) {
            return
        }
        this.callBase.apply(this, arguments)
    },
    _renderItemContent: function(args) {
        var $itemTitle = this.callBase(extend({}, args, {
            contentClass: ACCORDION_ITEM_TITLE_CLASS,
            templateProperty: "titleTemplate",
            defaultTemplateName: this.option("itemTitleTemplate")
        }));
        var deferred = $.Deferred();
        this._deferredItems.push(deferred);
        if (!this.option("deferRendering")) {
            deferred.resolve()
        }
        deferred.done(this.callBase.bind(this, extend({}, args, {
            contentClass: ACCORDION_ITEM_BODY_CLASS,
            container: $("<div>").appendTo($itemTitle.parent())
        })))
    },
    _attachItemTitleClickAction: function() {
        var itemSelector = "." + ACCORDION_ITEM_TITLE_CLASS,
            eventName = eventUtils.addNamespace(clickEvent.name, this.NAME);
        this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, this._itemTitleClickHandler.bind(this))
    },
    _itemTitleClickHandler: function(e) {
        this._itemJQueryEventHandler(e, "onItemTitleClick")
    },
    _renderSelection: function(addedSelection, removedSelection) {
        this._itemElements().addClass(ACCORDION_ITEM_CLOSED_CLASS);
        this.setAria("hidden", true, this._itemContents());
        this._updateItems(addedSelection, removedSelection, true)
    },
    _updateSelection: function(addedSelection, removedSelection) {
        this._updateItems(addedSelection, removedSelection, false)
    },
    _updateItems: function(addedSelection, removedSelection, skipAnimation) {
        var $items = this._itemElements(),
            that = this;
        $.each(addedSelection, function(_, index) {
            that._deferredItems[index].resolve();
            var $item = $items.eq(index).addClass(ACCORDION_ITEM_OPENED_CLASS).removeClass(ACCORDION_ITEM_CLOSED_CLASS);
            that.setAria("hidden", false, $item.find("." + ACCORDION_ITEM_BODY_CLASS))
        });
        $.each(removedSelection, function(_, index) {
            var $item = $items.eq(index).removeClass(ACCORDION_ITEM_OPENED_CLASS);
            that.setAria("hidden", true, $item.find("." + ACCORDION_ITEM_BODY_CLASS))
        });
        if (that.option("templatesRenderAsynchronously")) {
            this._animationTimer = setTimeout(function() {
                this._updateItemHeights(skipAnimation)
            }.bind(this))
        } else {
            this._updateItemHeights(skipAnimation)
        }
    },
    _updateItemHeights: function(skipAnimation) {
        var that = this,
            deferredAnimate = that._deferredAnimate,
            itemHeight = this._splitFreeSpace(this._calculateFreeSpace());
        clearTimeout(this._animationTimer);
        return when.apply($, $.map(this._itemElements(), function(item) {
            return that._updateItemHeight($(item), itemHeight, skipAnimation)
        })).done(function() {
            if (deferredAnimate) {
                deferredAnimate.resolveWith(that)
            }
        })
    },
    _updateItemHeight: function($item, itemHeight, skipAnimation) {
        var $title = $item.children("." + ACCORDION_ITEM_TITLE_CLASS);
        if (fx.isAnimating($item)) {
            fx.stop($item)
        }
        var startItemHeight = $item.outerHeight(),
            finalItemHeight = $item.hasClass(ACCORDION_ITEM_OPENED_CLASS) ? itemHeight + $title.outerHeight() || $item.height("auto").outerHeight() : $title.outerHeight();
        return this._animateItem($item, startItemHeight, finalItemHeight, skipAnimation, !!itemHeight)
    },
    _animateItem: function($element, startHeight, endHeight, skipAnimation, fixedHeight) {
        var d;
        if (skipAnimation || startHeight === endHeight) {
            $element.css("height", endHeight);
            d = $.Deferred().resolve()
        } else {
            d = fx.animate($element, {
                type: "custom",
                from: {
                    height: startHeight
                },
                to: {
                    height: endHeight
                },
                duration: this.option("animationDuration")
            })
        }
        return d.done(function() {
            if ($element.hasClass(ACCORDION_ITEM_OPENED_CLASS) && !fixedHeight) {
                $element.css("height", "")
            }
            $element.not("." + ACCORDION_ITEM_OPENED_CLASS).addClass(ACCORDION_ITEM_CLOSED_CLASS)
        })
    },
    _splitFreeSpace: function(freeSpace) {
        if (!freeSpace) {
            return freeSpace
        }
        return freeSpace / this.option("selectedItems").length
    },
    _calculateFreeSpace: function() {
        var height = this.option("height");
        if (void 0 === height || "auto" === height) {
            return
        }
        var $titles = this._itemTitles(),
            itemsHeight = 0;
        $.each($titles, function(_, title) {
            itemsHeight += $(title).outerHeight()
        });
        return this.element().height() - itemsHeight
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _dimensionChanged: function() {
        this._updateItemHeights(true)
    },
    _clean: function() {
        clearTimeout(this._animationTimer);
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "animationDuration":
            case "onItemTitleClick":
                break;
            case "collapsible":
                this.option("selectionRequired", !this.option("collapsible"));
                break;
            case "itemTitleTemplate":
            case "height":
            case "deferRendering":
                this._invalidate();
                break;
            case "multiple":
                this.option("selectionMode", args.value ? "multiple" : "single");
                break;
            default:
                this.callBase(args)
        }
    },
    expandItem: function(index) {
        this._deferredAnimate = $.Deferred();
        this.selectItem(index);
        return this._deferredAnimate.promise()
    },
    collapseItem: function(index) {
        this._deferredAnimate = $.Deferred();
        this.unselectItem(index);
        return this._deferredAnimate.promise()
    },
    updateDimensions: function() {
        return this._updateItemHeights(false)
    }
});
registerComponent("dxAccordion", Accordion);
module.exports = Accordion;
module.exports.default = module.exports;


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/context_menu/ui.context_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    fx = __webpack_require__(22),
    positionUtils = __webpack_require__(46),
    devices = __webpack_require__(6),
    eventUtils = __webpack_require__(3),
    Overlay = __webpack_require__(39),
    MenuBase = __webpack_require__(212);
var DX_MENU_CLASS = "dx-menu",
    DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
    DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
    DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay",
    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
    DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
    DX_SUBMENU_CLASS = "dx-submenu",
    DX_CONTEXT_MENU_CLASS = "dx-context-menu",
    DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu",
    DX_STATE_DISABLED_CLASS = "dx-state-disabled",
    FOCUS_UP = "up",
    FOCUS_DOWN = "down",
    FOCUS_LEFT = "left",
    FOCUS_RIGHT = "right",
    FOCUS_FIRST = "first",
    FOCUS_LAST = "last",
    ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
    LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST],
    DEFAULT_SHOW_EVENT = "dxcontextmenu";
var ContextMenu = MenuBase.inherit(function() {
    var getShowEvent = function(that) {
            var result = null,
                optionValue = that.option("showEvent");
            if (commonUtils.isObject(optionValue)) {
                if (null !== optionValue.name) {
                    result = optionValue.name || DEFAULT_SHOW_EVENT
                }
            } else {
                result = optionValue
            }
            return result
        },
        getShowDelay = function(that) {
            var optionValue = that.option("showEvent");
            return commonUtils.isObject(optionValue) && optionValue.delay
        };
    return {
        _getDefaultOptions: function() {
            return extend(this.callBase(), {
                showEvent: DEFAULT_SHOW_EVENT,
                closeOnOutsideClick: true,
                position: {
                    at: "top left",
                    my: "top left"
                },
                onShowing: null,
                onShown: null,
                onSubmenuCreated: null,
                onHiding: null,
                onHidden: null,
                onPositioning: null,
                submenuDirection: "auto",
                visible: false,
                target: void 0,
                onLeftFirstItem: null,
                onLeftLastItem: null,
                onCloseRootSubmenu: null,
                onExpandLastSubmenu: null
            })
        },
        _initActions: function() {
            this._actions = {};
            $.each(ACTIONS, function(index, action) {
                this._actions[action] = this._createActionByOption(action) || commonUtils.noop
            }.bind(this))
        },
        _setOptionsByReference: function() {
            this.callBase();
            extend(this._optionsByReference, {
                animation: true,
                selectedItem: true
            })
        },
        _focusInHandler: commonUtils.noop,
        _itemContainer: function() {
            return this._overlay ? this._overlay.content() : $()
        },
        _eventBindingTarget: function() {
            return this._itemContainer()
        },
        itemsContainer: function() {
            return this._overlay ? this._overlay.content() : void 0
        },
        _supportedKeys: function() {
            var selectItem = function() {
                var $item = this.option("focusedElement");
                this.hide();
                if (!$item || !this._isSelectionEnabled()) {
                    return
                }
                this.selectItem($item[0])
            };
            return extend(this.callBase(), {
                space: selectItem,
                esc: this.hide
            })
        },
        _getActiveItem: function() {
            var $items = this._getAvailableItems(),
                $focusedItem = $items.filter(".dx-state-focused"),
                $hoveredItem = $items.filter(".dx-state-hover"),
                $hoveredItemContainer = $hoveredItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS);
            if ($hoveredItemContainer.find("." + DX_MENU_ITEM_CLASS).index($focusedItem) >= 0) {
                return $focusedItem
            }
            if ($hoveredItem.length) {
                return $hoveredItem
            }
            return this.callBase()
        },
        _moveFocus: function(location) {
            var $newTarget, $items = this._getItemsByLocation(location),
                $oldTarget = this._getActiveItem(true),
                $hoveredItem = this.itemsContainer().find(".dx-state-hover"),
                $focusedItem = this.option("focusedElement"),
                $activeItemHighlighted = !!($focusedItem || $hoveredItem.length);
            switch (location) {
                case FOCUS_UP:
                    $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
                    if ($oldTarget.is($items.first())) {
                        this._actions.onLeftFirstItem($oldTarget)
                    }
                    break;
                case FOCUS_DOWN:
                    $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
                    if ($oldTarget.is($items.last())) {
                        this._actions.onLeftLastItem($oldTarget)
                    }
                    break;
                case FOCUS_RIGHT:
                    $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
                    break;
                case FOCUS_LEFT:
                    $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
                    break;
                case FOCUS_FIRST:
                    $newTarget = $items.first();
                    break;
                case FOCUS_LAST:
                    $newTarget = $items.last();
                    break;
                default:
                    return this.callBase(location)
            }
            if (0 !== $newTarget.length) {
                this.option("focusedElement", $newTarget)
            }
        },
        _getItemsByLocation: function(location) {
            var $items, $activeItem = this._getActiveItem(true);
            if (inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0) {
                $items = $activeItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).children().children()
            }
            $items = this._getAvailableItems($items);
            return $items
        },
        _getAriaTarget: function() {
            return this.element()
        },
        _refreshActiveDescendant: function() {
            if (!this._overlay) {
                return
            }
            var id = this.getFocusedItemId();
            this.setAria("activedescendant", "", this._overlay.content());
            this.setAria("activedescendant", id, this._overlay.content())
        },
        _hideSubmenuHandler: function() {
            var $curItem = this._getActiveItem(true),
                $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
            if ($parentItem.length) {
                this._hideSubmenusOnSameLevel($parentItem);
                this._hideSubmenu($curItem.closest("." + DX_SUBMENU_CLASS));
                return $parentItem
            }
            this._actions.onCloseRootSubmenu($curItem);
            return $curItem
        },
        _expandSubmenuHandler: function($items, location) {
            var $curItem = this._getActiveItem(true),
                itemData = this._getItemData($curItem),
                node = this._dataAdapter.getNodeByItem(itemData),
                isItemHasSubmenu = this._hasSubmenu(node),
                $submenu = $curItem.children("." + DX_SUBMENU_CLASS);
            if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
                if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
                    this._showSubmenu($curItem)
                }
                return this._nextItem(this._getItemsByLocation(location))
            }
            this._actions.onExpandLastSubmenu($curItem);
            return $curItem
        },
        _clean: function() {
            if (this._overlay) {
                this._overlay.element().remove();
                this._overlay = null
            }
            this._detachShowContextMenuEvents(this._getTarget());
            this.callBase()
        },
        _render: function() {
            this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
            this.callBase();
            this.setAria("role", "menu")
        },
        _renderContentImpl: function() {
            this._detachShowContextMenuEvents(this._getTarget());
            this._attachShowContextMenuEvents()
        },
        _renderContextMenuOverlay: function() {
            if (this._overlay) {
                return
            }
            var $overlayContent, overlayOptions = this._getOverlayOptions(),
                $overlayElement = $("<div>");
            this._overlay = this._createComponent($overlayElement.appendTo(this._$element), Overlay, overlayOptions);
            $overlayContent = this._overlay.content();
            $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
            this._addCustomCssClass($overlayContent);
            this._addPlatformDependentClass($overlayContent);
            this._attachContextMenuEvent()
        },
        _itemContextMenuHandler: function(e) {
            this.callBase(e);
            e.stopPropagation()
        },
        _addPlatformDependentClass: function($element) {
            if (devices.current().phone) {
                $element.addClass(DX_MENU_PHONE_CLASS)
            }
        },
        _detachShowContextMenuEvents: function(target) {
            var eventName, showEvent = getShowEvent(this);
            if (!showEvent) {
                return
            }
            eventName = eventUtils.addNamespace(showEvent, this.NAME);
            if (this._showContextMenuEventHandler) {
                $(document).off(eventName, target, this._showContextMenuEventHandler)
            } else {
                $(target).off(eventName)
            }
        },
        _attachShowContextMenuEvents: function() {
            var delay, handler, eventName, contextMenuAction, that = this,
                target = that._getTarget(),
                showEvent = getShowEvent(that);
            if (!showEvent) {
                return
            }
            eventName = eventUtils.addNamespace(showEvent, that.NAME);
            contextMenuAction = that._createAction(function(e) {
                delay = getShowDelay(that);
                if (delay) {
                    setTimeout(function() {
                        that._show(e.jQueryEvent)
                    }, delay)
                } else {
                    that._show(e.jQueryEvent)
                }
            }.bind(that), {
                validatingTargetName: "target"
            });
            handler = function(e) {
                contextMenuAction({
                    jQueryEvent: e,
                    target: $(e.currentTarget)
                })
            };
            contextMenuAction = that._createAction(contextMenuAction);
            if (target.jquery || target.nodeType || commonUtils.isWindow(target)) {
                that._showContextMenuEventHandler = void 0;
                $(target).on(eventName, handler)
            } else {
                that._showContextMenuEventHandler = handler;
                $(document).on(eventName, target, that._showContextMenuEventHandler)
            }
        },
        _hoverEndHandler: function(e) {
            this.callBase(e);
            e.stopPropagation()
        },
        _renderDimensions: commonUtils.noop,
        _renderContainer: function($wrapper, submenuContainer) {
            var $itemsContainer, $holder = submenuContainer || this._itemContainer();
            $wrapper = $("<div>");
            $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
            $itemsContainer = this.callBase($wrapper);
            if (submenuContainer) {
                return $itemsContainer
            }
            if (this.option("width")) {
                return $itemsContainer.css("min-width", this.option("width"))
            }
            if (this.option("height")) {
                return $itemsContainer.css("min-height", this.option("height"))
            }
            return $itemsContainer
        },
        _renderSubmenuItems: function(node, $itemFrame) {
            this._renderItems(this._getChildNodes(node), $itemFrame);
            this._actions.onSubmenuCreated({
                itemElement: $itemFrame,
                itemData: node.internalFields.item,
                submenuElement: $itemFrame.children("." + DX_SUBMENU_CLASS)
            })
        },
        _getOverlayOptions: function() {
            var position = this.option("position"),
                overlayAnimation = this.option("animation"),
                overlayOptions = {
                    focusStateEnabled: this.option("focusStateEnabled"),
                    animation: overlayAnimation,
                    closeOnOutsideClick: this._closeOnOutsideClickHandler.bind(this),
                    closeOnTargetScroll: true,
                    deferRendering: false,
                    position: {
                        at: position.at,
                        my: position.my,
                        of: this._getTarget(),
                        collision: "flipfit"
                    },
                    shading: false,
                    showTitle: false,
                    height: "auto",
                    width: "auto",
                    onShown: this._overlayShownActionHandler.bind(this),
                    onHiding: this._overlayHidingActionHandler.bind(this),
                    onHidden: this._overlayHiddenActionHandler.bind(this)
                };
            return overlayOptions
        },
        _overlayShownActionHandler: function(arg) {
            this._actions.onShown(arg)
        },
        _overlayHidingActionHandler: function(arg) {
            this._actions.onHiding(arg);
            if (!arg.cancel) {
                this._hideAllShownSubmenus();
                this._setOptionSilent("visible", false)
            }
        },
        _overlayHiddenActionHandler: function(arg) {
            this._actions.onHidden(arg)
        },
        _closeOnOutsideClickHandler: function(e) {
            var $clickedItem, $activeItemContainer, $itemContainers, $rootItem, isRootItemClicked, isInnerOverlayClicked, closeOnOutsideClick = this.option("closeOnOutsideClick");
            if (commonUtils.isFunction(closeOnOutsideClick)) {
                return closeOnOutsideClick(e)
            }
            if (!closeOnOutsideClick) {
                return false
            }
            if (e.target === document) {
                return true
            }
            $activeItemContainer = this._getActiveItemsContainer(e.target);
            $itemContainers = this._getItemsContainers();
            $clickedItem = this._searchActiveItem(e.target);
            $rootItem = this.element().parents("." + DX_MENU_ITEM_CLASS);
            isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
            isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
            if (isInnerOverlayClicked || isRootItemClicked) {
                if ("onClick" === this._getShowSubmenuMode()) {
                    this._hideAllShownChildSubmenus($clickedItem)
                }
                return false
            }
            return true
        },
        _getActiveItemsContainer: function(target) {
            return $(target).closest("." + DX_MENU_ITEMS_CONTAINER_CLASS)
        },
        _getItemsContainers: function() {
            return this._overlay._$content.find("." + DX_MENU_ITEMS_CONTAINER_CLASS)
        },
        _searchActiveItem: function(target) {
            return $(target).closest("." + DX_MENU_ITEM_CLASS).eq(0)
        },
        _isIncludeOverlay: function($activeOverlay, $allOverlays) {
            var isSame = false;
            $.each($allOverlays, function(index, $overlay) {
                if ($activeOverlay.is($overlay) && !isSame) {
                    isSame = true
                }
            });
            return isSame
        },
        _hideAllShownChildSubmenus: function($clickedItem) {
            var $context, that = this,
                $submenuElements = $clickedItem.find("." + DX_SUBMENU_CLASS),
                shownSubmenus = extend([], this._shownSubmenus);
            if ($submenuElements.length > 0) {
                $.each(shownSubmenus, function(index, $submenu) {
                    $context = that._searchActiveItem($submenu.context).parent();
                    if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
                        that._hideSubmenu($submenu)
                    }
                })
            }
        },
        _showSubmenu: function($item) {
            var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
            this._hideSubmenusOnSameLevel($item);
            if (!this._hasSubmenu(node)) {
                return
            }
            var $submenu = $item.children("." + DX_SUBMENU_CLASS),
                isSubmenuRendered = $submenu.length;
            this.callBase($item);
            if (!isSubmenuRendered) {
                this._renderSubmenuItems(node, $item)
            }
            if (!this._isSubmenuVisible($submenu)) {
                this._drawSubmenu($item)
            }
        },
        _hideSubmenusOnSameLevel: function($item) {
            var $expandedItems = $item.parent("." + DX_MENU_ITEM_WRAPPER_CLASS).siblings().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
            if ($expandedItems.length) {
                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                this._hideSubmenu($expandedItems.find("." + DX_SUBMENU_CLASS))
            }
        },
        _hideSubmenuGroup: function($submenu) {
            if (this._isSubmenuVisible($submenu)) {
                this._hideSubmenuCore($submenu)
            }
        },
        _isSubmenuVisible: function($submenu) {
            return "visible" === $submenu.css("visibility")
        },
        _drawSubmenu: function($itemElement) {
            var animation = this.option("animation") ? this.option("animation").show : {},
                $submenu = $itemElement.children("." + DX_SUBMENU_CLASS),
                submenuPosition = this._getSubmenuPosition($itemElement);
            if (this._overlay && this._overlay.option("visible")) {
                if (!commonUtils.isDefined(this._shownSubmenus)) {
                    this._shownSubmenus = []
                }
                if (inArray($submenu, this._shownSubmenus)) {
                    this._shownSubmenus.push($submenu)
                }
                if (animation) {
                    fx.stop($submenu)
                }
                positionUtils.setup($submenu, submenuPosition);
                if (animation) {
                    if (typeUtils.isPlainObject(animation.to)) {
                        animation.to.position = submenuPosition
                    }
                    this._animate($submenu, animation)
                }
                $submenu.css("visibility", "visible")
            }
        },
        _animate: function($container, options) {
            fx.animate($container, options)
        },
        _getSubmenuPosition: function($rootItem) {
            var submenuDirection = this.option("submenuDirection").toLowerCase(),
                $rootItemWrapper = $rootItem.parent("." + DX_MENU_ITEM_WRAPPER_CLASS),
                position = {
                    collision: "flip",
                    of: $rootItemWrapper,
                    offset: {
                        h: 0,
                        v: -1
                    }
                };
            switch (submenuDirection) {
                case "left":
                    position.at = "left top";
                    position.my = "right top";
                    break;
                case "right":
                    position.at = "right top";
                    position.my = "left top";
                    break;
                default:
                    if (this.option("rtlEnabled")) {
                        position.at = "left top";
                        position.my = "right top"
                    } else {
                        position.at = "right top";
                        position.my = "left top"
                    }
            }
            return position
        },
        _updateSubmenuVisibilityOnClick: function(actionArgs) {
            if (!actionArgs.args.length) {
                return
            }
            var $itemElement = actionArgs.args[0].itemElement,
                itemData = actionArgs.args[0].itemData,
                node = this._dataAdapter.getNodeByItem(itemData);
            if (!node) {
                return
            }
            var $submenu = $itemElement.find("." + DX_SUBMENU_CLASS),
                shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
            if (shouldRenderSubmenu) {
                this._renderSubmenuItems(node, $itemElement);
                $submenu = $itemElement.find("." + DX_SUBMENU_CLASS)
            }
            if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
                return
            }
            var notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
            if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
                return
            }
            this._updateSelectedItemOnClick(actionArgs);
            if (0 === $submenu.length) {
                var $prevSubmenu = $($itemElement.parents("." + DX_SUBMENU_CLASS)[0]);
                this._hideSubmenu($prevSubmenu);
                if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
                    this.option("visible", false)
                }
            } else {
                if (this._shownSubmenus && this._shownSubmenus.length > 0) {
                    if (this._shownSubmenus[0].is($submenu) || 1 === this._shownSubmenus[0].has($submenu).length) {
                        this._hideSubmenu($submenu)
                    } else {
                        this._hideAllShownSubmenus()
                    }
                }
                this._showSubmenu($itemElement)
            }
        },
        _hideSubmenu: function($curSubmenu) {
            var that = this,
                shownSubmenus = extend([], that._shownSubmenus);
            $.each(shownSubmenus, function(index, $submenu) {
                if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length) {
                    $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    that._hideSubmenuCore($submenu)
                }
            })
        },
        _hideSubmenuCore: function($submenu) {
            var index = inArray($submenu, this._shownSubmenus),
                animation = this.option("animation") ? this.option("animation").hide : null;
            if (index >= 0) {
                this._shownSubmenus.splice(index, 1)
            }
            this._stopAnimate($submenu);
            animation && this._animate($submenu, animation);
            $submenu.css("visibility", "hidden")
        },
        _stopAnimate: function($container) {
            fx.stop($container, true)
        },
        _hideAllShownSubmenus: function() {
            var that = this,
                shownSubmenus = extend([], that._shownSubmenus),
                $expandedItems = this._overlay.content().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
            $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
            $.each(shownSubmenus, function(_, $submenu) {
                that._hideSubmenuCore($submenu)
            })
        },
        _visibilityChanged: function(visible) {
            if (visible) {
                this._renderContentImpl()
            }
        },
        _optionChanged: function(args) {
            if (this._cancelOptionChange === args.name) {
                return
            }
            if (inArray(args.name, ACTIONS) > -1) {
                this._initActions();
                return
            }
            switch (args.name) {
                case "visible":
                    this._toggleVisibility(args.value);
                    break;
                case "showEvent":
                case "position":
                case "submenuDirection":
                    this._invalidate();
                    break;
                case "target":
                    args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
                    this.option("position").of = null;
                    this._invalidate();
                    break;
                case "closeOnOutsideClick":
                    break;
                default:
                    this.callBase(args)
            }
        },
        _toggleVisibility: function(showing) {
            showing ? this._show() : this._hide()
        },
        _show: function(jQEvent) {
            var args = {
                    jQEvent: jQEvent
                },
                promise = $.Deferred().reject().promise();
            this._actions.onShowing(args);
            if (args.cancel) {
                return promise
            }
            var position = this._positionContextMenu(jQEvent);
            if (position) {
                if (!this._overlay) {
                    this._renderContextMenuOverlay();
                    this._overlay.content().addClass(this._widgetClass());
                    this._renderFocusState();
                    this._attachHoverEvents();
                    this._attachClickEvent();
                    this._renderItems(this._dataAdapter.getRootNodes())
                }
                this._setOptionSilent("visible", true);
                this._overlay.option("position", position);
                promise = this._overlay.show();
                var id = "dx-" + new Guid;
                this._overlay.content().attr({
                    id: id,
                    role: "menu"
                });
                this.setAria("owns", id)
            }
            return promise
        },
        _getTarget: function() {
            return this.option("target") || this.option("position").of || $(document)
        },
        _getContextMenuPosition: function() {
            return extend({}, this.option("position"), { of: this._getTarget()
            })
        },
        _positionContextMenu: function(jQEvent) {
            var actionArgs, position = this._getContextMenuPosition(),
                isInitialPosition = this._isInitialOptionValue("position"),
                positioningAction = this._createActionByOption("onPositioning", actionArgs);
            if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
                position.of = jQEvent
            }
            actionArgs = {
                position: position,
                jQueryEvent: jQEvent
            };
            positioningAction(actionArgs);
            if (actionArgs.cancel) {
                position = null
            } else {
                if (actionArgs.jQueryEvent) {
                    actionArgs.jQueryEvent.cancel = true;
                    jQEvent.preventDefault()
                }
            }
            return position
        },
        _hide: function() {
            var promise;
            if (this._overlay) {
                this._overlay.content().removeAttr("id");
                promise = this._overlay.hide();
                this._setOptionSilent("visible", false)
            }
            this.setAria("owns", void 0);
            return promise || $.Deferred().reject().promise()
        },
        toggle: function(showing) {
            var visible = this.option("visible");
            showing = void 0 === showing ? !visible : showing;
            return this._toggleVisibility(showing)
        },
        show: function() {
            return this.toggle(true)
        },
        hide: function() {
            return this.toggle(false)
        }
    }
}());
registerComponent("dxContextMenu", ContextMenu);
module.exports = ContextMenu;


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/hierarchical_collection/ui.data_adapter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    errors = __webpack_require__(16),
    inArray = __webpack_require__(7).inArray,
    query = __webpack_require__(35),
    HierarchicalDataConverter = __webpack_require__(344);
var EXPANDED = "expanded",
    SELECTED = "selected",
    DISABLED = "disabled";
var DataAdapter = Class.inherit({
    ctor: function(options) {
        this.options = {};
        extend(this.options, this._defaultOptions(), options);
        this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
        this._selectedNodesKeys = [];
        this._expandedNodesKeys = [];
        this._dataStructure = [];
        this._createInternalDataStructure();
        this.getTreeNodes()
    },
    setOption: function(name, value) {
        this.options[name] = value;
        if ("recursiveSelection" === name) {
            this._updateSelection()
        }
    },
    _defaultOptions: function() {
        return {
            dataAccessors: void 0,
            items: [],
            multipleSelection: true,
            recursiveSelection: false,
            recursiveExpansion: false,
            rootValue: 0,
            searchValue: "",
            dataType: "tree",
            dataConverter: new HierarchicalDataConverter,
            onNodeChanged: commonUtils.noop
        }
    },
    _createInternalDataStructure: function() {
        this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
        this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
        this.options.dataConverter._dataStructure = this._dataStructure;
        this._updateSelection();
        this._updateExpansion()
    },
    _updateSelection: function() {
        if (this.options.recursiveSelection) {
            this._setChildrenSelection();
            this._setParentSelection()
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
    },
    _updateExpansion: function(key) {
        if (this.options.recursiveExpansion) {
            key ? this._updateOneBranch(key) : this._setParentExpansion()
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
    },
    _updateNodesKeysArray: function(property) {
        var that = this,
            array = [];
        $.each(this._dataStructure, function(_, node) {
            if (!that._isNodeVisible(node)) {
                return
            }
            if (!!node.internalFields[property]) {
                if (property === EXPANDED || that.options.multipleSelection) {
                    array.push(node.internalFields.key)
                } else {
                    array.length && that.toggleSelection(array[0], false, true);
                    array = [node.internalFields.key]
                }
            }
        });
        return array
    },
    _isNodeVisible: function(node) {
        return false !== node.internalFields.item.visible
    },
    _getByKey: function(data, key) {
        return data === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data, key)
    },
    _setChildrenSelection: function() {
        var that = this;
        $.each(this._dataStructure, function(_, node) {
            if (!node.internalFields.childrenKeys.length) {
                return
            }
            var isSelected = node.internalFields.selected;
            true === isSelected && that._toggleChildrenSelection(node, isSelected)
        })
    },
    _setParentSelection: function() {
        var that = this;
        $.each(this._dataStructure, function(_, node) {
            var parent = that.options.dataConverter.getParentNode(node);
            if (parent && node.internalFields.parentKey !== that.options.rootValue) {
                that._iterateParents(node, function(parent) {
                    var newParentState = that._calculateSelectedState(parent);
                    that._setFieldState(parent, SELECTED, newParentState)
                })
            }
        })
    },
    _setParentExpansion: function() {
        var that = this;
        $.each(this._dataStructure, function(_, node) {
            if (!node.internalFields.expanded) {
                return
            }
            that._updateOneBranch(node.internalFields.key)
        })
    },
    _updateOneBranch: function(key) {
        var that = this,
            node = this.getNodeByKey(key);
        that._iterateParents(node, function(parent) {
            that._setFieldState(parent, EXPANDED, true)
        })
    },
    _iterateChildren: function(node, recursive, callback) {
        var that = this;
        $.each(node.internalFields.childrenKeys, function(_, key) {
            var child = that.getNodeByKey(key);
            commonUtils.isFunction(callback) && callback(child);
            if (child.internalFields.childrenKeys.length && recursive) {
                that._iterateChildren(child, recursive, callback)
            }
        })
    },
    _iterateParents: function(node, callback) {
        if (node.internalFields.parentKey === this.options.rootValue) {
            return
        }
        var parent = this.options.dataConverter.getParentNode(node);
        if (parent) {
            commonUtils.isFunction(callback) && callback(parent);
            if (parent.internalFields.parentKey !== this.options.rootValue) {
                this._iterateParents(parent, callback)
            }
        }
    },
    _calculateSelectedState: function(node) {
        var itemsCount = node.internalFields.childrenKeys.length,
            selectedItemsCount = 0,
            invisibleItemsCount = 0,
            result = false;
        for (var i = 0; i <= itemsCount - 1; i++) {
            var childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]),
                isChildInvisible = false === childNode.internalFields.item.visible,
                childState = childNode.internalFields.selected;
            if (isChildInvisible) {
                invisibleItemsCount++;
                continue
            }
            if (childState) {
                selectedItemsCount++
            } else {
                if (void 0 === childState) {
                    selectedItemsCount += .5
                }
            }
        }
        if (selectedItemsCount) {
            result = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0
        }
        return result
    },
    _toggleChildrenSelection: function(node, state) {
        var that = this;
        this._iterateChildren(node, true, function(child) {
            if (that._isNodeVisible(child)) {
                that._setFieldState(child, SELECTED, state)
            }
        })
    },
    _setFieldState: function(node, field, state) {
        if (node.internalFields[field] === state) {
            return
        }
        node.internalFields[field] = state;
        if (node.internalFields.publicNode) {
            node.internalFields.publicNode[field] = state
        }
        this.options.dataAccessors.setters[field](node.internalFields.item, state);
        this.options.onNodeChanged(node)
    },
    _markChildren: function(keys) {
        var that = this;
        $.each(keys, function(_, key) {
            var index = that.getIndexByKey(key),
                node = that.getNodeByKey(key);
            that._dataStructure[index] = 0;
            node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys)
        })
    },
    _removeNode: function(key) {
        var node = this.getNodeByKey(key);
        this._dataStructure[this.getIndexByKey(key)] = 0;
        this._markChildren(node.internalFields.childrenKeys);
        var that = this,
            counter = 0,
            items = extend([], this._dataStructure);
        $.each(items, function(index, item) {
            if (!item) {
                that._dataStructure.splice(index - counter, 1);
                counter++
            }
        })
    },
    _addNode: function(item) {
        var dataConverter = this.options.dataConverter,
            node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
        this._dataStructure = this._dataStructure.concat(node);
        this._initialDataStructure = this._initialDataStructure.concat(node);
        dataConverter._dataStructure = dataConverter._dataStructure.concat(node)
    },
    _updateFields: function() {
        this.options.dataConverter.updateChildrenKeys();
        this._updateSelection();
        this._updateExpansion()
    },
    getSelectedNodesKeys: function() {
        return this._selectedNodesKeys
    },
    getExpandedNodesKeys: function() {
        return this._expandedNodesKeys
    },
    getData: function() {
        return this._dataStructure
    },
    getFullData: function() {
        return this._initialDataStructure
    },
    getNodeByItem: function(item) {
        var result = null;
        $.each(this._dataStructure, function(_, node) {
            if (node.internalFields.item === item) {
                result = node;
                return false
            }
        });
        return result
    },
    getNodesByItems: function(items) {
        var that = this,
            nodes = [];
        $.each(items, function(_, item) {
            var node = that.getNodeByItem(item);
            node && nodes.push(node)
        });
        return nodes
    },
    getNodeByKey: function(key) {
        return this._getByKey(this._dataStructure, key)
    },
    getTreeNodes: function() {
        return this.options.dataConverter.convertToPublicNodes(this.getRootNodes())
    },
    getItemsCount: function() {
        return this.options.dataConverter.getItemsCount()
    },
    getVisibleItemsCount: function() {
        return this.options.dataConverter.getVisibleItemsCount()
    },
    getPublicNode: function(node) {
        return node.internalFields.publicNode
    },
    getRootNodes: function() {
        return this.getChildrenNodes(this.options.rootValue)
    },
    getChildrenNodes: function(parentKey) {
        return query(this._dataStructure).filter(["internalFields.parentKey", parentKey]).toArray()
    },
    getIndexByKey: function(key) {
        return this.options.dataConverter.getIndexByKey(key)
    },
    addItem: function(item) {
        this._addNode(item);
        this._updateFields()
    },
    removeItem: function(key) {
        this._removeNode(key);
        this._updateFields()
    },
    toggleSelection: function(key, state, selectRecursive) {
        var node = this._getByKey(selectRecursive ? this._initialDataStructure : this._dataStructure, key);
        this._setFieldState(node, SELECTED, state);
        if (this.options.recursiveSelection && !selectRecursive) {
            state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
            this._setParentSelection()
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
    },
    toggleNodeDisabledState: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, DISABLED, state)
    },
    toggleSelectAll: function(state) {
        if (!commonUtils.isDefined(state)) {
            return
        }
        var that = this;
        $.each(this._dataStructure, function(_, node) {
            if (!that._isNodeVisible(node)) {
                return
            }
            that._setFieldState(node, SELECTED, state);
            that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED)
        })
    },
    isAllSelected: function() {
        if (this.getSelectedNodesKeys().length) {
            return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0
        } else {
            return false
        }
    },
    toggleExpansion: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, EXPANDED, state);
        if (state) {
            this._updateExpansion(key)
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
    },
    _filterDataStructure: function(substring) {
        var text, matches = [],
            dataStructure = this._initialDataStructure,
            escaped = commonUtils.escapeRegExp(substring),
            reg = new RegExp(escaped, "i");
        for (var i = 0, size = dataStructure.length; i < size; i++) {
            text = this.options.dataAccessors.getters.display(dataStructure[i]);
            reg.test(text) && matches.push(dataStructure[i])
        }
        return matches
    },
    search: function(substring) {
        var that = this,
            matches = this._filterDataStructure(substring),
            dataConverter = this.options.dataConverter;

        function lookForParents(matches, index) {
            var length = matches.length;
            while (index < length) {
                var node = matches[index];
                if (node.internalFields.parentKey === that.options.rootValue) {
                    index++;
                    continue
                }
                var parent = dataConverter.getParentNode(node);
                if (!parent) {
                    errors.log("W1007", node.internalFields.parentKey, node.internalFields.key);
                    index++;
                    continue
                }
                if (!parent.internalFields.expanded) {
                    that._setFieldState(parent, EXPANDED, true)
                }
                if (inArray(parent, matches) > -1) {
                    index++;
                    continue
                }
                matches.splice(index, 0, parent);
                lookForParents(matches, index)
            }
        }
        lookForParents(matches, 0);
        dataConverter._indexByKey = {};
        $.each(matches, function(index, node) {
            node.internalFields.childrenKeys = [];
            dataConverter._indexByKey[node.internalFields.key] = index
        });
        dataConverter._dataStructure = matches;
        dataConverter.setChildrenKeys();
        return dataConverter._dataStructure
    }
});
module.exports = DataAdapter;


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/hierarchical_collection/ui.data_converter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    extend = __webpack_require__(1).extend,
    errors = __webpack_require__(16),
    commonUtils = __webpack_require__(2);
var DataConverter = Class.inherit({
    ctor: function() {
        this._dataStructure = [];
        this._itemsCount = 0;
        this._visibleItemsCount = 0
    },
    _indexByKey: {},
    _convertItemsToNodes: function(items, parentKey) {
        var that = this;
        $.each(items, function(_, item) {
            var parentId = commonUtils.isDefined(parentKey) ? parentKey : that._getParentId(item),
                node = that._convertItemToNode(item, parentId);
            that._dataStructure.push(node);
            that._checkForDuplicateId(node.internalFields.key);
            that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
            if (that._itemHasChildren(item)) {
                that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key)
            }
        })
    },
    _checkForDuplicateId: function(key) {
        if (commonUtils.isDefined(this._indexByKey[key])) {
            throw errors.Error("E1040", key)
        }
    },
    _getParentId: function(item) {
        return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0
    },
    _itemHasChildren: function(item) {
        var items = this._dataAccessors.getters.items(item);
        return items && items.length
    },
    _getUniqueKey: function(item) {
        var keyGetter = this._dataAccessors.getters.key,
            itemKey = keyGetter(item),
            isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && commonUtils.isPrimitive(itemKey);
        return isCorrectKey ? itemKey : this.getItemsCount()
    },
    _convertItemToNode: function(item, parentKey) {
        this._itemsCount++;
        false !== item.visible && this._visibleItemsCount++;
        var that = this,
            node = {
                internalFields: {
                    disabled: that._dataAccessors.getters.disabled(item) || false,
                    expanded: that._dataAccessors.getters.expanded(item) || false,
                    selected: that._dataAccessors.getters.selected(item) || false,
                    key: that._getUniqueKey(item),
                    parentKey: commonUtils.isDefined(parentKey) ? parentKey : that._rootValue,
                    item: that._makeObjectFromPrimitive(item),
                    childrenKeys: []
                }
            };
        extend(node, item);
        delete node.items;
        return node
    },
    setChildrenKeys: function() {
        var that = this;
        $.each(this._dataStructure, function(_, node) {
            if (node.internalFields.parentKey === that._rootValue) {
                return
            }
            var parent = that.getParentNode(node);
            parent && parent.internalFields.childrenKeys.push(node.internalFields.key)
        })
    },
    _makeObjectFromPrimitive: function(item) {
        if (commonUtils.isPrimitive(item)) {
            var key = item;
            item = {};
            this._dataAccessors.setters.key(item, key)
        }
        return item
    },
    _convertToPublicNode: function(node, parent) {
        if (!node) {
            return null
        }
        var publicNode = {
            text: this._dataAccessors.getters.display(node),
            key: node.internalFields.key,
            selected: node.internalFields.selected,
            expanded: node.internalFields.expanded,
            disabled: node.internalFields.disabled,
            parent: parent || null,
            itemData: node.internalFields.item,
            children: [],
            items: []
        };
        if (publicNode.parent) {
            publicNode.parent.children.push(publicNode);
            publicNode.parent.items.push(publicNode)
        }
        return publicNode
    },
    convertToPublicNodes: function(data, parent) {
        if (!data.length) {
            return []
        }
        var that = this,
            publicNodes = [];
        $.each(data, function(_, node) {
            node = commonUtils.isPrimitive(node) ? that._getByKey(node) : node;
            var publicNode = that._convertToPublicNode(node, parent);
            publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
            publicNodes.push(publicNode);
            node.internalFields.publicNode = publicNode
        });
        return publicNodes
    },
    setDataAccessors: function(accessors) {
        this._dataAccessors = accessors
    },
    _getByKey: function(key) {
        return this._dataStructure[this.getIndexByKey(key)] || null
    },
    getParentNode: function(node) {
        return this._getByKey(node.internalFields.parentKey)
    },
    getByKey: function(data, key) {
        var result = null,
            that = this;
        var getByKey = function(data, key) {
            $.each(data, function(_, element) {
                var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element),
                    items = that._dataAccessors.getters.items(element);
                if (currentElementKey === key) {
                    result = element;
                    return false
                }
                if (items) {
                    getByKey(items, key)
                }
            });
            return result
        };
        return getByKey(data, key)
    },
    getItemsCount: function() {
        return this._itemsCount
    },
    getVisibleItemsCount: function() {
        return this._visibleItemsCount
    },
    updateIndexByKey: function() {
        var that = this;
        this._indexByKey = {};
        $.each(this._dataStructure, function(index, node) {
            that._checkForDuplicateId(node.internalFields.key);
            that._indexByKey[node.internalFields.key] = index
        })
    },
    updateChildrenKeys: function() {
        this._indexByKey = {};
        this.removeChildrenKeys();
        this.updateIndexByKey();
        this.setChildrenKeys()
    },
    removeChildrenKeys: function() {
        this._indexByKey = {};
        $.each(this._dataStructure, function(index, node) {
            node.internalFields.childrenKeys = []
        })
    },
    getIndexByKey: function(key) {
        return this._indexByKey[key]
    },
    createPlainStructure: function(items, rootValue, dataType) {
        this._itemsCount = 0;
        this._visibleItemsCount = 0;
        this._rootValue = rootValue;
        this._dataType = dataType;
        this._indexByKey = {};
        this._convertItemsToNodes(items);
        this.setChildrenKeys();
        return this._dataStructure
    }
});
module.exports = DataConverter;


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/context_menu/ui.menu_base.edit.strategy.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    PlainEditStrategy = __webpack_require__(149);
var MenuBaseEditStrategy = PlainEditStrategy.inherit({
    _getPlainItems: function() {
        return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
            return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
        })
    },
    _stringifyItem: function(item) {
        var that = this;
        return JSON.stringify(item, function(key, value) {
            if ("template" === key) {
                return that._getTemplateString(value)
            }
            return value
        })
    },
    _getTemplateString: function(template) {
        var result;
        if ("object" === typeof template) {
            result = $(template).text()
        } else {
            result = template.toString()
        }
        return result
    }
});
module.exports = MenuBaseEditStrategy;


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(347);
module.exports.default = module.exports;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var DataGrid = __webpack_require__(348);
module.exports = DataGrid;
__webpack_require__(360);
__webpack_require__(362);
__webpack_require__(363);
__webpack_require__(364);
__webpack_require__(367);
__webpack_require__(368);
__webpack_require__(372);
__webpack_require__(373);
__webpack_require__(375);
__webpack_require__(378);
__webpack_require__(380);
__webpack_require__(381);
__webpack_require__(383);
__webpack_require__(384);
__webpack_require__(385);
__webpack_require__(387);
__webpack_require__(388);
__webpack_require__(389);


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    logger = __webpack_require__(83).logger,
    browser = __webpack_require__(21),
    Widget = __webpack_require__(27),
    gridCore = __webpack_require__(12),
    callModuleItemsMethod = gridCore.callModuleItemsMethod;
var DATAGRID_ROW_SELECTOR = ".dx-row",
    DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.";
__webpack_require__(349);
__webpack_require__(351);
__webpack_require__(352);
__webpack_require__(353);
__webpack_require__(355);
__webpack_require__(356);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(359);
gridCore.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "editing", "grouping", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
var DataGrid = Widget.inherit({
    _activeStateUnit: DATAGRID_ROW_SELECTOR,
    _getDefaultOptions: function() {
        var that = this,
            result = that.callBase();
        $.each(gridCore.modules, function() {
            if (commonUtils.isFunction(this.defaultOptions)) {
                extend(true, result, this.defaultOptions())
            }
        });
        return result
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        extend(this._deprecatedOptions, {
            "editing.editMode": {
                since: "15.2",
                alias: "editing.mode"
            },
            "editing.editEnabled": {
                since: "15.2",
                alias: "editing.allowUpdating"
            },
            "editing.insertEnabled": {
                since: "15.2",
                alias: "editing.allowAdding"
            },
            "editing.removeEnabled": {
                since: "15.2",
                alias: "editing.allowDeleting"
            },
            "grouping.groupContinuedMessage": {
                since: "16.1",
                alias: "grouping.texts.groupContinuedMessage"
            },
            "grouping.groupContinuesMessage": {
                since: "16.1",
                alias: "grouping.texts.groupContinuesMessage"
            },
            "export.texts.excelFormat": {
                since: "16.1",
                alias: "export.texts.exportAll"
            },
            "export.texts.exportToExcel": {
                since: "16.1",
                alias: "export.texts.exportAll"
            },
            "export.texts.selectedRows": {
                since: "16.1",
                alias: "export.texts.exportSelectedRows"
            },
            "filterRow.operationDescriptions.>": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.greaterThan"
            },
            "filterRow.operationDescriptions.<": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.lessThan"
            },
            "filterRow.operationDescriptions.=": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.equal"
            },
            "filterRow.operationDescriptions.<>": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.notEqual"
            },
            "filterRow.operationDescriptions.<=": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.lessThanOrEqual"
            },
            "filterRow.operationDescriptions.>=": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.greaterThanOrEqual"
            },
            "filterRow.operationDescriptions.startswith": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.startsWith"
            },
            "filterRow.operationDescriptions.notcontains": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.notContains"
            },
            "filterRow.operationDescriptions.endswith": {
                since: "16.2",
                alias: "filterRow.operationDescriptions.endsWith"
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                showRowLines: true
            }
        }, {
            device: function() {
                return browser.webkit
            },
            options: {
                loadingTimeout: 30,
                loadPanel: {
                    animation: {
                        show: {
                            easing: "cubic-bezier(1, 0, 1, 0)",
                            duration: 500,
                            from: {
                                opacity: 0
                            },
                            to: {
                                opacity: 1
                            }
                        }
                    }
                }
            }
        }, {
            device: function(device) {
                return "desktop" !== device.deviceType
            },
            options: {
                grouping: {
                    expandMode: "rowClick"
                }
            }
        }])
    },
    _init: function() {
        var that = this;
        that.callBase();
        gridCore.processModules(that, gridCore);
        callModuleItemsMethod(that, "init")
    },
    _clean: commonUtils.noop,
    _optionChanged: function(args) {
        var that = this;
        callModuleItemsMethod(that, "optionChanged", [args]);
        if (!args.handled) {
            that.callBase(args)
        }
    },
    _dimensionChanged: function() {
        this.updateDimensions(true)
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this.updateDimensions()
        }
    },
    _renderContentImpl: function() {
        this.getView("gridView").render(this.element())
    },
    _renderContent: function() {
        var that = this;
        commonUtils.deferRender(function() {
            that._renderContentImpl()
        })
    },
    _getTemplate: function(templateName) {
        var template = templateName;
        if (commonUtils.isString(template) && "#" === template[0]) {
            template = $(templateName);
            logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
        }
        return this.callBase(template)
    },
    _dispose: function() {
        var that = this;
        that.callBase();
        callModuleItemsMethod(that, "dispose")
    },
    isReady: function() {
        return this.getController("data").isReady()
    },
    beginUpdate: function() {
        var that = this;
        that.callBase();
        callModuleItemsMethod(that, "beginUpdate")
    },
    endUpdate: function() {
        var that = this;
        callModuleItemsMethod(that, "endUpdate");
        that.callBase()
    },
    getController: function(name) {
        return this._controllers[name]
    },
    getView: function(name) {
        return this._views[name]
    },
    focus: function(element) {
        this.callBase();
        if (commonUtils.isDefined(element)) {
            this.getController("keyboardNavigation").focus(element)
        }
    }
});
DataGrid.registerModule = gridCore.registerModule.bind(gridCore);
registerComponent("dxDataGrid", DataGrid);
module.exports = DataGrid;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.column_headers.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    columnHeadersViewModule = __webpack_require__(214);
exports.ColumnHeadersView = columnHeadersViewModule.views.columnHeadersView;
gridCore.registerModule("columnHeaders", columnHeadersViewModule);


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_state_mixin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    commonUtils = __webpack_require__(2);
var COLUMN_INDICATORS_CLASS = "dx-column-indicators",
    GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item";
module.exports = {
    _applyColumnState: function(options) {
        var that = this,
            rtlEnabled = this.option("rtlEnabled"),
            columnAlignment = that._getColumnAlignment(options.column.alignment, rtlEnabled),
            parameters = extend(true, {
                columnAlignment: columnAlignment
            }, options),
            isGroupPanelItem = parameters.rootElement.hasClass(GROUP_PANEL_ITEM_CLASS),
            $indicatorsContainer = that._createIndicatorContainer(parameters, isGroupPanelItem),
            $span = $("<span>").addClass(that._getIndicatorClassName(options.name)),
            getIndicatorAlignment = function() {
                if (rtlEnabled) {
                    return "left" === columnAlignment ? "right" : "left"
                }
                return columnAlignment
            };
        parameters.container = $indicatorsContainer;
        parameters.indicator = $span;
        that._renderIndicator(parameters);
        $indicatorsContainer[(isGroupPanelItem || !options.showColumnLines) && "left" === getIndicatorAlignment() ? "appendTo" : "prependTo"](options.rootElement);
        return $span
    },
    _getIndicatorClassName: commonUtils.noop,
    _getColumnAlignment: function(alignment, rtlEnabled) {
        rtlEnabled = rtlEnabled || this.option("rtlEnabled");
        return alignment && "center" !== alignment ? alignment : getDefaultAlignment(rtlEnabled)
    },
    _createIndicatorContainer: function(options, ignoreIndicatorAlignment) {
        var $indicatorsContainer = this._getIndicatorContainer(options.rootElement),
            indicatorAlignment = "left" === options.columnAlignment ? "right" : "left";
        if (!$indicatorsContainer.length) {
            $indicatorsContainer = $("<div>").addClass(COLUMN_INDICATORS_CLASS)
        }
        return $indicatorsContainer.css("float", options.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null)
    },
    _getIndicatorContainer: function($cell) {
        return $cell && $cell.find("." + COLUMN_INDICATORS_CLASS)
    },
    _getIndicatorElements: function($cell) {
        var $indicatorContainer = this._getIndicatorContainer($cell);
        return $indicatorContainer && $indicatorContainer.children()
    },
    _renderIndicator: function(options) {
        var $container = options.container,
            $indicator = options.indicator;
        $container && $indicator && $container.append($indicator)
    },
    _updateIndicators: function(indicatorName) {
        var rowOptions, $cell, i, that = this,
            columns = that.getColumns(),
            $cells = that.getColumnElements();
        if (!$cells.length) {
            return
        }
        for (i = 0; i < columns.length; i++) {
            $cell = $cells.eq(i);
            that._updateIndicator($cell, columns[i], indicatorName);
            rowOptions = $cell.parent().data("options");
            if (rowOptions && rowOptions.cells) {
                rowOptions.cells[$cell.index()].column = columns[i]
            }
        }
    },
    _updateIndicator: function($cell, column, indicatorName) {
        if (!column.command) {
            return this._applyColumnState({
                name: indicatorName,
                rootElement: $cell,
                column: column,
                showColumnLines: this.option("showColumnLines")
            })
        }
    }
};


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.columns_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    columnsControllerModule = __webpack_require__(215),
    extend = __webpack_require__(1).extend;
gridCore.registerModule("columns", {
    defaultOptions: function() {
        return extend(true, {}, columnsControllerModule.defaultOptions(), {
            commonColumnSettings: {
                allowExporting: true
            }
        })
    },
    controllers: columnsControllerModule.controllers
});


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.data_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    dataSourceAdapterProvider = __webpack_require__(131),
    dataControllerModule = __webpack_require__(217);
exports.DataController = dataControllerModule.controllers.data.inherit(function() {
    return {
        _getDataSourceAdapter: function() {
            return dataSourceAdapterProvider
        }
    }
}());
gridCore.registerModule("data", {
    defaultOptions: dataControllerModule.defaultOptions,
    controllers: {
        data: exports.DataController
    }
});


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.sorting.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    sortingModule = __webpack_require__(218);
gridCore.registerModule("sorting", sortingModule);


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.sorting_mixin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var commonUtils = __webpack_require__(2);
var SORT_CLASS = "dx-sort",
    SORT_NONE_CLASS = "dx-sort-none",
    SORTUP_CLASS = "dx-sort-up",
    SORTDOWN_CLASS = "dx-sort-down",
    HEADERS_ACTION_CLASS = "action";
module.exports = {
    _applyColumnState: function(options) {
        var side, ariaSortState, $sortIndicator, that = this,
            sortingMode = that.option("sorting.mode"),
            rootElement = options.rootElement,
            column = options.column,
            $indicatorsContainer = that._getIndicatorContainer(rootElement);
        if ("sort" === options.name) {
            side = that.option("rtlEnabled") ? "right" : "left";
            rootElement.find("." + SORT_CLASS).remove();
            !$indicatorsContainer.children().length && $indicatorsContainer.remove();
            if (("single" === sortingMode || "multiple" === sortingMode) && column.allowSorting || commonUtils.isDefined(column.sortOrder)) {
                ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
                $sortIndicator = that.callBase(options).toggleClass(SORTUP_CLASS, "asc" === column.sortOrder).toggleClass(SORTDOWN_CLASS, "desc" === column.sortOrder);
                options.rootElement.addClass(that.addWidgetPrefix(HEADERS_ACTION_CLASS))
            }
            if (!commonUtils.isDefined(column.sortOrder)) {
                that.setAria("sort", "none", rootElement)
            } else {
                that.setAria("sort", ariaSortState, rootElement)
            }
            return $sortIndicator
        } else {
            return that.callBase(options)
        }
    },
    _getIndicatorClassName: function(name) {
        if ("sort" === name) {
            return SORT_CLASS
        }
        return this.callBase(name)
    },
    _renderIndicator: function(options) {
        var rtlEnabled, column = options.column,
            $container = options.container,
            $indicator = options.indicator;
        if ("sort" === options.name) {
            rtlEnabled = this.option("rtlEnabled");
            if (!commonUtils.isDefined(column.sortOrder)) {
                $indicator && $indicator.addClass(SORT_NONE_CLASS)
            }
            if ($container.children().length && (!rtlEnabled && "left" === options.columnAlignment || rtlEnabled && "right" === options.columnAlignment)) {
                $container.prepend($indicator);
                return
            }
        }
        this.callBase(options)
    },
    _updateIndicator: function($cell, column, indicatorName) {
        if ("sort" === indicatorName && commonUtils.isDefined(column.groupIndex)) {
            return
        }
        return this.callBase.apply(this, arguments)
    },
    _getIndicatorElements: function($cell, returnAll) {
        var $indicatorElements = this.callBase($cell);
        return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not("." + SORT_NONE_CLASS)
    }
};


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.rows.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    rowsViewModule = __webpack_require__(219);
exports.RowsView = rowsViewModule.views.rowsView;
gridCore.registerModule("rows", rowsViewModule);


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.context_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(12),
    contextMenuModule = __webpack_require__(220);
treeListCore.registerModule("contextMenu", contextMenuModule);


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.error_handling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    errorHandlingModule = __webpack_require__(221);
gridCore.registerModule("errorHandling", errorHandlingModule);


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.grid_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    gridViewModule = __webpack_require__(222);
gridCore.registerModule("gridView", gridViewModule);


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.header_panel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    headerPanelModule = __webpack_require__(223);
exports.HeaderPanel = headerPanelModule.views.headerPanel;
gridCore.registerModule("headerPanel", headerPanelModule);


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.state_storing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    stateStoringCore = __webpack_require__(361),
    equalByValue = commonUtils.equalByValue;
var processLoadState = function(that) {
    var columnsController = that.getController("columns"),
        selectionController = that.getController("selection"),
        exportController = that.getController("export"),
        dataController = that.getController("data"),
        pagerView = that.getView("pagerView");
    if (columnsController) {
        columnsController.columnsChanged.add(function() {
            var columnsState = columnsController.getUserState(),
                columnsStateHash = commonUtils.getKeyHash(columnsState),
                currentColumnsStateHash = commonUtils.getKeyHash(that._state.columns);
            if (!equalByValue(currentColumnsStateHash, columnsStateHash)) {
                extend(that._state, {
                    columns: columnsState
                });
                that.isEnabled() && that.save()
            }
        })
    }
    if (selectionController) {
        selectionController.selectionChanged.add(function(e) {
            extend(that._state, {
                selectedRowKeys: e.selectedRowKeys,
                selectionFilter: e.selectionFilter
            });
            that.isEnabled() && that.save()
        })
    }
    if (dataController) {
        that._initialPageSize = that.option("paging.pageSize");
        dataController.changed.add(function() {
            extend(that._state, {
                searchText: that.option("searchPanel.text"),
                pageIndex: dataController.pageIndex(),
                pageSize: dataController.pageSize(),
                allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0
            });
            that.isEnabled() && that.save()
        })
    }
    if (exportController) {
        exportController.selectionOnlyChanged.add(function() {
            extend(that._state, {
                exportSelectionOnly: exportController.selectionOnly()
            });
            that.isEnabled() && that.save()
        })
    }
};
var applyState = function(that, state) {
    var allowedPageSizes = state.allowedPageSizes,
        searchText = state.searchText,
        selectedRowKeys = state.selectedRowKeys,
        selectionFilter = state.selectionFilter,
        exportController = that.getController("export"),
        columnsController = that.getController("columns"),
        scrollingMode = that.option("scrolling.mode");
    that.component.beginUpdate();
    if (columnsController) {
        columnsController.setUserState(state.columns)
    }
    if (exportController) {
        exportController.selectionOnly(state.exportSelectionOnly)
    }
    that.option("selectedRowKeys", selectedRowKeys || []);
    that.option("selectionFilter", selectionFilter);
    if (allowedPageSizes && "auto" === that.option("pager.allowedPageSizes")) {
        that.option("pager").allowedPageSizes = allowedPageSizes
    }
    that.component.endUpdate();
    that.option("searchPanel.text", searchText || "");
    that.option("paging.pageSize", "virtual" !== scrollingMode && "infinite" !== scrollingMode && state.pageSize ? state.pageSize : that._initialPageSize);
    that.option("paging.pageIndex", state.pageIndex || 0)
};
gridCore.registerModule("stateStoring", {
    defaultOptions: function() {
        return {
            stateStoring: {
                enabled: false,
                storageKey: null,
                type: "localStorage",
                customLoad: null,
                customSave: null,
                savingTimeout: 2e3
            }
        }
    },
    controllers: {
        stateStoring: stateStoringCore.StateStoringController
    },
    extenders: {
        views: {
            rowsView: {
                init: function() {
                    var that = this;
                    var dataController = that.getController("data");
                    that.callBase();
                    dataController.stateLoaded.add(function() {
                        if (dataController.isLoaded()) {
                            that.setLoading(false);
                            that.renderNoDataText()
                        }
                    })
                }
            }
        },
        controllers: {
            stateStoring: {
                init: function() {
                    this.callBase.apply(this, arguments);
                    processLoadState(this)
                },
                isLoading: function() {
                    return this.callBase() || this.getController("data").isStateLoading()
                },
                state: function(state) {
                    var result = this.callBase.apply(this, arguments);
                    if (void 0 !== state) {
                        applyState(this, extend({}, state))
                    }
                    return result
                }
            },
            columns: {
                getVisibleColumns: function() {
                    var visibleColumns = this.callBase.apply(this, arguments),
                        stateStoringController = this.getController("stateStoring");
                    return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
                }
            },
            data: {
                callbackNames: function() {
                    return this.callBase().concat(["stateLoaded"])
                },
                _refreshDataSource: function() {
                    var that = this,
                        callBase = that.callBase,
                        stateStoringController = that.getController("stateStoring");
                    if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                        clearTimeout(that._restoreStateTimeoutID);
                        that._restoreStateTimeoutID = setTimeout(function() {
                            stateStoringController.load().always(function() {
                                that._restoreStateTimeoutID = null;
                                callBase.call(that);
                                that.stateLoaded.fire()
                            })
                        })
                    } else {
                        if (!that.isStateLoading()) {
                            callBase.call(that)
                        }
                    }
                },
                isLoading: function() {
                    var that = this,
                        stateStoringController = that.getController("stateStoring");
                    return this.callBase() || stateStoringController.isLoading()
                },
                isStateLoading: function() {
                    return commonUtils.isDefined(this._restoreStateTimeoutID)
                },
                isLoaded: function() {
                    return this.callBase() && !this.isStateLoading()
                },
                dispose: function() {
                    clearTimeout(this._restoreStateTimeoutID);
                    this.callBase()
                }
            }
        }
    }
});


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.state_storing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    errors = __webpack_require__(16),
    browser = __webpack_require__(21),
    sessionStorage = __webpack_require__(107).sessionStorage,
    extend = __webpack_require__(1).extend,
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9);
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function(state) {
    if (!state) {
        return
    }
    $.each(state, function(key, value) {
        var date;
        if (typeUtils.isPlainObject(value) || Array.isArray(value)) {
            parseDates(value)
        } else {
            if ("string" === typeof value) {
                date = DATE_REGEX.exec(value);
                if (date) {
                    state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                }
            }
        }
    })
};
exports.StateStoringController = modules.ViewController.inherit(function() {
    var getStorage = function(options) {
        var storage = "sessionStorage" === options.type ? sessionStorage() : localStorage;
        if (!storage) {
            if ("file:" === window.location.protocol && browser.msie) {
                throw new Error("E1038")
            } else {
                throw new Error("E1007")
            }
        }
        return storage
    };
    var getUniqueStorageKey = function(options) {
        return commonUtils.isDefined(options.storageKey) ? options.storageKey : "storage"
    };
    return {
        _loadState: function() {
            var options = this.option("stateStoring");
            if ("custom" === options.type) {
                return options.customLoad && options.customLoad()
            }
            try {
                return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
            } catch (e) {
                errors.log(e.message)
            }
        },
        _saveState: function(state) {
            var options = this.option("stateStoring");
            if ("custom" === options.type) {
                options.customSave && options.customSave(state);
                return
            }
            try {
                getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
            } catch (e) {}
        },
        publicMethods: function() {
            return ["state"]
        },
        isEnabled: function() {
            return this.option("stateStoring.enabled")
        },
        init: function() {
            var that = this;
            that._state = {};
            that._isLoaded = false;
            that._isLoading = false;
            that._windowUnloadHandler = function() {
                if (void 0 !== that._savingTimeoutID) {
                    that._saveState(that.state())
                }
            };
            $(window).on("unload", that._windowUnloadHandler);
            return that
        },
        isLoaded: function() {
            return this._isLoaded
        },
        isLoading: function() {
            return this._isLoading
        },
        load: function() {
            var loadResult, that = this;
            that._isLoading = true;
            loadResult = that._loadState();
            if (!loadResult || !commonUtils.isFunction(loadResult.done)) {
                loadResult = $.Deferred().resolve(loadResult)
            }
            loadResult.done(function(state) {
                that._isLoaded = true;
                that._isLoading = false;
                that.state(state)
            });
            return loadResult
        },
        state: function(state) {
            var that = this;
            if (!arguments.length) {
                return extend(true, {}, that._state)
            } else {
                that._state = extend({}, state);
                parseDates(that._state)
            }
        },
        save: function() {
            var that = this;
            clearTimeout(that._savingTimeoutID);
            that._savingTimeoutID = setTimeout(function() {
                that._saveState(that.state());
                that._savingTimeoutID = void 0
            }, that.option("stateStoring.savingTimeout"))
        },
        optionChanged: function(args) {
            var that = this;
            switch (args.name) {
                case "stateStoring":
                    if (that.isEnabled() && !that.isLoading()) {
                        that.load()
                    }
                    args.handled = true;
                    break;
                default:
                    that.callBase(args)
            }
        },
        dispose: function() {
            clearTimeout(this._savingTimeoutID);
            $(window).off("unload", this._windowUnloadHandler)
        }
    }
}());


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.selection.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    selectionModule = __webpack_require__(224);
gridCore.registerModule("selection", selectionModule);


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.column_chooser.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    columnChooserModule = __webpack_require__(225);
exports.ColumnChooserController = columnChooserModule.controllers.columnChooser;
exports.ColumnChooserView = columnChooserModule.views.columnChooserView;
gridCore.registerModule("columnChooser", columnChooserModule);


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.grouping.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    gridCore = __webpack_require__(12),
    ExpandedGroupingHelper = __webpack_require__(365).GroupingHelper,
    CollapsedGroupingHelper = __webpack_require__(366).GroupingHelper,
    messageLocalization = __webpack_require__(8),
    dataSourceAdapter = __webpack_require__(131),
    commonUtils = __webpack_require__(2),
    devices = __webpack_require__(6),
    when = __webpack_require__(10).when;
var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
    DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
    DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
    DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
    DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
    DATAGRID_EXPAND_CLASS = "dx-datagrid-expand",
    DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
    DATAGRID_GROUP_ROW_CLASS = "dx-group-row";
var GroupingDataSourceAdapterExtender = function() {
    return {
        init: function() {
            this.callBase.apply(this, arguments);
            this._initGroupingHelper()
        },
        _initGroupingHelper: function(options) {
            var grouping = this._grouping,
                remoteOperations = options ? options.remoteOperations : this.remoteOperations();
            if (remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging && !remoteOperations.grouping) {
                if (!grouping || grouping instanceof CollapsedGroupingHelper) {
                    this._grouping = new ExpandedGroupingHelper(this)
                }
            } else {
                if (!grouping || grouping instanceof ExpandedGroupingHelper) {
                    this._grouping = new CollapsedGroupingHelper(this)
                }
            }
        },
        totalItemsCount: function() {
            var that = this,
                totalCount = that.callBase();
            return totalCount > 0 && that._dataSource.group() && that._dataSource.requireTotalCount() ? totalCount + that._grouping.totalCountCorrection() : totalCount
        },
        itemsCount: function() {
            return this._dataSource.group() ? this._grouping.itemsCount() || 0 : this.callBase()
        },
        allowCollapseAll: function() {
            return this._grouping.allowCollapseAll()
        },
        isRowExpanded: function(key) {
            var groupInfo = this._grouping.findGroupInfo(key);
            return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll()
        },
        collapseAll: function(groupIndex) {
            return this._collapseExpandAll(groupIndex, false)
        },
        expandAll: function(groupIndex) {
            return this._collapseExpandAll(groupIndex, true)
        },
        _collapseExpandAll: function(groupIndex, isExpand) {
            var i, that = this,
                dataSource = that._dataSource,
                group = dataSource.group(),
                groups = gridCore.normalizeSortingInfo(group || []);
            if (groups.length) {
                for (i = 0; i < groups.length; i++) {
                    if (void 0 === groupIndex || groupIndex === i) {
                        groups[i].isExpanded = isExpand
                    } else {
                        if (group && group[i]) {
                            groups[i].isExpanded = group[i].isExpanded
                        }
                    }
                }
                dataSource.group(groups);
                that._grouping.foreachGroups(function(groupInfo, parents) {
                    if (void 0 === groupIndex || groupIndex === parents.length - 1) {
                        groupInfo.isExpanded = isExpand
                    }
                }, false, true)
            }
            return true
        },
        refresh: function() {
            this.callBase.apply(this, arguments);
            return this._grouping.refresh.apply(this._grouping, arguments)
        },
        changeRowExpand: function(path) {
            var that = this,
                dataSource = that._dataSource;
            if (dataSource.group()) {
                dataSource.beginLoading();
                return that._changeRowExpandCore(path).always(function() {
                    dataSource.endLoading()
                })
            }
        },
        _changeRowExpandCore: function(path) {
            return this._grouping.changeRowExpand(path)
        },
        _hasGroupLevelsExpandState: function(group, isExpanded) {
            if (group && Array.isArray(group)) {
                for (var i = 0; i < group.length; i++) {
                    if (group[i].isExpanded === isExpanded) {
                        return true
                    }
                }
            }
        },
        _customizeRemoteOperations: function(options) {
            var remoteOperations = options.remoteOperations;
            if (options.storeLoadOptions.group) {
                if (remoteOperations.grouping && !options.isCustomLoading) {
                    if (!remoteOperations.groupPaging || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, true)) {
                        remoteOperations.paging = false
                    }
                }
                if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options.isCustomLoading || this._hasGroupLevelsExpandState(options.storeLoadOptions.group, false))) {
                    remoteOperations.paging = false
                }
            }
            this.callBase.apply(this, arguments)
        },
        _handleDataLoading: function(options) {
            this.callBase(options);
            this._initGroupingHelper(options);
            return this._grouping.handleDataLoading(options)
        },
        _handleDataLoaded: function(options) {
            return this._grouping.handleDataLoaded(options, this.callBase.bind(this))
        },
        _handleDataLoadedCore: function(options) {
            return this._grouping.handleDataLoadedCore(options, this.callBase.bind(this))
        }
    }
}();
dataSourceAdapter.extend(GroupingDataSourceAdapterExtender);
var GroupingDataControllerExtender = function() {
    return {
        init: function() {
            var that = this;
            that.callBase();
            that.createAction("onRowExpanding");
            that.createAction("onRowExpanded");
            that.createAction("onRowCollapsing");
            that.createAction("onRowCollapsed")
        },
        _processItems: function(items, changeType) {
            var groupColumns = this._columnsController.getGroupColumns();
            if (items.length && groupColumns.length) {
                items = this._processGroupItems(items, groupColumns.length)
            }
            return this.callBase(items, changeType)
        },
        _processItem: function(item, options) {
            if (commonUtils.isDefined(item.groupIndex) && commonUtils.isString(item.rowType) && 0 === item.rowType.indexOf("group")) {
                item = this._processGroupItem(item, options);
                options.dataIndex = 0
            } else {
                item = this.callBase.apply(this, arguments)
            }
            return item
        },
        _processGroupItem: function(item) {
            return item
        },
        _processGroupItems: function(items, groupsCount, options) {
            var scrollingMode, i, item, resultItems, that = this,
                groupedColumns = that._columnsController.getGroupColumns(),
                column = groupedColumns[groupedColumns.length - groupsCount];
            if (!options) {
                scrollingMode = that.option("scrolling.mode");
                options = {
                    collectContinuationItems: "virtual" !== scrollingMode && "infinite" !== scrollingMode,
                    resultItems: [],
                    path: [],
                    values: []
                }
            }
            resultItems = options.resultItems;
            if (options.data) {
                if (options.collectContinuationItems || !options.data.isContinuation) {
                    resultItems.push({
                        rowType: "group",
                        data: options.data,
                        groupIndex: options.path.length - 1,
                        isExpanded: !!options.data.items,
                        key: options.path.slice(0),
                        values: options.values.slice(0)
                    })
                }
            }
            if (items) {
                if (0 === groupsCount) {
                    resultItems.push.apply(resultItems, items)
                } else {
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item && "items" in item) {
                            options.data = item;
                            options.path.push(item.key);
                            options.values.push(column && column.deserializeValue ? column.deserializeValue(item.key) : item.key);
                            that._processGroupItems(item.items, groupsCount - 1, options);
                            options.data = void 0;
                            options.path.pop();
                            options.values.pop()
                        } else {
                            resultItems.push(item)
                        }
                    }
                }
            }
            return resultItems
        },
        publicMethods: function() {
            return this.callBase().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"])
        },
        collapseAll: function(groupIndex) {
            var dataSource = this._dataSource;
            if (dataSource && dataSource.collapseAll(groupIndex)) {
                dataSource.pageIndex(0);
                dataSource.reload()
            }
        },
        expandAll: function(groupIndex) {
            var dataSource = this._dataSource;
            if (dataSource && dataSource.expandAll(groupIndex)) {
                dataSource.pageIndex(0);
                dataSource.reload()
            }
        },
        changeRowExpand: function(key) {
            var that = this,
                expanded = that.isRowExpanded(key),
                args = {
                    key: key,
                    expanded: expanded
                };
            that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
            if (!args.cancel) {
                return when(that._changeRowExpandCore(key)).done(function() {
                    args.expanded = !expanded;
                    that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args)
                })
            }
        },
        _changeRowExpandCore: function(key) {
            var d, that = this,
                dataSource = this._dataSource;
            if (!dataSource) {
                return
            }
            d = $.Deferred();
            when(dataSource.changeRowExpand(key)).done(function() {
                that.load().done(d.resolve).fail(d.reject)
            }).fail(d.reject);
            return d
        },
        isRowExpanded: function(key) {
            var dataSource = this._dataSource;
            return dataSource && dataSource.isRowExpanded(key)
        },
        expandRow: function(key) {
            if (!this.isRowExpanded(key)) {
                return this.changeRowExpand(key)
            }
            return $.Deferred().resolve()
        },
        collapseRow: function(key) {
            if (this.isRowExpanded(key)) {
                return this.changeRowExpand(key)
            }
            return $.Deferred().resolve()
        },
        optionChanged: function(args) {
            if ("grouping" === args.name) {
                args.name = "dataSource"
            }
            this.callBase(args)
        }
    }
}();
var onGroupingMenuItemClick = function(column, params) {
    var columnsController = this._columnsController;
    switch (params.itemData.value) {
        case "group":
            var groups = columnsController._dataSource.group() || [];
            columnsController.columnOption(column.dataField, "groupIndex", groups.length);
            break;
        case "ungroup":
            columnsController.columnOption(column.dataField, "groupIndex", -1);
            break;
        case "ungroupAll":
            this.component.clearGrouping()
    }
};
var GroupingHeaderPanelExtender = function() {
    return {
        _getToolbarItems: function() {
            var items = this.callBase();
            return this._appendGroupingItem(items)
        },
        _appendGroupingItem: function(items) {
            var that = this,
                groupPanelRenderedCallback = function(e) {
                    that._updateGroupPanelContent(e.itemElement.find("." + DATAGRID_GROUP_PANEL_CLASS))
                };
            if (that._isGroupPanelVisible()) {
                var toolbarItem = {
                    html: "<div class='" + DATAGRID_GROUP_PANEL_CLASS + "'></div>",
                    name: "groupPanel",
                    onItemRendered: groupPanelRenderedCallback,
                    location: "before",
                    locateInMenu: "never",
                    sortIndex: 1
                };
                items.push(toolbarItem)
            }
            return items
        },
        _isGroupPanelVisible: function() {
            var isVisible, groupPanelOptions = this.option("groupPanel");
            if (groupPanelOptions) {
                isVisible = groupPanelOptions.visible;
                if ("auto" === isVisible) {
                    isVisible = "desktop" === devices.current().deviceType ? true : false
                }
            }
            return isVisible
        },
        _renderGroupPanelItems: function($groupPanel, groupColumns) {
            var that = this;
            $groupPanel.empty();
            $.each(groupColumns, function(index, groupColumn) {
                that._createGroupPanelItem($groupPanel, groupColumn)
            })
        },
        _createGroupPanelItem: function($rootElement, groupColumn) {
            return $("<div />").addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).data("columnData", groupColumn).appendTo($rootElement).text(groupColumn.caption)
        },
        _columnOptionChanged: function(e) {
            if (!this._requireReady && !gridCore.checkChanges(e.optionNames, ["width", "visibleWidth"])) {
                var $toolbarElement = this.element(),
                    $groupPanel = $toolbarElement && $toolbarElement.find("." + DATAGRID_GROUP_PANEL_CLASS);
                if ($groupPanel && $groupPanel.length) {
                    this._updateGroupPanelContent($groupPanel);
                    this.renderCompleted.fire()
                }
            }
            this.callBase()
        },
        _updateGroupPanelContent: function($groupPanel) {
            var that = this,
                groupColumns = that.getController("columns").getGroupColumns(),
                groupPanelOptions = that.option("groupPanel");
            that._renderGroupPanelItems($groupPanel, groupColumns);
            if (groupPanelOptions.allowColumnDragging && !groupColumns.length) {
                $("<div />").addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
            }
        },
        allowDragging: function(column) {
            var groupPanelOptions = this.option("groupPanel");
            return this._isGroupPanelVisible() && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
        },
        getColumnElements: function() {
            var $element = this.element();
            return $element && $element.find("." + DATAGRID_GROUP_PANEL_ITEM_CLASS)
        },
        getColumns: function() {
            return this.getController("columns").getGroupColumns()
        },
        getBoundingRect: function() {
            var offset, that = this,
                $element = that.element();
            if ($element && $element.find("." + DATAGRID_GROUP_PANEL_CLASS).length) {
                offset = $element.offset();
                return {
                    top: offset.top,
                    bottom: offset.top + $element.height()
                }
            }
            return null
        },
        getName: function() {
            return "group"
        },
        getContextMenuItems: function(options) {
            var items, that = this,
                contextMenuEnabled = that.option("grouping.contextMenuEnabled"),
                $groupedColumnElement = options.targetElement.closest("." + DATAGRID_GROUP_PANEL_ITEM_CLASS);
            if ($groupedColumnElement.length) {
                options.column = $groupedColumnElement.data("columnData")
            }
            if (contextMenuEnabled && options.column) {
                var column = options.column,
                    isGroupingAllowed = commonUtils.isDefined(column.allowGrouping) ? column.allowGrouping : true;
                if (isGroupingAllowed) {
                    var isColumnGrouped = commonUtils.isDefined(column.groupIndex) && column.groupIndex > -1,
                        groupingTexts = that.option("grouping.texts"),
                        onItemClick = onGroupingMenuItemClick.bind(that, column);
                    items = [{
                        text: groupingTexts.ungroup,
                        value: "ungroup",
                        disabled: !isColumnGrouped,
                        onItemClick: onItemClick
                    }, {
                        text: groupingTexts.ungroupAll,
                        value: "ungroupAll",
                        onItemClick: onItemClick
                    }]
                }
            }
            return items
        },
        isVisible: function() {
            return this.callBase() || this._isGroupPanelVisible()
        },
        optionChanged: function(args) {
            if ("groupPanel" === args.name) {
                this._invalidate();
                args.handled = true
            } else {
                this.callBase(args)
            }
        }
    }
}();
exports.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
var GroupingRowsViewExtender = function() {
    return {
        getContextMenuItems: function(options) {
            var items, that = this,
                contextMenuEnabled = that.option("grouping.contextMenuEnabled");
            if (contextMenuEnabled && options.row && "group" === options.row.rowType) {
                var columnsController = that._columnsController,
                    column = columnsController.columnOption("groupIndex:" + options.row.groupIndex);
                if (column && column.allowGrouping) {
                    var groupingTexts = that.option("grouping.texts"),
                        onItemClick = onGroupingMenuItemClick.bind(that, column);
                    items = [];
                    items.push({
                        text: groupingTexts.ungroup,
                        value: "ungroup",
                        onItemClick: onItemClick
                    }, {
                        text: groupingTexts.ungroupAll,
                        value: "ungroupAll",
                        onItemClick: onItemClick
                    })
                }
            }
            return items
        },
        _rowClick: function(e) {
            var that = this,
                expandMode = that.option("grouping.expandMode"),
                scrollingMode = that.option("scrolling.mode"),
                isGroupRowStateChanged = "infinite" !== scrollingMode && "rowClick" === expandMode && $(e.jQueryEvent.target).closest("." + DATAGRID_GROUP_ROW_CLASS).length,
                isExpandButtonClicked = $(e.jQueryEvent.target).closest("." + DATAGRID_EXPAND_CLASS).length;
            if (isGroupRowStateChanged || isExpandButtonClicked) {
                that._changeGroupRowState(e)
            }
            that.callBase(e)
        },
        _changeGroupRowState: function(e) {
            var dataController = this.getController("data"),
                row = dataController.items()[e.rowIndex];
            if ("detail" !== row.rowType) {
                dataController.changeRowExpand(row.key);
                e.jQueryEvent.preventDefault();
                e.handled = true
            }
        },
        _getCellTemplate: function(options) {
            var that = this;
            if ("expand" === options.column.command) {
                return {
                    allowRenderToDetachedContainer: true,
                    render: function(container, options) {
                        if (commonUtils.isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.inserted) {
                            container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
                            $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo(container);
                            that.setAria("label", options.value ? that.localize("dxDataGrid-ariaCollapse") : that.localize("dxDataGrid-ariaExpand"), container)
                        }
                    }
                }
            }
            return that.callBase(options)
        }
    }
}();
var columnHeadersViewExtender = function() {
    return {
        getContextMenuItems: function(options) {
            var that = this,
                contextMenuEnabled = that.option("grouping.contextMenuEnabled"),
                items = that.callBase(options);
            if (contextMenuEnabled && options.row && "header" === options.row.rowType) {
                var column = options.column;
                if (!column.command && (!commonUtils.isDefined(column.allowGrouping) || column.allowGrouping)) {
                    var groupingTexts = that.option("grouping.texts"),
                        isColumnGrouped = commonUtils.isDefined(column.groupIndex) && column.groupIndex > -1,
                        onItemClick = onGroupingMenuItemClick.bind(that, column);
                    items = items || [];
                    items.push({
                        text: groupingTexts.groupByThisColumn,
                        value: "group",
                        beginGroup: true,
                        disabled: isColumnGrouped,
                        onItemClick: onItemClick
                    });
                    if (column.showWhenGrouped) {
                        items.push({
                            text: groupingTexts.ungroup,
                            value: "ungroup",
                            disabled: !isColumnGrouped,
                            onItemClick: onItemClick
                        })
                    }
                    items.push({
                        text: groupingTexts.ungroupAll,
                        value: "ungroupAll",
                        onItemClick: onItemClick
                    })
                }
            }
            return items
        }
    }
}();
gridCore.registerModule("grouping", {
    defaultOptions: function() {
        return {
            grouping: {
                autoExpandAll: true,
                allowCollapsing: true,
                contextMenuEnabled: false,
                expandMode: "buttonClick",
                texts: {
                    groupContinuesMessage: messageLocalization.format("dxDataGrid-groupContinuesMessage"),
                    groupContinuedMessage: messageLocalization.format("dxDataGrid-groupContinuedMessage"),
                    groupByThisColumn: messageLocalization.format("dxDataGrid-groupHeaderText"),
                    ungroup: messageLocalization.format("dxDataGrid-ungroupHeaderText"),
                    ungroupAll: messageLocalization.format("dxDataGrid-ungroupAllText")
                }
            },
            groupPanel: {
                visible: false,
                emptyPanelText: messageLocalization.format("dxDataGrid-groupPanelEmptyText"),
                allowColumnDragging: true
            }
        }
    },
    extenders: {
        controllers: {
            data: GroupingDataControllerExtender
        },
        views: {
            headerPanel: GroupingHeaderPanelExtender,
            rowsView: GroupingRowsViewExtender,
            columnHeadersView: columnHeadersViewExtender
        }
    }
});


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.grouping.expanded.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    toComparable = __webpack_require__(14).toComparable,
    dataUtils = __webpack_require__(28),
    extend = __webpack_require__(1).extend,
    storeHelper = __webpack_require__(97),
    gridCore = __webpack_require__(12),
    normalizeSortingInfo = gridCore.normalizeSortingInfo,
    groupingCore = __webpack_require__(226),
    createGroupFilter = groupingCore.createGroupFilter,
    createOffsetFilter = groupingCore.createOffsetFilter,
    dataQuery = __webpack_require__(35),
    when = __webpack_require__(10).when;
var loadTotalCount = function(dataSource, options) {
    var d = $.Deferred(),
        loadOptions = extend({
            skip: 0,
            take: 1,
            requireTotalCount: true
        }, options);
    dataSource.load(loadOptions).done(function(data, extra) {
        d.resolve(extra && extra.totalCount)
    }).fail(d.reject.bind(d));
    return d
};
exports.GroupingHelper = groupingCore.GroupingHelper.inherit(function() {
    var foreachCollapsedGroups = function(that, callback, updateOffsets) {
        return that.foreachGroups(function(groupInfo) {
            if (!groupInfo.isExpanded) {
                return callback(groupInfo)
            }
        }, false, false, updateOffsets, true)
    };
    var correctSkipLoadOption = function(that, skip) {
        var skipCorrection = 0,
            resultSkip = skip || 0;
        if (skip) {
            foreachCollapsedGroups(that, function(groupInfo) {
                if (groupInfo.offset - skipCorrection >= skip) {
                    return false
                }
                skipCorrection += groupInfo.count - 1
            });
            resultSkip += skipCorrection
        }
        return resultSkip
    };
    var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
        var i, item, offsetInfo, removeLastItemsCount = 0,
            needRemoveFirstItem = false;
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (void 0 !== item.items) {
                path.push(item.key);
                var groupInfo = that.findGroupInfo(path);
                if (groupInfo && !groupInfo.isExpanded) {
                    item.collapsedItems = item.items;
                    item.items = null;
                    offset += groupInfo.count;
                    take--;
                    if (take < 0) {
                        removeLastItemsCount++
                    }
                    if (skipFirstItem) {
                        needRemoveFirstItem = true
                    }
                } else {
                    if (item.items) {
                        offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
                        if (skipFirstItem) {
                            if (offsetInfo.offset - offset > 1) {
                                item.isContinuation = true
                            } else {
                                needRemoveFirstItem = true
                            }
                        }
                        offset = offsetInfo.offset;
                        take = offsetInfo.take;
                        if (take < 0) {
                            if (item.items.length) {
                                item.isContinuationOnNextPage = true
                            } else {
                                removeLastItemsCount++
                            }
                        }
                    }
                }
                path.pop()
            } else {
                if (skipFirstItem) {
                    needRemoveFirstItem = true
                }
                offset++;
                take--;
                if (take < 0) {
                    removeLastItemsCount++
                }
            }
            skipFirstItem = false
        }
        if (needRemoveFirstItem) {
            items.splice(0, 1)
        }
        if (removeLastItemsCount) {
            items.splice(-removeLastItemsCount, removeLastItemsCount)
        }
        return {
            offset: offset,
            take: take
        }
    };
    var pathEquals = function(path1, path2) {
        var i;
        if (path1.length !== path2.length) {
            return false
        }
        for (i = 0; i < path1.length; i++) {
            if (!dataUtils.keysEqual(null, path1[i], path2[i])) {
                return false
            }
        }
        return true
    };
    var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
        var i, item;
        if (!items) {
            return
        }
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if ("key" in item && void 0 !== item.items) {
                path.push(item.key);
                if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {
                    additionalGroupInfo.offset = offset
                }
                var groupInfo = that.findGroupInfo(path);
                if (groupInfo && !item.isContinuation) {
                    groupInfo.offset = offset
                }
                if (groupInfo && !groupInfo.isExpanded) {
                    offset += groupInfo.count
                } else {
                    offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo)
                }
                path.pop()
            } else {
                offset++
            }
        }
        return offset
    };
    var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
        var groups, sorts;
        if (loadOptions.group) {
            groups = normalizeSortingInfo(loadOptions.group);
            sorts = normalizeSortingInfo(storeLoadOptions.sort);
            storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);
            delete loadOptions.group
        }
    };
    var createNotGroupFilter = function(path, storeLoadOptions, group) {
        var i, j, filterElement, groups = normalizeSortingInfo(group || storeLoadOptions.group),
            filter = [];
        for (i = 0; i < path.length; i++) {
            filterElement = [];
            for (j = 0; j <= i; j++) {
                filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]])
            }
            filter.push(gridCore.combineFilters(filterElement))
        }
        filter = gridCore.combineFilters(filter, "or");
        return gridCore.combineFilters([filter, storeLoadOptions.filter])
    };
    var getGroupCount = function(item, groupCount) {
        var i, count = item.count || item.items.length;
        if (!item.count && groupCount > 1) {
            count = 0;
            for (i = 0; i < item.items.length; i++) {
                count += getGroupCount(item.items[i], groupCount - 1)
            }
        }
        return count
    };
    return {
        handleDataLoading: function(options) {
            var loadOptions, take, that = this,
                storeLoadOptions = options.storeLoadOptions,
                collapsedGroups = [],
                collapsedItemsCount = 0,
                skipFirstItem = false,
                group = options.loadOptions.group,
                skipCorrection = 0;
            removeGroupLoadOption(storeLoadOptions, options.loadOptions);
            options.group = options.group || group;
            if (options.isCustomLoading) {
                return
            }
            loadOptions = extend({}, storeLoadOptions);
            loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
            if (loadOptions.skip && loadOptions.take && group) {
                loadOptions.skip--;
                loadOptions.take++;
                skipFirstItem = true
            }
            if (loadOptions.take && group) {
                take = loadOptions.take;
                loadOptions.take++
            }
            foreachCollapsedGroups(that, function(groupInfo) {
                if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {
                    return false
                } else {
                    if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
                        skipCorrection += groupInfo.count - 1;
                        collapsedGroups.push(groupInfo);
                        collapsedItemsCount += groupInfo.count
                    }
                }
            });
            $.each(collapsedGroups, function() {
                loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group)
            });
            options.storeLoadOptions = loadOptions;
            options.collapsedGroups = collapsedGroups;
            options.collapsedItemsCount = collapsedItemsCount;
            options.skip = loadOptions.skip || 0;
            options.skipFirstItem = skipFirstItem;
            options.take = take
        },
        handleDataLoaded: function(options, callBase) {
            var pathIndex, query, that = this,
                data = options.data,
                collapsedGroups = options.collapsedGroups,
                groups = normalizeSortingInfo(options.group),
                groupCount = groups.length;

            function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {
                if (!data || !path.length || !groups.length) {
                    return
                }
                var i, keyValue, pathValue = toComparable(path[0], true);
                for (i = 0; i < data.length; i++) {
                    keyValue = toComparable(data[i].key, true);
                    if (offset >= collapsedGroup.offset || pathValue === keyValue) {
                        break
                    } else {
                        offset += getGroupCount(data[i], groups.length)
                    }
                }
                if (!data.length || pathValue !== keyValue) {
                    data.splice(i, 0, {
                        key: path[0],
                        items: [],
                        count: 1 === path.length ? collapsedGroup.count : void 0
                    })
                }
                appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset)
            }
            callBase(options);
            if (groupCount) {
                query = dataQuery(data);
                storeHelper.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
                    data = groupedData
                });
                if (collapsedGroups) {
                    for (pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {
                        appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip)
                    }
                }
                if (!options.isCustomLoading) {
                    processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
                    that.updateItemsCount(data, groupCount)
                }
                options.data = data;
                if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {
                    options.extra.totalCount += options.collapsedItemsCount
                }
            }
        },
        updateTotalItemsCount: function() {
            var itemsCountCorrection = 0;
            foreachCollapsedGroups(this, function(groupInfo) {
                if (groupInfo.count) {
                    itemsCountCorrection -= groupInfo.count - 1
                }
            });
            this.callBase(itemsCountCorrection)
        },
        changeRowExpand: function(path) {
            var groupCountQuery, that = this,
                dataSource = that._dataSource,
                beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex(),
                dataSourceItems = dataSource.items(),
                offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize()),
                groupInfo = that.findGroupInfo(path);
            if (groupInfo && !groupInfo.isExpanded) {
                groupCountQuery = $.Deferred().resolve(groupInfo.count)
            } else {
                groupCountQuery = loadTotalCount(dataSource, {
                    filter: createGroupFilter(path, {
                        filter: dataSource.filter(),
                        group: dataSource.group()
                    })
                })
            }
            return when(groupCountQuery).done(function(count) {
                count = parseInt(count.length ? count[0] : count);
                if (groupInfo) {
                    updateGroupOffsets(that, dataSourceItems, [], offset);
                    groupInfo.isExpanded = !groupInfo.isExpanded;
                    groupInfo.count = count
                } else {
                    groupInfo = {
                        offset: -1,
                        count: count,
                        path: path,
                        isExpanded: false
                    };
                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
                    if (groupInfo.offset >= 0) {
                        that.addGroupInfo(groupInfo)
                    }
                }
                that.updateTotalItemsCount()
            }).fail(function() {
                dataSource.fireEvent("loadError", arguments)
            })
        },
        allowCollapseAll: function() {
            return false
        },
        refresh: function(options, isReload, operationTypes) {
            var that = this,
                storeLoadOptions = options.storeLoadOptions,
                dataSource = that._dataSource;
            this.callBase.apply(this, arguments);
            if (isReload || operationTypes.reload) {
                return foreachCollapsedGroups(that, function(groupInfo) {
                    var groupCountQuery = loadTotalCount(dataSource, {
                            filter: createGroupFilter(groupInfo.path, storeLoadOptions)
                        }),
                        groupOffsetQuery = loadTotalCount(dataSource, {
                            filter: createOffsetFilter(groupInfo.path, storeLoadOptions)
                        });
                    return when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                        offset = parseInt(offset.length ? offset[0] : offset);
                        count = parseInt(count.length ? count[0] : count);
                        groupInfo.offset = offset;
                        if (groupInfo.count !== count) {
                            groupInfo.count = count;
                            that.updateTotalItemsCount()
                        }
                    })
                }, true)
            }
        }
    }
}());


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.grouping.collapsed.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    gridCore = __webpack_require__(12),
    normalizeSortingInfo = gridCore.normalizeSortingInfo,
    groupingCore = __webpack_require__(226),
    createGroupFilter = groupingCore.createGroupFilter,
    createOffsetFilter = groupingCore.createOffsetFilter,
    errors = __webpack_require__(16),
    dataErrors = __webpack_require__(29).errors,
    when = __webpack_require__(10).when;
exports.GroupingHelper = groupingCore.GroupingHelper.inherit(function() {
    var foreachExpandedGroups = function(that, callback, updateGroups) {
        return that.foreachGroups(function(groupInfo, parents) {
            if (groupInfo.isExpanded) {
                return callback(groupInfo, parents)
            }
        }, true, false, updateGroups, updateGroups)
    };
    var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
        var i, item, groupInfo, isExpanded;
        expandedInfo.items = expandedInfo.items || [];
        expandedInfo.paths = expandedInfo.paths || [];
        expandedInfo.count = expandedInfo.count || 0;
        expandedInfo.lastCount = expandedInfo.lastCount || 0;
        if (!groupsCount) {
            return
        }
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (void 0 !== item.items) {
                path.push(item.key);
                if (isCustomLoading) {
                    isExpanded = true
                } else {
                    groupInfo = that.findGroupInfo(path);
                    isExpanded = groupInfo && groupInfo.isExpanded
                }
                if (!isExpanded) {
                    item.collapsedItems = item.items;
                    item.items = null
                } else {
                    if (item.items) {
                        processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded)
                    } else {
                        if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {
                            expandedInfo.items.push(item);
                            expandedInfo.paths.push(path.slice(0));
                            expandedInfo.count += expandedInfo.lastCount;
                            expandedInfo.lastCount = item.count
                        }
                    }
                }
                path.pop()
            }
        }
    };
    var updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset) {
        var count, groupInfo = that.findGroupInfo(path);
        if (!groupInfo) {
            if (isLastGroupLevel) {
                count = item.count > 0 ? item.count : item.items.length
            }
            that.addGroupInfo({
                isExpanded: that._isGroupExpanded(path.length - 1),
                path: path.slice(0),
                offset: offset,
                count: count || 0
            })
        } else {
            if (isLastGroupLevel) {
                groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0
            } else {
                item.count = groupInfo.count || item.count
            }
            groupInfo.offset = offset
        }
    };
    var updateGroupInfos = function(that, options, items, loadedGroupCount, groupIndex, path) {
        var item, count, i, groupCount = options.group ? options.group.length : 0,
            isLastGroupLevel = groupCount === loadedGroupCount,
            remotePaging = options.remoteOperations.paging,
            offset = 0,
            totalCount = 0;
        groupIndex = groupIndex || 0;
        path = path || [];
        if (remotePaging) {
            offset = 0 === groupIndex ? options.skip || 0 : options.skips[groupIndex - 1] || 0
        }
        if (groupIndex >= loadedGroupCount) {
            return items.length
        }
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (item) {
                path.push(item.key);
                if (!item.count && !item.items || void 0 === item.items) {
                    return -1
                }
                updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);
                count = item.items ? updateGroupInfos(that, options, item.items, loadedGroupCount, groupIndex + 1, path) : item.count || -1;
                if (count < 0) {
                    return -1
                }
                totalCount += count;
                path.pop()
            }
        }
        return totalCount
    };
    var isGroupExpanded = function(groups, groupIndex) {
        return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
    };
    var getTotalOffset = function(groupInfos, pageSize, offset) {
        var groupIndex, groupSize, totalOffset = offset;
        for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
            groupSize = groupInfos[groupIndex].offset + 1;
            if (groupIndex > 0) {
                groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
                if (pageSize) {
                    groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
                }
            }
            totalOffset += groupSize
        }
        return totalOffset
    };
    var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
        groupIndex = groupIndex || 0;
        if (pageSize > 1 && groupSize > 0) {
            var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
            pageOffset += groupSize - groupIndex - 2;
            if (pageOffset < 0) {
                pageOffset += pageSize
            }
            return Math.floor(pageOffset / (pageSize - groupIndex - 1))
        }
        return 0
    };

    function applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex) {
        var item = expandedInfo.items[expandedItemIndex],
            skip = options.skips && options.skips[groupLevel],
            take = options.takes && options.takes[groupLevel],
            isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1,
            isFirstExpandedItem = 0 === expandedItemIndex,
            lastExpandedItemSkip = isFirstExpandedItem && skip || 0,
            isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;
        if (isFirstExpandedItem && void 0 !== skip) {
            item.isContinuation = true
        }
        if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {
            item.isContinuationOnNextPage = true
        }
    }

    function fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount) {
        var currentGroupIndex = currentGroupCount - 1,
            groupCount = options.group ? options.group.length : 0;
        expandedInfo.skip = options.skips && options.skips[currentGroupIndex];
        if (options.takes && void 0 !== options.takes[currentGroupIndex]) {
            if (groupCount === currentGroupCount) {
                expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0
            } else {
                expandedInfo.take = 0
            }
            expandedInfo.take += options.takes[currentGroupIndex]
        }
    }

    function isDataDeferred(data) {
        return !Array.isArray(data)
    }

    function makeDataDeferred(options) {
        if (!isDataDeferred(options.data)) {
            options.data = $.Deferred()
        }
    }

    function loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel, data) {
        if (!options.isCustomLoading) {
            expandedInfo = {};
            var currentGroupCount = loadedGroupCount + groupLevel;
            processGroupItems(that, data, currentGroupCount, expandedInfo, []);
            fillSkipTakeInExpandedInfo(options, expandedInfo, currentGroupCount)
        }
        var groupCount = options.group ? options.group.length : 0;
        if (expandedInfo.paths.length && groupCount - loadedGroupCount - groupLevel > 0) {
            makeDataDeferred(options);
            loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data)
        } else {
            if (expandedInfo.paths.length && options.storeLoadOptions.group) {
                makeDataDeferred(options);
                loadLastLevelGroupItems(that, options, expandedInfo, data)
            } else {
                if (isDataDeferred(options.data)) {
                    options.data.resolve(data)
                }
            }
        }
    }

    function loadExpandedGroups(that, options, expandedInfo, loadedGroupCount, groupLevel, data) {
        var groups = options.group || [],
            currentGroup = groups[groupLevel + 1],
            deferreds = [];
        $.each(expandedInfo.paths, function(expandedItemIndex) {
            var loadOptions = {
                requireTotalCount: false,
                requireGroupCount: true,
                group: [currentGroup],
                groupSummary: options.storeLoadOptions.groupSummary,
                filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {
                    filter: options.storeLoadOptions.filter,
                    group: groups
                })
            };
            if (0 === expandedItemIndex) {
                loadOptions.skip = expandedInfo.skip || 0
            }
            if (expandedItemIndex === expandedInfo.paths.length - 1) {
                loadOptions.take = expandedInfo.take
            }
            var loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);
            when(loadResult).done(function(data) {
                var item = expandedInfo.items[expandedItemIndex];
                applyContinuationToGroupItem(options, expandedInfo, groupLevel, expandedItemIndex);
                item.items = data
            });
            deferreds.push(loadResult)
        });
        when.apply(null, deferreds).done(function() {
            updateGroupInfos(that, options, data, groups.length);
            loadGroupItems(that, options, loadedGroupCount, expandedInfo, groupLevel + 1, data)
        })
    }

    function loadLastLevelGroupItems(that, options, expandedInfo, data) {
        var expandedFilters = [],
            groups = options.group || [];
        $.each(expandedInfo.paths, function(_, expandedPath) {
            expandedFilters.push(createGroupFilter(expandedPath, {
                group: options.isCustomLoading ? options.storeLoadOptions.group : groups
            }))
        });
        var filter = options.storeLoadOptions.filter;
        if (!options.storeLoadOptions.isLoadingAll) {
            filter = gridCore.combineFilters([filter, gridCore.combineFilters(expandedFilters, "or")])
        }
        var loadOptions = extend({}, options.storeLoadOptions, {
            requireTotalCount: false,
            requireGroupCount: false,
            group: null,
            sort: groups.concat(normalizeSortingInfo(options.storeLoadOptions.sort || [])),
            filter: filter
        });
        loadOptions.skip = expandedInfo.skip;
        loadOptions.take = expandedInfo.take;
        when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(function(items, extra) {
            $.each(expandedInfo.items, function(index, item) {
                var itemCount = item.count - (0 === index && loadOptions.skip || 0),
                    expandedItems = items.splice(0, itemCount);
                applyContinuationToGroupItem(options, expandedInfo, groups.length - 1, index);
                item.items = expandedItems
            });
            options.data.resolve(data)
        }).fail(options.data.reject)
    }
    var loadGroupTotalCount = function(dataSource, options) {
        var d = $.Deferred(),
            isGrouping = !!(options.group && options.group.length),
            loadOptions = extend({
                skip: 0,
                take: 1,
                requireGroupCount: isGrouping,
                requireTotalCount: !isGrouping
            }, options, {
                group: isGrouping ? options.group : null
            });
        dataSource.load(loadOptions).done(function(data, extra) {
            var count = extra && (isGrouping ? extra.groupCount : extra.totalCount);
            if (!isFinite(count)) {
                throw dataErrors.Error(isGrouping ? "E4022" : "E4021")
            }
            d.resolve(count)
        }).fail(d.reject.bind(d));
        return d
    };
    return {
        updateTotalItemsCount: function(options) {
            var totalItemsCount = 0,
                totalCount = options.extra && options.extra.totalCount || 0,
                groupCount = options.extra && options.extra.groupCount || 0,
                pageSize = this._dataSource.pageSize(),
                isVirtualPaging = this._isVirtualPaging();
            foreachExpandedGroups(this, function(groupInfo) {
                groupInfo.childrenTotalCount = 0
            });
            foreachExpandedGroups(this, function(groupInfo, parents) {
                var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
                    count = groupInfo.count + groupInfo.childrenTotalCount;
                if (!isVirtualPaging) {
                    count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1)
                }
                if (parents[parents.length - 2]) {
                    parents[parents.length - 2].childrenTotalCount += count
                } else {
                    totalItemsCount += count
                }
            });
            this.callBase(totalItemsCount - totalCount + groupCount)
        },
        _isGroupExpanded: function(groupIndex) {
            var groups = this._dataSource.group();
            return isGroupExpanded(groups, groupIndex)
        },
        _updatePagingOptions: function(options) {
            var that = this,
                isVirtualPaging = that._isVirtualPaging(),
                pageSize = that._dataSource.pageSize(),
                skips = [],
                takes = [],
                skipChildrenTotalCount = 0,
                childrenTotalCount = 0;
            if (options.take) {
                foreachExpandedGroups(this, function(groupInfo) {
                    groupInfo.childrenTotalCount = 0;
                    groupInfo.skipChildrenTotalCount = 0
                });
                foreachExpandedGroups(that, function(groupInfo, parents) {
                    var skip, take, takeCorrection = 0,
                        parentTakeCorrection = 0,
                        totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
                        continuationGroupCount = 0,
                        skipContinuationGroupCount = 0,
                        groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
                        childrenGroupInfoCount = groupInfoCount;
                    skip = options.skip - totalOffset;
                    if (totalOffset <= options.skip + options.take && groupInfoCount) {
                        take = options.take;
                        if (!isVirtualPaging) {
                            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
                            groupInfoCount += continuationGroupCount * parents.length;
                            childrenGroupInfoCount += continuationGroupCount;
                            if (pageSize && skip >= 0) {
                                takeCorrection = parents.length;
                                parentTakeCorrection = parents.length - 1;
                                skipContinuationGroupCount = Math.floor(skip / pageSize)
                            }
                        }
                        if (skip >= 0) {
                            if (totalOffset + groupInfoCount > options.skip) {
                                skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount)
                            }
                            if (totalOffset + groupInfoCount >= options.skip + take) {
                                takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
                            }
                        } else {
                            if (totalOffset + groupInfoCount >= options.skip + take) {
                                takes.unshift(take + skip - groupInfo.childrenTotalCount)
                            }
                        }
                    }
                    if (totalOffset <= options.skip) {
                        if (parents[parents.length - 2]) {
                            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection)
                        } else {
                            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1)
                        }
                    }
                    if (totalOffset <= options.skip + take) {
                        groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
                        if (parents[parents.length - 2]) {
                            parents[parents.length - 2].childrenTotalCount += groupInfoCount
                        } else {
                            childrenTotalCount += groupInfoCount
                        }
                    }
                });
                options.skip -= skipChildrenTotalCount;
                options.take -= childrenTotalCount - skipChildrenTotalCount
            }
            options.skips = skips;
            options.takes = takes
        },
        changeRowExpand: function(path) {
            var that = this,
                groupInfo = that.findGroupInfo(path),
                dataSource = that._dataSource,
                remoteGroupPaging = dataSource.remoteOperations().groupPaging,
                groups = normalizeSortingInfo(dataSource.group());
            if (groupInfo) {
                groupInfo.isExpanded = !groupInfo.isExpanded;
                if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {
                    return loadGroupTotalCount(dataSource, {
                        filter: createGroupFilter(path, {
                            filter: dataSource.filter(),
                            group: dataSource.group()
                        }),
                        group: groups.slice(path.length)
                    }).done(function(groupCount) {
                        groupInfo.count = groupCount
                    })
                }
                return $.Deferred().resolve()
            }
            return $.Deferred().reject()
        },
        handleDataLoading: function(options) {
            var that = this,
                storeLoadOptions = options.storeLoadOptions,
                groups = normalizeSortingInfo(storeLoadOptions.group || options.loadOptions.group);
            if (options.isCustomLoading || !groups.length) {
                return
            }
            if (options.remoteOperations.grouping) {
                var remotePaging = that._dataSource.remoteOperations().paging;
                storeLoadOptions.group = normalizeSortingInfo(storeLoadOptions.group);
                storeLoadOptions.group.forEach(function(group, index) {
                    var isLastGroup = index === storeLoadOptions.group.length - 1;
                    group.isExpanded = !remotePaging || !isLastGroup
                })
            }
            options.group = options.group || groups;
            if (options.remoteOperations.paging) {
                options.skip = storeLoadOptions.skip;
                options.take = storeLoadOptions.take;
                storeLoadOptions.requireGroupCount = true;
                storeLoadOptions.group = groups.slice(0, 1);
                that._updatePagingOptions(options);
                storeLoadOptions.skip = options.skip;
                storeLoadOptions.take = options.take
            } else {
                that.foreachGroups(function(groupInfo) {
                    groupInfo.count = 0
                })
            }
        },
        handleDataLoadedCore: function(options, callBase) {
            var totalCount, that = this,
                loadedGroupCount = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length,
                groupCount = options.group ? options.group.length : 0,
                expandedInfo = {};
            if (options.isCustomLoading) {
                callBase(options);
                processGroupItems(that, options.data, loadedGroupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll)
            } else {
                totalCount = updateGroupInfos(that, options, options.data, loadedGroupCount);
                if (totalCount < 0) {
                    throw errors.Error("E1037")
                }
                if (!options.remoteOperations.paging) {
                    if (loadedGroupCount && options.extra && options.loadOptions.requireTotalCount) {
                        options.extra.totalCount = totalCount;
                        options.extra.groupCount = options.data.length
                    }
                }
                if (groupCount && options.storeLoadOptions.requireGroupCount && !isFinite(options.extra.groupCount)) {
                    throw dataErrors.Error("E4022")
                }
                that.updateTotalItemsCount(options);
                if (!options.remoteOperations.paging) {
                    that._updatePagingOptions(options)
                }
                callBase(options);
                if (!options.remoteOperations.paging) {
                    that._processPaging(options, loadedGroupCount)
                }
            }
            loadGroupItems(that, options, loadedGroupCount, expandedInfo, 0, options.data);
            if (!options.isCustomLoading) {
                when(options.data).done(function(data) {
                    that.updateItemsCount(data, groupCount)
                })
            }
        },
        _processSkips: function(items, skips, groupCount) {
            if (!groupCount) {
                return
            }
            var firstItem = items[0],
                skip = skips[0],
                children = firstItem && firstItem.items;
            if (void 0 !== skip) {
                firstItem.isContinuation = true;
                if (children) {
                    firstItem.items = children.slice(skip);
                    this._processSkips(firstItem.items, skips.slice(1), groupCount - 1)
                }
            }
        },
        _processTakes: function(items, skips, takes, groupCount) {
            if (!groupCount || !items) {
                return
            }
            var lastItem = items[items.length - 1],
                children = lastItem && lastItem.items,
                take = takes[0],
                skip = skips[0];
            if (lastItem) {
                var maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;
                if (void 0 !== take && maxTakeCount > take) {
                    lastItem.isContinuationOnNextPage = true;
                    if (children) {
                        children = children.slice(0, take);
                        lastItem.items = children
                    }
                }
                this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1)
            }
        },
        _processPaging: function(options, groupCount) {
            this._processSkips(options.data, options.skips, groupCount);
            this._processTakes(options.data, options.skips, options.takes, groupCount)
        },
        refresh: function(options, isReload, operationTypes) {
            var isExpanded, groupIndex, that = this,
                dataSource = that._dataSource,
                storeLoadOptions = options.storeLoadOptions,
                group = options.group || options.storeLoadOptions.group,
                oldGroups = normalizeSortingInfo(that._group);

            function handleGroup(groupInfo, parents) {
                if (parents.length === groupIndex + 1) {
                    groupInfo.isExpanded = isExpanded
                }
            }
            for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
                isExpanded = isGroupExpanded(group, groupIndex);
                if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {
                    that.foreachGroups(handleGroup)
                }
            }
            that.callBase.apply(this, arguments);
            if (group && options.remoteOperations.paging && (isReload || operationTypes.reload)) {
                return foreachExpandedGroups(that, function(groupInfo) {
                    var groupCountQuery = loadGroupTotalCount(dataSource, {
                            filter: createGroupFilter(groupInfo.path, {
                                filter: storeLoadOptions.filter,
                                group: group
                            }),
                            group: group.slice(groupInfo.path.length)
                        }),
                        groupOffsetQuery = loadGroupTotalCount(dataSource, {
                            filter: createOffsetFilter(groupInfo.path, {
                                filter: storeLoadOptions.filter,
                                group: group
                            }),
                            group: group.slice(groupInfo.path.length - 1, 1)
                        });
                    return when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                        offset = parseInt(offset.length ? offset[0] : offset);
                        count = parseInt(count.length ? count[0] : count);
                        groupInfo.offset = offset;
                        if (groupInfo.count !== count) {
                            groupInfo.count = count;
                            that.updateTotalItemsCount(options)
                        }
                    })
                }, true)
            }
        }
    }
}());


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.master_detail.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    masterDetailModule = __webpack_require__(227);
gridCore.registerModule("masterDetail", masterDetailModule);


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.editing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(369);
var gridCore = __webpack_require__(12),
    editingModule = __webpack_require__(229);
gridCore.registerModule("editing", editingModule);


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.editor_factory.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    editorFactoryModule = __webpack_require__(228);
gridCore.registerModule("editorFactory", editorFactoryModule);


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/form/ui.form.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    Guid = __webpack_require__(34),
    utils = __webpack_require__(2),
    isEmptyObject = __webpack_require__(9).isEmptyObject,
    inArray = __webpack_require__(7).inArray,
    extend = __webpack_require__(1).extend,
    stringUtils = __webpack_require__(30),
    errors = __webpack_require__(16),
    browser = __webpack_require__(21),
    domUtils = __webpack_require__(15),
    messageLocalization = __webpack_require__(8),
    Widget = __webpack_require__(27),
    windowUtils = __webpack_require__(61),
    ValidationEngine = __webpack_require__(58),
    LayoutManager = __webpack_require__(371),
    TabPanel = __webpack_require__(204),
    Scrollable = __webpack_require__(70);
__webpack_require__(157);
__webpack_require__(211);
var FORM_CLASS = "dx-form",
    FIELD_ITEM_CLASS = "dx-field-item",
    FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
    FORM_GROUP_CLASS = "dx-form-group",
    FORM_GROUP_CONTENT_CLASS = "dx-form-group-content",
    FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption",
    FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption",
    HIDDEN_LABEL_CLASS = "dx-layout-manager-hidden-label",
    FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
    FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
    FIELD_ITEM_TAB_CLASS = "dx-field-item-tab",
    FORM_FIELD_ITEM_COL_CLASS = "dx-col-",
    GROUP_COL_COUNT_CLASS = "dx-group-colcount-",
    FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
    FORM_VALIDATION_SUMMARY = "dx-form-validation-summary",
    WIDGET_CLASS = "dx-widget",
    FOCUSED_STATE_CLASS = "dx-state-focused";
var Form = Widget.inherit({
    _init: function() {
        this.callBase();
        this._cachedColCountOptions = [];
        this._groupsColCount = []
    },
    _initOptions: function(options) {
        if (!("screenByWidth" in options)) {
            options.screenByWidth = windowUtils.defaultScreenFactorFunc
        }
        this.callBase(options)
    },
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            formID: "dx-" + new Guid,
            formData: {},
            colCount: 1,
            screenByWidth: null,
            colCountByScreen: void 0,
            labelLocation: "left",
            readOnly: false,
            onFieldDataChanged: null,
            customizeItem: null,
            onEditorEnterKey: null,
            minColWidth: 200,
            alignItemLabels: true,
            alignItemLabelsInAllGroups: true,
            showColonAfterLabel: true,
            showRequiredMark: true,
            showOptionalMark: false,
            requiredMark: "*",
            optionalMark: messageLocalization.format("dxForm-optionalMark"),
            requiredMessage: messageLocalization.getFormatter("dxForm-requiredMessage"),
            showValidationSummary: false,
            items: void 0,
            scrollingEnabled: false,
            validationGroup: void 0
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            formData: true,
            validationGroup: true
        })
    },
    _getColCount: function($element) {
        var $cols, index = 0,
            isColsExist = true;
        while (isColsExist) {
            $cols = $element.find("." + FORM_FIELD_ITEM_COL_CLASS + index);
            if (!$cols.length) {
                isColsExist = false
            } else {
                index++
            }
        }
        return index
    },
    _createHiddenElement: function(rootLayoutManager) {
        this._$hiddenElement = $("<div/>").addClass(WIDGET_CLASS).addClass(HIDDEN_LABEL_CLASS).appendTo(document.body);
        var $hiddenLabel = rootLayoutManager._renderLabel({
            text: " ",
            location: this.option("labelLocation")
        }).appendTo(this._$hiddenElement);
        this._hiddenLabelText = $hiddenLabel.find("." + FIELD_ITEM_LABEL_TEXT_CLASS)[0]
    },
    _removeHiddenElement: function() {
        this._$hiddenElement.remove();
        this._hiddenLabelText = null
    },
    _getLabelWidthByText: function(text) {
        this._hiddenLabelText.innerHTML = text;
        return this._hiddenLabelText.offsetWidth
    },
    _getLabelsSelectorByCol: function(index, options) {
        options = options || {};
        var fieldItemClass = options.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index,
            cssExcludeTabbedSelector = options.excludeTabbed ? ":not(." + FIELD_ITEM_TAB_CLASS + ")" : "",
            childLabelContentSelector = "> ." + FIELD_ITEM_LABEL_CLASS + " > ." + FIELD_ITEM_LABEL_CONTENT_CLASS;
        return "." + fieldItemClass + cssExcludeTabbedSelector + childLabelContentSelector
    },
    _getLabelText: function(labelText) {
        var child, i, length = labelText.children.length,
            result = "";
        for (i = 0; i < length; i++) {
            child = labelText.children[i];
            result += !stringUtils.isEmpty(child.innerText) ? child.innerText : child.innerHTML
        }
        return result
    },
    _applyLabelsWidthByCol: function($container, index, options) {
        var labelWidth, i, $labelTexts = $container.find(this._getLabelsSelectorByCol(index, options)),
            $labelTextsLength = $labelTexts.length,
            maxWidth = 0;
        for (i = 0; i < $labelTextsLength; i++) {
            labelWidth = this._getLabelWidthByText(this._getLabelText($labelTexts[i]));
            if (labelWidth > maxWidth) {
                maxWidth = labelWidth
            }
        }
        for (i = 0; i < $labelTextsLength; i++) {
            $labelTexts[i].style.width = maxWidth + "px"
        }
    },
    _applyLabelsWidth: function($container, excludeTabbed, inOneColumn) {
        var i, colCount = inOneColumn ? 1 : this._getColCount($container),
            applyLabelsOptions = {
                excludeTabbed: excludeTabbed,
                inOneColumn: inOneColumn
            };
        for (i = 0; i < colCount; i++) {
            this._applyLabelsWidthByCol($container, i, applyLabelsOptions)
        }
    },
    _getGroupElementsInColumn: function($container, columnIndex, colCount) {
        var cssColCountSelector = utils.isDefined(colCount) ? "." + GROUP_COL_COUNT_CLASS + colCount : "",
            groupSelector = "." + FORM_FIELD_ITEM_COL_CLASS + columnIndex + " > ." + FIELD_ITEM_CONTENT_CLASS + " > ." + FORM_GROUP_CLASS + cssColCountSelector;
        return $container.find(groupSelector)
    },
    _applyLabelsWidthWithGroups: function($container, colCount, excludeTabbed) {
        var alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
        if (alignItemLabelsInAllGroups) {
            this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed)
        } else {
            var i, $groups = this.element().find("." + FORM_GROUP_CLASS);
            for (i = 0; i < $groups.length; i++) {
                this._applyLabelsWidth($groups.eq(i), excludeTabbed)
            }
        }
    },
    _applyLabelsWidthWithNestedGroups: function($container, colCount, excludeTabbed) {
        var colIndex, groupsColIndex, groupColIndex, $groupsByCol, applyLabelsOptions = {
            excludeTabbed: excludeTabbed
        };
        for (colIndex = 0; colIndex < colCount; colIndex++) {
            $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
            this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions);
            for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
                $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
                var groupColCount = this._getColCount($groupsByCol);
                for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
                    this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions)
                }
            }
        }
    },
    _alignLabelsInColumn: function(options) {
        this._createHiddenElement(options.layoutManager);
        if (options.inOneColumn) {
            this._applyLabelsWidth(options.$container, options.excludeTabbed, true)
        } else {
            if (this._checkGrouping(options.items)) {
                this._applyLabelsWidthWithGroups(options.$container, options.layoutManager._getColCount(), options.excludeTabbed)
            } else {
                this._applyLabelsWidth(options.$container, options.excludeTabbed)
            }
        }
        this._removeHiddenElement()
    },
    _render: function() {
        this._clearCachedInstances();
        this.callBase();
        this.element().addClass(FORM_CLASS);
        this._attachSyncSubscriptions();
        this._cachedScreenFactor = windowUtils.getCurrentScreenFactor(this.option("screenByWidth"))
    },
    _clearCachedInstances: function() {
        this._editorInstancesByField = {};
        this._cachedLayoutManagers = []
    },
    _alignLabels: function(layoutManager, inOneColumn) {
        this._alignLabelsInColumn({
            $container: this.element(),
            layoutManager: layoutManager,
            excludeTabbed: true,
            items: this.option("items"),
            inOneColumn: inOneColumn
        })
    },
    _clean: function() {
        this.callBase();
        this._groupsColCount = [];
        this._cachedColCountOptions = [];
        delete this._cachedScreenFactor
    },
    _renderContentImpl: function() {
        this.callBase();
        this.setAria("role", "form", this.element());
        if (this.option("scrollingEnabled")) {
            this._renderScrollable()
        }
        this._renderLayout();
        this._renderValidationSummary()
    },
    _renderScrollable: function() {
        var useNativeScrolling = this.option("useNativeScrolling");
        this._scrollable = new Scrollable(this.element(), {
            useNative: !!useNativeScrolling,
            useSimulatedScrollbar: !useNativeScrolling,
            useKeyboard: false,
            direction: "both",
            bounceEnabled: false
        })
    },
    _getContent: function() {
        return this.option("scrollingEnabled") ? this._scrollable.content() : this.element()
    },
    _renderValidationSummary: function() {
        var $validationSummary = this.element().find("." + FORM_VALIDATION_SUMMARY);
        if ($validationSummary.length > 0) {
            $validationSummary.remove()
        }
        if (this.option("showValidationSummary")) {
            $("<div/>").addClass(FORM_VALIDATION_SUMMARY).dxValidationSummary({
                validationGroup: this._getValidationGroup()
            }).appendTo(this._getContent())
        }
    },
    _prepareItems: function(items, isTabbed) {
        if (items) {
            var i, item, clonedItem, that = this,
                extendedItems = [];
            for (i = 0; i < items.length; i++) {
                item = items[i];
                clonedItem = utils.isObject(item) ? extend({}, item) : item;
                that._prepareGroupItem(clonedItem);
                that._prepareTabbedItem(clonedItem);
                that._prepareItemTemplate(clonedItem);
                if (utils.isObject(clonedItem)) {
                    if (isTabbed) {
                        clonedItem.cssItemClass = FIELD_ITEM_TAB_CLASS
                    }
                    clonedItem.items = this._prepareItems(clonedItem.items, isTabbed)
                }
                extendedItems.push(clonedItem)
            }
            return extendedItems
        }
    },
    _prepareGroupItem: function(item) {
        if ("group" === item.itemType) {
            item.alignItemLabels = utils.ensureDefined(item.alignItemLabels, true);
            if (item.template) {
                item.groupContentTemplate = this._getTemplate(item.template)
            }
            item.template = this._itemGroupTemplate.bind(this, item)
        }
    },
    _prepareTabbedItem: function(item) {
        if ("tabbed" === item.itemType) {
            item.template = this._itemTabbedTemplate.bind(this, item);
            item.tabs = this._prepareItems(item.tabs, true)
        }
    },
    _prepareItemTemplate: function(item) {
        if (item.template) {
            item.template = this._getTemplate(item.template)
        }
    },
    _checkGrouping: function(items) {
        if (items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if ("group" === item.itemType) {
                    return true
                }
            }
        }
    },
    _renderLayout: function() {
        var that = this,
            items = that.option("items"),
            $content = that._getContent();
        items = that._prepareItems(items);
        that._rootLayoutManager = that._renderLayoutManager(items, $content, {
            colCount: that.option("colCount"),
            alignItemLabels: that.option("alignItemLabels"),
            screenByWidth: this.option("screenByWidth"),
            colCountByScreen: this.option("colCountByScreen"),
            onLayoutChanged: function(inOneColumn) {
                that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn)
            },
            onContentReady: function(e) {
                that._alignLabels(e.component, e.component.isSingleColumnMode())
            }
        })
    },
    _itemTabbedTemplate: function(item, e, $container) {
        var that = this,
            $tabPanel = $("<div/>").appendTo($container),
            tabPanelOptions = extend({}, item.tabPanelOptions, {
                dataSource: item.tabs,
                onItemRendered: function(args) {
                    domUtils.triggerShownEvent(args.itemElement)
                },
                itemTemplate: function(itemData, e, $container) {
                    var layoutManager, alignItemLabels = utils.ensureDefined(itemData.alignItemLabels, true);
                    layoutManager = that._renderLayoutManager(itemData.items, $container, {
                        colCount: itemData.colCount,
                        alignItemLabels: alignItemLabels,
                        screenByWidth: this.option("screenByWidth"),
                        colCountByScreen: itemData.colCountByScreen,
                        cssItemClass: itemData.cssItemClass,
                        onLayoutChanged: function(inOneColumn) {
                            that._alignLabelsInColumn.bind(that)({
                                $container: $container,
                                layoutManager: layoutManager,
                                items: itemData.items,
                                inOneColumn: inOneColumn
                            })
                        }
                    });
                    if (alignItemLabels) {
                        that._alignLabelsInColumn.bind(that)({
                            $container: $container,
                            layoutManager: layoutManager,
                            items: itemData.items,
                            inOneColumn: layoutManager.isSingleColumnMode()
                        })
                    }
                }
            });
        that._createComponent($tabPanel, TabPanel, tabPanelOptions)
    },
    _itemGroupTemplate: function(item, e, $container) {
        var $groupContent, colCount, layoutManager, $group = $("<div/>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, utils.isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
        if (item.caption) {
            $("<span/>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).appendTo($group)
        }
        $groupContent = $("<div/>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
        if (item.groupContentTemplate) {
            var data = {
                formData: this.option("formData"),
                component: this
            };
            item.groupContentTemplate.render({
                model: data,
                container: $groupContent
            })
        } else {
            layoutManager = this._renderLayoutManager(item.items, $groupContent, {
                colCount: item.colCount,
                colCountByScreen: item.colCountByScreen,
                alignItemLabels: item.alignItemLabels,
                cssItemClass: item.cssItemClass
            });
            colCount = layoutManager._getColCount();
            if (inArray(colCount, this._groupsColCount) === -1) {
                this._groupsColCount.push(colCount)
            }
            $group.addClass(GROUP_COL_COUNT_CLASS + colCount)
        }
    },
    _renderLayoutManager: function(items, $rootElement, options) {
        var instance, $element = $("<div />"),
            that = this,
            config = that._getLayoutManagerConfig(items, options),
            baseColCountByScreen = {
                lg: options.colCount,
                md: options.colCount,
                sm: options.colCount,
                xs: 1
            };
        that._cachedColCountOptions.push({
            colCountByScreen: extend(baseColCountByScreen, options.colCountByScreen)
        });
        $element.appendTo($rootElement);
        instance = that._createComponent($element, "dxLayoutManager", config);
        instance.on("autoColCountChanged", function() {
            that._refresh()
        });
        that._cachedLayoutManagers.push(instance);
        return instance
    },
    _getValidationGroup: function() {
        return this.option("validationGroup") || this
    },
    _getLayoutManagerConfig: function(items, options) {
        var that = this,
            baseConfig = {
                form: that,
                validationGroup: that._getValidationGroup(),
                showRequiredMark: that.option("showRequiredMark"),
                showOptionalMark: that.option("showOptionalMark"),
                requiredMark: that.option("requiredMark"),
                optionalMark: that.option("optionalMark"),
                requiredMessage: that.option("requiredMessage"),
                screenByWidth: that.option("screenByWidth"),
                layoutData: that.option("formData"),
                labelLocation: that.option("labelLocation"),
                customizeItem: that.option("customizeItem"),
                minColWidth: that.option("minColWidth"),
                showColonAfterLabel: that.option("showColonAfterLabel"),
                onEditorEnterKey: that.option("onEditorEnterKey"),
                onFieldDataChanged: function(args) {
                    if (!that._isDataUpdating) {
                        that._triggerOnFieldDataChanged(args)
                    }
                },
                validationBoundary: that.option("scrollingEnabled") ? that.element() : void 0
            };
        return extend(baseConfig, {
            items: items,
            onContentReady: function(args) {
                that._updateEditorInstancesFromLayoutManager(args.component._editorInstancesByField);
                options.onContentReady && options.onContentReady(args)
            },
            colCount: options.colCount,
            alignItemLabels: options.alignItemLabels,
            cssItemClass: options.cssItemClass,
            colCountByScreen: options.colCountByScreen,
            onLayoutChanged: options.onLayoutChanged,
            width: options.width
        })
    },
    _updateEditorInstancesFromLayoutManager: function(instancesByDataFields) {
        extend(this._editorInstancesByField, instancesByDataFields)
    },
    _createComponent: function($element, type, config) {
        var that = this;
        config = config || {};
        that._extendConfig(config, {
            readOnly: that.option("readOnly")
        });
        return that.callBase($element, type, config)
    },
    _attachSyncSubscriptions: function() {
        var that = this;
        that.off("optionChanged").on("optionChanged", function(args) {
            var optionFullName = args.fullName;
            if ("formData" === optionFullName) {
                if (!utils.isDefined(args.value)) {
                    that._options.formData = args.value = {}
                }
                that._triggerOnFieldDataChangedByDataSet(args.value)
            }
            if (that._cachedLayoutManagers.length) {
                $.each(that._cachedLayoutManagers, function(index, layoutManager) {
                    if ("formData" === optionFullName) {
                        that._isDataUpdating = true;
                        layoutManager.option("layoutData", args.value);
                        that._isDataUpdating = false
                    }
                    if ("readOnly" === args.name || "disabled" === args.name) {
                        layoutManager.option(optionFullName, args.value)
                    }
                })
            }
        })
    },
    _optionChanged: function(args) {
        var rootNameOfComplexOption = this._getRootLevelOfExpectedComplexOption(args.fullName, ["formData", "items"]);
        if (rootNameOfComplexOption) {
            this._customHandlerOfComplexOption(args, rootNameOfComplexOption);
            return
        }
        switch (args.name) {
            case "formData":
                if (!this.option("items")) {
                    this._invalidate()
                } else {
                    if (isEmptyObject(args.value)) {
                        this._resetValues()
                    }
                }
                break;
            case "items":
            case "colCount":
            case "onFieldDataChanged":
            case "onEditorEnterKey":
            case "labelLocation":
            case "alignItemLabels":
            case "showColonAfterLabel":
            case "customizeItem":
            case "alignItemLabelsInAllGroups":
            case "showRequiredMark":
            case "showOptionalMark":
            case "requiredMark":
            case "optionalMark":
            case "requiredMessage":
            case "scrollingEnabled":
            case "formID":
            case "colCountByScreen":
            case "screenByWidth":
                this._invalidate();
                break;
            case "showValidationSummary":
                this._renderValidationSummary();
                break;
            case "minColWidth":
                if ("auto" === this.option("colCount")) {
                    this._invalidate()
                }
                break;
            case "readOnly":
                break;
            case "width":
                this.callBase(args);
                this._rootLayoutManager.option(args.name, args.value);
                this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
                break;
            case "visible":
                this.callBase(args);
                if (args.value) {
                    domUtils.triggerShownEvent(this.element())
                }
                break;
            default:
                this.callBase(args)
        }
    },
    _getRootLevelOfExpectedComplexOption: function(fullOptionName, expectedRootNames) {
        var result, splitFullName = fullOptionName.split(".");
        if (splitFullName.length > 1) {
            var i, rootOptionName = splitFullName[0];
            for (i = 0; i < expectedRootNames.length; i++) {
                if (rootOptionName.search(expectedRootNames[i]) !== -1) {
                    result = expectedRootNames[i]
                }
            }
        }
        return result
    },
    _customHandlerOfComplexOption: function(args, rootOptionName) {
        var nameParts = args.fullName.split(".");
        switch (rootOptionName) {
            case "items":
                var instance, items, name, itemPath = this._getItemPath(nameParts),
                    item = this.option(itemPath);
                if (args.fullName.search("editorOptions") !== -1) {
                    instance = this.getEditor(item.dataField);
                    instance && instance.option(item.editorOptions)
                } else {
                    if (item) {
                        name = args.fullName.replace(itemPath + ".", "");
                        this._changeItemOption(item, name, args.value);
                        items = this._generateItemsFromData(this.option("items"));
                        this.option("items", items)
                    }
                }
                break;
            case "formData":
                var dataField = nameParts.slice(1).join("."),
                    editor = this.getEditor(dataField);
                if (editor) {
                    editor.option("value", args.value)
                } else {
                    this._triggerOnFieldDataChanged({
                        dataField: dataField,
                        value: args.value
                    })
                }
        }
    },
    _getItemPath: function(nameParts) {
        var i, itemPath = nameParts[0];
        for (i = 1; i < nameParts.length; i++) {
            if (nameParts[i].search("items|tabs") !== -1) {
                itemPath += "." + nameParts[i]
            } else {
                break
            }
        }
        return itemPath
    },
    _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args)
    },
    _triggerOnFieldDataChangedByDataSet: function(data) {
        var that = this;
        if (data && utils.isObject(data)) {
            $.each(data, function(dataField, value) {
                that._triggerOnFieldDataChanged({
                    dataField: dataField,
                    value: value
                })
            })
        }
    },
    _updateFieldValue: function(dataField, value) {
        if (utils.isDefined(this.option("formData"))) {
            var editor = this.getEditor(dataField);
            this.option("formData." + dataField, value);
            if (editor) {
                var editorValue = editor.option("value");
                if (editorValue !== value) {
                    editor.option("value", value)
                }
            }
        }
    },
    _generateItemsFromData: function(items) {
        var formData = this.option("formData"),
            result = [];
        if (!items && utils.isDefined(formData)) {
            $.each(formData, function(dataField) {
                result.push({
                    dataField: dataField
                })
            })
        }
        if (items) {
            $.each(items, function(index, item) {
                if (utils.isObject(item)) {
                    result.push(item)
                } else {
                    result.push({
                        dataField: item
                    })
                }
            })
        }
        return result
    },
    _getItemByField: function(field, items) {
        var resultItem, that = this,
            fieldParts = utils.isObject(field) ? field : that._getFieldParts(field),
            fieldName = fieldParts.fieldName,
            fieldPath = fieldParts.fieldPath;
        if (items.length) {
            $.each(items, function(index, item) {
                var itemType = item.itemType;
                if (fieldPath.length) {
                    var path = fieldPath.slice();
                    item = that._getItemByFieldPath(path, fieldName, item)
                } else {
                    if ("group" === itemType && !item.caption || "tabbed" === itemType) {
                        var subItemsField = that._getSubItemField(itemType);
                        item.items = that._generateItemsFromData(item.items);
                        item = that._getItemByField({
                            fieldName: fieldName,
                            fieldPath: fieldPath
                        }, item[subItemsField])
                    }
                }
                if (that._isExpectedItem(item, fieldName)) {
                    resultItem = item;
                    return false
                }
            })
        }
        return resultItem
    },
    _getFieldParts: function(field) {
        var fieldSeparator = ".",
            fieldName = field,
            separatorIndex = fieldName.indexOf(fieldSeparator),
            resultPath = [];
        while (separatorIndex !== -1) {
            resultPath.push(fieldName.substr(0, separatorIndex));
            fieldName = fieldName.substr(separatorIndex + 1);
            separatorIndex = fieldName.indexOf(fieldSeparator)
        }
        return {
            fieldName: fieldName,
            fieldPath: resultPath.reverse()
        }
    },
    _getItemByFieldPath: function(path, fieldName, item) {
        var result, that = this,
            itemType = item.itemType,
            subItemsField = that._getSubItemField(itemType),
            isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
        do {
            if (isItemWithSubItems) {
                var pathNode, isGroupWithCaption = utils.isDefined(item.caption || item.title),
                    captionWithoutSpaces = that._getTextWithoutSpaces(item.caption || item.title);
                item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
                if (isGroupWithCaption) {
                    pathNode = path.pop()
                }
                if (!path.length) {
                    result = that._getItemByField(fieldName, item[subItemsField]);
                    if (result) {
                        break
                    }
                }
                if (!isGroupWithCaption || isGroupWithCaption && captionWithoutSpaces === pathNode) {
                    if (path.length) {
                        result = that._searchItemInEverySubItem(path, fieldName, item[subItemsField])
                    }
                }
            } else {
                break
            }
        } while (path.length && false !== result);
        return result
    },
    _getSubItemField: function(itemType) {
        return "tabbed" === itemType ? "tabs" : "items"
    },
    _searchItemInEverySubItem: function(path, fieldName, items) {
        var result, that = this;
        $.each(items, function(index, groupItem) {
            result = that._getItemByFieldPath(path, fieldName, groupItem);
            if (result) {
                return false
            }
        });
        if (!result) {
            result = false
        }
        return result
    },
    _getTextWithoutSpaces: function(text) {
        return text ? text.replace(" ", "") : void 0
    },
    _isExpectedItem: function(item, fieldName) {
        return item && (item.dataField === fieldName || item.name === fieldName || this._getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && this._getTextWithoutSpaces(item.caption) === fieldName)
    },
    _changeItemOption: function(item, option, value) {
        if (utils.isObject(item)) {
            item[option] = value
        }
    },
    _dimensionChanged: function() {
        var currentScreenFactor = windowUtils.getCurrentScreenFactor(this.option("screenByWidth"));
        if (this._cachedScreenFactor !== currentScreenFactor) {
            if (this._isColCountChanged(this._cachedScreenFactor, currentScreenFactor)) {
                this._refresh()
            }
            this._cachedScreenFactor = currentScreenFactor;
            return
        }
    },
    _isColCountChanged: function(oldScreenSize, newScreenSize) {
        var isChanged = false;
        $.each(this._cachedColCountOptions, function(index, item) {
            if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
                isChanged = true;
                return false
            }
        });
        return isChanged
    },
    _refresh: function() {
        var editorSelector = "." + FOCUSED_STATE_CLASS + " input, ." + FOCUSED_STATE_CLASS + " textarea";
        this.element().find(editorSelector).trigger("change");
        this.callBase()
    },
    _resetValues: function() {
        var validationGroup = ValidationEngine.getGroupConfig(this);
        validationGroup && validationGroup.reset();
        $.each(this._editorInstancesByField, function(dataField, editor) {
            editor.reset();
            editor.option("isValid", true)
        })
    },
    _updateData: function(data, value, isComplexData) {
        var that = this,
            _data = isComplexData ? value : data;
        if (utils.isObject(_data)) {
            $.each(_data, function(dataField, fieldValue) {
                that._updateData(isComplexData ? data + "." + dataField : dataField, fieldValue, utils.isObject(fieldValue))
            })
        } else {
            if (utils.isString(data)) {
                that._updateFieldValue(data, value)
            }
        }
    },
    registerKeyHandler: function(key, handler) {
        this.callBase(key, handler);
        $.each(this._editorInstancesByField, function(dataField, editor) {
            editor.registerKeyHandler(key, handler)
        })
    },
    _focusTarget: function() {
        return this.element().find("." + FIELD_ITEM_CONTENT_CLASS + " [tabindex]").first()
    },
    _visibilityChanged: function(visible) {
        if (visible && browser.msie) {
            this._refresh()
        }
    },
    resetValues: function() {
        this._resetValues()
    },
    updateData: function(data, value) {
        this._updateData(data, value)
    },
    getEditor: function(field) {
        return this._editorInstancesByField[field]
    },
    updateDimensions: function() {
        var that = this,
            deferred = $.Deferred();
        if (that._scrollable) {
            that._scrollable.update().done(function() {
                deferred.resolveWith(that)
            })
        } else {
            deferred.resolveWith(that)
        }
        return deferred.promise()
    },
    itemOption: function(field, option, value) {
        var that = this,
            argsCount = arguments.length,
            items = that._generateItemsFromData(that.option("items")),
            item = that._getItemByField(field, items);
        switch (argsCount) {
            case 1:
                return item;
            case 3:
                that._changeItemOption(item, option, value);
                break;
            default:
                if (utils.isObject(option)) {
                    $.each(option, function(optionName, optionValue) {
                        that._changeItemOption(item, optionName, optionValue)
                    })
                }
        }
        this.option("items", items)
    },
    validate: function() {
        try {
            return ValidationEngine.validateGroup(this._getValidationGroup())
        } catch (e) {
            errors.log("E1036", e.message)
        }
    },
    getItemID: function(name) {
        return "dx_" + this.option("formID") + "_" + (name || new Guid)
    }
});
registerComponent("dxForm", Form);
module.exports = Form;


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/form/ui.form.layout_manager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Guid = __webpack_require__(34),
    registerComponent = __webpack_require__(4),
    utils = __webpack_require__(2),
    isEmptyObject = __webpack_require__(9).isEmptyObject,
    isWrapped = __webpack_require__(41).isWrapped,
    isWritableWrapped = __webpack_require__(41).isWritableWrapped,
    unwrap = __webpack_require__(41).unwrap,
    windowUtils = __webpack_require__(61),
    stringUtils = __webpack_require__(30),
    extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    dataUtils = __webpack_require__(14),
    removeEvent = __webpack_require__(86),
    clickEvent = __webpack_require__(11),
    normalizeIndexes = __webpack_require__(7).normalizeIndexes,
    errors = __webpack_require__(16),
    messageLocalization = __webpack_require__(8),
    support = __webpack_require__(24),
    inflector = __webpack_require__(36),
    Widget = __webpack_require__(27),
    Validator = __webpack_require__(129),
    ResponsiveBox = __webpack_require__(203);
__webpack_require__(69);
__webpack_require__(81);
__webpack_require__(99);
__webpack_require__(153);
var FORM_EDITOR_BY_DEFAULT = "dxTextBox",
    FIELD_ITEM_CLASS = "dx-field-item",
    FIELD_EMPTY_ITEM_CLASS = "dx-field-empty-item",
    FIELD_ITEM_REQUIRED_CLASS = "dx-field-item-required",
    FIELD_ITEM_OPTIONAL_CLASS = "dx-field-item-optional",
    FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark",
    FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark",
    FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
    FIELD_ITEM_LABEL_ALIGN_CLASS = "dx-field-item-label-align",
    FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
    FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
    FIELD_ITEM_LABEL_LOCATION_CLASS = "dx-field-item-label-location-",
    FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
    FIELD_ITEM_CONTENT_LOCATION_CLASS = "dx-field-item-content-location-",
    FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper",
    FIELD_ITEM_HELP_TEXT_CLASS = "dx-field-item-help-text",
    SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content",
    LABEL_HORIZONTAL_ALIGNMENT_CLASS = "dx-label-h-align",
    LABEL_VERTICAL_ALIGNMENT_CLASS = "dx-label-v-align",
    FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager",
    LAYOUT_MANAGER_FIRST_ROW_CLASS = "dx-first-row",
    LAYOUT_MANAGER_FIRST_COL_CLASS = "dx-first-col",
    LAYOUT_MANAGER_LAST_COL_CLASS = "dx-last-col",
    LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col",
    FLEX_LAYOUT_CLASS = "dx-flex-layout",
    LAYOUT_STRATEGY_FLEX = "flex",
    LAYOUT_STRATEGY_FALLBACK = "fallback",
    SIMPLE_ITEM_TYPE = "simple",
    DATA_OPTIONS = ["dataSource", "items"];
var LayoutManager = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            layoutData: {},
            readOnly: false,
            colCount: 1,
            colCountByScreen: void 0,
            labelLocation: "left",
            onFieldDataChanged: null,
            onEditorEnterKey: null,
            customizeItem: null,
            alignItemLabels: true,
            minColWidth: 200,
            showRequiredMark: true,
            screenByWidth: null,
            showOptionalMark: false,
            requiredMark: "*",
            optionalMark: messageLocalization.format("dxForm-optionalMark"),
            requiredMessage: messageLocalization.getFormatter("dxForm-requiredMessage")
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            layoutData: true,
            validationGroup: true
        })
    },
    _init: function() {
        this.callBase();
        this._itemWatchers = [];
        this._initDataAndItems(this.option("layoutData"))
    },
    _initDataAndItems: function(initialData) {
        this._syncDataWithItems();
        this._updateItems(initialData)
    },
    _syncDataWithItems: function() {
        var that = this,
            userItems = that.option("items");
        if (utils.isDefined(userItems)) {
            $.each(userItems, function(index, item) {
                var value;
                if (item.dataField && void 0 === that._getDataByField(item.dataField)) {
                    if (item.editorOptions) {
                        value = item.editorOptions.value
                    }
                    that._updateFieldValue(item.dataField, value)
                }
            })
        }
    },
    _getDataByField: function(dataField) {
        return dataField ? this.option("layoutData." + dataField) : null
    },
    _updateFieldValue: function(dataField, value) {
        var layoutData = this.option("layoutData"),
            newValue = value;
        if (!isWrapped(layoutData[dataField]) && utils.isDefined(dataField)) {
            this.option("layoutData." + dataField, newValue)
        } else {
            if (isWritableWrapped(layoutData[dataField])) {
                newValue = utils.isFunction(newValue) ? newValue() : newValue;
                layoutData[dataField](newValue)
            }
        }
        this._triggerOnFieldDataChanged({
            dataField: dataField,
            value: newValue
        })
    },
    _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args)
    },
    _updateItems: function(layoutData) {
        var items, processedItems, that = this,
            userItems = this.option("items"),
            isUserItemsExist = utils.isDefined(userItems),
            customizeItem = that.option("customizeItem");
        items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
        if (utils.isDefined(items)) {
            processedItems = [];
            $.each(items, function(index, item) {
                if (that._isAcceptableItem(item)) {
                    item = that._processItem(item);
                    customizeItem && customizeItem(item);
                    if (utils.isObject(item) && false !== unwrap(item.visible)) {
                        processedItems.push(item)
                    }
                }
            });
            if (!that._itemWatchers.length || !isUserItemsExist) {
                that._updateItemWatchers(items)
            }
            this._items = processedItems;
            this._sortItems()
        }
    },
    _cleanItemWatchers: function() {
        this._itemWatchers.forEach(function(dispose) {
            dispose()
        });
        this._itemWatchers = []
    },
    _updateItemWatchers: function(items) {
        var that = this,
            watch = that._getWatch();
        items.forEach(function(item) {
            if (utils.isObject(item) && utils.isDefined(item.visible) && $.isFunction(watch)) {
                that._itemWatchers.push(watch(function() {
                    return unwrap(item.visible)
                }, function() {
                    that._updateItems(that.option("layoutData"));
                    that.repaint()
                }, {
                    skipImmediate: true
                }))
            }
        })
    },
    _generateItemsByData: function(layoutData) {
        var result = [];
        if (utils.isDefined(layoutData)) {
            $.each(layoutData, function(dataField) {
                result.push({
                    dataField: dataField
                })
            })
        }
        return result
    },
    _isAcceptableItem: function(item) {
        var itemField = item.dataField || item,
            itemData = this._getDataByField(itemField);
        return !(utils.isFunction(itemData) && !isWrapped(itemData))
    },
    _processItem: function(item) {
        if ("string" === typeof item) {
            item = {
                dataField: item
            }
        }
        if ("object" === typeof item && !item.itemType) {
            item.itemType = SIMPLE_ITEM_TYPE
        }
        if (!utils.isDefined(item.editorType) && utils.isDefined(item.dataField)) {
            var value = this._getDataByField(item.dataField);
            item.editorType = utils.isDefined(value) ? this._getEditorTypeByDataType(utils.type(value)) : FORM_EDITOR_BY_DEFAULT
        }
        return item
    },
    _getEditorTypeByDataType: function(dataType) {
        switch (dataType) {
            case "number":
                return "dxNumberBox";
            case "date":
                return "dxDateBox";
            case "boolean":
                return "dxCheckBox";
            default:
                return "dxTextBox"
        }
    },
    _sortItems: function() {
        normalizeIndexes(this._items, "visibleIndex");
        this._sortIndexes()
    },
    _sortIndexes: function() {
        this._items.sort(function(itemA, itemB) {
            var result, indexA = itemA.visibleIndex,
                indexB = itemB.visibleIndex;
            if (indexA > indexB) {
                result = 1
            } else {
                if (indexA < indexB) {
                    result = -1
                } else {
                    result = 0
                }
            }
            return result
        })
    },
    _render: function() {
        this._clearEditorInstances();
        this.element().addClass(FORM_LAYOUT_MANAGER_CLASS);
        this.callBase()
    },
    _clearEditorInstances: function() {
        this._editorInstancesByField = {}
    },
    _hasBrowserFlex: function() {
        return support.styleProp(LAYOUT_STRATEGY_FLEX) === LAYOUT_STRATEGY_FLEX
    },
    _renderContentImpl: function() {
        this.callBase();
        this._renderResponsiveBox()
    },
    _renderResponsiveBox: function() {
        var that = this;
        if (that._items && that._items.length) {
            var layoutItems, colCount = that._getColCount(),
                $container = $("<div />").appendTo(that.element());
            that._prepareItemsWithMerging(colCount);
            layoutItems = that._generateLayoutItems();
            that._extendItemsWithDefaultTemplateOptions(layoutItems, that._items);
            that._responsiveBox = that._createComponent($container, ResponsiveBox, that._getResponsiveBoxConfig(layoutItems, colCount))
        }
    },
    _extendItemsWithDefaultTemplateOptions: function(targetItems, sourceItems) {
        sourceItems.forEach(function(item) {
            if (!item.merged) {
                if (utils.isDefined(item.disabled)) {
                    targetItems[item.visibleIndex].disabled = item.disabled
                }
                if (utils.isDefined(item.visible)) {
                    targetItems[item.visibleIndex].visible = item.visible
                }
            }
        })
    },
    _itemStateChangedHandler: function(e) {
        this._refresh()
    },
    _getResponsiveBoxConfig: function(layoutItems, colCount) {
        var that = this,
            colCountByScreen = that.option("colCountByScreen"),
            xsColCount = colCountByScreen && colCountByScreen.xs;
        return {
            onItemStateChanged: this._itemStateChangedHandler.bind(this),
            _layoutStrategy: that._hasBrowserFlex() ? LAYOUT_STRATEGY_FLEX : LAYOUT_STRATEGY_FALLBACK,
            onLayoutChanged: function() {
                var onLayoutChanged = that.option("onLayoutChanged"),
                    isSingleColumnMode = that.isSingleColumnMode();
                if (onLayoutChanged) {
                    that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
                    onLayoutChanged(isSingleColumnMode)
                }
            },
            onContentReady: function(e) {
                if (that.option("onLayoutChanged")) {
                    that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component))
                }
                that._fireContentReadyAction()
            },
            itemTemplate: function(e, itemData, $itemElement) {
                if (!e.location) {
                    return
                }
                var itemRenderedCountInPreviousRows = e.location.row * colCount,
                    item = that._items[e.location.col + itemRenderedCountInPreviousRows],
                    $fieldItem = $("<div/>").addClass(item.cssClass).appendTo($itemElement);
                $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
                if (0 === e.location.row) {
                    $fieldItem.addClass(LAYOUT_MANAGER_FIRST_ROW_CLASS)
                }
                if (0 === e.location.col) {
                    $fieldItem.addClass(LAYOUT_MANAGER_FIRST_COL_CLASS)
                }
                if (e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount) {
                    $fieldItem.addClass(LAYOUT_MANAGER_LAST_COL_CLASS)
                }
                "empty" === item.itemType ? that._renderEmptyItem($fieldItem) : that._renderFieldItem(item, $fieldItem)
            },
            cols: that._generateRatio(colCount),
            rows: that._generateRatio(that._getRowsCount(), true),
            dataSource: layoutItems,
            screenByWidth: that.option("screenByWidth"),
            singleColumnScreen: xsColCount ? false : "xs"
        }
    },
    _getColCount: function() {
        var colCount = this.option("colCount"),
            colCountByScreen = this.option("colCountByScreen");
        if (colCountByScreen) {
            var currentColCount = colCountByScreen[windowUtils.getCurrentScreenFactor(this.option("screenByWidth"))];
            colCount = currentColCount || colCount
        }
        if ("auto" === colCount) {
            if (!!this._cashedColCount) {
                return this._cashedColCount
            }
            this._cashedColCount = colCount = this._getMaxColCount()
        }
        return colCount < 1 ? 1 : colCount
    },
    _getMaxColCount: function() {
        var minColWidth = this.option("minColWidth"),
            width = this.element().width(),
            itemsCount = this._items.length,
            maxColCount = Math.floor(width / minColWidth) || 1;
        return itemsCount < maxColCount ? itemsCount : maxColCount
    },
    isCachedColCountObsolete: function() {
        return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount
    },
    _prepareItemsWithMerging: function(colCount) {
        var item, itemsMergedByCol, j, i, items = this._items.slice(0),
            result = [];
        for (i = 0; i < items.length; i++) {
            item = items[i];
            result.push(item);
            if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
                item.col = this._getColByIndex(result.length - 1, colCount)
            }
            if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
                itemsMergedByCol = [];
                for (j = 0; j < item.colSpan - 1; j++) {
                    itemsMergedByCol.push({
                        merged: true
                    })
                }
                result = result.concat(itemsMergedByCol)
            } else {
                delete item.colSpan
            }
        }
        this._items = result
    },
    _getColByIndex: function(index, colCount) {
        return index % colCount
    },
    _generateLayoutItems: function() {
        var item, i, items = this._items,
            colCount = this._getColCount(),
            result = [];
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (!item.merged) {
                var generatedItem = {
                    location: {
                        row: parseInt(i / colCount),
                        col: this._getColByIndex(i, colCount)
                    }
                };
                if (utils.isDefined(item.colSpan)) {
                    generatedItem.location.colspan = item.colSpan
                }
                if (utils.isDefined(item.rowSpan)) {
                    generatedItem.location.rowspan = item.rowSpan
                }
                result.push(generatedItem)
            }
        }
        return result
    },
    _renderEmptyItem: function($container) {
        return $container.addClass(FIELD_EMPTY_ITEM_CLASS).html("&nbsp;")
    },
    _renderFieldItem: function(item, $container) {
        var $label, that = this,
            name = that._getName(item),
            id = that.getItemID(name),
            isRequired = utils.isDefined(item.isRequired) ? item.isRequired : !!that._hasRequiredRuleInSet(item.validationRules),
            labelOptions = that._getLabelOptions(item, id, isRequired),
            $editor = $("<div/>"),
            helpID = item.helpText ? "dx-" + new Guid : null;
        $container.addClass(FIELD_ITEM_CLASS).addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS).addClass(that.option("cssItemClass")).addClass(utils.isDefined(item.col) ? "dx-col-" + item.col : "");
        if (labelOptions.visible && labelOptions.text) {
            $label = that._renderLabel(labelOptions).appendTo($container)
        }
        if (item.itemType === SIMPLE_ITEM_TYPE) {
            if (that._isLabelNeedBaselineAlign(item) && "top" !== labelOptions.location) {
                $container.addClass(FIELD_ITEM_LABEL_ALIGN_CLASS)
            }
            that._hasBrowserFlex() && $container.addClass(FLEX_LAYOUT_CLASS)
        }
        $editor.data("dx-form-item", item);
        that._appendEditorToField({
            $fieldItem: $container,
            $label: $label,
            $editor: $editor,
            labelOptions: labelOptions
        });
        that._renderEditor({
            $container: $editor,
            dataField: name,
            editorType: item.editorType,
            editorOptions: item.editorOptions,
            template: that._getTemplateByFieldItem(item),
            isRequired: isRequired,
            helpID: helpID,
            id: id,
            validationBoundary: that.option("validationBoundary")
        });
        var $validationTarget = $editor.children().first();
        if ($validationTarget && $validationTarget.data("dx-validation-target")) {
            that._renderValidator($validationTarget, item)
        }
        that._renderHelpText(item, $editor, helpID);
        that._attachClickHandler($label, $editor, item.editorType)
    },
    _hasRequiredRuleInSet: function(rules) {
        var hasRequiredRule;
        if (rules && rules.length) {
            $.each(rules, function(index, rule) {
                if ("required" === rule.type) {
                    hasRequiredRule = true;
                    return false
                }
            })
        }
        return hasRequiredRule
    },
    _getName: function(item) {
        return item.dataField || item.name
    },
    _isLabelNeedBaselineAlign: function(item) {
        var largeEditors = ["dxTextArea", "dxRadioGroup", "dxCalendar"];
        return !!item.helpText && !this._hasBrowserFlex() || inArray(item.editorType, largeEditors) !== -1
    },
    _getLabelOptions: function(item, id, isRequired) {
        var labelOptions = extend({
            showColon: this.option("showColonAfterLabel"),
            location: this.option("labelLocation"),
            id: id,
            visible: true,
            isRequired: isRequired
        }, item ? item.label : {});
        if (!labelOptions.text && item.dataField) {
            labelOptions.text = inflector.captionize(item.dataField)
        }
        if (labelOptions.text) {
            labelOptions.text += labelOptions.showColon ? ":" : ""
        }
        return labelOptions
    },
    _renderLabel: function(options) {
        if (utils.isDefined(options.text) && options.text.length > 0) {
            var labelClasses = FIELD_ITEM_LABEL_CLASS + " " + FIELD_ITEM_LABEL_LOCATION_CLASS + options.location,
                $label = $("<label />").addClass(labelClasses).attr("for", options.id),
                $labelContent = $("<span/>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS).appendTo($label);
            $("<span />").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(options.text).appendTo($labelContent);
            if (options.alignment) {
                $label.css("text-align", options.alignment)
            }
            $labelContent.append(this._renderLabelMark(options.isRequired));
            return $label
        }
    },
    _renderLabelMark: function(isRequired) {
        var $mark, requiredMarksConfig = this._getRequiredMarksConfig(),
            isRequiredMark = requiredMarksConfig.showRequiredMark && isRequired,
            isOptionalMark = requiredMarksConfig.showOptionalMark && !isRequired;
        if (isRequiredMark || isOptionalMark) {
            var markClass = isRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS,
                markText = isRequiredMark ? requiredMarksConfig.requiredMark : requiredMarksConfig.optionalMark;
            $mark = $("<span />").addClass(markClass).html("&nbsp" + markText)
        }
        return $mark
    },
    _getRequiredMarksConfig: function() {
        if (!this._cashedRequiredConfig) {
            this._cashedRequiredConfig = {
                showRequiredMark: this.option("showRequiredMark"),
                showOptionalMark: this.option("showOptionalMark"),
                requiredMark: this.option("requiredMark"),
                optionalMark: this.option("optionalMark")
            }
        }
        return this._cashedRequiredConfig
    },
    _renderEditor: function(options) {
        var editorOptions, dataValue = this._getDataByField(options.dataField),
            defaultEditorOptions = {
                value: dataValue
            },
            isDeepExtend = true;
        if ("dxTagBox" === options.editorType) {
            defaultEditorOptions.value = defaultEditorOptions.value || []
        }
        editorOptions = extend(isDeepExtend, defaultEditorOptions, options.editorOptions, {
            inputAttr: {
                id: options.id
            },
            validationBoundary: options.validationBoundary
        });
        this._replaceDataOptions(options.editorOptions, editorOptions);
        this._createEditor(options.$container, {
            editorType: options.editorType,
            dataField: options.dataField,
            template: options.template,
            name: options.name,
            helpID: options.helpID,
            isRequired: options.isRequired
        }, editorOptions)
    },
    _replaceDataOptions: function(originalOptions, resultOptions) {
        if (originalOptions) {
            DATA_OPTIONS.forEach(function(item) {
                if (resultOptions[item]) {
                    resultOptions[item] = originalOptions[item]
                }
            })
        }
    },
    _renderValidator: function($editor, item) {
        var fieldName = this._getFieldLabelName(item),
            validationRules = this._prepareValidationRules(item.validationRules, item.isRequired, item.itemType, fieldName);
        if (Array.isArray(validationRules)) {
            this._createComponent($editor, Validator, {
                validationRules: validationRules,
                validationGroup: this.option("validationGroup")
            })
        }
    },
    _getFieldLabelName: function(item) {
        var isItemHaveCustomLabel = item.label && item.label.text,
            itemName = isItemHaveCustomLabel ? null : this._getName(item);
        return isItemHaveCustomLabel ? item.label.text : itemName && inflector.captionize(itemName)
    },
    _prepareValidationRules: function(userValidationRules, isItemRequired, itemType, itemName) {
        var validationRules, isSimpleItem = itemType === SIMPLE_ITEM_TYPE;
        if (isSimpleItem) {
            if (userValidationRules) {
                validationRules = userValidationRules
            } else {
                var requiredMessage = stringUtils.format(this.option("requiredMessage"), itemName || "");
                validationRules = isItemRequired ? [{
                    type: "required",
                    message: requiredMessage
                }] : null
            }
        }
        return validationRules
    },
    _createEditor: function($container, renderOptions, editorOptions) {
        var editorInstance, that = this,
            template = renderOptions.template;
        if (renderOptions.dataField && !editorOptions.name) {
            editorOptions.name = renderOptions.dataField
        }
        that._addItemContentClasses($container);
        if (template) {
            var data = {
                dataField: renderOptions.dataField,
                editorType: renderOptions.editorType,
                editorOptions: editorOptions,
                component: that.option("form") || that
            };
            template.render({
                model: data,
                container: $container
            })
        } else {
            var $editor = $("<div/>").appendTo($container);
            try {
                editorInstance = that._createComponent($editor, renderOptions.editorType, editorOptions);
                editorInstance.setAria("describedby", renderOptions.helpID);
                editorInstance.setAria("required", renderOptions.isRequired);
                if (renderOptions.dataField) {
                    var componentOwner = that.option("form") || that;
                    editorInstance.on("enterKey", function(args) {
                        componentOwner._createActionByOption("onEditorEnterKey")(extend(args, {
                            dataField: renderOptions.dataField
                        }))
                    });
                    that._registerEditorInstance(editorInstance, renderOptions.dataField);
                    that._createWatcher(editorInstance, $container, renderOptions);
                    that.linkEditorToDataField(editorInstance, renderOptions.dataField, renderOptions.editorType)
                }
            } catch (e) {
                errors.log("E1035", e.message)
            }
        }
    },
    _createWatcher: function(editorInstance, $container, renderOptions) {
        var that = this,
            watch = that._getWatch();
        if (!utils.isFunction(watch)) {
            return
        }
        var dispose = watch(function() {
            return that._getDataByField(renderOptions.dataField)
        }, function() {
            editorInstance.option("value", that._getDataByField(renderOptions.dataField))
        }, {
            deep: true,
            skipImmediate: true
        });
        $container.on(removeEvent, dispose)
    },
    _getWatch: function() {
        if (!utils.isDefined(this._watch)) {
            var formInstance = this.option("form");
            this._watch = formInstance && formInstance.option("integrationOptions.watchMethod")
        }
        return this._watch
    },
    _addItemContentClasses: function($itemContent) {
        var locationSpecificClass = this._getItemContentLocationSpecificClass();
        $itemContent.addClass([FIELD_ITEM_CONTENT_CLASS, locationSpecificClass].join(" "))
    },
    _getItemContentLocationSpecificClass: function() {
        var labelLocation = this.option("labelLocation"),
            oppositeClasses = {
                right: "left",
                left: "right",
                top: "bottom"
            };
        return FIELD_ITEM_CONTENT_LOCATION_CLASS + oppositeClasses[labelLocation]
    },
    _registerEditorInstance: function(instance, dataField) {
        this._editorInstancesByField[dataField] = instance
    },
    _createComponent: function($editor, type, editorOptions) {
        var instance, that = this,
            readOnlyState = this.option("readOnly");
        instance = that.callBase($editor, type, editorOptions);
        readOnlyState && instance.option("readOnly", readOnlyState);
        that.on("optionChanged", function(args) {
            if ("readOnly" === args.name) {
                instance.option(args.name, args.value)
            }
        });
        return instance
    },
    _getTemplateByFieldItem: function(fieldItem) {
        return fieldItem.template ? this._getTemplate(fieldItem.template) : null
    },
    _appendEditorToField: function(params) {
        if (params.$label) {
            var location = params.labelOptions.location;
            if ("top" === location || "left" === location) {
                params.$fieldItem.append(params.$editor)
            }
            if ("right" === location) {
                params.$fieldItem.prepend(params.$editor)
            }
            this._addInnerItemAlignmentClass(params.$fieldItem, location)
        } else {
            params.$fieldItem.append(params.$editor)
        }
    },
    _addInnerItemAlignmentClass: function($fieldItem, location) {
        if ("top" === location) {
            $fieldItem.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS)
        } else {
            $fieldItem.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS)
        }
    },
    _renderHelpText: function(fieldItem, $editor, helpID) {
        var helpText = fieldItem.helpText,
            isSimpleItem = fieldItem.itemType === SIMPLE_ITEM_TYPE;
        if (helpText && isSimpleItem) {
            var $editorWrapper = $("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS);
            $editor.wrap($editorWrapper);
            $("<div>").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr("id", helpID).text(helpText).appendTo($editor.parent())
        }
    },
    _attachClickHandler: function($label, $editor, editorType) {
        var isBooleanEditors = "dxCheckBox" === editorType || "dxSwitch" === editorType;
        if ($label && isBooleanEditors) {
            $label.on(clickEvent.name, function() {
                $editor.children().trigger(clickEvent.name)
            })
        }
    },
    _generateRatio: function(count, isAutoSize) {
        var ratio, i, result = [];
        for (i = 0; i < count; i++) {
            ratio = {
                ratio: 1
            };
            if (isAutoSize) {
                ratio.baseSize = "auto"
            }
            result.push(ratio)
        }
        return result
    },
    _getRowsCount: function() {
        return Math.ceil(this._items.length / this._getColCount())
    },
    _optionChanged: function(args) {
        if (0 === args.fullName.search("layoutData.")) {
            return
        }
        switch (args.name) {
            case "showRequiredMark":
            case "showOptionalMark":
            case "requiredMark":
            case "optionalMark":
                this._cashedRequiredConfig = null;
                this._invalidate();
                break;
            case "layoutData":
                if (this.option("items")) {
                    if (!isEmptyObject(args.value)) {
                        $.each(this._editorInstancesByField, function(name, editor) {
                            var valueGetter = dataUtils.compileGetter(name),
                                dataValue = valueGetter(args.value);
                            if (utils.isDefined(dataValue)) {
                                editor.option("value", dataValue)
                            } else {
                                editor.reset();
                                editor.option("isValid", true)
                            }
                        })
                    }
                } else {
                    this._initDataAndItems(args.value);
                    this._invalidate()
                }
                break;
            case "items":
                this._cleanItemWatchers();
                this._initDataAndItems(args.value);
                this._invalidate();
                break;
            case "alignItemLabels":
            case "labelLocation":
            case "requiredMessage":
                this._invalidate();
                break;
            case "customizeItem":
                this._updateItems(this.option("layoutData"));
                this._invalidate();
                break;
            case "colCount":
                this._resetColCount();
                break;
            case "minColWidth":
                if ("auto" === this.option("colCount")) {
                    this._resetColCount()
                }
                break;
            case "readOnly":
                break;
            case "width":
                this.callBase(args);
                if ("auto" === this.option("colCount")) {
                    this._resetColCount()
                }
                break;
            case "onFieldDataChanged":
                break;
            default:
                this.callBase(args)
        }
    },
    _resetColCount: function() {
        this._cashedColCount = null;
        this._invalidate()
    },
    linkEditorToDataField: function(editorInstance, dataField, editorType) {
        var isDataUpdating, fullFieldName = "layoutData." + dataField,
            that = this;
        that.on("optionChanged", function(args) {
            if (args.fullName === fullFieldName) {
                isDataUpdating = true;
                if ("object" === typeof args.value) {
                    that._managedUpdateEditorOption(editorInstance, "value", args.value)
                } else {
                    editorInstance.option("value", args.value)
                }
                isDataUpdating = false
            }
        });
        editorInstance.on("valueChanged", function(args) {
            var isObjectValue = "object" === typeof args.value,
                isSameObjectValue = isObjectValue && args.value === args.previousValue;
            if (!isDataUpdating && !isSameObjectValue) {
                if (isObjectValue) {
                    that._managedUpdateFieldValue(dataField, args.value)
                } else {
                    that._updateFieldValue(dataField, args.value)
                }
            }
        })
    },
    _managedUpdateEditorOption: function(editorInstance, optionName, value) {
        if (!this._isValueChangedCalled) {
            this._isFieldValueChanged = true;
            editorInstance.option(optionName, value);
            this._isFieldValueChanged = false
        }
    },
    _managedUpdateFieldValue: function(dataField, value) {
        this._isValueChangedCalled = true;
        if (!this._isFieldValueChanged) {
            this._updateFieldValue(dataField, value)
        }
        this._isValueChangedCalled = false
    },
    _dimensionChanged: function() {
        if ("auto" === this.option("colCount") && this.isCachedColCountObsolete()) {
            this.fireEvent("autoColCountChanged")
        }
    },
    getItemID: function(name) {
        var formInstance = this.option("form");
        return formInstance && formInstance.getItemID(name)
    },
    updateData: function(data, value) {
        var that = this;
        if (utils.isObject(data)) {
            $.each(data, function(dataField, fieldValue) {
                that._updateFieldValue(dataField, fieldValue)
            })
        } else {
            if ("string" === typeof data) {
                that._updateFieldValue(data, value)
            }
        }
    },
    getEditor: function(field) {
        return this._editorInstancesByField[field]
    },
    isSingleColumnMode: function(component) {
        var responsiveBox = this._responsiveBox || component;
        if (responsiveBox) {
            return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen")
        }
    }
});
registerComponent("dxLayoutManager", LayoutManager);
module.exports = LayoutManager;


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.validating.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    validatingModule = __webpack_require__(231);
gridCore.registerModule("validating", validatingModule);


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.virtual_scrolling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    dataSourceAdapter = __webpack_require__(131),
    virtualScrollingModule = __webpack_require__(232);
gridCore.registerModule("virtualScrolling", virtualScrollingModule);
dataSourceAdapter.extend(virtualScrollingModule.extenders.dataSourceAdapter);


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_scrolling_core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    browser = __webpack_require__(21),
    positionUtils = __webpack_require__(46),
    Class = __webpack_require__(5);
var SCROLLING_MODE_INFINITE = "infinite",
    SCROLLING_MODE_VIRTUAL = "virtual";
var isVirtualMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
};
var isAppendMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
};
exports.getContentHeightLimit = function(browser) {
    if (browser.msie) {
        return 4e6
    } else {
        if (browser.mozilla) {
            return 8e6
        }
    }
    return 15e6
};
exports.subscribeToExternalScrollers = function($element, scrollChangedHandler, $targetElement) {
    var $scrollElement, scrollableArray = [],
        scrollToArray = [],
        disposeArray = [];
    $targetElement = $targetElement || $element;

    function getElementOffset(scrollable) {
        var $scrollableElement = scrollable.element ? scrollable.element() : scrollable,
            scrollableOffset = positionUtils.offset($scrollableElement);
        if (!scrollableOffset) {
            return $element.offset().top
        }
        return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top)
    }

    function createWindowScrollHandler(scrollable) {
        return function() {
            var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);
            scrollTop = scrollTop > 0 ? scrollTop : 0;
            scrollChangedHandler(scrollTop)
        }
    }

    function subscribeToScrollEvents($scrollElement) {
        var handler, isDocument = "#document" === $scrollElement.get(0).nodeName,
            scrollable = $scrollElement.data("dxScrollable") || isDocument && $(window) || "auto" === $scrollElement.css("overflow-y") && $scrollElement;
        if (scrollable) {
            handler = createWindowScrollHandler(scrollable);
            scrollable.on("scroll", handler);
            scrollToArray.push(function(pos) {
                var topOffset = getElementOffset(scrollable),
                    scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
                if (pos - topOffset >= 0) {
                    scrollable[scrollMethod](pos + topOffset)
                }
            });
            scrollableArray.push(scrollable);
            disposeArray.push(function() {
                scrollable.off("scroll", handler)
            })
        }
    }
    for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {
        subscribeToScrollEvents($scrollElement)
    }
    return {
        scrollTo: function(pos) {
            $.each(scrollToArray, function(_, scrollTo) {
                scrollTo(pos)
            })
        },
        dispose: function() {
            $.each(disposeArray, function(_, dispose) {
                dispose()
            })
        }
    }
};
exports.VirtualScrollController = Class.inherit(function() {
    var getViewportPageCount = function(that) {
        var pageSize = that._dataSource.pageSize(),
            preventPreload = that.option("scrolling.preventPreload");
        if (preventPreload) {
            return 0
        }
        return pageSize && that._viewportSize > 0 ? Math.ceil(that._viewportSize / pageSize) : 1
    };
    var getPreloadPageCount = function(that, previous) {
        var preloadEnabled = that.option("scrolling.preloadEnabled"),
            pageCount = getViewportPageCount(that);
        if (pageCount) {
            if (previous) {
                pageCount = preloadEnabled ? 1 : 0
            } else {
                if (preloadEnabled) {
                    pageCount++
                }
                if (isAppendMode(that)) {
                    pageCount--
                }
            }
        }
        return pageCount
    };
    var getPageIndexForLoad = function(that) {
        var needToLoadNextPage, needToLoadPrevPage, needToLoadPageBeforeLast, result = -1,
            beginPageIndex = getBeginPageIndex(that),
            dataSource = that._dataSource;
        if (beginPageIndex < 0 || !that._cache[that._pageIndex - beginPageIndex]) {
            result = that._pageIndex
        } else {
            if (beginPageIndex >= 0 && that._viewportSize >= 0) {
                if (beginPageIndex > 0) {
                    needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataSource.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
                    needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
                    if (needToLoadPrevPage) {
                        result = beginPageIndex - 1
                    }
                }
                if (result < 0) {
                    needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
                    if (needToLoadNextPage) {
                        result = beginPageIndex + that._cache.length
                    }
                }
            }
        }
        return result
    };
    var getBeginPageIndex = function(that) {
        return that._cache.length ? that._cache[0].pageIndex : -1
    };
    var getEndPageIndex = function(that) {
        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
    };
    var fireChanged = function(that, changed, args) {
        that._isChangedFiring = true;
        changed(args);
        that._isChangedFiring = false
    };
    var processDelayChanged = function(that, changed, args) {
        if (that._isDelayChanged) {
            that._isDelayChanged = false;
            fireChanged(that, changed, args);
            return true
        }
    };
    var processChanged = function(that, changed, changeType, isDelayChanged) {
        var change, dataSource = that._dataSource,
            items = dataSource.items();
        if (changeType && !that._isDelayChanged) {
            change = {
                changeType: changeType,
                items: items
            }
        }
        var viewportItems = that._dataSource.viewportItems();
        if ("append" === changeType) {
            viewportItems.push.apply(viewportItems, items)
        } else {
            if ("prepend" === changeType) {
                viewportItems.unshift.apply(viewportItems, items)
            } else {
                that._dataSource.viewportItems(items)
            }
        }
        dataSource.updateLoading();
        that._lastPageIndex = that.pageIndex();
        that._isDelayChanged = isDelayChanged;
        if (!isDelayChanged) {
            fireChanged(that, changed, change)
        }
    };
    var loadCore = function(that, pageIndex) {
        var dataSource = that._dataSource;
        if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < dataSource.pageCount() || !dataSource.hasKnownLastPage() && pageIndex === dataSource.pageCount()) {
            dataSource.pageIndex(pageIndex);
            return dataSource.load()
        }
    };
    return {
        ctor: function(component, dataSource) {
            var that = this;
            that._dataSource = dataSource;
            that.component = component;
            that._pageIndex = that._lastPageIndex = dataSource.pageIndex();
            that._viewportSize = 0;
            that._viewportItemSize = 20;
            that._viewportItemIndex = -1;
            that._sizeRatio = 1;
            that._items = [];
            that._cache = []
        },
        option: function() {
            return this.component.option.apply(this.component, arguments)
        },
        virtualItemsCount: function() {
            var pageIndex, beginItemsCount, endItemsCount, that = this,
                itemsCount = 0;
            if (isVirtualMode(that)) {
                pageIndex = getBeginPageIndex(that);
                if (pageIndex < 0) {
                    pageIndex = that._dataSource.pageIndex()
                }
                beginItemsCount = pageIndex * that._dataSource.pageSize();
                itemsCount = that._cache.length * that._dataSource.pageSize();
                endItemsCount = Math.max(0, that._dataSource.totalItemsCount() - itemsCount - beginItemsCount);
                return {
                    begin: beginItemsCount,
                    end: endItemsCount
                }
            }
        },
        _setViewportPositionCore: function(position, isNear) {
            var that = this,
                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._dataSource.changingDuration());
            if (isNear && scrollingTimeout < that.option("scrolling.renderingThreshold")) {
                scrollingTimeout = 10
            }
            clearTimeout(that._scrollTimeoutID);
            if (scrollingTimeout > 0) {
                that._scrollTimeoutID = setTimeout(function() {
                    that.setViewportItemIndex(position)
                }, scrollingTimeout)
            } else {
                that.setViewportItemIndex(position)
            }
        },
        getViewportPosition: function() {
            return this._position || 0
        },
        setViewportPosition: function(position) {
            var that = this,
                virtualItemsCount = that.virtualItemsCount(),
                sizeRatio = that._sizeRatio || 1,
                itemSize = that._viewportItemSize,
                offset = virtualItemsCount ? Math.floor(virtualItemsCount.begin * itemSize * sizeRatio) : 0;
            that._position = position;
            if (virtualItemsCount && position >= offset && position <= offset + that._contentSize) {
                that._setViewportPositionCore(virtualItemsCount.begin + (position - offset) / itemSize, true)
            } else {
                that._setViewportPositionCore(position / (itemSize * sizeRatio))
            }
        },
        setContentSize: function(size) {
            var that = this,
                virtualItemsCount = that.virtualItemsCount();
            that._contentSize = size;
            if (virtualItemsCount) {
                var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + that.itemsCount()) * that._viewportItemSize;
                var contentHeightLimit = exports.getContentHeightLimit(browser);
                if (virtualContentSize > contentHeightLimit) {
                    that._sizeRatio = contentHeightLimit / virtualContentSize
                } else {
                    that._sizeRatio = 1
                }
            }
        },
        getContentOffset: function() {
            var that = this,
                virtualItemsCount = that.virtualItemsCount();
            return virtualItemsCount ? Math.floor(virtualItemsCount.begin * that._viewportItemSize * that._sizeRatio) : 0
        },
        getVirtualContentSize: function() {
            var that = this,
                virtualItemsCount = that.virtualItemsCount();
            return virtualItemsCount ? (virtualItemsCount.begin + virtualItemsCount.end) * that._viewportItemSize * that._sizeRatio + that._contentSize : 0
        },
        getViewportItemIndex: function() {
            return this._viewportItemIndex
        },
        setViewportItemIndex: function(itemIndex) {
            var lastPageSize, maxPageIndex, newPageIndex, that = this,
                pageSize = that._dataSource.pageSize(),
                pageCount = that._dataSource.pageCount(),
                virtualMode = isVirtualMode(that),
                appendMode = isAppendMode(that),
                totalItemsCount = that._dataSource.totalItemsCount(),
                needLoad = that._viewportItemIndex < 0;
            that._viewportItemIndex = itemIndex;
            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount) {
                    if (that._dataSource.hasKnownLastPage()) {
                        newPageIndex = pageCount - 1;
                        lastPageSize = totalItemsCount % pageSize;
                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2) {
                            newPageIndex--
                        }
                    } else {
                        newPageIndex = pageCount
                    }
                } else {
                    newPageIndex = Math.floor(itemIndex / pageSize);
                    maxPageIndex = pageCount - 1;
                    newPageIndex = Math.max(newPageIndex, 0);
                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                }
                if (that.pageIndex() !== newPageIndex || needLoad) {
                    that.pageIndex(newPageIndex);
                    that.load()
                }
            }
        },
        viewportItemSize: function(size) {
            if (void 0 !== size) {
                this._viewportItemSize = size
            }
            return this._viewportItemSize
        },
        viewportSize: function(size) {
            if (void 0 !== size) {
                this._viewportSize = size
            }
            return this._viewportSize
        },
        pageIndex: function(pageIndex) {
            if (isVirtualMode(this) || isAppendMode(this)) {
                if (void 0 !== pageIndex) {
                    this._pageIndex = pageIndex
                }
                return this._pageIndex
            } else {
                return this._dataSource.pageIndex(pageIndex)
            }
        },
        beginPageIndex: function(defaultPageIndex) {
            var beginPageIndex = getBeginPageIndex(this);
            if (beginPageIndex < 0) {
                beginPageIndex = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex()
            }
            return beginPageIndex
        },
        endPageIndex: function() {
            var endPageIndex = getEndPageIndex(this);
            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
        },
        load: function() {
            var pageIndexForLoad, result, dataSource = this._dataSource;
            if (isVirtualMode(this) || isAppendMode(this)) {
                pageIndexForLoad = getPageIndexForLoad(this);
                if (pageIndexForLoad >= 0) {
                    result = loadCore(this, pageIndexForLoad)
                }
                dataSource.updateLoading()
            } else {
                result = dataSource.load()
            }
            if (!result && this._lastPageIndex !== this.pageIndex()) {
                this._dataSource.onChanged({
                    changeType: "pageIndex"
                })
            }
            return result || $.Deferred().resolve()
        },
        loadIfNeed: function() {
            var that = this;
            if ((isVirtualMode(that) || isAppendMode(that)) && !that._dataSource.isLoading() && !that._isChangedFiring) {
                that.load()
            }
        },
        handleDataChanged: function(callBase) {
            var beginPageIndex, changeType, removeInvisiblePages, cacheItem, that = this,
                dataSource = that._dataSource,
                lastCacheLength = that._cache.length;
            if (isVirtualMode(that) || isAppendMode(that)) {
                beginPageIndex = getBeginPageIndex(that);
                if (beginPageIndex >= 0) {
                    if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex()) {
                        that._cache = []
                    }
                    if (isAppendMode(that)) {
                        if (0 === dataSource.pageIndex()) {
                            that._cache = []
                        } else {
                            if (dataSource.pageIndex() < getEndPageIndex(that)) {
                                fireChanged(that, callBase, {
                                    changeType: "append",
                                    items: []
                                });
                                return
                            }
                        }
                    }
                }
                cacheItem = {
                    pageIndex: dataSource.pageIndex(),
                    itemsCount: that.itemsCount(true)
                };
                if (that.option("scrolling.removeInvisiblePages")) {
                    removeInvisiblePages = that._cache.length > Math.max(getPreloadPageCount(this), 2)
                } else {
                    processDelayChanged(that, callBase, {
                        isDelayed: true
                    })
                }
                if (beginPageIndex === dataSource.pageIndex() + 1) {
                    if (removeInvisiblePages) {
                        that._cache.pop()
                    } else {
                        changeType = "prepend"
                    }
                    that._cache.unshift(cacheItem)
                } else {
                    if (removeInvisiblePages) {
                        that._cache.shift()
                    } else {
                        changeType = "append"
                    }
                    that._cache.push(cacheItem)
                }
                processChanged(that, callBase, that._cache.length > 1 ? changeType : void 0, 0 === lastCacheLength);
                that.load().done(function() {
                    if (processDelayChanged(that, callBase)) {
                        that.load()
                    }
                })
            } else {
                processChanged(that, callBase)
            }
        },
        itemsCount: function(isBase) {
            var itemsCount = 0;
            if (!isBase && isVirtualMode(this)) {
                $.each(this._cache, function() {
                    itemsCount += this.itemsCount
                })
            } else {
                itemsCount = this._dataSource.itemsCount()
            }
            return itemsCount
        },
        reset: function() {
            this._cache = []
        },
        subscribeToWindowScrollEvents: function($element) {
            var that = this;
            that._windowScroll = that._windowScroll || exports.subscribeToExternalScrollers($element, function(scrollTop) {
                if (that.viewportItemSize()) {
                    that.setViewportPosition(scrollTop)
                }
            })
        },
        dispose: function() {
            clearTimeout(this._scrollTimeoutID);
            this._windowScroll && this._windowScroll.dispose();
            this._windowScroll = null
        },
        scrollTo: function(pos) {
            this._windowScroll && this._windowScroll.scrollTo(pos)
        }
    }
}());


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.filter_row.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(12),
    filterRowModule = __webpack_require__(233);
core.registerModule("filterRow", filterRowModule);


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/menu/ui.menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    typeUtils = __webpack_require__(9),
    extend = __webpack_require__(1).extend,
    eventUtils = __webpack_require__(3),
    pointerEvents = __webpack_require__(17),
    hoverEvents = __webpack_require__(113),
    MenuBase = __webpack_require__(212),
    Overlay = __webpack_require__(39),
    Submenu = __webpack_require__(377),
    Button = __webpack_require__(25),
    TreeView = __webpack_require__(132);
var DX_MENU_CLASS = "dx-menu",
    DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical",
    DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal",
    DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
    DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
    DX_CONTEXT_MENU_CLASS = "dx-context-menu",
    DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border",
    DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
    DX_SUBMENU_CLASS = "dx-submenu",
    DX_STATE_DISABLED_CLASS = "dx-state-disabled",
    DX_STATE_HOVER_CLASS = "dx-state-hover",
    DX_STATE_ACTIVE_CLASS = "dx-state-active",
    DX_ADAPTIVE_MODE_CLASS = DX_MENU_CLASS + "-adaptive-mode",
    DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS = DX_MENU_CLASS + "-hamburger-button",
    FOCUS_UP = "up",
    FOCUS_DOWN = "down",
    FOCUS_LEFT = "left",
    FOCUS_RIGHT = "right",
    SHOW_SUBMENU_OPERATION = "showSubmenu",
    NEXTITEM_OPERATION = "nextItem",
    PREVITEM_OPERATION = "prevItem",
    DEFAULT_DELAY = {
        show: 50,
        hide: 300
    },
    ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged"];
var Menu = MenuBase.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            orientation: "horizontal",
            submenuDirection: "auto",
            showFirstSubmenuMode: {
                name: "onClick",
                delay: {
                    show: 50,
                    hide: 300
                }
            },
            hideSubmenuOnMouseLeave: false,
            onSubmenuShowing: null,
            onSubmenuShown: null,
            onSubmenuHiding: null,
            onSubmenuHidden: null,
            adaptivityEnabled: false
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        extend(this._optionsByReference, {
            animation: true,
            selectedItem: true
        })
    },
    _itemElements: function() {
        var rootMenuElements = this.callBase(),
            submenuElements = this._submenuItemElements();
        return rootMenuElements.add(submenuElements)
    },
    _submenuItemElements: function() {
        var elements = [],
            itemSelector = "." + DX_MENU_ITEM_CLASS,
            currentSubmenu = this._submenus.length && this._submenus[0];
        if (currentSubmenu && currentSubmenu.itemsContainer()) {
            elements = currentSubmenu.itemsContainer().find(itemSelector)
        }
        return elements
    },
    _focusTarget: function() {
        return this.element()
    },
    _isMenuHorizontal: function() {
        return "horizontal" === this.option("orientation")
    },
    _moveFocus: function(location) {
        var argument, operation, navigationAction, $newTarget, $items = this._getAvailableItems(),
            isMenuHorizontal = this._isMenuHorizontal(),
            $activeItem = this._getActiveItem(true);
        switch (location) {
            case FOCUS_UP:
                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                argument = isMenuHorizontal ? $activeItem : $items;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_DOWN:
                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                argument = isMenuHorizontal ? $activeItem : $items;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_RIGHT:
                operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                argument = isMenuHorizontal ? $items : $activeItem;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_LEFT:
                operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                argument = isMenuHorizontal ? $items : $activeItem;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            default:
                return this.callBase(location)
        }
        if ($newTarget && 0 !== $newTarget.length) {
            this.option("focusedElement", $newTarget)
        }
    },
    _getItemsNavigationOperation: function(operation) {
        var navOperation = operation;
        if (this.option("rtlEnabled")) {
            navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION
        }
        return navOperation
    },
    _getKeyboardNavigationAction: function(operation, argument) {
        var action = commonUtils.noop;
        switch (operation) {
            case SHOW_SUBMENU_OPERATION:
                if (!argument.hasClass(DX_STATE_DISABLED_CLASS)) {
                    action = this._showSubmenu.bind(this, argument)
                }
                break;
            case NEXTITEM_OPERATION:
                action = this._nextItem.bind(this, argument);
                break;
            case PREVITEM_OPERATION:
                action = this._prevItem.bind(this, argument)
        }
        return action
    },
    _clean: function() {
        this.callBase();
        this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer)
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _isAdaptivityEnabled: function() {
        return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation")
    },
    _dimensionChanged: function() {
        if (!this._isAdaptivityEnabled()) {
            return
        }
        var $menuItems = this.element().find("ul").first().children("li").children("." + DX_MENU_ITEM_CLASS),
            menuItemsWidth = 0,
            containerWidth = this.element().outerWidth();
        $menuItems.each(function(_, menuItem) {
            menuItemsWidth += $(menuItem).outerWidth(true)
        });
        this._toggleAdaptiveMode(menuItemsWidth > containerWidth)
    },
    _init: function() {
        this.callBase();
        this._submenus = []
    },
    _initActions: function() {
        this._actions = {};
        $.each(ACTIONS, function(index, action) {
            this._actions[action] = this._createActionByOption(action)
        }.bind(this))
    },
    _render: function() {
        this._visibleSubmenu = null;
        this.callBase();
        this.element().addClass(DX_MENU_CLASS);
        this._isAdaptivityEnabled() && this._initAdaptivity();
        this.setAria("role", "menubar")
    },
    _renderHamburgerButton: function() {
        this._hamburger = new Button($("<div>", {
            "class": DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS
        }), {
            icon: "menu",
            activeStateEnabled: false,
            onClick: this._toggleTreeView.bind(this)
        });
        return this._hamburger.element()
    },
    _toggleTreeView: function(state) {
        if (typeUtils.isPlainObject(state)) {
            state = !this._overlay.option("visible")
        }
        this._overlay.option("visible", state);
        this._toggleHamburgerActiveState(state)
    },
    _toggleHamburgerActiveState: function(state) {
        this._hamburger && this._hamburger.element().toggleClass(DX_STATE_ACTIVE_CLASS, state)
    },
    _toggleAdaptiveMode: function(state) {
        var $menuItemsContainer = this.element().find("." + DX_MENU_HORIZONTAL_CLASS),
            $adaptiveElements = this.element().find("." + DX_ADAPTIVE_MODE_CLASS);
        if (state) {
            this._hideVisibleSubmenu()
        } else {
            this._treeView && this._treeView.collapseAll();
            this._overlay && this._toggleTreeView(state)
        }
        $menuItemsContainer.toggle(!state);
        $adaptiveElements.toggle(state)
    },
    _removeAdaptivity: function() {
        if (!this._$adaptiveContainer) {
            return
        }
        this._toggleAdaptiveMode(false);
        this._$adaptiveContainer.remove();
        this._$adaptiveContainer = null;
        this._treeView = null;
        this._hamburger = null;
        this._overlay = null
    },
    _treeviewItemClickHandler: function(e) {
        this._actions.onItemClick(e);
        if (!e.node.children.length) {
            this._toggleTreeView(false)
        }
    },
    _getAdaptiveOverlayOptions: function() {
        var rtl = this.option("rtlEnabled"),
            position = rtl ? "right" : "left";
        return {
            deferRendering: false,
            shading: false,
            animation: false,
            closeOnTargetScroll: true,
            onHidden: function() {
                this._toggleHamburgerActiveState(false)
            }.bind(this),
            height: "auto",
            closeOnOutsideClick: function(e) {
                return !!!$(e.target).closest("." + DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS).length
            },
            position: {
                collision: "flipfit",
                at: "bottom " + position,
                my: "top " + position,
                of: this._hamburger.element()
            }
        }
    },
    _getTreeViewOptions: function() {
        var menuOptions = {},
            that = this,
            optionsToTransfer = ["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"],
            actionsToTransfer = ["onItemContextMenu", "onSelectionChanged"];
        $.each(optionsToTransfer, function(_, option) {
            menuOptions[option] = that.option(option)
        });
        $.each(actionsToTransfer, function(_, actionName) {
            menuOptions[actionName] = function(e) {
                this._actions[actionName](e)
            }.bind(that)
        });
        return extend(menuOptions, {
            animationEnabled: !!this.option("animation"),
            onItemClick: that._treeviewItemClickHandler.bind(that),
            onItemExpanded: function(e) {
                this._overlay.repaint();
                this._actions.onSubmenuShown(e)
            }.bind(that),
            onItemCollapsed: function(e) {
                this._overlay.repaint();
                this._actions.onSubmenuHidden(e)
            }.bind(that),
            selectNodesRecursive: false,
            selectByClick: this.option("selectByClick"),
            expandEvent: "click"
        })
    },
    _initAdaptivity: function() {
        if (!this._isAdaptivityEnabled()) {
            return
        }
        this._$adaptiveContainer = $("<div>", {
            "class": DX_ADAPTIVE_MODE_CLASS
        });
        var $hamburger = this._renderHamburgerButton();
        this._treeView = this._createComponent($("<div>"), TreeView, this._getTreeViewOptions());
        this._overlay = this._createComponent($("<div>"), Overlay, this._getAdaptiveOverlayOptions());
        this._overlay.content().append(this._treeView.element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
        this._$adaptiveContainer.append($hamburger);
        this._$adaptiveContainer.append(this._overlay.element());
        this.element().append(this._$adaptiveContainer);
        if (this.option("templatesRenderAsynchronously")) {
            this._resizeEventTimer = setTimeout(function() {
                this._dimensionChanged()
            }.bind(this), 0)
        } else {
            this._dimensionChanged()
        }
    },
    _getDelay: function(delayType) {
        var delay = this.option("showFirstSubmenuMode").delay;
        if (!commonUtils.isDefined(delay)) {
            return DEFAULT_DELAY[delayType]
        } else {
            return commonUtils.isObject(delay) ? delay[delayType] : delay
        }
    },
    _renderContainer: function() {
        var $wrapper = $("<div>");
        $wrapper.appendTo(this.element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);
        return this.callBase($wrapper)
    },
    _renderSubmenuItems: function(node, $itemFrame) {
        var submenu = this._createSubmenu(node, $itemFrame);
        this._submenus.push(submenu);
        this._renderBorderElement($itemFrame);
        return submenu
    },
    _createSubmenu: function(node, $rootItem) {
        var $submenuContainer = $("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
        var items = this._getChildNodes(node),
            result = this._createComponent($submenuContainer, Submenu, extend(this._getSubmenuOptions(), {
                _dataAdapter: this._dataAdapter,
                _parentKey: node.internalFields.key,
                items: items,
                onHoverStart: this._clearTimeouts.bind(this),
                position: this.getSubmenuPosition($rootItem)
            }));
        this._attachSubmenuHandlers($rootItem, result);
        return result
    },
    _getSubmenuOptions: function() {
        var $submenuTarget = $("<div>"),
            isMenuHorizontal = this._isMenuHorizontal();
        return {
            itemTemplate: this.option("itemTemplate"),
            target: $submenuTarget,
            orientation: this.option("orientation"),
            selectionMode: this.option("selectionMode"),
            cssClass: this.option("cssClass"),
            selectByClick: this.option("selectByClick"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            activeStateEnabled: this.option("activeStateEnabled"),
            focusStateEnabled: this.option("focusStateEnabled"),
            animation: this.option("animation"),
            showSubmenuMode: this.option("showSubmenuMode"),
            displayExpr: this.option("displayExpr"),
            disabledExpr: this.option("disabledExpr"),
            selectedExpr: this.option("selectedExpr"),
            itemsExpr: this.option("itemsExpr"),
            onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
            onItemClick: this._nestedItemOnItemClickHandler.bind(this),
            onItemRendered: this.option("onItemRendered"),
            onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, PREVITEM_OPERATION),
            onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION),
            onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? PREVITEM_OPERATION : null),
            onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION) : null
        }
    },
    _getShowFirstSubmenuMode: function() {
        if (!this._isDesktopDevice()) {
            return "onClick"
        }
        var optionValue = this.option("showFirstSubmenuMode");
        return commonUtils.isObject(optionValue) ? optionValue.name : optionValue
    },
    _moveMainMenuFocus: function(direction) {
        var $items = this._getAvailableItems(),
            itemCount = $items.length,
            $currentItem = $items.filter("." + DX_MENU_ITEM_EXPANDED_CLASS).eq(0),
            itemIndex = $items.index($currentItem);
        itemIndex += direction === PREVITEM_OPERATION ? -1 : 1;
        if (itemIndex >= itemCount) {
            itemIndex = 0
        } else {
            if (itemIndex < 0) {
                itemIndex = itemCount - 1
            }
        }
        var $newItem = $items.eq(itemIndex);
        this._hideSubmenu(this._visibleSubmenu);
        this.focus();
        this.option("focusedElement", $newItem)
    },
    _nestedItemOnSelectionChangedHandler: function(args) {
        var selectedItem = args.addedItems.length && args.addedItems[0],
            submenu = Submenu.getInstance(args.element),
            onSelectionChanged = this._actions.onSelectionChanged;
        onSelectionChanged(args);
        selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
        this._clearRootSelection();
        this._setOptionSilent("selectedItem", selectedItem)
    },
    _clearSelectionInSubmenus: function(item, targetSubmenu) {
        var that = this,
            cleanAllSubmenus = !arguments.length;
        $.each(this._submenus, function(index, submenu) {
            var $submenu = submenu._itemContainer(),
                isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
                $selectedItem = $submenu.find("." + that._selectedItemClass());
            if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                var selectedItemData;
                $selectedItem.removeClass(that._selectedItemClass());
                selectedItemData = that._getItemData($selectedItem);
                if (selectedItemData) {
                    selectedItemData.selected = false
                }
                submenu._clearSelectedItems()
            }
        })
    },
    _clearRootSelection: function() {
        var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + this._selectedItemClass());
        if ($prevSelectedItem.length) {
            var prevSelectedItemData;
            prevSelectedItemData = this._getItemData($prevSelectedItem);
            prevSelectedItemData.selected = false;
            $prevSelectedItem.removeClass(this._selectedItemClass())
        }
    },
    _nestedItemOnItemClickHandler: function(e) {
        this._actions.onItemClick(e)
    },
    _attachSubmenuHandlers: function($rootItem, submenu) {
        var that = this,
            $submenuOverlayContent = submenu.getOverlayContent(),
            submenus = $submenuOverlayContent.find("." + DX_SUBMENU_CLASS),
            submenuMouseLeaveName = eventUtils.addNamespace(hoverEvents.end, this.NAME + "_submenu");
        submenu.option({
            onShowing: this._submenuOnShowingHandler.bind(this, $rootItem, submenu),
            onShown: this._submenuOnShownHandler.bind(this, $rootItem, submenu),
            onHiding: this._submenuOnHidingHandler.bind(this, $rootItem, submenu),
            onHidden: this._submenuOnHiddenHandler.bind(this, $rootItem, submenu)
        });
        $.each(submenus, function(index, submenu) {
            $(submenu).off(submenuMouseLeaveName).on(submenuMouseLeaveName, null, that._submenuMouseLeaveHandler.bind(that, $rootItem))
        })
    },
    _submenuOnShowingHandler: function($rootItem, submenu) {
        var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS);
        this._actions.onSubmenuShowing({
            rootItem: $rootItem,
            submenu: submenu
        });
        $border.show();
        $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
    },
    _submenuOnShownHandler: function($rootItem, submenu) {
        this._actions.onSubmenuShown({
            rootItem: $rootItem,
            submenu: submenu
        })
    },
    _submenuOnHidingHandler: function($rootItem, submenu, eventArgs) {
        var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
            args = eventArgs;
        args.rootItem = $rootItem;
        args.submenu = submenu;
        this._actions.onSubmenuHiding(args);
        eventArgs = args;
        if (!eventArgs.cancel) {
            if (this._visibleSubmenu === submenu) {
                this._visibleSubmenu = null
            }
            $border.hide();
            $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
        }
    },
    _submenuOnHiddenHandler: function($rootItem, submenu) {
        this._actions.onSubmenuHidden({
            rootItem: $rootItem,
            submenu: submenu
        })
    },
    _submenuMouseLeaveHandler: function($rootItem, eventArgs) {
        var that = this,
            target = $(eventArgs.relatedTarget).parents("." + DX_CONTEXT_MENU_CLASS)[0],
            contextMenu = that._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
        if (that.option("hideSubmenuOnMouseLeave") && target !== contextMenu) {
            that._clearTimeouts();
            setTimeout(that._hideSubmenuAfterTimeout.bind(that), that._getDelay("hide"))
        }
    },
    _hideSubmenuAfterTimeout: function() {
        if (!this._visibleSubmenu) {
            return
        }
        var isRootItemHovered = $(this._visibleSubmenu.element().context).hasClass(DX_STATE_HOVER_CLASS),
            isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find("." + DX_STATE_HOVER_CLASS).length;
        if (!isSubmenuItemHovered && !isRootItemHovered) {
            this._visibleSubmenu.hide()
        }
    },
    _getSubmenuByRootElement: function($rootItem) {
        if (!$rootItem) {
            return false
        }
        var $submenu = $rootItem.children("." + DX_CONTEXT_MENU_CLASS);
        return $submenu.length && Submenu.getInstance($submenu)
    },
    getSubmenuPosition: function($rootItem) {
        var isHorizontalMenu = this._isMenuHorizontal(),
            submenuDirection = this.option("submenuDirection").toLowerCase(),
            rtlEnabled = this.option("rtlEnabled"),
            submenuPosition = {
                collision: "flip",
                of: $rootItem
            };
        switch (submenuDirection) {
            case "leftortop":
                submenuPosition.at = "left top";
                submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
                break;
            case "rightorbottom":
                submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
                submenuPosition.my = "left top";
                break;
            default:
                if (isHorizontalMenu) {
                    submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
                } else {
                    submenuPosition.at = rtlEnabled ? "left top" : "right top";
                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
                }
        }
        return submenuPosition
    },
    _renderBorderElement: function($item) {
        $("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
    },
    _itemPointerDownHandler: function(e) {
        var $target = $(e.target),
            $closestItem = $target.closest(this._itemElements());
        if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
            this.option("focusedElement", null);
            return
        }
        this.callBase(e)
    },
    _hoverStartHandler: function(e) {
        var mouseMoveEventName = eventUtils.addNamespace(pointerEvents.move, this.NAME),
            $item = this._getItemElementByEventArgs(e),
            node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
            isSelectionActive = commonUtils.isDefined(e.buttons) && 1 === e.buttons || !commonUtils.isDefined(e.buttons) && 1 === e.which;
        if (this._isItemDisabled($item)) {
            return
        }
        $item.off(mouseMoveEventName);
        if (!this._hasChildren(node)) {
            this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
            return
        }
        if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
            var submenu = this._getSubmenuByElement($item);
            this._clearTimeouts();
            if (!submenu.isOverlayVisible()) {
                $item.on(mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
                this._showSubmenuTimer = this._getDelay("hide")
            }
        }
    },
    _hoverEndHandler: function(eventArg) {
        var that = this,
            $item = that._getItemElementByEventArgs(eventArg),
            relatedTarget = $(eventArg.relatedTarget);
        that.callBase(eventArg);
        that._clearTimeouts();
        if (that._isItemDisabled($item)) {
            return
        }
        if (relatedTarget.hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)) {
            return
        }
        if (that.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
            that._hideSubmenuTimer = setTimeout(function() {
                that._hideSubmenuAfterTimeout()
            }, that._getDelay("hide"))
        }
    },
    _hideVisibleSubmenu: function() {
        if (!this._visibleSubmenu) {
            return false
        }
        this._hideSubmenu(this._visibleSubmenu);
        return true
    },
    _showSubmenu: function($itemElement) {
        var submenu = this._getSubmenuByElement($itemElement);
        if (this._visibleSubmenu !== submenu) {
            this._hideVisibleSubmenu()
        }
        submenu && submenu.show();
        this._visibleSubmenu = submenu;
        this._hoveredRootItem = $itemElement
    },
    _hideSubmenu: function(submenu) {
        submenu && submenu.hide();
        if (this._visibleSubmenu === submenu) {
            this._visibleSubmenu = null
        }
        this._hoveredRootItem = null
    },
    _itemMouseMoveHandler: function(e) {
        if (e.pointers && e.pointers.length) {
            return
        }
        var that = this,
            $item = $(e.currentTarget);
        if (!commonUtils.isDefined(that._showSubmenuTimer)) {
            return
        }
        that._clearTimeouts();
        that._showSubmenuTimer = setTimeout(function() {
            var submenu = that._getSubmenuByElement($item);
            if (submenu && !submenu.isOverlayVisible()) {
                that._showSubmenu($item)
            }
        }, that._getDelay("show"))
    },
    _clearTimeouts: function() {
        clearTimeout(this._hideSubmenuTimer);
        clearTimeout(this._showSubmenuTimer)
    },
    _getSubmenuByElement: function($itemElement, itemData) {
        var submenu = this._getSubmenuByRootElement($itemElement);
        if (submenu) {
            return submenu
        } else {
            itemData = itemData || this._getItemData($itemElement);
            var node = this._dataAdapter.getNodeByItem(itemData);
            return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement)
        }
    },
    _updateSubmenuVisibilityOnClick: function(actionArgs) {
        var currentSubmenu, args = actionArgs.args.length && actionArgs.args[0];
        if (!args || this._disabledGetter(args.itemData)) {
            return
        }
        currentSubmenu = this._getSubmenuByElement(args.itemElement, args.itemData);
        this._updateSelectedItemOnClick(actionArgs);
        if (this._visibleSubmenu) {
            if (this._visibleSubmenu === currentSubmenu) {
                if ("onClick" === this.option("showFirstSubmenuMode")) {
                    this._hideSubmenu(this._visibleSubmenu)
                }
                return
            } else {
                this._hideSubmenu(this._visibleSubmenu)
            }
        }
        if (!currentSubmenu) {
            return
        }
        if (!currentSubmenu.isOverlayVisible()) {
            this._showSubmenu(args.itemElement);
            return
        }
    },
    _optionChanged: function(args) {
        if (this._cancelOptionChange === args.name) {
            return
        }
        switch (args.name) {
            case "orientation":
            case "submenuDirection":
                this._invalidate();
                break;
            case "showFirstSubmenuMode":
            case "hideSubmenuOnMouseLeave":
                break;
            case "showSubmenuMode":
                this._changeSubmenusOption(args.name, args.value);
                break;
            case "onSubmenuShowing":
            case "onSubmenuShown":
            case "onSubmenuHiding":
            case "onSubmenuHidden":
                this._initActions();
                break;
            case "adaptivityEnabled":
                args.value ? this._initAdaptivity() : this._removeAdaptivity();
                break;
            case "width":
                if (this._isAdaptivityEnabled()) {
                    this._treeView.option(args.name, args.value);
                    this._overlay.option(args.name, args.value)
                }
                this.callBase(args);
                this._dimensionChanged();
                break;
            case "animation":
                if (this._isAdaptivityEnabled()) {
                    this._treeView.option("animationEnabled", !!args.value)
                }
                this.callBase(args);
                break;
            default:
                if (this._isAdaptivityEnabled()) {
                    this._treeView.option(args.name, args.value)
                }
                this.callBase(args)
        }
    },
    _changeSubmenusOption: function(name, value) {
        $.each(this._submenus, function(index, submenu) {
            submenu.option(name, value)
        })
    },
    selectItem: function(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        this.callBase(itemElement)
    },
    unselectItem: function(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        this.callBase(itemElement)
    }
});
registerComponent("dxMenu", Menu);
module.exports = Menu;


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/menu/ui.submenu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    noop = __webpack_require__(2).noop,
    positionUtils = __webpack_require__(46),
    extend = __webpack_require__(1).extend,
    ContextMenu = __webpack_require__(130);
var DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
    DX_SUBMENU_CLASS = "dx-submenu";
var Submenu = ContextMenu.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            orientation: "horizontal",
            onHoverStart: noop
        })
    },
    _initDataAdapter: function() {
        this._dataAdapter = this.option("_dataAdapter");
        if (!this._dataAdapter) {
            this.callBase()
        }
    },
    _renderContentImpl: function() {
        this._renderContextMenuOverlay();
        this.callBase();
        var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
        node && this._renderItems(this._getChildNodes(node));
        this._renderDelimiter()
    },
    _renderDelimiter: function() {
        this.$contentDelimiter = $("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
    },
    _getOverlayOptions: function() {
        return extend(this.callBase(), {
            onPositioned: this._overlayPositionedActionHandler.bind(this)
        })
    },
    _overlayPositionedActionHandler: function(arg) {
        this._showDelimiter(arg)
    },
    _hoverEndHandler: function(e) {
        this.callBase(e);
        this._toggleFocusClass(false, e.currentTarget)
    },
    _isMenuHorizontal: function() {
        return "horizontal" === this.option("orientation")
    },
    _hoverStartHandler: function(e) {
        var hoverStartAction = this.option("onHoverStart");
        hoverStartAction(e);
        this.callBase(e);
        this._toggleFocusClass(true, e.currentTarget)
    },
    _drawSubmenu: function($rootItem) {
        this._actions.onShowing({
            rootItem: $rootItem,
            submenu: this
        });
        this.callBase($rootItem);
        this._actions.onShown({
            rootItem: $rootItem,
            submenu: this
        })
    },
    _hideAllShownSubmenus: function($rootItem) {
        this._actions.onHiding({
            rootItem: $rootItem,
            submenu: this
        });
        this.callBase($rootItem);
        this._actions.onHidden({
            rootItem: $rootItem,
            submenu: this
        })
    },
    _hideSubmenu: function($rootItem) {
        this._actions.onHiding({
            rootItem: $rootItem,
            submenu: this
        });
        this.callBase($rootItem);
        this._actions.onHidden({
            rootItem: $rootItem,
            submenu: this
        })
    },
    _showDelimiter: function(arg) {
        if (!this.$contentDelimiter) {
            return
        }
        var $submenu = this._itemContainer().children("." + DX_SUBMENU_CLASS).eq(0),
            $rootItem = this.option("position").of,
            position = { of: $submenu
            },
            containerOffset = arg.position,
            vLocation = containerOffset.v.location,
            hLocation = containerOffset.h.location,
            rootOffset = $rootItem.offset(),
            offsetLeft = Math.round(rootOffset.left),
            offsetTop = Math.round(rootOffset.top),
            rootWidth = $rootItem.width(),
            rootHeight = $rootItem.height(),
            submenuWidth = $submenu.width(),
            submenuHeight = $submenu.height();
        this.$contentDelimiter.css("display", "block");
        this.$contentDelimiter.width(this._isMenuHorizontal() ? rootWidth < submenuWidth ? rootWidth - 2 : submenuWidth : 2);
        this.$contentDelimiter.height(this._isMenuHorizontal() ? 2 : rootHeight < submenuHeight ? rootHeight - 2 : submenuHeight);
        if (this._isMenuHorizontal()) {
            if (vLocation > offsetTop) {
                if (Math.round(hLocation) === offsetLeft) {
                    position.offset = "1 -1";
                    position.at = position.my = "left top"
                } else {
                    position.offset = "-1 -1";
                    position.at = position.my = "right top"
                }
            } else {
                this.$contentDelimiter.height(5);
                if (Math.round(hLocation) === offsetLeft) {
                    position.offset = "1 4";
                    position.at = position.my = "left bottom"
                } else {
                    position.offset = "-1 2";
                    position.at = position.my = "right bottom"
                }
            }
        } else {
            if (hLocation > offsetLeft) {
                if (Math.round(vLocation) === offsetTop) {
                    position.offset = "-1 1";
                    position.at = position.my = "left top"
                } else {
                    position.offset = "-1 -1";
                    position.at = position.my = "left bottom"
                }
            } else {
                if (Math.round(vLocation) === offsetTop) {
                    position.offset = "1 1";
                    position.at = position.my = "right top"
                } else {
                    position.offset = "1 -1";
                    position.at = position.my = "right bottom"
                }
            }
        }
        positionUtils.setup(this.$contentDelimiter, position)
    },
    _getContextMenuPosition: function() {
        return this.option("position")
    },
    isOverlayVisible: function() {
        return this._overlay.option("visible")
    },
    getOverlayContent: function() {
        return this._overlay.content()
    }
});
module.exports = Submenu;


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.header_filter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(12),
    headerFilterModule = __webpack_require__(235);
core.registerModule("headerFilter", headerFilterModule);


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_filter_core.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    modules = __webpack_require__(23),
    gridCoreUtils = __webpack_require__(26),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    Popup = __webpack_require__(68),
    TreeView = __webpack_require__(132),
    List = __webpack_require__(79);
var HEADER_FILTER_CLASS = "dx-header-filter",
    HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu";

function resetChildrenItemSelection(items) {
    items = items || [];
    for (var i = 0; i < items.length; i++) {
        items[i].selected = false;
        resetChildrenItemSelection(items[i].items)
    }
}

function updateSelectAllState($listContainer, filterValues) {
    var selectAllCheckBox = $listContainer.find(".dx-list-select-all-checkbox").data("dxCheckBox");
    if (selectAllCheckBox && filterValues && filterValues.length) {
        selectAllCheckBox.option("value", void 0)
    }
}
exports.updateHeaderFilterItemSelectionState = function(item, filterValuesMatch, isExcludeFilter) {
    if (filterValuesMatch ^ isExcludeFilter) {
        item.selected = true;
        if (isExcludeFilter && item.items) {
            for (var j = 0; j < item.items.length; j++) {
                if (!item.items[j].selected) {
                    item.selected = void 0;
                    break
                }
            }
        }
    } else {
        if (isExcludeFilter || item.selected) {
            item.selected = false;
            resetChildrenItemSelection(item.items)
        }
    }
};
exports.HeaderFilterView = modules.View.inherit({
    getPopupContainer: function() {
        return this._popupContainer
    },
    getListContainer: function() {
        return this._listContainer
    },
    applyHeaderFilter: function(options) {
        var that = this,
            list = that.getListContainer(),
            isSelectAll = list.element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked"),
            filterValues = [];
        var fillSelectedItemKeys = function(filterValues, items, isExclude) {
            $.each(items, function(_, item) {
                if (void 0 !== item.selected && !!item.selected ^ isExclude) {
                    filterValues.push(item.value)
                } else {
                    if (item.items && item.items.length) {
                        fillSelectedItemKeys(filterValues, item.items, isExclude)
                    }
                }
            })
        };
        if (!isSelectAll) {
            if ("tree" === options.type) {
                fillSelectedItemKeys(filterValues, list.option("items"), "exclude" === options.filterType);
                options.filterValues = filterValues
            }
        } else {
            if (Array.isArray(options.filterValues)) {
                options.filterValues = []
            }
        }
        if (options.filterValues && !options.filterValues.length) {
            options.filterValues = null
        }
        options.apply();
        that.hideHeaderFilterMenu()
    },
    showHeaderFilterMenu: function($columnElement, options) {
        var popupContainer, that = this;
        if (options) {
            that._initializePopupContainer(options);
            popupContainer = that.getPopupContainer();
            that.hideHeaderFilterMenu();
            that.updatePopup($columnElement, options);
            popupContainer.show()
        }
    },
    hideHeaderFilterMenu: function() {
        var headerFilterMenu = this.getPopupContainer();
        headerFilterMenu && headerFilterMenu.hide()
    },
    updatePopup: function($element, options) {
        var that = this,
            alignment = "right" === options.alignment ? "left" : "right";
        if (that._popupContainer) {
            that._cleanPopupContent();
            that._popupContainer.option("position", {
                my: alignment + " top",
                at: alignment + " bottom",
                of: $element,
                collision: "flip fit"
            })
        }
    },
    _cleanPopupContent: function() {
        this._popupContainer && this._popupContainer.content().empty()
    },
    _initializePopupContainer: function(options) {
        var that = this,
            $element = that.element(),
            headerFilterOptions = that.option("headerFilter"),
            width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width,
            height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height,
            dxPopupOptions = {
                width: width,
                height: height,
                visible: false,
                shading: false,
                showTitle: false,
                showCloseButton: false,
                closeOnTargetScroll: true,
                dragEnabled: false,
                closeOnOutsideClick: true,
                toolbarItems: [{
                    toolbar: "bottom",
                    location: "after",
                    widget: "dxButton",
                    options: {
                        text: headerFilterOptions.texts.ok,
                        onClick: function() {
                            that.applyHeaderFilter(options)
                        }
                    }
                }, {
                    toolbar: "bottom",
                    location: "after",
                    widget: "dxButton",
                    options: {
                        text: headerFilterOptions.texts.cancel,
                        onClick: function() {
                            that.hideHeaderFilterMenu()
                        }
                    }
                }],
                resizeEnabled: true,
                onShowing: function(e) {
                    that._initializeListContainer(options);
                    options.onShowing && options.onShowing(e)
                },
                onInitialized: function(e) {
                    var component = e.component;
                    component.option("animation", component._getDefaultOptions().animation)
                }
            };
        if (!commonUtils.isDefined(that._popupContainer)) {
            that._popupContainer = that._createComponent($element, Popup, dxPopupOptions)
        } else {
            that._popupContainer.option(dxPopupOptions)
        }
    },
    _initializeListContainer: function(options) {
        var that = this,
            $content = that._popupContainer.content(),
            widgetOptions = {
                dataSource: options.dataSource,
                onContentReady: function() {
                    that.renderCompleted.fire()
                },
                itemTemplate: function(data, _, $element) {
                    if (options.encodeHtml) {
                        return $element.text(data.text)
                    }
                    return $element.html(data.text)
                }
            };
        if ("tree" === options.type) {
            that._listContainer = that._createComponent($("<div>").appendTo($content), TreeView, extend(widgetOptions, {
                showCheckBoxesMode: "selectAll",
                keyExpr: "id"
            }))
        } else {
            that._listContainer = that._createComponent($("<div>").appendTo($content), List, extend(widgetOptions, {
                pageLoadMode: "scrollBottom",
                showSelectionControls: true,
                selectionMode: "all",
                onSelectionChanged: function(e) {
                    var items = e.component.option("items"),
                        selectedItems = e.component.option("selectedItems");
                    if (!e.component._selectedItemsUpdating) {
                        if (0 === selectedItems.length && items.length && (!options.filterValues || options.filterValues.length <= 1)) {
                            options.filterType = "include";
                            options.filterValues = []
                        } else {
                            if (selectedItems.length === items.length) {
                                options.filterType = "exclude";
                                options.filterValues = []
                            }
                        }
                    }
                    $.each(items, function(index, item) {
                        var filterValueIndex, selected = gridCoreUtils.getIndexByKey(item, selectedItems, null) >= 0,
                            oldSelected = !!item.selected;
                        if (oldSelected !== selected) {
                            item.selected = selected;
                            options.filterValues = options.filterValues || [];
                            filterValueIndex = gridCoreUtils.getIndexByKey(item.value, options.filterValues, null);
                            if (filterValueIndex >= 0) {
                                options.filterValues.splice(filterValueIndex, 1)
                            }
                            if (selected ^ "exclude" === options.filterType) {
                                options.filterValues.push(item.value)
                            }
                        }
                    });
                    updateSelectAllState(e.element, options.filterValues)
                },
                onContentReady: function(e) {
                    var component = e.component,
                        items = component.option("items"),
                        selectedItems = [];
                    $.each(items, function() {
                        if (this.selected) {
                            selectedItems.push(this)
                        }
                    });
                    component._selectedItemsUpdating = true;
                    component.option("selectedItems", selectedItems);
                    component._selectedItemsUpdating = false;
                    updateSelectAllState(e.element, options.filterValues)
                }
            }))
        }
    },
    _renderCore: function() {
        this.element().addClass(HEADER_FILTER_MENU_CLASS)
    }
});
var allowHeaderFiltering = exports.allowHeaderFiltering = function(column) {
    return commonUtils.isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering
};
exports.headerFilterMixin = {
    _applyColumnState: function(options) {
        var $headerFilterIndicator, rootElement = options.rootElement,
            column = options.column;
        if ("headerFilter" === options.name) {
            rootElement.find("." + HEADER_FILTER_CLASS).remove();
            if (allowHeaderFiltering(column)) {
                $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", !column.filterValues || !column.filterValues.length)
            }
            return $headerFilterIndicator
        }
        return this.callBase(options)
    },
    _getIndicatorClassName: function(name) {
        if ("headerFilter" === name) {
            return HEADER_FILTER_CLASS
        }
        return this.callBase(name)
    },
    _renderIndicator: function(options) {
        var rtlEnabled, $container = options.container,
            $indicator = options.indicator;
        if ("headerFilter" === options.name) {
            rtlEnabled = this.option("rtlEnabled");
            if ($container.children().length && (!rtlEnabled && "right" === options.columnAlignment || rtlEnabled && "left" === options.columnAlignment)) {
                $container.prepend($indicator);
                return
            }
        }
        this.callBase(options)
    },
    optionChanged: function(args) {
        if ("headerFilter" === args.name) {
            this._invalidate();
            args.handled = true
        } else {
            this.callBase(args)
        }
    }
};


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.search.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    searchModule = __webpack_require__(236);
gridCore.registerModule("search", searchModule);


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.pager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    Pager = __webpack_require__(382),
    inArray = __webpack_require__(7).inArray,
    commonUtils = __webpack_require__(2);
var DATAGRID_PAGER_CLASS = "dx-datagrid-pager",
    MAX_PAGES_COUNT = 10;
exports.PagerView = gridCore.View.inherit({
    init: function() {
        var that = this,
            dataController = that.getController("data");
        that._isVisible = false;
        dataController.changed.add(function(e) {
            if (!e || "update" !== e.changeType) {
                that.render()
            }
        })
    },
    _getPager: function() {
        var $element = this.element();
        return $element && $element.data("dxPager")
    },
    _renderCore: function() {
        var that = this,
            $element = that.element().addClass(DATAGRID_PAGER_CLASS),
            pagerOptions = that.option("pager") || {},
            dataController = that.getController("data"),
            options = {
                maxPagesCount: MAX_PAGES_COUNT,
                pageIndex: 1 + (parseInt(dataController.pageIndex()) || 0),
                pageCount: dataController.pageCount(),
                pageSize: dataController.pageSize(),
                showPageSizes: pagerOptions.showPageSizeSelector,
                showInfo: pagerOptions.showInfo,
                pagesNavigatorVisible: pagerOptions.visible,
                showNavigationButtons: pagerOptions.showNavigationButtons,
                pageSizes: that.getPageSizes(),
                totalCount: dataController.totalCount(),
                hasKnownLastPage: dataController.hasKnownLastPage(),
                pageIndexChanged: function(pageIndex) {
                    if (dataController.pageIndex() !== pageIndex - 1) {
                        setTimeout(function() {
                            dataController.pageIndex(pageIndex - 1)
                        })
                    }
                },
                pageSizeChanged: function(pageSize) {
                    setTimeout(function() {
                        dataController.pageSize(pageSize)
                    })
                }
            };
        if (commonUtils.isDefined(pagerOptions.infoText)) {
            options.infoText = pagerOptions.infoText
        }
        that._createComponent($element, Pager, options)
    },
    getPageSizes: function() {
        var that = this,
            dataController = that.getController("data"),
            pagerOptions = that.option("pager"),
            allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
            pageSize = dataController.pageSize();
        if (!commonUtils.isDefined(that._pageSizes) || inArray(pageSize, that._pageSizes) === -1) {
            that._pageSizes = [];
            if (pagerOptions) {
                if (Array.isArray(allowedPageSizes)) {
                    that._pageSizes = allowedPageSizes
                } else {
                    if (allowedPageSizes && pageSize > 1) {
                        that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize]
                    }
                }
            }
        }
        return that._pageSizes
    },
    isVisible: function() {
        var that = this,
            dataController = that.getController("data"),
            pagerOptions = that.option("pager"),
            pagerVisible = pagerOptions && pagerOptions.visible,
            scrolling = that.option("scrolling");
        if (that._isVisible) {
            return true
        }
        if ("auto" === pagerVisible) {
            if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
                pagerVisible = false
            } else {
                pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage()
            }
        }
        that._isVisible = pagerVisible;
        return pagerVisible
    },
    getHeight: function() {
        return this.getElementHeight()
    },
    optionChanged: function(args) {
        var that = this,
            name = args.name,
            isPager = "pager" === name,
            isPaging = "paging" === name,
            isDataSource = "dataSource" === name,
            isScrolling = "scrolling" === name;
        if (isPager || isPaging || isScrolling || isDataSource) {
            if (isPager || isPaging) {
                that._pageSizes = null
            }
            if (isPager || isPaging || isScrolling) {
                that._isVisible = false
            }
            if (!isDataSource) {
                that._invalidate();
                if (isPager && that.component) {
                    that.component.resize()
                }
            }
            args.handled = true
        }
    }
});
gridCore.registerModule("pager", {
    defaultOptions: function() {
        return {
            pager: {
                visible: "auto",
                showPageSizeSelector: false,
                allowedPageSizes: "auto"
            }
        }
    },
    views: {
        pagerView: exports.PagerView
    }
});


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/pager.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    stringUtils = __webpack_require__(30),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    clickEvent = __webpack_require__(11),
    messageLocalization = __webpack_require__(8),
    Widget = __webpack_require__(27),
    SelectBox = __webpack_require__(128),
    NumberBox = __webpack_require__(81),
    eventUtils = __webpack_require__(3);
var PAGES_LIMITER = 4,
    PAGER_CLASS = "dx-pager",
    PAGER_PAGE_CLASS = "dx-page",
    PAGER_PAGES_CLASS = "dx-pages",
    LIGHT_MODE_CLASS = "dx-light-mode",
    LIGHT_PAGES_CLASS = "dx-light-pages",
    PAGER_PAGE_INDEX_CLASS = "dx-page-index",
    PAGER_PAGES_COUNT_CLASS = "dx-pages-count",
    PAGER_SELECTION_CLASS = "dx-selection",
    PAGER_PAGE_SEPARATOR_CLASS = "dx-separator",
    PAGER_PAGE_SIZES_CLASS = "dx-page-sizes",
    PAGER_PAGE_SIZE_CLASS = "dx-page-size",
    PAGER_NAVIGATE_BUTTON = "dx-navigate-button",
    PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
    PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
    PAGER_INFO_CLASS = "dx-info",
    PAGER_INFO_TEXT_CLASS = "dx-info-text",
    PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
var Page = Class.inherit({
    ctor: function(value, index) {
        var that = this;
        that.index = index;
        that._$page = $("<div />").text(value).addClass(PAGER_PAGE_CLASS)
    },
    value: function(value) {
        var that = this;
        if (commonUtils.isDefined(value)) {
            that._$page.text(value)
        } else {
            var text = that._$page.text();
            if (commonUtils.isNumeric(text)) {
                return parseInt(text)
            } else {
                return text
            }
        }
    },
    element: function() {
        return this._$page
    },
    select: function(value) {
        this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
    },
    render: function(rootElement, rtlEnabled) {
        rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
    }
});
var Pager = Widget.inherit({
    _getDefaultOptions: function() {
        return extend(this.callBase(), {
            visible: true,
            pagesNavigatorVisible: "auto",
            pageIndex: 1,
            maxPagesCount: 10,
            pageCount: 10,
            totalCount: 0,
            pageSize: 5,
            showPageSizes: true,
            pageSizes: [5, 10],
            hasKnownLastPage: true,
            showNavigationButtons: false,
            showInfo: false,
            infoText: messageLocalization.getFormatter("dxPager-infoText"),
            pagesCountText: messageLocalization.getFormatter("dxPager-pagesCountText"),
            rtlEnabled: false,
            lightModeEnabled: false,
            pageIndexChanged: commonUtils.noop,
            pageSizeChanged: commonUtils.noop
        })
    },
    _toggleVisibility: function(value) {
        var $element = this.element();
        if ($element) {
            $element.css("display", value ? "" : "none")
        }
    },
    _getPages: function(currentPage, count) {
        var firstValue, i, pages = [],
            showMoreButton = !this.option("hasKnownLastPage");
        if (count > 0 || showMoreButton) {
            if (count <= this.option("maxPagesCount")) {
                for (i = 1; i <= count; i++) {
                    pages.push(new Page(i, i - 1))
                }
                if (showMoreButton) {
                    pages.push(new Page(">", i - 1))
                }
            } else {
                pages.push(new Page(1, 0));
                firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                for (i = 1; i <= PAGES_LIMITER; i++) {
                    pages.push(new Page(firstValue + i, i))
                }
                pages.push(new Page(count, PAGES_LIMITER + 1));
                if (showMoreButton) {
                    pages.push(new Page(">", PAGES_LIMITER + 1))
                }
            }
        }
        return pages
    },
    _getPageByValue: function(value) {
        var page, i, that = this;
        for (i = 0; i < that._pages.length; i++) {
            page = that._pages[i];
            if (page.value() === value) {
                return page
            }
        }
    },
    _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
        var selectedPageIndex, that = this,
            isPageIndexValid = false;
        if (that._pages) {
            $.each(that._pages, function(key, page) {
                if (pageIndex === page.value()) {
                    isPageIndexValid = true
                }
            });
            if (!isPageIndexValid) {
                that.selectedPage = null
            }
        }
        if (commonUtils.isDefined(that.selectedPage)) {
            if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1) {
                that.selectedPage.index = PAGES_LIMITER + 1
            }
        } else {
            if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                that.selectedPage = new Page(pageIndex, selectedPageIndex)
            }
        }
    },
    _selectPageByValue: function(value) {
        var i, prevPage, nextPage, morePage, that = this,
            page = that._getPageByValue(value),
            pages = that._pages,
            pagesLength = pages.length;
        if (!commonUtils.isDefined(page)) {
            return
        }
        prevPage = that._pages[page.index - 1];
        nextPage = that._pages[page.index + 1];
        if (nextPage && ">" === nextPage.value()) {
            morePage = nextPage;
            nextPage = void 0;
            pagesLength--;
            pages.pop()
        }
        if (that.selectedPage) {
            that.selectedPage.select(false)
        }
        page.select(true);
        that.selectedPage = page;
        if (nextPage && nextPage.value() - value > 1) {
            if (0 !== page.index) {
                prevPage.value(value + 1);
                that._pages.splice(page.index, 1);
                that._pages.splice(page.index - 1, 0, page);
                that._pages[page.index].index = page.index;
                page.index = page.index - 1;
                for (i = page.index - 1; i > 0; i--) {
                    that._pages[i].value(that._pages[i + 1].value() - 1)
                }
            } else {
                for (i = 0; i < pagesLength - 1; i++) {
                    that._pages[i].value(i + 1)
                }
            }
        }
        if (prevPage && value - prevPage.value() > 1) {
            if (page.index !== pagesLength - 1) {
                nextPage.value(value - 1);
                that._pages.splice(page.index, 1);
                that._pages.splice(page.index + 1, 0, page);
                that._pages[page.index].index = page.index;
                page.index = page.index + 1;
                for (i = page.index + 1; i < pagesLength - 1; i++) {
                    that._pages[i].value(that._pages[i - 1].value() + 1)
                }
            } else {
                for (i = 1; i <= pagesLength - 2; i++) {
                    that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i)
                }
            }
        }
        if (morePage) {
            pages.push(morePage)
        }
    },
    _nextPage: function(direction) {
        var pageIndex = this.option("pageIndex"),
            pageCount = this.option("pageCount");
        if (commonUtils.isDefined(pageIndex)) {
            pageIndex = "next" === direction ? ++pageIndex : --pageIndex;
            if (pageIndex > 0 && pageIndex <= pageCount) {
                this.option("pageIndex", pageIndex)
            }
        }
    },
    _renderPages: function(pages) {
        var $separator, page, that = this,
            pagesLength = pages.length,
            clickPagesIndexAction = that._createAction(function(args) {
                var e = args.jQueryEvent,
                    pageNumber = $(e.target).text(),
                    pageIndex = ">" === pageNumber ? that.option("pageCount") + 1 : Number(pageNumber);
                that.option("pageIndex", pageIndex)
            });
        if (pagesLength > 1) {
            that._pageClickHandler = function(e) {
                clickPagesIndexAction({
                    jQueryEvent: e
                })
            };
            that._$pagesChooser.on(eventUtils.addNamespace(clickEvent.name, that.Name + "Pages"), "." + PAGER_PAGE_CLASS, that._pageClickHandler)
        }
        for (var i = 0; i < pagesLength; i++) {
            page = pages[i];
            page.render(that._$pagesChooser, that.option("rtlEnabled"));
            that.setAria({
                role: "button",
                label: "Page " + page.value()
            }, page.element());
            if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                that.option("rtlEnabled") ? $separator.prependTo(that._$pagesChooser) : $separator.appendTo(that._$pagesChooser)
            }
        }
    },
    _calculateLightPagesWidth: function($pageIndex, pageCount) {
        return Number($pageIndex.css("min-width").replace("px", "")) + 10 * pageCount.toString().length
    },
    _renderLightPages: function() {
        var $pageCount, $pageIndex, that = this,
            pageCount = this.option("pageCount"),
            pageIndex = this.option("pageIndex"),
            clickAction = that._createAction(function() {
                that.option("pageIndex", pageCount)
            }),
            pagesCountText = this.option("pagesCountText");
        var $container = $("<div/>").addClass(LIGHT_PAGES_CLASS).appendTo(this._$pagesChooser);
        $pageIndex = $("<div/>").addClass(PAGER_PAGE_INDEX_CLASS).appendTo($container);
        that._pageIndexEditor = that._createComponent($pageIndex, NumberBox, {
            value: pageIndex,
            min: 1,
            max: pageCount,
            width: that._calculateLightPagesWidth($pageIndex, pageCount),
            onValueChanged: function(e) {
                that.option("pageIndex", e.value)
            }
        });
        $("<span/>").text(pagesCountText).addClass(PAGER_INFO_TEXT_CLASS + " " + PAGER_INFO_CLASS).appendTo($container);
        $pageCount = $("<span/>").addClass(PAGER_PAGES_COUNT_CLASS).text(pageCount).on(eventUtils.addNamespace(clickEvent.name, that.Name + "PagesCount"), function(e) {
            clickAction({
                jQueryEvent: e
            })
        }).appendTo($container);
        that.setAria({
            role: "button",
            label: "Navigates to the last page"
        }, $pageCount)
    },
    _renderPagesChooser: function() {
        var that = this,
            lightModeEnabled = that.option("lightModeEnabled"),
            pagesNavigatorVisible = that.option("pagesNavigatorVisible"),
            $element = that.element();
        that._$pagesChooser && that._$pagesChooser.remove();
        if (!pagesNavigatorVisible) {
            return
        }
        if (that._pages && 0 === that._pages.length) {
            that.selectedPage = null;
            return
        }
        that._$pagesChooser = $("<div />").addClass(PAGER_PAGES_CLASS).appendTo($element);
        if ("auto" === pagesNavigatorVisible) {
            that._$pagesChooser.css("visibility", 1 === that.option("pageCount") ? "hidden" : "")
        }
        if (!lightModeEnabled) {
            that._renderInfo()
        }
        that._renderNavigateButton("prev");
        if (lightModeEnabled) {
            that._renderLightPages()
        } else {
            that._renderPages(that._pages)
        }
        that._renderNavigateButton("next");
        that._updatePagesChooserWidth()
    },
    _renderPageSizes: function() {
        var i, pageSizeValue, $pageSize, that = this,
            pageSizes = that.option("pageSizes"),
            pagesSizesLength = pageSizes && pageSizes.length,
            currentPageSize = that.option("pageSize"),
            clickPagesSizeAction = that._createAction(function(args) {
                var e = args.jQueryEvent;
                pageSizeValue = parseInt($(e.target).text());
                that.option("pageSize", pageSizeValue)
            });
        that._$pagesSizeChooser.on(eventUtils.addNamespace(clickEvent.name, that.Name + "PageSize"), "." + PAGER_PAGE_SIZE_CLASS, function(e) {
            clickPagesSizeAction({
                jQueryEvent: e
            })
        });
        for (i = 0; i < pagesSizesLength; i++) {
            $pageSize = $("<div />").text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
            that.setAria({
                role: "button",
                label: "Display " + pageSizes[i] + " items on page"
            }, $pageSize);
            if (currentPageSize === pageSizes[i]) {
                $pageSize.addClass(PAGER_SELECTION_CLASS)
            }
            that._$pagesSizeChooser.append($pageSize)
        }
    },
    _calculateLightPageSizesWidth: function(pageSizes) {
        return Number(this._$pagesSizeChooser.css("min-width").replace("px", "")) + 10 * Math.max.apply(Math, pageSizes).toString().length
    },
    _renderLightPageSizes: function() {
        var $editor, that = this,
            pageSizes = that.option("pageSizes");
        $editor = $("<div/>").appendTo(that._$pagesSizeChooser);
        that._pageSizeEditor = that._createComponent($editor, SelectBox, {
            dataSource: pageSizes,
            value: that.option("pageSize"),
            onSelectionChanged: function(e) {
                that.option("pageSize", e.selectedItem)
            },
            width: that._calculateLightPageSizesWidth(pageSizes)
        })
    },
    _renderPagesSizeChooser: function() {
        var that = this,
            pageSizes = that.option("pageSizes"),
            showPageSizes = that.option("showPageSizes"),
            pagesSizesLength = pageSizes && pageSizes.length,
            $element = that.element();
        if (!showPageSizes || !pagesSizesLength) {
            return
        }
        that._$pagesSizeChooser && that._$pagesSizeChooser.remove();
        that._$pagesSizeChooser = $("<div />").addClass(PAGER_PAGE_SIZES_CLASS).appendTo($element);
        if (that.option("lightModeEnabled")) {
            that._renderLightPageSizes()
        } else {
            that._renderPageSizes()
        }
        that._pagesSizeChooserWidth = that._$pagesSizeChooser.width()
    },
    _renderInfo: function() {
        var infoText = this.option("infoText");
        if (this.option("showInfo") && commonUtils.isDefined(infoText)) {
            this._$info = $("<div>").css("display", this._isInfoHide ? "none" : "").addClass(PAGER_INFO_CLASS).text(stringUtils.format(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"), this.option("totalCount"))).appendTo(this._$pagesChooser);
            if (!this._isInfoHide) {
                this._infoWidth = this._$info.outerWidth(true)
            }
        }
    },
    _renderNavigateButton: function(direction) {
        var $button, that = this,
            clickAction = that._createAction(function() {
                that._nextPage(direction)
            });
        if (that.option("showNavigationButtons") || that.option("lightModeEnabled")) {
            $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).on(eventUtils.addNamespace(clickEvent.name, that.Name + "Pages"), function(e) {
                clickAction({
                    jQueryEvent: e
                })
            });
            that.setAria({
                role: "button",
                label: "prev" === direction ? "Previous page" : " Next page"
            }, $button);
            if (that.option("rtlEnabled")) {
                $button.addClass("prev" === direction ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                $button.prependTo(this._$pagesChooser)
            } else {
                $button.addClass("prev" === direction ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                $button.appendTo(this._$pagesChooser)
            }
        }
    },
    _renderContentImpl: function() {
        this.element().addClass(PAGER_CLASS).toggleClass(LIGHT_MODE_CLASS, this.option("lightModeEnabled"));
        this._toggleVisibility(this.option("visible"));
        this._updatePageSizes(true);
        this._updatePages(true)
    },
    _render: function() {
        this.callBase();
        this._updateLightMode()
    },
    _updatePageSizes: function(forceRender) {
        var lightModeEnabled = this.option("lightModeEnabled"),
            pageSize = this.option("pageSize"),
            pageSizes = this.option("pageSizes");
        if (lightModeEnabled) {
            this._pageSizeEditor && this._pageSizeEditor.option({
                value: pageSize,
                dataSource: pageSizes,
                width: this._calculateLightPageSizesWidth(pageSizes)
            })
        }
        if (!lightModeEnabled || forceRender) {
            this._renderPagesSizeChooser()
        }
    },
    _updatePages: function(forceRender) {
        var pageCount = this.option("pageCount"),
            pageIndex = this.option("pageIndex"),
            lightModeEnabled = this.option("lightModeEnabled");
        if (!lightModeEnabled) {
            this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
            this._pages = this._getPages(this.selectedPage, pageCount);
            this._selectPageByValue(pageIndex)
        } else {
            this._pageIndexEditor && this._pageIndexEditor.option({
                value: pageIndex,
                width: this._calculateLightPagesWidth(this._pageIndexEditor.element(), pageCount)
            })
        }
        if (!lightModeEnabled || forceRender) {
            this._renderPagesChooser()
        }
        this._updateButtonsState(pageIndex)
    },
    _isPageIndexInvalid: function(direction, pageIndex) {
        var isNextDirection = "next" === direction,
            rtlEnabled = this.option("rtlEnabled");
        if (rtlEnabled && isNextDirection || !rtlEnabled && !isNextDirection) {
            return pageIndex <= 1
        }
        return pageIndex >= this.option("pageCount")
    },
    _updateButtonsState: function(pageIndex) {
        var nextButton = this.element().find("." + PAGER_NEXT_BUTTON_CLASS),
            prevButton = this.element().find("." + PAGER_PREV_BUTTON_CLASS);
        nextButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, this._isPageIndexInvalid("next", pageIndex));
        prevButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, this._isPageIndexInvalid("prev", pageIndex))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "visible":
                this._toggleVisibility(args.value);
                break;
            case "pageIndex":
                var pageIndexChanged = this.option("pageIndexChanged");
                if (pageIndexChanged) {
                    pageIndexChanged(args.value)
                }
                this._updatePages();
                break;
            case "maxPagesCount":
            case "pageCount":
            case "totalCount":
            case "hasKnownLastPage":
            case "pagesNavigatorVisible":
            case "showNavigationButtons":
                this._updatePages();
                break;
            case "pageSize":
                var pageSizeChanged = this.option("pageSizeChanged");
                if (pageSizeChanged) {
                    pageSizeChanged(args.value)
                }
                this._updatePageSizes();
                break;
            case "pageSizes":
                this._updatePageSizes();
                break;
            case "lightModeEnabled":
                this._renderContentImpl();
                !args.value && this._updateLightMode();
                break;
            default:
                this._invalidate()
        }
    },
    _clean: function() {
        this._$pagesChooser && this._$pagesChooser.off(eventUtils.addNamespace(clickEvent.name, this.Name + "Pages"), "." + PAGER_PAGE_CLASS, this._pageClickHandler);
        this.callBase()
    },
    _getMinPagerWidth: function() {
        var pagesChooserWidth = commonUtils.isDefined(this._pagesChooserWidth) ? this._pagesChooserWidth : 0,
            pagesSizeChooserWidth = commonUtils.isDefined(this._pagesSizeChooserWidth) ? this._pagesSizeChooserWidth : 0;
        return pagesChooserWidth + pagesSizeChooserWidth
    },
    _updatePagesChooserWidth: commonUtils.deferUpdater(function() {
        var lastPageWidth = this._pages && this._pages.length > 0 ? this._pages[this._pages.length - 1]._$page.width() : 0;
        this._pagesChooserWidth = this._$pagesChooser.width() + lastPageWidth
    }),
    _updateLightMode: commonUtils.deferUpdater(function() {
        var that = this,
            width = this.element().width(),
            infoWidth = commonUtils.isDefined(this._infoWidth) ? this._infoWidth : 0;
        commonUtils.deferRender(function() {
            if (that._isInfoHide && width > that._getMinPagerWidth() + infoWidth) {
                that._$info.show();
                that._updatePagesChooserWidth();
                that._isInfoHide = false
            }
            if (!that._isInfoHide && width > that._getMinPagerWidth() - infoWidth && width < that._getMinPagerWidth()) {
                that._$info.hide();
                that._updatePagesChooserWidth();
                that._isInfoHide = true
            }
            commonUtils.deferUpdate(function() {
                commonUtils.deferRender(function() {
                    if (that.option("lightModeEnabled") && width >= that._previousWidth) {
                        that.option("lightModeEnabled", false)
                    } else {
                        if (width < that._getMinPagerWidth()) {
                            that.option("lightModeEnabled", true)
                        }
                    }
                    that._previousWidth = width
                })
            })
        })
    }),
    _dimensionChanged: function() {
        this._updateLightMode()
    },
    getHeight: function() {
        return this.option("visible") ? this.element().outerHeight() : 0
    }
});
module.exports = Pager;
registerComponent("dxPager", Pager);


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.columns_resizing_reordering.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    columnsResizingReorderingModule = __webpack_require__(237);
exports.DraggingHeaderView = columnsResizingReorderingModule.views.draggingHeaderView;
exports.DraggingHeaderViewController = columnsResizingReorderingModule.controllers.draggingHeader;
exports.ColumnsSeparatorView = columnsResizingReorderingModule.views.columnsSeparatorView;
exports.TablePositionViewController = columnsResizingReorderingModule.controllers.tablePosition;
exports.ColumnsResizerViewController = columnsResizingReorderingModule.controllers.columnsResizer;
exports.TrackerView = columnsResizingReorderingModule.views.trackerView;
gridCore.registerModule("columnsResizingReordering", columnsResizingReorderingModule);


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.keyboard_navigation.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    keyboardNavigationModule = __webpack_require__(238);
gridCore.registerModule("keyboardNavigation", keyboardNavigationModule);


/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.summary.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    commonUtils = __webpack_require__(2),
    isEmptyObject = __webpack_require__(9).isEmptyObject,
    extend = __webpack_require__(1).extend,
    compileGetter = __webpack_require__(14).compileGetter,
    errors = __webpack_require__(16),
    gridCore = __webpack_require__(12),
    messageLocalization = __webpack_require__(8),
    dataSourceAdapter = __webpack_require__(131),
    columnsView = __webpack_require__(101),
    AggregateCalculator = __webpack_require__(386),
    dataQuery = __webpack_require__(35),
    dataUtils = __webpack_require__(28);
var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
    DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
    DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
    DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
    DATAGRID_GROUP_TEXT_CONTENT_CLASS = "dx-datagrid-group-text-content",
    DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
    DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
var renderSummaryCell = function($cell, options) {
        var i, summaryItem, column = options.column,
            summaryItems = options.summaryItems,
            $summaryItems = [];
        if (!column.command && summaryItems) {
            for (i = 0; i < summaryItems.length; i++) {
                summaryItem = summaryItems[i];
                $summaryItems.push($("<div>").css("text-align", summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).toggleClass(DATAGRID_GROUP_TEXT_CONTENT_CLASS, "group" === options.rowType).text(gridCore.getSummaryText(summaryItem, options.summaryTexts)))
            }
            $cell.append($summaryItems)
        }
    },
    getSummaryCellOptions = function(that, options) {
        var summaryTexts = that.option("summary.texts") || {};
        return {
            totalItem: options.row,
            summaryItems: options.row.summaryCells[options.columnIndex],
            summaryTexts: summaryTexts
        }
    };
var getGroupAggregates = function(data) {
    return data.summary || data.aggregates || []
};
exports.FooterView = columnsView.ColumnsView.inherit(function() {
    return {
        _getRows: function() {
            return this._dataController.footerItems()
        },
        _getCellOptions: function(options) {
            return extend(this.callBase(options), getSummaryCellOptions(this, options))
        },
        _renderCellContent: function($cell, options) {
            renderSummaryCell($cell, options);
            this.callBase($cell, options)
        },
        _renderCore: function() {
            var totalItem = this._dataController.footerItems()[0];
            this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !this.option("wordWrapEnabled"));
            if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
                this._updateContent(this._renderTable())
            }
        },
        _rowClick: function(e) {
            var item = this._dataController.footerItems()[e.rowIndex] || {};
            this.executeAction("onRowClick", extend({}, e, item))
        },
        _columnOptionChanged: function(e) {
            var optionNames = e.optionNames;
            if (e.changeTypes.grouping) {
                return
            }
            if (optionNames.width || optionNames.visibleWidth) {
                this.callBase(e)
            }
        },
        _handleDataChanged: function(e) {
            if ("refresh" === e.changeType) {
                this.render()
            }
        },
        getHeight: function() {
            return this.getElementHeight()
        },
        isVisible: function() {
            return !!this._dataController.footerItems().length
        }
    }
}());
var SummaryDataSourceAdapterExtender = function() {
    return {
        init: function() {
            this.callBase.apply(this, arguments);
            this._totalAggregates = [];
            this._summaryGetter = commonUtils.noop
        },
        summaryGetter: function(summaryGetter) {
            if (!arguments.length) {
                return this._summaryGetter
            }
            if (commonUtils.isFunction(summaryGetter)) {
                this._summaryGetter = summaryGetter
            }
        },
        summary: function(summary) {
            if (!arguments.length) {
                return this._summaryGetter()
            }
            this._summaryGetter = function() {
                return summary
            }
        },
        totalAggregates: function() {
            return this._totalAggregates
        }
    }
}();
var SummaryDataSourceAdapterClientExtender = function() {
    var calculateAggregates = function(that, summary, data, groupLevel) {
        var calculator;
        if (summary) {
            calculator = new AggregateCalculator({
                totalAggregates: summary.totalAggregates,
                groupAggregates: summary.groupAggregates,
                data: data,
                groupLevel: groupLevel
            });
            calculator.calculate()
        }
        return calculator ? calculator.totalAggregates() : []
    };
    var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
        if (!items || !groups.length) {
            return items
        }
        var query, group = groups[0],
            sorts = sortByGroups[0];
        if (group && sorts && sorts.length) {
            query = dataQuery(items);
            $.each(sorts, function(index) {
                if (0 === index) {
                    query = query.sortBy(this.selector, this.desc)
                } else {
                    query = query.thenBy(this.selector, this.desc)
                }
            });
            query.enumerate().done(function(sortedItems) {
                items = sortedItems
            })
        }
        groups = groups.slice(1);
        sortByGroups = sortByGroups.slice(1);
        if (groups.length && sortByGroups.length) {
            $.each(items, function() {
                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
            })
        }
        return items
    };
    var sortGroupsBySummary = function(data, group, summary) {
        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
        if (sortByGroups && sortByGroups.length) {
            return sortGroupsBySummaryCore(data, group, sortByGroups)
        }
        return data
    };
    return {
        _customizeRemoteOperations: function(options) {
            var summary = this.summary();
            if (summary) {
                if (options.remoteOperations.summary) {
                    if (!options.isCustomLoading || options.storeLoadOptions.isLoadingAll) {
                        if (options.storeLoadOptions.group) {
                            if (options.remoteOperations.grouping) {
                                options.storeLoadOptions.groupSummary = summary.groupAggregates
                            } else {
                                if (summary.groupAggregates.length) {
                                    options.remoteOperations.paging = false
                                }
                            }
                        }
                        options.storeLoadOptions.totalSummary = summary.totalAggregates
                    }
                } else {
                    if (summary.totalAggregates.length || summary.groupAggregates.length && options.storeLoadOptions.group) {
                        options.remoteOperations.paging = false
                    }
                }
            }
            this.callBase.apply(this, arguments)
        },
        _handleDataLoadedCore: function(options) {
            var totalAggregates, that = this,
                groups = dataUtils.normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group || []),
                remoteOperations = options.remoteOperations || {},
                summary = that.summaryGetter()(remoteOperations);
            if (remoteOperations.summary) {
                if (!remoteOperations.paging && groups.length && summary) {
                    if (!remoteOperations.grouping) {
                        calculateAggregates(that, {
                            groupAggregates: summary.groupAggregates
                        }, options.data, groups.length)
                    }
                    options.data = sortGroupsBySummary(options.data, groups, summary)
                }
            } else {
                if (!remoteOperations.paging) {
                    totalAggregates = calculateAggregates(that, summary, options.data, groups.length);
                    options.data = sortGroupsBySummary(options.data, groups, summary);
                    options.extra = options.extra || {};
                    options.extra.summary = totalAggregates
                }
            }
            if (!options.isCustomLoading) {
                that._totalAggregates = options.extra && options.extra.summary || that._totalAggregates
            }
            that.callBase(options)
        }
    }
}();
dataSourceAdapter.extend(SummaryDataSourceAdapterExtender);
dataSourceAdapter.extend(SummaryDataSourceAdapterClientExtender);
exports.renderSummaryCell = renderSummaryCell;
gridCore.registerModule("summary", {
    defaultOptions: function() {
        return {
            summary: {
                groupItems: void 0,
                totalItems: void 0,
                calculateCustomSummary: void 0,
                skipEmptyValues: true,
                texts: {
                    sum: messageLocalization.getFormatter("dxDataGrid-summarySum"),
                    sumOtherColumn: messageLocalization.getFormatter("dxDataGrid-summarySumOtherColumn"),
                    min: messageLocalization.getFormatter("dxDataGrid-summaryMin"),
                    minOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryMinOtherColumn"),
                    max: messageLocalization.getFormatter("dxDataGrid-summaryMax"),
                    maxOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryMaxOtherColumn"),
                    avg: messageLocalization.getFormatter("dxDataGrid-summaryAvg"),
                    avgOtherColumn: messageLocalization.getFormatter("dxDataGrid-summaryAvgOtherColumn"),
                    count: messageLocalization.getFormatter("dxDataGrid-summaryCount")
                }
            },
            sortByGroupSummaryInfo: void 0
        }
    },
    views: {
        footerView: exports.FooterView
    },
    extenders: {
        controllers: {
            data: function() {
                return {
                    _isDataColumn: function(column) {
                        return column && (!commonUtils.isDefined(column.groupIndex) || column.showWhenGrouped)
                    },
                    _isGroupFooterVisible: function() {
                        var groupItem, column, i, groupItems = this.option("summary.groupItems") || [];
                        for (i = 0; i < groupItems.length; i++) {
                            groupItem = groupItems[i];
                            column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
                            if (groupItem.showInGroupFooter && this._isDataColumn(column)) {
                                return true
                            }
                        }
                        return false
                    },
                    _processGroupItems: function(items, groupCount, options) {
                        var data = options && options.data,
                            result = this.callBase.apply(this, arguments);
                        if (options) {
                            if (void 0 === options.isGroupFooterVisible) {
                                options.isGroupFooterVisible = this._isGroupFooterVisible()
                            }
                            if (data && data.items && options.isGroupFooterVisible && (options.collectContinuationItems || !data.isContinuationOnNextPage)) {
                                result.push({
                                    rowType: DATAGRID_GROUP_FOOTER_ROW_TYPE,
                                    data: data,
                                    groupIndex: options.path.length - 1,
                                    values: []
                                })
                            }
                        }
                        return result
                    },
                    _processGroupItem: function(groupItem, options) {
                        var that = this;
                        if (!options.summaryGroupItems) {
                            options.summaryGroupItems = that.option("summary.groupItems") || []
                        }
                        if ("group" === groupItem.rowType) {
                            var groupColumnIndex = -1,
                                afterGroupColumnIndex = -1;
                            $.each(options.visibleColumns, function(visibleIndex) {
                                var prevColumn = options.visibleColumns[visibleIndex - 1];
                                if (groupItem.groupIndex === this.groupIndex) {
                                    groupColumnIndex = this.index
                                }
                                if (visibleIndex > 0 && "expand" === prevColumn.command && "expand" !== this.command) {
                                    afterGroupColumnIndex = this.index
                                }
                            });
                            groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                if (summaryItem.showInGroupFooter) {
                                    return -1
                                }
                                if (summaryItem.alignByColumn && column && !commonUtils.isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex) {
                                    return column.index
                                } else {
                                    return groupColumnIndex
                                }
                            })
                        }
                        if (groupItem.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE) {
                            groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                return summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1
                            })
                        }
                        return groupItem
                    },
                    _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
                        var that = this,
                            summaryCells = [],
                            summaryCellsByColumns = {};
                        $.each(summaryItems, function(summaryIndex, summaryItem) {
                            var aggregate, column = that._columnsController.columnOption(summaryItem.column),
                                showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
                                columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn);
                            if (columnIndex >= 0) {
                                if (!summaryCellsByColumns[columnIndex]) {
                                    summaryCellsByColumns[columnIndex] = []
                                }
                                aggregate = aggregates[summaryIndex];
                                if (aggregate === aggregate) {
                                    summaryCellsByColumns[columnIndex].push(extend({}, summaryItem, {
                                        value: commonUtils.isString(aggregate) && column && column.deserializeValue ? column.deserializeValue(aggregate) : aggregate,
                                        valueFormat: !commonUtils.isDefined(summaryItem.valueFormat) ? gridCore.getFormatByDataType(column && column.dataType) : summaryItem.valueFormat,
                                        columnCaption: column && column.index !== columnIndex ? column.caption : void 0
                                    }))
                                }
                            }
                        });
                        if (!isEmptyObject(summaryCellsByColumns)) {
                            $.each(visibleColumns, function() {
                                summaryCells.push(summaryCellsByColumns[this.index] || [])
                            })
                        }
                        return summaryCells
                    },
                    _getSummaryCells: function(summaryTotalItems, totalAggregates) {
                        var that = this,
                            columnsController = that._columnsController;
                        return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), function(summaryItem, column) {
                            return that._isDataColumn(column) ? column.index : -1
                        })
                    },
                    _updateItemsCore: function(change) {
                        var summaryCells, totalAggregates, that = this,
                            dataSource = that._dataSource,
                            summaryTotalItems = that.option("summary.totalItems");
                        that.callBase(change);
                        that._footerItems = [];
                        if (dataSource && summaryTotalItems && summaryTotalItems.length) {
                            totalAggregates = dataSource.totalAggregates();
                            summaryCells = this._getSummaryCells(summaryTotalItems, totalAggregates);
                            if (summaryCells.length) {
                                that._footerItems.push({
                                    rowType: "totalFooter",
                                    summaryCells: summaryCells
                                })
                            }
                        }
                    },
                    _getAggregates: function(summaryItems, remoteOperations) {
                        var that = this,
                            columnsController = that.getController("columns"),
                            calculateCustomSummary = that.option("summary.calculateCustomSummary"),
                            commonSkipEmptyValues = that.option("summary.skipEmptyValues");
                        return $.map(summaryItems || [], function(summaryItem) {
                            var options, column = columnsController.columnOption(summaryItem.column),
                                calculateCellValue = column && column.calculateCellValue ? column.calculateCellValue.bind(column) : compileGetter(column ? column.dataField : summaryItem.column),
                                aggregator = summaryItem.summaryType || "count",
                                selector = summaryItem.column,
                                skipEmptyValues = commonUtils.isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues;
                            if (remoteOperations) {
                                return {
                                    selector: summaryItem.column,
                                    summaryType: summaryItem.summaryType
                                }
                            } else {
                                if ("avg" === aggregator || "sum" === aggregator) {
                                    selector = function(data) {
                                        var value = calculateCellValue(data);
                                        return commonUtils.isDefined(value) ? Number(value) : value
                                    }
                                } else {
                                    selector = calculateCellValue
                                }
                                if ("custom" === aggregator) {
                                    if (!calculateCustomSummary) {
                                        errors.log("E1026");
                                        calculateCustomSummary = function() {}
                                    }
                                    options = {
                                        component: that.component,
                                        name: summaryItem.name
                                    };
                                    calculateCustomSummary(options);
                                    options.summaryProcess = "calculate";
                                    aggregator = {
                                        seed: function() {
                                            options.summaryProcess = "start";
                                            options.totalValue = void 0;
                                            delete options.value;
                                            calculateCustomSummary(options);
                                            return options.totalValue
                                        },
                                        step: function(totalValue, value) {
                                            options.summaryProcess = "calculate";
                                            options.totalValue = totalValue;
                                            options.value = value;
                                            calculateCustomSummary(options);
                                            return options.totalValue
                                        },
                                        finalize: function(totalValue) {
                                            options.summaryProcess = "finalize";
                                            options.totalValue = totalValue;
                                            delete options.value;
                                            calculateCustomSummary(options);
                                            return options.totalValue
                                        }
                                    }
                                }
                                return {
                                    selector: selector,
                                    aggregator: aggregator,
                                    skipEmptyValues: skipEmptyValues
                                }
                            }
                        })
                    },
                    _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
                        var groupIndex;
                        if (groupColumn) {
                            groupIndex = groupColumn.groupIndex;
                            sortOrder = sortOrder || groupColumn.sortOrder;
                            if (commonUtils.isDefined(groupIndex)) {
                                sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
                                sortByGroups[groupIndex].push({
                                    selector: selector,
                                    desc: "desc" === sortOrder
                                })
                            }
                        }
                    },
                    _findSummaryItem: function(summaryItems, name) {
                        var summaryItemIndex = -1;
                        var getFullName = function(summaryItem) {
                            var summaryType = summaryItem.summaryType,
                                column = summaryItem.column;
                            return summaryType && column && summaryType + "_" + column
                        };
                        if (commonUtils.isDefined(name)) {
                            $.each(summaryItems || [], function(index) {
                                if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
                                    summaryItemIndex = index;
                                    return false
                                }
                            })
                        }
                        return summaryItemIndex
                    },
                    _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
                        var that = this,
                            columnsController = that._columnsController,
                            groupColumns = columnsController.getGroupColumns(),
                            sortByGroups = [];
                        if (!groupSummaryItems || !groupSummaryItems.length) {
                            return
                        }
                        $.each(sortByGroupSummaryInfo || [], function() {
                            var sortOrder = this.sortOrder,
                                groupColumn = this.groupColumn,
                                summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
                            if (summaryItemIndex < 0) {
                                return
                            }
                            var selector = function(data) {
                                return getGroupAggregates(data)[summaryItemIndex]
                            };
                            if (commonUtils.isDefined(groupColumn)) {
                                groupColumn = columnsController.columnOption(groupColumn);
                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                            } else {
                                $.each(groupColumns, function(groupIndex, groupColumn) {
                                    that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                })
                            }
                        });
                        return sortByGroups
                    },
                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                        var that = this,
                            dataSourceAdapter = this.callBase(dataSource, remoteOperations);
                        dataSourceAdapter.summaryGetter(function(currentRemoteOperations) {
                            return that._getSummaryOptions(currentRemoteOperations || remoteOperations)
                        });
                        return dataSourceAdapter
                    },
                    _getSummaryOptions: function(remoteOperations) {
                        var that = this,
                            groupSummaryItems = that.option("summary.groupItems"),
                            totalSummaryItems = that.option("summary.totalItems"),
                            sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
                            groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary),
                            totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary),
                            sortByGroups = function() {
                                return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
                            };
                        if (groupAggregates.length || totalAggregates.length) {
                            return {
                                groupAggregates: groupAggregates,
                                totalAggregates: totalAggregates,
                                sortByGroups: sortByGroups
                            }
                        }
                    },
                    publicMethods: function() {
                        var methods = this.callBase();
                        methods.push("getTotalSummaryValue");
                        return methods
                    },
                    getTotalSummaryValue: function(summaryItemName) {
                        var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
                            aggregates = this._dataSource.totalAggregates();
                        if (aggregates.length && summaryItemIndex > -1) {
                            return aggregates[summaryItemIndex]
                        }
                    },
                    optionChanged: function(args) {
                        if ("summary" === args.name || "sortByGroupSummaryInfo" === args.name) {
                            args.name = "dataSource"
                        }
                        this.callBase(args)
                    },
                    init: function() {
                        this._footerItems = [];
                        this.callBase()
                    },
                    footerItems: function() {
                        return this._footerItems
                    }
                }
            }()
        },
        views: {
            rowsView: function() {
                return {
                    _createRow: function(row) {
                        var $row = this.callBase(row);
                        row && $row.addClass(row.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
                        return $row
                    },
                    _renderCells: function($row, options) {
                        this.callBase.apply(this, arguments);
                        if ("group" === options.row.rowType && options.row.summaryCells && options.row.summaryCells.length) {
                            this._renderGroupSummaryCells($row, options)
                        }
                    },
                    _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                        return !commonUtils.isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length
                    },
                    _getAlignByColumnCellCount: function(groupCellColSpan, options) {
                        var columnIndex, alignByColumnCellCount = 0;
                        for (var i = 1; i < groupCellColSpan; i++) {
                            columnIndex = options.row.summaryCells.length - i;
                            alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount
                        }
                        return alignByColumnCellCount
                    },
                    _renderGroupSummaryCells: function($row, options) {
                        var $groupCell = $row.children().last(),
                            groupCellColSpan = Number($groupCell.attr("colspan")) || 1,
                            alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                        this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                    },
                    _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                        if (alignByColumnCellCount > 0) {
                            $groupCell.attr("colspan", groupCellColSpan - alignByColumnCellCount);
                            for (var i = 0; i < alignByColumnCellCount; i++) {
                                var columnIndex = options.columns.length - alignByColumnCellCount + i;
                                this._renderCell($groupCell.parent(), extend({
                                    column: options.columns[columnIndex],
                                    columnIndex: this._getSummaryCellIndex(columnIndex, options.columns)
                                }, options))
                            }
                        }
                    },
                    _getSummaryCellIndex: function(columnIndex) {
                        return columnIndex
                    },
                    _getCellTemplate: function(options) {
                        if (!options.column.command && !commonUtils.isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length) {
                            return renderSummaryCell
                        } else {
                            return this.callBase(options)
                        }
                    },
                    _getCellOptions: function(options) {
                        var that = this,
                            parameters = that.callBase(options);
                        if (options.row.summaryCells) {
                            return extend(parameters, getSummaryCellOptions(that, options))
                        } else {
                            return parameters
                        }
                    }
                }
            }()
        }
    }
});


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/aggregate_calculator.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var Class = __webpack_require__(5),
    compileGetter = __webpack_require__(14).compileGetter,
    isFunction = __webpack_require__(2).isFunction,
    errors = __webpack_require__(29).errors,
    dataUtils = __webpack_require__(28);

function depthFirstSearch(i, depth, root, callback) {
    var j = 0;
    if (i < depth) {
        for (; j < root.items.length; j++) {
            depthFirstSearch(i + 1, depth, root.items[j], callback)
        }
    }
    if (i === depth) {
        callback(root)
    }
}

function map(array, callback) {
    var i, result;
    if ("map" in array) {
        return array.map(callback)
    }
    result = new Array(array.length);
    for (i in array) {
        result[i] = callback(array[i], i)
    }
    return result
}

function isEmpty(x) {
    return x !== x || "" === x || null === x || void 0 === x
}

function isCount(aggregator) {
    return aggregator === dataUtils.aggregators.count
}

function normalizeAggregate(aggregate) {
    var selector = compileGetter(aggregate.selector),
        skipEmptyValues = "skipEmptyValues" in aggregate ? aggregate.skipEmptyValues : true,
        aggregator = aggregate.aggregator;
    if ("string" === typeof aggregator) {
        aggregator = dataUtils.aggregators[aggregator];
        if (!aggregator) {
            throw errors.Error("E4001", aggregate.aggregator)
        }
    }
    return {
        selector: selector,
        aggregator: aggregator,
        skipEmptyValues: skipEmptyValues
    }
}
module.exports = Class.inherit({
    ctor: function(options) {
        this._data = options.data;
        this._groupLevel = options.groupLevel || 0;
        this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);
        this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);
        this._totals = []
    },
    calculate: function() {
        if (this._totalAggregates.length) {
            this._calculateTotals(0, {
                items: this._data
            })
        }
        if (this._groupAggregates.length && this._groupLevel > 0) {
            this._calculateGroups({
                items: this._data
            })
        }
    },
    totalAggregates: function() {
        return this._totals
    },
    _aggregate: function(aggregates, data, container) {
        var i, j;
        for (i = 0; i < aggregates.length; i++) {
            if (isCount(aggregates[i].aggregator)) {
                container[i] = (container[i] || 0) + data.items.length;
                continue
            }
            for (j = 0; j < data.items.length; j++) {
                this._accumulate(i, aggregates[i], container, data.items[j])
            }
        }
    },
    _calculateTotals: function(level, data) {
        var i;
        if (0 === level) {
            this._totals = this._seed(this._totalAggregates)
        }
        if (level === this._groupLevel) {
            this._aggregate(this._totalAggregates, data, this._totals)
        } else {
            for (i = 0; i < data.items.length; i++) {
                this._calculateTotals(level + 1, data.items[i])
            }
        }
        if (0 === level) {
            this._totals = this._finalize(this._totalAggregates, this._totals)
        }
    },
    _calculateGroups: function(root) {
        var maxLevel = this._groupLevel,
            currentLevel = maxLevel + 1,
            seedFn = this._seed.bind(this, this._groupAggregates),
            stepFn = this._aggregate.bind(this, this._groupAggregates),
            finalizeFn = this._finalize.bind(this, this._groupAggregates);

        function aggregator(node) {
            node.aggregates = seedFn();
            if (currentLevel === maxLevel) {
                stepFn(node, node.aggregates)
            } else {
                depthFirstSearch(currentLevel, maxLevel, node, function(innerNode) {
                    stepFn(innerNode, node.aggregates)
                })
            }
            node.aggregates = finalizeFn(node.aggregates)
        }
        while (--currentLevel > 0) {
            depthFirstSearch(0, currentLevel, root, aggregator)
        }
    },
    _seed: function(aggregates) {
        return map(aggregates, function(aggregate) {
            var aggregator = aggregate.aggregator,
                seed = "seed" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed : NaN;
            return seed
        })
    },
    _accumulate: function(aggregateIndex, aggregate, results, item) {
        var value = aggregate.selector(item),
            aggregator = aggregate.aggregator,
            skipEmptyValues = aggregate.skipEmptyValues;
        if (skipEmptyValues && isEmpty(value)) {
            return
        }
        if (results[aggregateIndex] !== results[aggregateIndex]) {
            results[aggregateIndex] = value
        } else {
            results[aggregateIndex] = aggregator.step(results[aggregateIndex], value)
        }
    },
    _finalize: function(aggregates, results) {
        return map(aggregates, function(aggregate, index) {
            var fin = aggregate.aggregator.finalize;
            return fin ? fin(results[index]) : results[index]
        })
    }
});


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.column_fixing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    columnFixingModule = __webpack_require__(239);
gridCore.registerModule("columnFixing", columnFixingModule);


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.adaptivity.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(12),
    adaptivityModule = __webpack_require__(240);
gridCore.registerModule("adaptivity", adaptivityModule);


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/data_grid/ui.data_grid.export.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    Class = __webpack_require__(5),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    getDefaultAlignment = __webpack_require__(57).getDefaultAlignment,
    dataGridCore = __webpack_require__(12),
    exportMixin = __webpack_require__(390),
    clientExporter = __webpack_require__(133),
    messageLocalization = __webpack_require__(8),
    excelExporter = clientExporter.excel,
    Button = __webpack_require__(25),
    List = __webpack_require__(79),
    ContextMenu = __webpack_require__(130),
    when = __webpack_require__(10).when;
var DATAGRID_EXPORT_MENU_CLASS = "dx-datagrid-export-menu",
    DATAGRID_EXPORT_BUTTON_CLASS = "dx-datagrid-export-button",
    DATAGRID_EXPORT_ICON = "export-to",
    DATAGRID_EXPORT_EXCEL_ICON = "exportxlsx",
    DATAGRID_EXPORT_SELECTED_ICON = "exportselected",
    DATAGRID_EXPORT_EXCEL_BUTTON_ICON = "export-excel-button",
    DATA_STYLE_OFFSET = 3;
exports.DataProvider = Class.inherit({
    _getGroupValue: function(item) {
        var visibleIndex, groupColumn = this._options.groupColumns[item.groupIndex],
            value = dataGridCore.getDisplayValue(groupColumn, item.values[item.groupIndex], item.data, item.rowType),
            result = groupColumn.caption + ": " + dataGridCore.formatValue(value, groupColumn);
        visibleIndex = this._options.getVisibleIndex(groupColumn.index);
        if (item.summaryCells && item.summaryCells.length && item.summaryCells[visibleIndex].length) {
            result += " " + dataGridCore.getGroupRowSummaryText(item.summaryCells[visibleIndex], this._options.summaryTexts)
        }
        return result
    },
    _correctCellIndex: function(cellIndex) {
        var startIndex = this._options.startValueIndex,
            endIndex = this._options.endValueIndex;
        return cellIndex <= endIndex ? startIndex + cellIndex : null
    },
    _initOptions: function() {
        var exportController = this._exportController,
            groupColumns = exportController._columnsController.getGroupColumns(),
            startEndIndexes = exportController._getStartEndValueIndexes(exportController._columnsController.getVisibleColumns()),
            excelWrapTextEnabled = exportController.option("export.excelWrapTextEnabled");
        this._options = {
            columns: exportController._getColumns(),
            groupColumns: groupColumns,
            items: !!exportController._selectionOnly ? exportController._getSelectedItems() : exportController._getAllItems(),
            getVisibleIndex: exportController._columnsController.getVisibleIndex.bind(exportController._columnsController),
            startValueIndex: startEndIndexes.startIndex,
            endValueIndex: startEndIndexes.endIndex,
            isHeadersVisible: exportController.option("showColumnHeaders"),
            summaryTexts: exportController.option("summary.texts"),
            customizeExportData: exportController.option("customizeExportData"),
            rtlEnabled: exportController.option("rtlEnabled"),
            wrapTextEnabled: commonUtils.isDefined(excelWrapTextEnabled) ? excelWrapTextEnabled : !!exportController.option("wordWrapEnabled")
        }
    },
    ctor: function(exportController) {
        this._exportController = exportController
    },
    getStyles: function() {
        var wrapTextEnabled = this._options.wrapTextEnabled,
            styles = ["center", "left", "right"].map(function(alignment) {
                return {
                    bold: true,
                    alignment: alignment,
                    wrapText: true
                }
            });
        this.getColumns().forEach(function(column) {
            styles.push({
                alignment: column.alignment || "left",
                format: column.format,
                precision: column.precision,
                wrapText: wrapTextEnabled,
                dataType: column.dataType
            })
        });
        styles.push({
            bold: true,
            wrapText: false,
            alignment: getDefaultAlignment(this._options.rtlEnabled)
        });
        return styles
    },
    _getTotalCellStyleId: function(cellIndex) {
        var alignment = this.getColumns()[cellIndex] && this.getColumns()[cellIndex].alignment || "right";
        return ["center", "left", "right"].indexOf(alignment)
    },
    getStyleId: function(rowIndex, cellIndex) {
        if (rowIndex < this.getHeaderRowCount()) {
            return 0
        } else {
            if (this.isTotalCell(rowIndex - this.getHeaderRowCount(), cellIndex)) {
                return this._getTotalCellStyleId(cellIndex)
            } else {
                if (this.isGroupRow(rowIndex - this.getHeaderRowCount())) {
                    return DATA_STYLE_OFFSET + this.getColumns().length
                } else {
                    return cellIndex + DATA_STYLE_OFFSET
                }
            }
        }
    },
    getColumns: function(getColumnsByAllRows) {
        var columns = this._options.columns;
        return getColumnsByAllRows ? columns : columns[columns.length - 1]
    },
    getRowsCount: function() {
        return this._options.items.length + this.getHeaderRowCount()
    },
    getHeaderRowCount: function() {
        if (this.isHeadersVisible()) {
            return this._options.columns.length - 1
        }
        return 0
    },
    isGroupRow: function(rowIndex) {
        return rowIndex < this._options.items.length && "group" === this._options.items[rowIndex].rowType
    },
    getGroupLevel: function(rowIndex) {
        var item = this._options.items[rowIndex - this.getHeaderRowCount()],
            groupIndex = item && item.groupIndex;
        if (item && "totalFooter" === item.rowType) {
            return 0
        }
        return commonUtils.isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length
    },
    getCellType: function(rowIndex, cellIndex) {
        var columns = this.getColumns();
        if (rowIndex < this.getHeaderRowCount()) {
            return "string"
        } else {
            rowIndex -= this.getHeaderRowCount()
        }
        if (cellIndex < columns.length) {
            var item = this._options.items.length && this._options.items[rowIndex],
                column = columns[cellIndex];
            if (item && "data" === item.rowType) {
                if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !commonUtils.isDefined(column.customizeText)) {
                    return commonUtils.isDefined(column.lookup) ? column.lookup.dataType : column.dataType
                }
            }
            return "string"
        }
    },
    ready: function() {
        var options, that = this;
        that._initOptions();
        options = this._options;
        return when(options.items).done(function(items) {
            options.customizeExportData && options.customizeExportData(that.getColumns(that.getHeaderRowCount() > 1), items);
            options.items = items
        }).fail(function() {
            options.items = []
        })
    },
    _getHeaderCellValue: function(rowIndex, cellIndex) {
        var row = this.getColumns(true)[rowIndex];
        return row[cellIndex] && row[cellIndex].caption
    },
    getCellValue: function(rowIndex, cellIndex) {
        var column, value, i, summaryItems, itemValues, item, columns = this.getColumns(),
            correctedCellIndex = this._correctCellIndex(cellIndex);
        if (rowIndex < this.getHeaderRowCount()) {
            return this._getHeaderCellValue(rowIndex, cellIndex)
        } else {
            rowIndex -= this.getHeaderRowCount()
        }
        item = this._options.items.length && this._options.items[rowIndex];
        if (item) {
            itemValues = item.values;
            switch (item.rowType) {
                case "groupFooter":
                case "totalFooter":
                    if (correctedCellIndex < itemValues.length) {
                        value = itemValues[correctedCellIndex];
                        if (commonUtils.isDefined(value)) {
                            return dataGridCore.getSummaryText(value, this._options.summaryTexts)
                        }
                    }
                    break;
                case "group":
                    if (cellIndex < 1) {
                        return this._getGroupValue(item)
                    } else {
                        summaryItems = item.values[correctedCellIndex];
                        if (Array.isArray(summaryItems)) {
                            value = "";
                            for (i = 0; i < summaryItems.length; i++) {
                                value += (i > 0 ? " \n " : "") + dataGridCore.getSummaryText(summaryItems[i], this._options.summaryTexts)
                            }
                            return value
                        }
                    }
                    break;
                default:
                    column = columns[cellIndex];
                    if (column) {
                        value = dataGridCore.getDisplayValue(column, itemValues[correctedCellIndex], item.data, item.rowType);
                        return !isFinite(value) || column.customizeText ? dataGridCore.formatValue(value, column) : value
                    }
            }
        }
    },
    isHeadersVisible: function() {
        return this._options.isHeadersVisible
    },
    isTotalCell: function(rowIndex, cellIndex) {
        var items = this._options.items,
            item = items[rowIndex],
            correctCellIndex = this._correctCellIndex(cellIndex),
            isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
        return item && "groupFooter" === item.rowType || "totalFooter" === item.rowType || isSummaryAlignByColumn
    },
    getCellMerging: function(rowIndex, cellIndex) {
        var columns = this._options.columns,
            column = columns[rowIndex] && columns[rowIndex][cellIndex];
        return column ? {
            colspan: (column.colspan || 1) - 1,
            rowspan: (column.rowspan || 1) - 1
        } : {
            colspan: 0,
            rowspan: 0
        }
    },
    getFrozenArea: function() {
        var that = this;
        return {
            x: 0,
            y: that.getHeaderRowCount()
        }
    }
});
exports.ExportController = dataGridCore.ViewController.inherit({}).include(exportMixin).inherit({
    _getEmptyCell: function() {
        return {
            caption: "",
            colspan: 1,
            rowspan: 1
        }
    },
    _updateColumnWidth: function(column, width) {
        column.width = width
    },
    _getColumns: function() {
        var i, j, column, columns, result = [],
            columnsController = this._columnsController,
            rowCount = columnsController.getRowCount(),
            columnWidths = this._headersView && this._headersView.isVisible() ? this._headersView.getColumnWidths() : this._rowsView.getColumnWidths();
        for (i = 0; i <= rowCount; i++) {
            result.push([]);
            columns = columnsController.getVisibleColumns(i);
            for (j = 0; j < columns.length; j++) {
                column = extend({}, columns[j]);
                if (column.allowExporting && !column.command) {
                    if (i === rowCount && columnWidths && columnWidths.length) {
                        this._updateColumnWidth(column, columnWidths[j])
                    }
                    result[i].push(column)
                }
            }
        }
        columns = result[rowCount];
        result = this._prepareItems(0, result.slice(0, -1));
        result.push(columns);
        return result
    },
    _getFooterSummaryItems: function(summaryCells, isTotal) {
        var values, itemsLength, summaryCell, j, result = [],
            estimatedItemsCount = 1,
            i = 0;
        do {
            values = [];
            for (j = 0; j < summaryCells.length; j++) {
                summaryCell = summaryCells[j];
                itemsLength = summaryCell.length;
                if (estimatedItemsCount < itemsLength) {
                    estimatedItemsCount = itemsLength
                }
                values.push(summaryCell[i])
            }
            result.push({
                values: values,
                rowType: isTotal ? "totalFooter" : "groupFooter"
            })
        } while (i++ < estimatedItemsCount - 1);
        return result
    },
    _hasSummaryGroupFooters: function() {
        var i, groupItems = this.option("summary.groupItems");
        if (commonUtils.isDefined(groupItems)) {
            for (i = 0; i < groupItems.length; i++) {
                if (groupItems[i].showInGroupFooter) {
                    return true
                }
            }
        }
        return false
    },
    _getItemsWithSummaryGroupFooters: function(sourceItems) {
        var item, i, result = [],
            beforeGroupFooterItems = [],
            groupFooterItems = [];
        for (i = 0; i < sourceItems.length; i++) {
            item = sourceItems[i];
            if ("groupFooter" === item.rowType) {
                groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
                result = result.concat(beforeGroupFooterItems, groupFooterItems);
                beforeGroupFooterItems = []
            } else {
                beforeGroupFooterItems.push(item)
            }
        }
        return result.length ? result : beforeGroupFooterItems
    },
    _updateGroupValuesWithSummaryByColumn: function(sourceItems) {
        var item, summaryCells, summaryItem, groupColumnCount, k, j, i, summaryValues = [];
        for (i = 0; i < sourceItems.length; i++) {
            item = sourceItems[i];
            summaryCells = item.summaryCells;
            if ("group" === item.rowType && summaryCells && summaryCells.length > 1) {
                groupColumnCount = item.values.length;
                for (j = 1; j < summaryCells.length; j++) {
                    for (k = 0; k < summaryCells[j].length; k++) {
                        summaryItem = summaryCells[j][k];
                        if (summaryItem && summaryItem.alignByColumn) {
                            if (!Array.isArray(summaryValues[j - groupColumnCount])) {
                                summaryValues[j - groupColumnCount] = []
                            }
                            summaryValues[j - groupColumnCount].push(summaryItem)
                        }
                    }
                }
                if (summaryValues.length > 0) {
                    $.merge(item.values, summaryValues);
                    summaryValues = []
                }
            }
        }
    },
    _processUnExportedItems: function(items) {
        var item, column, values, i, j, columns = this._columnsController.getVisibleColumns();
        for (i = 0; i < items.length; i++) {
            item = items[i];
            values = [];
            if ("group" === item.rowType) {
                continue
            }
            for (j = 0; j < columns.length; j++) {
                column = columns[j];
                if ((commonUtils.isDefined(column.command) || column.allowExporting) && item.values) {
                    values.push(item.values[j])
                }
            }
            if (values.length) {
                item.values = values
            }
        }
    },
    _getAllItems: function(data) {
        var summaryCells, summaryItems, that = this,
            d = $.Deferred(),
            dataController = this.getController("data"),
            footerItems = dataController.footerItems(),
            totalItem = footerItems.length && footerItems[0],
            summaryTotalItems = that.option("summary.totalItems");
        when(data).done(function(data) {
            dataController.loadAll(data).done(function(sourceItems, totalAggregates) {
                that._updateGroupValuesWithSummaryByColumn(sourceItems);
                if (that._hasSummaryGroupFooters()) {
                    sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems)
                }
                summaryCells = totalItem && totalItem.summaryCells;
                if (commonUtils.isDefined(totalAggregates) && summaryTotalItems) {
                    summaryCells = dataController._getSummaryCells(summaryTotalItems, totalAggregates)
                }
                summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
                if (summaryItems) {
                    sourceItems = sourceItems.concat(summaryItems)
                }
                that._processUnExportedItems(sourceItems);
                d.resolve(sourceItems)
            }).fail(d.reject)
        }).fail(d.reject);
        return d
    },
    _getSelectedItems: function() {
        var selectionController = this.getController("selection"),
            selectedRowData = selectionController.getSelectedRowsData();
        return this._getAllItems(selectedRowData)
    },
    _getStartEndValueIndexes: function(visibleColumns) {
        var i, startIndex, endIndex, visibleColumnsLength = visibleColumns.length;
        for (i = 0; i < visibleColumnsLength; i++) {
            if (!commonUtils.isDefined(visibleColumns[i].command)) {
                startIndex = i;
                break
            }
        }
        for (i = visibleColumnsLength - 1; i >= 0; i--) {
            if (!commonUtils.isDefined(visibleColumns[i].command)) {
                endIndex = i;
                break
            }
        }
        return {
            startIndex: startIndex,
            endIndex: endIndex
        }
    },
    init: function() {
        this._columnsController = this.getController("columns");
        this._rowsView = this.getView("rowsView");
        this._headersView = this.getView("columnHeadersView");
        this.createAction("onExporting", {
            excludeValidators: ["disabled", "readOnly"]
        });
        this.createAction("onExported", {
            excludeValidators: ["disabled", "readOnly"]
        });
        this.createAction("onFileSaving", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    callbackNames: function() {
        return ["selectionOnlyChanged"]
    },
    getExportFormat: function() {
        return ["EXCEL"]
    },
    getDataProvider: function() {
        return new exports.DataProvider(this)
    },
    exportToExcel: function(selectionOnly) {
        var that = this;
        that._selectionOnly = selectionOnly;
        clientExporter.export(that.component.getDataProvider(), {
            fileName: that.option("export.fileName"),
            proxyUrl: that.option("export.proxyUrl"),
            format: "EXCEL",
            autoFilterEnabled: !!that.option("export.excelFilterEnabled"),
            rtlEnabled: that.option("rtlEnabled"),
            exportingAction: that.getAction("onExporting"),
            exportedAction: that.getAction("onExported"),
            fileSavingAction: that.getAction("onFileSaving")
        }, excelExporter.getData)
    },
    publicMethods: function() {
        return ["getDataProvider", "getExportFormat", "exportToExcel"]
    },
    selectionOnly: function(value) {
        if (commonUtils.isDefined(value)) {
            this._isSelectedRows = value;
            this.selectionOnlyChanged.fire()
        } else {
            return this._isSelectedRows
        }
    }
});
dataGridCore.registerModule("export", {
    defaultOptions: function() {
        return {
            "export": {
                enabled: false,
                fileName: "DataGrid",
                excelFilterEnabled: false,
                excelWrapTextEnabled: void 0,
                proxyUrl: void 0,
                allowExportSelectedData: false,
                texts: {
                    exportTo: messageLocalization.format("dxDataGrid-exportTo"),
                    exportAll: messageLocalization.format("dxDataGrid-exportAll"),
                    exportSelectedRows: messageLocalization.format("dxDataGrid-exportSelectedRows")
                }
            }
        }
    },
    controllers: {
        "export": exports.ExportController
    },
    extenders: {
        controllers: {
            editing: {
                callbackNames: function() {
                    var callbackList = this.callBase();
                    return commonUtils.isDefined(callbackList) ? callbackList.push("editingChanged") : ["editingChanged"]
                },
                _updateEditButtons: function() {
                    this.callBase();
                    this.editingChanged.fire(this.hasChanges())
                }
            }
        },
        views: {
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase();
                    return this._appendExportItems(items)
                },
                _appendExportItems: function(items) {
                    var that = this,
                        exportOptions = that.option("export");
                    if (exportOptions.enabled) {
                        var exportItems = [];
                        if (exportOptions.allowExportSelectedData) {
                            exportItems.push({
                                template: function(data, index, $container) {
                                    that._renderButton(data, $container);
                                    that._renderExportMenu($container)
                                },
                                menuItemTemplate: function(data, index, $container) {
                                    that._renderList(data, $container)
                                },
                                name: "exportButton",
                                allowExportSelected: true,
                                location: "after",
                                locateInMenu: "auto",
                                sortIndex: 30
                            })
                        } else {
                            exportItems.push({
                                template: function(data, index, $container) {
                                    that._renderButton(data, $container)
                                },
                                menuItemTemplate: function(data, index, $container) {
                                    that._renderButton(data, $container, true)
                                },
                                name: "exportButton",
                                location: "after",
                                locateInMenu: "auto",
                                sortIndex: 30
                            })
                        }
                        items = items.concat(exportItems);
                        that._correctItemsPosition(items)
                    }
                    return items
                },
                _renderButton: function(data, $container, withText) {
                    var that = this,
                        buttonOptions = that._getButtonOptions(data.allowExportSelected),
                        $buttonContainer = that._getButtonContainer().addClass(DATAGRID_EXPORT_BUTTON_CLASS).appendTo($container);
                    if (withText) {
                        $container.wrapInner("<div class='dx-toolbar-item-auto-hide'></div>").parent().addClass("dx-toolbar-menu-action dx-toolbar-menu-button dx-toolbar-hidden-button");
                        buttonOptions.text = buttonOptions.hint
                    }
                    that._createComponent($buttonContainer, Button, buttonOptions)
                },
                _renderList: function(data, $container) {
                    var that = this,
                        texts = that.option("export.texts"),
                        renderFakeButton = function(data, $container, iconName) {
                            var $icon = $("<div />").addClass("dx-icon dx-icon-" + iconName),
                                $text = $("<span class='dx-button-text'/>").text(data.text),
                                $content = $("<div class='dx-button-content' />").append($icon).append($text),
                                $button = $("<div class='dx-button dx-button-has-text dx-button-has-icon dx-datagrid-toolbar-button'>").append($content),
                                $toolbarItem = $("<div class ='dx-toolbar-item-auto-hide' />").append($button);
                            $container.append($toolbarItem).parent().addClass("dx-toolbar-menu-custom dx-toolbar-hidden-button")
                        },
                        items = [{
                            template: function(data, index, $container) {
                                renderFakeButton(data, $container, DATAGRID_EXPORT_EXCEL_ICON)
                            },
                            text: texts.exportAll
                        }, {
                            template: function(data, index, $container) {
                                renderFakeButton(data, $container, DATAGRID_EXPORT_SELECTED_ICON)
                            },
                            text: texts.exportSelectedRows,
                            exportSelected: true
                        }];
                    that._createComponent($container, List, {
                        items: items,
                        onItemClick: function(e) {
                            that._exportController.exportToExcel(e.itemData.exportSelected)
                        },
                        scrollingEnabled: false
                    })
                },
                _correctItemsPosition: function(items) {
                    items.sort(function(itemA, itemB) {
                        return itemA.sortIndex - itemB.sortIndex
                    })
                },
                _renderExportMenu: function($buttonContainer) {
                    var that = this,
                        $button = $buttonContainer.find(".dx-button"),
                        texts = that.option("export.texts"),
                        menuItems = [{
                            text: texts.exportAll,
                            icon: DATAGRID_EXPORT_EXCEL_ICON
                        }, {
                            text: texts.exportSelectedRows,
                            exportSelected: true,
                            icon: DATAGRID_EXPORT_SELECTED_ICON
                        }],
                        $menuContainer = $("<div>").appendTo($buttonContainer);
                    that._contextMenu = that._createComponent($menuContainer, ContextMenu, {
                        showEvent: "dxclick",
                        items: menuItems,
                        cssClass: DATAGRID_EXPORT_MENU_CLASS,
                        onItemClick: function(e) {
                            that._exportController.exportToExcel(e.itemData.exportSelected)
                        },
                        target: $button,
                        position: {
                            at: "left bottom",
                            my: "left top",
                            offset: "0 3",
                            collision: "fit",
                            boundary: that._$parent,
                            boundaryOffset: "1 1"
                        }
                    })
                },
                _isExportButtonVisible: function() {
                    return this.option("export.enabled")
                },
                _getButtonOptions: function(allowExportSelected) {
                    var options, that = this,
                        texts = that.option("export.texts");
                    if (allowExportSelected) {
                        options = {
                            hint: texts.exportTo,
                            icon: DATAGRID_EXPORT_ICON
                        }
                    } else {
                        options = {
                            hint: texts.exportAll,
                            icon: DATAGRID_EXPORT_EXCEL_BUTTON_ICON,
                            onClick: function() {
                                that._exportController.exportToExcel()
                            }
                        }
                    }
                    return options
                },
                optionChanged: function(args) {
                    this.callBase(args);
                    if ("export" === args.name) {
                        args.handled = true;
                        this._invalidate()
                    }
                },
                init: function() {
                    var that = this;
                    this.callBase();
                    this._exportController = this.getController("export");
                    this._editingController = this.getController("editing");
                    this._editingController.editingChanged.add(function(hasChanges) {
                        that.setToolbarItemDisabled("exportButton", hasChanges)
                    })
                },
                isVisible: function() {
                    return this.callBase() || this._isExportButtonVisible()
                }
            }
        }
    }
});


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/grid_core/ui.grid_core.export_mixin.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend;
module.exports = {
    _getEmptyCell: function() {
        return {
            text: "",
            value: void 0,
            colspan: 1,
            rowspan: 1
        }
    },
    _defaultSetter: function(value) {
        value = parseInt(value, 10);
        return !value ? 1 : value
    },
    _makeRowOffset: function(resultItems) {
        var offset = 0,
            rowIndex = resultItems.length - 1,
            row = resultItems[rowIndex],
            cellIndex = row.length;
        $.each(resultItems, function(rowIndex) {
            if (this[cellIndex] && this[cellIndex].rowspan + rowIndex > resultItems.length - 1) {
                offset = Math.max.apply(this, [this[cellIndex].colspan, offset])
            }
        });
        for (var i = 0; i < offset; i++) {
            row.push(this._cloneItem(resultItems[resultItems.length - 2][cellIndex && cellIndex - 1 || 0]))
        }
        if (offset > 0) {
            this._makeRowOffset(resultItems)
        }
    },
    _cloneItem: function(item) {
        return extend({}, item, this._getEmptyCell())
    },
    _prepareItems: function(cols, items) {
        var i, row, cellIndex, rowIndex, that = this,
            resultItems = [];
        for (rowIndex = 0; rowIndex < items.length; rowIndex++) {
            row = [];
            resultItems.push(row);
            do {
                that._makeRowOffset(resultItems);
                cellIndex = row.length;
                row.push(items[rowIndex].shift());
                if (row[row.length - 1]) {
                    row[row.length - 1].colspan = that._defaultSetter(row[row.length - 1].colspan);
                    row[row.length - 1].rowspan = that._defaultSetter(row[row.length - 1].rowspan)
                } else {
                    row[row.length - 1] = $({}, that._getEmptyCell())
                }
                for (i = 1; i < row[cellIndex].colspan; i++) {
                    row.push(that._cloneItem(row[row.length - 1]))
                }
            } while (items[rowIndex].length);
            while (row.length < cols) {
                row.push(that._cloneItem(row[row.length - 1]))
            }
        }
        return resultItems
    }
};


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

module.exports = __webpack_require__(392);
module.exports.default = module.exports;


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var TreeList = __webpack_require__(393);
module.exports = TreeList;
__webpack_require__(403);
__webpack_require__(404);
__webpack_require__(405);
__webpack_require__(407);
__webpack_require__(408);
__webpack_require__(409);
__webpack_require__(410);
__webpack_require__(411);
__webpack_require__(412);
__webpack_require__(413);
__webpack_require__(414);
__webpack_require__(415);
__webpack_require__(416);


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.base.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    registerComponent = __webpack_require__(4),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    Widget = __webpack_require__(27),
    treeListCore = __webpack_require__(18),
    callModuleItemsMethod = treeListCore.callModuleItemsMethod;
var DATAGRID_ROW_SELECTOR = ".dx-row",
    TREELIST_CLASS = "dx-treelist";
__webpack_require__(394);
__webpack_require__(395);
__webpack_require__(396);
__webpack_require__(397);
__webpack_require__(398);
__webpack_require__(399);
__webpack_require__(400);
__webpack_require__(401);
__webpack_require__(402);
treeListCore.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "editing", "grouping", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
var TreeList = Widget.inherit({
    _activeStateUnit: DATAGRID_ROW_SELECTOR,
    _getDefaultOptions: function() {
        var that = this,
            result = that.callBase();
        $.each(treeListCore.modules, function() {
            if (commonUtils.isFunction(this.defaultOptions)) {
                extend(true, result, this.defaultOptions())
            }
        });
        return result
    },
    _init: function() {
        var that = this;
        that.callBase();
        treeListCore.processModules(that, treeListCore);
        callModuleItemsMethod(that, "init")
    },
    _clean: commonUtils.noop,
    _optionChanged: function(args) {
        var that = this;
        callModuleItemsMethod(that, "optionChanged", [args]);
        if (!args.handled) {
            that.callBase(args)
        }
    },
    _dimensionChanged: function() {
        this.updateDimensions(true)
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this.updateDimensions()
        }
    },
    _renderContentImpl: function() {
        var $element = this.element().addClass(TREELIST_CLASS);
        this.getView("gridView").render($element)
    },
    _renderContent: function() {
        var that = this;
        commonUtils.deferRender(function() {
            that._renderContentImpl()
        })
    },
    _dispose: function() {
        var that = this;
        that.callBase();
        callModuleItemsMethod(that, "dispose")
    },
    isReady: function() {
        return this.getController("data").isReady()
    },
    beginUpdate: function() {
        var that = this;
        that.callBase();
        callModuleItemsMethod(that, "beginUpdate")
    },
    endUpdate: function() {
        var that = this;
        callModuleItemsMethod(that, "endUpdate");
        that.callBase()
    },
    getController: function(name) {
        return this._controllers[name]
    },
    getView: function(name) {
        return this._views[name]
    },
    focus: function(element) {
        this.callBase();
        if (commonUtils.isDefined(element)) {
            this.getController("keyboardNavigation").focus(element)
        }
    }
});
TreeList.registerModule = treeListCore.registerModule.bind(treeListCore);
registerComponent("dxTreeList", TreeList);
module.exports = TreeList;


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.column_headers.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    columnHeadersViewModule = __webpack_require__(214);
treeListCore.registerModule("columnHeaders", columnHeadersViewModule);


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.columns_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var commonUtils = __webpack_require__(2),
    treeListCore = __webpack_require__(18),
    columnsControllerModule = __webpack_require__(215);
exports.ColumnsController = columnsControllerModule.controllers.columns.inherit(function() {
    return {
        _getFirstItems: function(dataSourceAdapter) {
            return this.callBase(dataSourceAdapter).map(function(node) {
                return node.data
            })
        },
        getFirstDataColumnIndex: function() {
            var visibleColumns = this.getVisibleColumns(),
                visibleColumnsLength = visibleColumns.length,
                firstDataColumnIndex = 0;
            for (var i = 0; i <= visibleColumnsLength - 1; i++) {
                if (!commonUtils.isDefined(visibleColumns[i].command)) {
                    firstDataColumnIndex = visibleColumns[i].index;
                    break
                }
            }
            return firstDataColumnIndex
        }
    }
}());
treeListCore.registerModule("columns", {
    defaultOptions: columnsControllerModule.defaultOptions,
    controllers: {
        columns: exports.ColumnsController
    }
});


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.data_controller.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    extend = __webpack_require__(1).extend,
    treeListCore = __webpack_require__(18),
    dataSourceAdapterProvider = __webpack_require__(241),
    dataControllerModule = __webpack_require__(217);
exports.DataController = dataControllerModule.controllers.data.inherit(function() {
    return {
        _getDataSourceAdapter: function() {
            return dataSourceAdapterProvider
        },
        _getNodeLevel: function(node) {
            var level = -1;
            while (node.parent) {
                if (node.visible) {
                    level++
                }
                node = node.parent
            }
            return level
        },
        _generateDataItem: function(node) {
            return {
                rowType: "data",
                node: node,
                key: node.key,
                data: node.data,
                isExpanded: this.isRowExpanded(node.key),
                level: this._getNodeLevel(node)
            }
        },
        _setPagingOptions: function(dataSource) {
            var isVirtualScrolling = "virtual" === this.option("scrolling.mode");
            dataSource.paginate(isVirtualScrolling);
            dataSource.requireTotalCount(true)
        },
        init: function() {
            this.createAction("onRowExpanding");
            this.createAction("onRowExpanded");
            this.createAction("onRowCollapsing");
            this.createAction("onRowCollapsed");
            this.callBase.apply(this, arguments)
        },
        keyOf: function(data) {
            var dataSource = this._dataSource;
            if (dataSource) {
                return dataSource.keyOf(data)
            }
        },
        key: function() {
            var dataSource = this._dataSource;
            if (dataSource) {
                return dataSource.getKeyExpr()
            }
        },
        publicMethods: function() {
            return this.callBase().concat(["expandRow", "collapseRow", "isRowExpanded", "getRootNode", "getNodeByKey"])
        },
        changeRowExpand: function(key) {
            if (this._dataSource) {
                var that = this,
                    args = {
                        key: key
                    },
                    isExpanded = this.isRowExpanded(key);
                that.executeAction(isExpanded ? "onRowCollapsing" : "onRowExpanding", args);
                if (!args.cancel) {
                    return that._dataSource.changeRowExpand(key).done(function() {
                        that.executeAction(isExpanded ? "onRowCollapsed" : "onRowExpanded", args)
                    })
                }
            }
            return $.Deferred().resolve()
        },
        isRowExpanded: function(key) {
            return this._dataSource && this._dataSource.isRowExpanded(key)
        },
        expandRow: function(key) {
            if (!this.isRowExpanded(key)) {
                return this.changeRowExpand(key)
            }
            return $.Deferred().resolve()
        },
        collapseRow: function(key) {
            if (this.isRowExpanded(key)) {
                return this.changeRowExpand(key)
            }
            return $.Deferred().resolve()
        },
        getRootNode: function() {
            return this._dataSource && this._dataSource.getRootNode()
        },
        optionChanged: function(args) {
            switch (args.name) {
                case "rootValue":
                case "parentIdExpr":
                case "itemsExpr":
                case "filterMode":
                case "expandNodesOnFiltering":
                case "autoExpandAll":
                case "hasItemsExpr":
                case "dataStructure":
                    this._columnsController.reset();
                    this._items = [];
                    this._refreshDataSource();
                    args.handled = true;
                    break;
                case "expandedRowKeys":
                case "onNodesInitialized":
                    this._dataSource && !this._dataSource._isNodesInitializing && this._dataSource.load();
                    args.handled = true;
                    break;
                case "maxFilterLengthInRequest":
                    args.handled = true;
                    break;
                default:
                    this.callBase(args)
            }
        },
        getNodeByKey: function(key) {
            if (!this._dataSource) {
                return
            }
            return this._dataSource.getNodeByKey(key)
        }
    }
}());
treeListCore.registerModule("data", {
    defaultOptions: function() {
        return extend({}, dataControllerModule.defaultOptions(), {
            itemsExpr: "items",
            parentIdExpr: "parentId",
            rootValue: 0,
            dataStructure: "plain",
            expandedRowKeys: [],
            filterMode: "extended",
            expandNodesOnFiltering: true,
            autoExpandAll: false,
            onNodesInitialized: null,
            maxFilterLengthInRequest: 1500
        })
    },
    controllers: {
        data: exports.DataController
    }
});


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.sorting.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    sortingModule = __webpack_require__(218);
treeListCore.registerModule("sorting", sortingModule);


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.rows.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    treeListCore = __webpack_require__(18),
    rowsViewModule = __webpack_require__(219);
var TREELIST_TEXT_CONTENT = "dx-treelist-text-content",
    TREELIST_EXPAND_ICON_CONTAINER_CLASS = "dx-treelist-icon-container",
    TREELIST_CELL_EXPANDABLE_CLASS = "dx-treelist-cell-expandable",
    TREELIST_EMPTY_SPACE = "dx-treelist-empty-space",
    TREELIST_EXPANDED_CLASS = "dx-treelist-expanded",
    TREELIST_COLLAPSED_CLASS = "dx-treelist-collapsed";
exports.RowsView = rowsViewModule.views.rowsView.inherit(function() {
    var createCellContent = function($container) {
        return $("<div />").addClass(TREELIST_TEXT_CONTENT).appendTo($container)
    };
    var createIcon = function(hasIcon, isExpanded) {
        var $iconElement = $("<div/>").addClass(TREELIST_EMPTY_SPACE);
        if (hasIcon) {
            $iconElement.toggleClass(TREELIST_EXPANDED_CLASS, isExpanded).toggleClass(TREELIST_COLLAPSED_CLASS, !isExpanded).append($("<span/>"))
        }
        return $iconElement
    };
    return {
        _renderExpandIcon: function($container, options) {
            var level = options.row.level,
                $iconContainer = $("<div/>").addClass(TREELIST_EXPAND_ICON_CONTAINER_CLASS).appendTo($container);
            for (var i = 0; i <= level; i++) {
                $iconContainer.append(createIcon(i === level && options.row.node.hasChildren, options.row.isExpanded))
            }
            $container.addClass(TREELIST_CELL_EXPANDABLE_CLASS);
            return $iconContainer
        },
        _renderCellCommandContent: function(container, model) {
            this._renderExpandIcon(container, model);
            return true
        },
        _processTemplate: function(template, options) {
            var resultTemplate, that = this,
                renderingTemplate = this.callBase(template);
            var firstDataColumnIndex = that._columnsController.getFirstDataColumnIndex();
            if (renderingTemplate && options.column.index === firstDataColumnIndex) {
                resultTemplate = {
                    render: function(options) {
                        var $container = options.container;
                        if (that._renderCellCommandContent($container, options.model)) {
                            options.container = createCellContent($container)
                        }
                        renderingTemplate.render(options)
                    }
                }
            } else {
                resultTemplate = renderingTemplate
            }
            return resultTemplate
        },
        _updateCell: function($cell, options) {
            $cell = $cell.hasClass(TREELIST_TEXT_CONTENT) ? $cell.parent() : $cell;
            this.callBase($cell, options)
        },
        _rowClick: function(e) {
            var dataController = this._dataController,
                $targetElement = $(e.jQueryEvent.target),
                isExpandIcon = this.isExpandIcon($targetElement),
                item = dataController && dataController.items()[e.rowIndex];
            if (isExpandIcon && item) {
                dataController.changeRowExpand(item.key)
            }
            this.callBase(e)
        },
        _createRow: function(row) {
            var node = row && row.node,
                $rowElement = this.callBase.apply(this, arguments);
            if (node) {
                this.setAria("level", row.level, $rowElement);
                if (node.hasChildren) {
                    this.setAria("expanded", row.isExpanded, $rowElement)
                }
            }
            return $rowElement
        },
        _getTableRoleName: function() {
            return "treegrid"
        },
        isExpandIcon: function($targetElement) {
            return !!$targetElement.closest("." + TREELIST_EXPANDED_CLASS + ", ." + TREELIST_COLLAPSED_CLASS).length
        }
    }
}());
treeListCore.registerModule("rows", {
    defaultOptions: rowsViewModule.defaultOptions,
    views: {
        rowsView: exports.RowsView
    }
});


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.context_menu.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    contextMenuModule = __webpack_require__(220);
treeListCore.registerModule("contextMenu", contextMenuModule);


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.error_handling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    errorHandlingModule = __webpack_require__(221);
treeListCore.registerModule("errorHandling", errorHandlingModule);


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.grid_view.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    gridViewModule = __webpack_require__(222);
var GridView = gridViewModule.views.gridView.inherit(function() {
    return {
        _getWidgetAriaLabel: function() {
            return "dxTreeList-ariaTreeList"
        }
    }
}());
treeListCore.registerModule("gridView", {
    defaultOptions: gridViewModule.defaultOptions,
    controllers: gridViewModule.controllers,
    views: {
        gridView: GridView
    }
});


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.header_panel.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    headerPanelModule = __webpack_require__(223);
treeListCore.registerModule("headerPanel", headerPanelModule);


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.column_chooser.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    columnChooserModule = __webpack_require__(225);
treeListCore.registerModule("columnChooser", columnChooserModule);


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.master_detail.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    masterDetailModule = __webpack_require__(227),
    extend = __webpack_require__(1).extend;
treeListCore.registerModule("masterDetail", extend(true, {}, masterDetailModule, {
    extenders: {
        controllers: {
            data: {
                isRowExpanded: function() {
                    return this.callBase.apply(this, arguments)
                },
                _processItems: function() {
                    return this.callBase.apply(this, arguments)
                },
                _processDataItem: function() {
                    return this.callBase.apply(this, arguments)
                }
            }
        }
    }
}));


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.editing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(406);
var $ = __webpack_require__(0),
    errors = __webpack_require__(16),
    commonUtils = __webpack_require__(2),
    extend = __webpack_require__(1).extend,
    messageLocalization = __webpack_require__(8),
    treeListCore = __webpack_require__(18),
    gridCoreUtils = __webpack_require__(26),
    editingModule = __webpack_require__(229);
var TREELIST_EXPAND_ICON_CONTAINER_CLASS = "dx-treelist-icon-container",
    SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
    DATA_EDIT_DATA_INSERT_TYPE = "insert";
var EditingController = editingModule.controllers.editing.inherit(function() {
    return {
        _generateNewItem: function(key) {
            var item = this.callBase(key);
            item.data = {
                key: key
            };
            item.children = [];
            item.level = 0;
            item.parentKey = this.option("rootValue");
            return item
        },
        _needInsertItem: function(editData, changeType, items, item) {
            var parentKey = editData.key.parentKey;
            if (void 0 !== parentKey && parentKey !== this.option("rootValue")) {
                var rowIndex = gridCoreUtils.getIndexByKey(parentKey, items);
                if (rowIndex >= 0 && this._dataController.isRowExpanded(parentKey)) {
                    items.splice(rowIndex + 1, 0, item)
                }
                return false
            }
            return this.callBase.apply(this, arguments)
        },
        _isEditColumnVisible: function() {
            var result = this.callBase.apply(this, arguments),
                editingOptions = this.option("editing");
            return result || editingOptions && editingOptions.allowAdding
        },
        _createEditingLinks: function(container, options, editingOptions) {
            var callBase = this.callBase,
                editingTexts = editingOptions.texts || {};
            if (editingOptions.allowAdding && !(options.row.removed || options.row.inserted)) {
                this._createLink(container, editingTexts.addRowToNode, "addRowByRowIndex", options, "dx-link-add")
            }
            callBase.apply(this, arguments)
        },
        _beforeSaveEditData: function(editData) {
            var key, store, dataController = this._dataController,
                result = this.callBase.apply(this, arguments);
            if (editData && editData.type !== DATA_EDIT_DATA_INSERT_TYPE) {
                store = dataController && dataController.store();
                key = store && store.key();
                if (!commonUtils.isDefined(key)) {
                    throw errors.Error("E1045")
                }
            }
            return result
        },
        addRowByRowIndex: function(rowIndex) {
            var dataController = this.getController("data"),
                row = dataController.getVisibleRows()[rowIndex];
            return this.addRow(row ? row.key : void 0)
        },
        addRow: function(key) {
            var that = this,
                callBase = this.callBase,
                dataController = this.getController("data");
            if (void 0 !== key && !dataController.isRowExpanded(key)) {
                var d = $.Deferred();
                dataController.expandRow(key).done(function() {
                    setTimeout(function() {
                        callBase.call(that, key);
                        d.resolve()
                    })
                }).fail(d.reject);
                return d
            }
            callBase.call(that, key)
        },
        _initNewRow: function(options, insertKey) {
            var parentKey = insertKey.parentKey,
                dataController = this.getController("data"),
                dataSourceAdapter = dataController.dataSource(),
                parentIdSetter = dataSourceAdapter.createParentIdSetter();
            if (void 0 === parentKey) {
                parentKey = this.option("rootValue");
                insertKey.parentKey = parentKey
            }
            parentIdSetter(options.data, parentKey);
            this.callBase.apply(this, arguments)
        }
    }
}());
var originalRowClick = editingModule.extenders.views.rowsView._rowClick;
var RowsViewExtender = extend({}, editingModule.extenders.views.rowsView, {
    _renderCellCommandContent: function($container, options) {
        var editingController = this._editingController,
            isEditRow = options.row && editingController.isEditRow(options.row.rowIndex),
            isEditing = options.isEditing || isEditRow;
        if (!isEditing) {
            return this.callBase.apply(this, arguments)
        }
        return false
    },
    _rowClick: function(e) {
        var $targetElement = $(e.jQueryEvent.target);
        if ($targetElement.closest("." + SELECT_CHECKBOX_CLASS).length) {
            return
        }
        if ($targetElement.closest("." + TREELIST_EXPAND_ICON_CONTAINER_CLASS).length) {
            this.callBase.apply(this, arguments)
        } else {
            originalRowClick.apply(this, arguments)
        }
    }
});
treeListCore.registerModule("editing", {
    defaultOptions: function() {
        return extend(true, editingModule.defaultOptions(), {
            editing: {
                texts: {
                    addRowToNode: messageLocalization.format("dxTreeList-editingAddRowToNode")
                }
            }
        })
    },
    controllers: {
        editing: EditingController
    },
    extenders: {
        controllers: extend(true, {}, editingModule.extenders.controllers, {
            data: {
                changeRowExpand: function() {
                    this._editingController.refresh();
                    return this.callBase.apply(this, arguments)
                }
            }
        }),
        views: {
            rowsView: RowsViewExtender,
            headerPanel: editingModule.extenders.views.headerPanel
        }
    }
});


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.editor_factory.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    editorFactoryModule = __webpack_require__(228);
treeListCore.registerModule("editorFactory", editorFactoryModule);


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.validating.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    treeListCore = __webpack_require__(18),
    validatingModule = __webpack_require__(231);
var EditingControllerExtender = extend({}, validatingModule.extenders.controllers.editing);
delete EditingControllerExtender.processItems;
delete EditingControllerExtender.processDataItem;
treeListCore.registerModule("validating", {
    defaultOptions: validatingModule.defaultOptions,
    controllers: validatingModule.controllers,
    extenders: {
        controllers: {
            editing: EditingControllerExtender,
            editorFactory: validatingModule.extenders.controllers.editorFactory
        },
        views: validatingModule.extenders.views
    }
});


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.virtual_scrolling.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var gridCore = __webpack_require__(18),
    dataSourceAdapter = __webpack_require__(241),
    virtualScrollingModule = __webpack_require__(232),
    extend = __webpack_require__(1).extend;
var oldDefaultOptions = virtualScrollingModule.defaultOptions;
gridCore.registerModule("virtualScrolling", extend({}, virtualScrollingModule, {
    defaultOptions: function() {
        return extend(true, oldDefaultOptions(), {
            scrolling: {
                mode: "virtual"
            }
        })
    }
}));
dataSourceAdapter.extend(virtualScrollingModule.extenders.dataSourceAdapter);


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.filter_row.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(18),
    filterRowModule = __webpack_require__(233);
core.registerModule("filterRow", filterRowModule);


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.header_filter.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(18),
    headerFilterModule = __webpack_require__(235);
core.registerModule("headerFilter", headerFilterModule);


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.columns_resizing_reordering.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    columnsResizingReorderingModule = __webpack_require__(237);
treeListCore.registerModule("columnsResizingReordering", columnsResizingReorderingModule);


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.column_fixing.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(18),
    columnFixingModule = __webpack_require__(239);
core.registerModule("columnFixing", columnFixingModule);


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.adaptivity.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var treeListCore = __webpack_require__(18),
    adaptivityModule = __webpack_require__(240);
treeListCore.registerModule("adaptivity", adaptivityModule);


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.selection.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var $ = __webpack_require__(0),
    treeListCore = __webpack_require__(18),
    noop = __webpack_require__(2).noop,
    selectionModule = __webpack_require__(224),
    extend = __webpack_require__(1).extend;
var TREELIST_SELECT_ALL_CLASS = "dx-treelist-select-all",
    SELECT_CHECKBOX_CLASS = "dx-select-checkbox";
var originalRowClick = selectionModule.extenders.views.rowsView._rowClick;

function foreachNodes(nodes, func) {
    for (var i = 0; i < nodes.length; i++) {
        if (false !== func(nodes[i]) && nodes[i].hasChildren && nodes[i].children.length) {
            foreachNodes(nodes[i].children, func)
        }
    }
}
treeListCore.registerModule("selection", extend(true, {}, selectionModule, {
    defaultOptions: function() {
        return extend(true, selectionModule.defaultOptions(), {
            selection: {
                showCheckBoxesMode: "always"
            }
        })
    },
    extenders: {
        controllers: {
            selection: {
                renderSelectCheckBoxContainer: function($container, model) {
                    var that = this,
                        rowsView = that.component.getView("rowsView");
                    var $checkbox = rowsView._renderSelectCheckBox($container, model.row.isSelected);
                    rowsView._attachCheckBoxClickEvent($checkbox)
                },
                _updateSelectColumn: noop,
                _getVisibleNodeKeys: function() {
                    var component = this.component,
                        root = component.getRootNode(),
                        keys = [];
                    root && foreachNodes(root.children, function(node) {
                        if (void 0 !== node.key && node.visible) {
                            keys.push(node.key)
                        }
                        return component.isRowExpanded(node.key)
                    });
                    return keys
                },
                isSelectAll: function() {
                    var component = this.component,
                        visibleKeys = this._getVisibleNodeKeys();
                    var selectedVisibleKeys = visibleKeys.filter(function(key) {
                        return component.isRowSelected(key)
                    });
                    if (!selectedVisibleKeys.length) {
                        return false
                    } else {
                        if (selectedVisibleKeys.length === visibleKeys.length) {
                            return true
                        }
                    }
                },
                selectAll: function() {
                    var visibleKeys = this._getVisibleNodeKeys();
                    return this.selectRows(visibleKeys, true)
                },
                deselectAll: function() {
                    var visibleKeys = this._getVisibleNodeKeys();
                    return this.deselectRows(visibleKeys)
                }
            }
        },
        views: {
            columnHeadersView: {
                _processTemplate: function(template, options) {
                    var resultTemplate, that = this,
                        renderingTemplate = this.callBase(template, options);
                    var firstDataColumnIndex = that._columnsController.getFirstDataColumnIndex();
                    if (renderingTemplate && options.column.index === firstDataColumnIndex) {
                        resultTemplate = {
                            render: function(options) {
                                if ("multiple" === that.option("selection.mode")) {
                                    that.renderSelectAll(options.container, options.model)
                                }
                                renderingTemplate.render(options)
                            }
                        }
                    } else {
                        resultTemplate = renderingTemplate
                    }
                    return resultTemplate
                },
                renderSelectAll: function($cell, options) {
                    $cell.addClass(TREELIST_SELECT_ALL_CLASS);
                    this._renderSelectAllCheckBox($cell)
                },
                _isSortableElement: function($target) {
                    return this.callBase($target) && !$target.closest("." + SELECT_CHECKBOX_CLASS).length
                }
            },
            rowsView: {
                _renderExpandIcon: function($container, options) {
                    var $iconContainer = this.callBase($container, options);
                    if ("multiple" === this.option("selection.mode")) {
                        this.getController("selection").renderSelectCheckBoxContainer($iconContainer, options)
                    }
                    return $iconContainer
                },
                _rowClick: function(e) {
                    var $targetElement = $(e.jQueryEvent.target);
                    if (this.isExpandIcon($targetElement)) {
                        this.callBase.apply(this, arguments)
                    } else {
                        originalRowClick.apply(this, arguments)
                    }
                }
            }
        }
    }
}));


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.search.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(18),
    searchModule = __webpack_require__(236);
core.registerModule("search", searchModule);


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (ui/tree_list/ui.tree_list.keyboard_navigation.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var core = __webpack_require__(18),
    keyboardNavigationModule = __webpack_require__(238);
core.registerModule("keyboardNavigation", keyboardNavigationModule);


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (bundles/modules/viz.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

__webpack_require__(82);
module.exports = DevExpress.viz = DevExpress.viz || {};


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * DevExtreme (viz/core/export.js)
 * Version: 17.1.7
 * Build date: Fri Sep 29 2017
 *
 * Copyright (c) 2012 - 2017 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var extend = __webpack_require__(1).extend,
    inArray = __webpack_require__(7).inArray,
    patchFontOptions = __webpack_require__(159).patchFontOptions,
    _extend = extend,
    clientExporter = __webpack_require__(133),
    messageLocalization = __webpack_require__(8),
    imageExporter = clientExporter.image,
    svgExporter = clientExporter.svg,
    pdfExporter = clientExporter.pdf,
    hoverEvent = __webpack_require__(113),
    pointerEvents = __webpack_require__(17),
    pointerActions = [pointerEvents.down, pointerEvents.move].join(" "),
    BUTTON_SIZE = 35,
    ICON_COORDS = [
        [9, 12, 26, 12, 26, 14, 9, 14],
        [9, 17, 26, 17, 26, 19, 9, 19],
        [9, 22, 26, 22, 26, 24, 9, 24]
    ],
    LIST_PADDING_TOP = 4,
    LIST_WIDTH = 120,
    VERTICAL_TEXT_MARGIN = 8,
    HORIZONTAL_TEXT_MARGIN = 15,
    MENU_ITEM_HEIGHT = 30,
    LIST_STROKE_WIDTH = 1,
    MARGIN = 10,
    SHADOW_OFFSET = 2,
    SHADOW_BLUR = 3,
    ALLOWED_EXPORT_FORMATS = ["PNG", "PDF", "JPEG", "SVG", "GIF"],
    EXPORT_CSS_CLASS = "dx-export-menu",
    EXPORT_DATA_KEY = "export-element-type",
    FORMAT_DATA_KEY = "export-element-format";

function validateFormat(format) {
    var validatedFormat = String(format).toUpperCase();
    if (inArray(validatedFormat, ALLOWED_EXPORT_FORMATS) !== -1) {
        return validatedFormat
    }
}

function getCreatorFunc(format) {
    if ("SVG" === format) {
        return svgExporter.getData
    } else {
        if ("PDF" === format) {
            return pdfExporter.getData
        } else {
            return imageExporter.getData
        }
    }
}

function doExport(menu, markup, options) {
    menu && menu.hide();
    clientExporter.export(markup(), options, getCreatorFunc(options.format));
    menu && menu.show()
}

function print(data, backgroundColor) {
    var svg, vizWindow = window.open();
    if (!vizWindow) {
        return
    }
    vizWindow.document.open();
    vizWindow.document.write(data);
    vizWindow.document.close();
    svg = vizWindow.document.body.getElementsByTagName("svg")[0];
    svg && (svg.style.backgroundColor = backgroundColor);
    vizWindow.print();
    vizWindow.close()
}

function getItemAttributes(options, type, itemIndex) {
    var path, attr = {},
        x = BUTTON_SIZE - LIST_WIDTH,
        y = BUTTON_SIZE + LIST_PADDING_TOP + itemIndex * MENU_ITEM_HEIGHT;
    attr.rect = {
        width: LIST_WIDTH - 2 * LIST_STROKE_WIDTH,
        height: MENU_ITEM_HEIGHT,
        x: x + LIST_STROKE_WIDTH,
        y: y
    };
    attr.text = {
        x: x + HORIZONTAL_TEXT_MARGIN,
        y: y + MENU_ITEM_HEIGHT - VERTICAL_TEXT_MARGIN,
        align: "left"
    };
    if ("printing" === type) {
        path = "M " + x + " " + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH) + " L " + (x + LIST_WIDTH) + " " + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH);
        attr.separator = {
            stroke: options.button.default.borderColor,
            "stroke-width": LIST_STROKE_WIDTH,
            cursor: "pointer",
            sharp: "v",
            d: path
        }
    }
    return attr
}

function createMenuItem(renderer, options, settings) {
    var menuItem, itemData = {},
        type = settings.type,
        format = settings.format,
        attr = getItemAttributes(options, type, settings.itemIndex),
        fontStyle = patchFontOptions(options.font),
        rect = renderer.rect(),
        text = renderer.text(settings.text);
    fontStyle["pointer-events"] = "none";
    menuItem = renderer.g().attr({
        "class": EXPORT_CSS_CLASS + "-list-item"
    });
    itemData[EXPORT_DATA_KEY] = type;
    if (format) {
        itemData[FORMAT_DATA_KEY] = format
    }
    rect.attr(attr.rect).css({
        cursor: "pointer",
        "pointer-events": "all"
    }).data(itemData);
    rect.on(hoverEvent.start + ".export", function() {
        rect.attr({
            fill: options.button.hover.backgroundColor
        })
    }).on(hoverEvent.end + ".export", function() {
        rect.attr({
            fill: null
        })
    });
    rect.append(menuItem);
    text.css(fontStyle).attr(attr.text).append(menuItem);
    if ("printing" === type) {
        renderer.path(null, "line").attr(attr.separator).append(menuItem)
    }
    return {
        g: menuItem,
        rect: rect,
        resetState: function() {
            rect.attr({
                fill: null
            })
        }
    }
}

function createMenuItems(renderer, options) {
    var formats = options.formats,
        items = [];
    if (options.printingEnabled) {
        items.push(createMenuItem(renderer, options, {
            type: "printing",
            text: messageLocalization.format("vizExport-printingButtonText"),
            itemIndex: items.length
        }))
    }
    items = formats.reduce(function(r, format) {
        format = validateFormat(format);
        if (format) {
            r.push(createMenuItem(renderer, options, {
                type: "exporting",
                text: messageLocalization.getFormatter("vizExport-exportButtonText")(format),
                format: format,
                itemIndex: r.length
            }))
        }
        return r
    }, items);
    return items
}
exports.exportFromMarkup = function(markup, options) {
    options.format = validateFormat(options.format) || "PNG";
    options.fileName = options.fileName || "file";
    options.exportingAction = options.onExporting;
    options.exportedAction = options.onExported;
    options.fileSavingAction = options.onFileSaving;
    clientExporter.export(markup, options, getCreatorFunc(options.format))
};
exports.getMarkup = function(widgets) {
    var svgArr = [],
        height = 0,
        width = 0;
    widgets.forEach(function(widget) {
        var size = widget.getSize();
        svgArr.push(widget.svg().replace("<svg", '<g transform="translate(0,' + height + ')" ').replace("</svg>", "</g>"));
        height += size.height;
        width = Math.max(width, size.width)
    });
    return '<svg height="' + height + '" width="' + width + '" version="1.1" xmlns="http://www.w3.org/2000/svg">' + svgArr.join("") + "</svg>"
};
exports.ExportMenu = function(params) {
    var that = this,
        renderer = that._renderer = params.renderer;
    that._incidentOccurred = params.incidentOccurred;
    that._svgMethod = params.svgMethod;
    that._shadow = renderer.shadowFilter("-50%", "-50%", "200%", "200%", SHADOW_OFFSET, 6, SHADOW_BLUR);
    that._shadow.attr({
        opacity: .8
    });
    that._group = renderer.g().attr({
        "class": EXPORT_CSS_CLASS
    }).linkOn(renderer.root, {
        name: "export-menu",
        after: "peripheral"
    });
    that._buttonGroup = renderer.g().attr({
        "class": EXPORT_CSS_CLASS + "-button"
    }).append(that._group);
    that._listGroup = renderer.g().attr({
        "class": EXPORT_CSS_CLASS + "-list"
    }).append(that._group);
    that._overlay = renderer.rect(-LIST_WIDTH + BUTTON_SIZE, BUTTON_SIZE + LIST_PADDING_TOP, LIST_WIDTH, 0);
    that._overlay.attr({
        "stroke-width": LIST_STROKE_WIDTH,
        cursor: "pointer",
        rx: 4,
        ry: 4,
        filter: that._shadow.id
    });
    that._overlay.data({
        "export-element-type": "list"
    });
    that._subscribeEvents()
};
_extend(exports.ExportMenu.prototype, {
    getLayoutOptions: function() {
        if (this._hiddenDueToLayout) {
            return {
                width: 0,
                height: 0
            }
        }
        var bBox = this._buttonGroup.getBBox();
        bBox.cutSide = "vertical";
        bBox.cutLayoutSide = "top";
        bBox.height += MARGIN;
        bBox.position = {
            vertical: "top",
            horizontal: "right"
        };
        bBox.verticalAlignment = "top";
        bBox.horizontalAlignment = "right";
        return bBox
    },
    probeDraw: function() {
        this._hiddenDueToLayout = false;
        this.show()
    },
    shift: function(_, y) {
        this._group.attr({
            translateY: this._group.attr("translateY") + y
        })
    },
    draw: function(width, height, canvas) {
        var layoutOptions;
        this._options.exportOptions.width = canvas.width;
        this._options.exportOptions.height = canvas.height;
        this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR + canvas.left, Math.floor(height / 2 - BUTTON_SIZE / 2));
        layoutOptions = this.getLayoutOptions();
        if (layoutOptions.width > width || layoutOptions.height > height) {
            this._incidentOccurred("W2107");
            this._hiddenDueToLayout = true;
            this.hide()
        }
        return this
    },
    show: function() {
        !this._hiddenDueToLayout && this._group.linkAppend()
    },
    hide: function() {
        this._group.linkRemove()
    },
    setOptions: function(options) {
        this._options = options;
        options.formats = options.formats || ALLOWED_EXPORT_FORMATS;
        options.printingEnabled = void 0 === options.printingEnabled ? true : options.printingEnabled;
        if (options.enabled && (options.formats.length || options.printingEnabled)) {
            this.show();
            this._updateButton();
            this._updateList();
            this._hideList()
        } else {
            this.hide()
        }
    },
    dispose: function() {
        var that = this;
        that._unsubscribeEvents();
        that._group.linkRemove().linkOff();
        that._group.dispose();
        that._shadow.dispose();
        that._shadow = that._group = that._listGroup = that._buttonGroup = that._button = null;
        that._options = null
    },
    layoutOptions: function() {
        var options = this._options;
        return options.enabled && {
            horizontalAlignment: "right",
            verticalAlignment: "top",
            weak: true
        }
    },
    measure: function() {
        return [BUTTON_SIZE + SHADOW_OFFSET, BUTTON_SIZE]
    },
    move: function(rect) {
        this._group.attr({
            translateX: Math.round(rect[0]),
            translateY: Math.round(rect[1])
        })
    },
    _hideList: function() {
        this._listGroup.remove();
        this._listShown = false;
        this._setButtonState("default");
        this._menuItems.forEach(function(item) {
            item.resetState()
        })
    },
    _showList: function() {
        this._listGroup.append(this._group);
        this._listShown = true
    },
    _setButtonState: function(state) {
        var that = this,
            style = that._options.button[state];
        this._button.attr({
            stroke: style.borderColor,
            fill: style.backgroundColor
        });
        this._icon.attr({
            fill: style.color
        })
    },
    _subscribeEvents: function() {
        var that = this;
        that._renderer.root.on(pointerEvents.up + ".export", function(e) {
            var exportOptions, elementType = e.target[EXPORT_DATA_KEY],
                options = that._options;
            if (!elementType) {
                if (that._button) {
                    that._hideList()
                }
                return
            }
            if ("button" === elementType) {
                if (that._listShown) {
                    that._setButtonState("default");
                    that._hideList()
                } else {
                    that._setButtonState("focus");
                    that._showList()
                }
            } else {
                if ("printing" === elementType) {
                    that.hide();
                    print(that._svgMethod(), options.backgroundColor);
                    that.show();
                    that._hideList()
                } else {
                    if ("exporting" === elementType) {
                        exportOptions = _extend({}, options.exportOptions, {
                            format: e.target[FORMAT_DATA_KEY]
                        });
                        doExport(that, function() {
                            return that._svgMethod()
                        }, exportOptions);
                        that._hideList()
                    }
                }
            }
        });
        that._listGroup.on(pointerActions, function(e) {
            e.stopPropagation()
        });
        that._buttonGroup.on(pointerEvents.enter, function() {
            that._setButtonState("hover")
        });
        that._buttonGroup.on(pointerEvents.leave, function() {
            that._setButtonState(that._listShown ? "focus" : "default")
        });
        that._buttonGroup.on(pointerEvents.down + ".export", function() {
            that._setButtonState("active")
        })
    },
    _unsubscribeEvents: function() {
        this._renderer.root.off(".export");
        this._listGroup.off();
        this._buttonGroup.off()
    },
    _updateButton: function() {
        var that = this,
            renderer = that._renderer,
            options = that._options,
            iconAttr = {
                fill: options.button.default.color,
                cursor: "pointer"
            },
            exportData = {
                "export-element-type": "button"
            };
        if (!that._button) {
            that._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(that._buttonGroup);
            that._button.attr({
                rx: 4,
                ry: 4,
                fill: options.button.default.backgroundColor,
                stroke: options.button.default.borderColor,
                "stroke-width": 1,
                cursor: "pointer"
            });
            that._button.data(exportData);
            that._icon = renderer.path(ICON_COORDS).append(that._buttonGroup);
            that._icon.attr(iconAttr);
            that._icon.data(exportData);
            that._buttonGroup.setTitle(messageLocalization.format("vizExport-titleMenuText"))
        }
    },
    _updateList: function() {
        var that = this,
            options = that._options,
            buttonDefault = options.button.default,
            listGroup = that._listGroup,
            items = createMenuItems(that._renderer, options);
        that._shadow.attr({
            color: options.shadowColor
        });
        that._overlay.attr({
            height: items.length * MENU_ITEM_HEIGHT,
            fill: buttonDefault.backgroundColor,
            stroke: buttonDefault.borderColor
        });
        listGroup.clear();
        that._overlay.append(listGroup);
        items.forEach(function(item) {
            item.g.append(listGroup)
        });
        that._menuItems = items
    }
});

function getExportOptions(widget, exportOptions, fileName, format) {
    return {
        format: validateFormat(format || exportOptions.format) || "PNG",
        fileName: fileName || exportOptions.fileName || "file",
        proxyUrl: exportOptions.proxyUrl,
        backgroundColor: exportOptions.backgroundColor,
        width: widget._canvas.width,
        height: widget._canvas.height,
        exportingAction: widget._createActionByOption("onExporting"),
        exportedAction: widget._createActionByOption("onExported"),
        fileSavingAction: widget._createActionByOption("onFileSaving")
    }
}
exports.plugin = {
    name: "export",
    init: function() {
        var that = this;
        that._exportMenu = new exports.ExportMenu({
            renderer: that._renderer,
            svgMethod: function() {
                return that.svg()
            },
            incidentOccurred: that._incidentOccurred
        });
        that._layout.add(that._exportMenu)
    },
    dispose: function() {
        this._exportMenu.dispose();
        this._exportMenu = null
    },
    members: {
        _getExportMenuOptions: function() {
            var userOptions = this._getOption("export") || {},
                options = getExportOptions(this, userOptions);
            return _extend({}, userOptions, {
                exportOptions: options
            })
        },
        exportTo: function(fileName, format) {
            var that = this,
                exportOptions = getExportOptions(that, that._getOption("export") || {}, fileName, format);
            doExport(that._exportMenu, function() {
                return that.svg()
            }, exportOptions)
        },
        print: function() {
            print(this.svg(), this._getOption("export").backgroundColor)
        }
    },
    customize: function(constructor) {
        var proto = constructor.prototype;
        constructor.addChange({
            code: "EXPORT",
            handler: function() {
                this._exportMenu.setOptions(this._getExportMenuOptions());
                this._change(["LAYOUT"])
            },
            isThemeDependent: true,
            isOptionChange: true,
            option: "export"
        });
        proto._optionChangesMap.onExporting = "EXPORT";
        proto._optionChangesMap.onExported = "EXPORT";
        proto._optionChangesMap.onFileSaving = "EXPORT"
    }
};


/***/ })
/******/ ]);